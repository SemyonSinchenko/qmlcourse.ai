---
jupytext:
  formats: md:myst
  text_representation:
    extension: .md
    format_name: myst
kernelspec:
  display_name: Python 3
  language: python
  name: python3
---

(bra-ket)=
# Ско бки

Дисклеймер: нам нужен инструментарий для работы с более абстрактными пространствами!

Символ Кронекера и остальные специальные тензора -- это удобные примитивы для низкоуровневой работы с матрицами и векторами.
Физики смогли придумать поверх примитивов линейной алгебры отличный синтаксический сахар, т.н. нотацию Дирака. Но давайте начнем с определения гильбертово пространства.

- Гильбертово пространство

Гильбертово пространство определяется:
1) скалярным произведением (u, v) (в простейшем частном случае - $(u, v) = u^{\dagger} v$)
2) зафиксированной нормой вида $||v|| = \sqrt{(v,v)}$
3) является полным с метрикой $d(u,v) = ||u-v|| = \sqrt{(u-v,u-v)}$

- Полное пространство

Полное метрическое пространство дает возможность не думать при нахождении предела некоторой последовательности о принадлежности этого предела данному пространству, то есть по своей сути разрешает предельный переход и позволяет доказать множество красивых теорем. Подробнее строгое определение можно посмотреть [тут](https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D0%BB%D0%BD%D0%BE%D0%B5_%D0%BC%D0%B5%D1%82%D1%80%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D1%81%D1%82%D1%80%D0%B0%D0%BD%D1%81%D1%82%D0%B2%D0%BE)

- Нотация Дирака или Bra-Ket нотация

Напомним, что в гильбертовом пространстве у нас есть к пространству $H$ сопряженное пространство $H^{\dagger}$.
Тогда можно рассмотреть обозначение Ket для элемента $v$ из $H$ как вектор столбец
$$
\ket{v} = \begin{pmatrix} v_1 \\ v_2 \\ \vdots \\ v_N \end{pmatrix}
$$
и обозначение Bra для элемента $u$ из сопряженного пространства $H^*$ как сопряженную вектор строку
$$
\bra{u}= \begin{pmatrix} u_1^* & u_2^* & \cdots & u_N^* \end{pmatrix}
$$
тогда bra-ket u и v просто задает скалярное произведение между этими элементами:
$$
\bra{u} \ket{v} = u_1^* v_1 + u_2^* v_2 + \cdots + u_N^* v_N =
\begin{pmatrix} u_1^* & u_2^* & \cdots & u_N^* \end{pmatrix}
\begin{pmatrix} v_1 \\ v_2 \\ \vdots \\ v_N \end{pmatrix}
$$

Часто, например, требуется показать два граничных  состояния кубита $|0>$, $|1>$, тогда мы можем записать их просто как вектора столбцы: $\ket{0} = \begin{pmatrix} 1 \\ 0 \end{pmatrix}$ и $\ket{1} = \begin{pmatrix} 0 \\ 1 \end{pmatrix}$. В следующей лекции этот вопрос будет рассмотрен детальнее.

- Внешнее произведение (outer-product)

Также имеет смысл и переставленная запись, которая называется внешним произведением:
$$
\ket{u} \bra{v} = \begin{pmatrix} u_1^* & u_2^* & \cdots & u_N^* \end{pmatrix} \begin{pmatrix} v_1 \\ v_2 \\ \vdots \\ v_N \end{pmatrix} = \begin{pmatrix}
  u_1^* v_1 & u_1^* v_2 & \cdots & u_1^* v_N \\
  u_2^* v_1 & u_2^* v_2 & \cdots & u_2^* v_N \\
  \vdots & \cdots &  \ddots & \vdots\\
  u_N^* v_1 & \cdots & \cdots & u_N^* v_N
\end{pmatrix}
$$
по сути это матрица N x N, то есть новый оператор в гильбертовом пространстве. Не все перестановки имеют смысл, например, нельзя записать $\bra{v} \bra{v}$ или $\ket{u} \ket{v}$.

- Эрмитов оператор

Оператор U называется [эрмитовым](https://ru.wikipedia.org/wiki/%D0%AD%D1%80%D0%BC%D0%B8%D1%82%D0%BE%D0%B2_%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80), если он удовлетворяет равенству $(Uv,u) = (v,Uu)$ для всех $u$, $v$ из $H$ или в матричном виде:
$$
U=U^{\dagger}
$$

- Унитарный оператор

Унитарный оператор $\hat{U}:H \rightarrow H$ на гильбертовом пространстве $H$ это линейный оператор, который удовлетворяет следующему равенству $(Uv, Uu) = (u,v)$ для любых $v \in H$, $u \in H$. Или в матричной форме:
$$
\hat{U}^{\dagger}\hat{U}=\hat{U}\hat{U}^{\dagger}=I
$$
напомним, что операция $\hat{U}^\dagger$ (другое частое обозначение в работах - звездочка или H $\hat{U}^{*}=\hat{U}^{H}$) в матричных терминах является последовательным применением операции транспонирования и последующего сопряжения элементов этой матрицы $\hat{U}^\dagger = \overline{\hat{U}}^T$ (порядок этих операций, естественно не влияет на результат).

```{code-cell} ipython3
import numpy as np
import scipy as sp
from scipy import linalg
U_hat = np.array([
    [1 + 0j, 0 + 0j],
    [0 + 0j, 1 + 0j]
    ])
U_hat_star_byhands = U_hat.conj().T
U_hat_star_long = np.conjugate(np.transpose(U_hat))

print(np.allclose(U_hat_star, U_hat_star_byhands))
```
Также в python для многих операций есть соответствующие методы вместо функций и их сокращения, например U.transpose() тоже самое, что U.T, а U.conjugate() - U.conj()

Важное свойство, что любой эрмитов оператор U можно привести к унитарному оператору с помощью взятия матричной экспоненты от матрицы оператора умноженного на мнимую единицу:

$$
\hat{U} = \exp(iU)
$$

Давайте докажем быстро этот факт: для эрмитовых квадратных матриц можно определить матричные функции через спектральное разложение матрицы, которое в силу свойств эрмитовых матриц имеет вид: $U=S \Lambda S^{\dagger}$, где $S$ - унитарная матрица перехода к тому базису, где изначальный оператор выражается диагональной матрицей. Тогда матричная функция $f(U) = $S f(\Lambda) S^{\dagger}$, т.е. мы диагонализируем матрицу и применяем функцию ко всем диагональным элементам, а потом возвращаемся в исходный базис унитарным преобразованием. Соответственно для экспоненты:
$$
\exp V = S \exp (\Lambda) S^\dagger
$$

```{note}
В качестве упражнения для самопроверки можете показать, что такое определение эквивалентно определению через степенной ряд: $e^U = \sum_{k=0}^\infty{1 \over k!}U^k$
```

Доказательство:
Проверим определение унитарной матрицы: $\hat{U}^{\dagger}\hat{U} = (S \exp (i*\Lambda) S^\dagger)^\dagger S \exp (i*\Lambda) S^\dagger$.
Пользуясь тем, что эрмитово сопряжение переставляет матрицы и является обратной операцией к себе же и так как S - унитарная матрица (то есть $S S^{\dagger}=I$) получаем:
$$
(S \exp (i*\Lambda) S^\dagger)^\dagger S \exp (i*\Lambda) S^\dagger = \exp(-i*\Lambda) S^\dagger  S \exp (i*\Lambda)  S^\dagger
$$
Заметим, что теперь у нас уже скалярная экспонента, которая применяется к элементам диагональной матрицы и мы можем воспользоваться тем, что произведение экспонент превращается в экспоненту от суммы степеней
$$
S \exp(-i \Lambda  + i \Lambda) S^\dagger = S \exp(O) S^\dagger = S I S^\dagger = I
$$
В конце мы еще раз воспользовались тем, что S - унитарная. Абсолютно также доказывается, что $\hat{U}\hat{U}^{\dagger}$
``` note
Кстати, любая матрица вида $HH^{\dagger}$ является эрмитовой
```
Давайте продемонстрируем доказанный факт на примере матрицы дискретного преобразования Фурье без нормировочного коэффициента $\frac{1}{N}$, $N=3$ преобразованной к $DD^{dagger}:

```{code-cell} ipython3
N=3
w = np.sqrt(np.exp(-1j*2*np.pi/N))
D = np.array([
    [1, 1, 1],
    [1, w, w**2],
    [1, w**2, w**4]
    ])
print(U)
U = D@D.conj().T
print(D)
print(np.allclose(U@U.H, np.eye(N))) # no

U_hat = linalg.expm(np.i*U)
print(np.allclose(U_hat@U_hat.conj().T, np.eye(N)))
print(np.allclose(U_hat.conj().T@U_hat, np.eye(N)))
```

- Пример: оператор проектор

Оператором проекции является оператор $P$ со свойством $P^2=P$

- Пример: оператор поворота

Оператор поворота по оси вращения $v=(x,y,z)$ на угол $\theta$ является
$$
M(v,\theta) = \begin{pmatrix}
   \cos \theta + (1 - \cos \theta) x^2
 & (1 - \cos \theta) x y - (\sin \theta) z
 & (1 - \cos \theta) x z + (\sin \theta) y  
\\
   (1 - \cos \theta) y x + (\sin \theta) z
 & \cos \theta + (1 - \cos \theta) y^2
 & (1 - \cos \theta) y z - (\sin \theta) x
\\
   (1 - \cos \theta) z x - (\sin \theta) y
 & (1 - \cos \theta) z y + (\sin \theta) x
 & \cos \theta + (1 - \cos \theta) z^2
\end{pmatrix}
$$
Например, если бы хотим повернуть относительно оси x на $90^\degree$: $x=1$, $y=0$, $z=0$, $\theta = \frac{\pi}{2} наша матрица будет иметь вид:
$$
M = \begin{pmatrix}
1 & 0 & 0 \\
0 & \cos{\frac{\pi}{2}} & -\sin{\frac{\pi}{2}} \\
0 & \sin{\frac{\pi}{2}} & 1 \end{pmatrix}
$$

Если у нас больше измерений, то по тем измерениям, которые не затрагиваются этим поворотом у нас в строке и столбце стоят нули, кроме пересечения строки и столбца, отвечающим за это измерение - там стоит единица.

- Пример: оператор дифференцирования
в пространстве многочленов $P$ с базисом \{1,t,t^2,...,t^n\} можно задать оператор дифференцирования $\mathcal{D} \colon P_n \to P_{n-1}$ в виде матрицы:

$$
D=\begin{pmatrix}
0 & 1 & 0 & 0 & \cdots & 0 \\
0 & 0 & 2 & 0 & \cdots & 0 \\
0 & 0 & 0 & 3 &\cdots & 0 \\
\cdots & \cdots & \cdots & \cdots &\cdots & \cdots \\
0 & 0 & 0 & 0 &\cdots & n \\
\end{pmatrix}
$$

тогда производная многочлена $p = a_0 + a_1 t  + \cdots + a_n t^{n} = \begin{pmatrix} a_0 & a_1 & \cdots & a_n \end{pmatrix} \begin{pmatrix} 1 \\ t \\ \vdots \\ t^{n} \end{pmatrix}$
$$
\mathcal{D}(p)  = \begin{pmatrix} a_0 & a_1 & \cdots & a_n \end{pmatrix} D \begin{pmatrix} 1 \\ t \\ \vdots \\ t^{n-1} \end{pmatrix} = a_1 + 2 a_2 t+\cdots+n a_n t^{n-1}
$$

- Про разницу между оператором и матрицей преобразования

Мы с вами рассматривали операторы, через конечные матрицы, но на самом деле Гильбертово пространство было придумано как раз, чтобы можно было работать с бесконечномерными векторами и применять непрерывные операторы. Можно считать, что есть некоторый дуализм между непрерывным оператором и пределом бесконечной матрицы. Иногда удобнее работать с матрицей, а иногда - с абстрактным оператором.

- Символ Леви-Чивиты

[TODO](https://ru.wikipedia.org/wiki/%D0%A1%D0%B8%D0%BC%D0%B2%D0%BE%D0%BB_%D0%9B%D0%B5%D0%B2%D0%B8-%D0%A7%D0%B8%D0%B2%D0%B8%D1%82%D1%8B)

- Произведение Кронекера

[TODO](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D0%B8%D0%B7%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5_%D0%9A%D1%80%D0%BE%D0%BD%D0%B5%D0%BA%D0%B5%D1%80%D0%B0)

## Что мы узнали

- произвол со скобками
- Гильбертовы пространства
- Эрмитовый оператор
- Унитарный оператор
- Примеры различных операторов
