---
jupytext:
  formats: md:myst
  text_representation:
    extension: .md
    format_name: myst
kernelspec:
  display_name: Python 3
  language: python
  name: python3
---

(simon_algorithm)=

# Алгоритм Саймона

Представьте, что ваш учитель магии позвонил вам и предложил отправиться в фантастический поход с приключениями вместе с другими студентами-магами.
Он сказал, что нужно взять самое необходимое, но часть вещей он принесёт вам сам и будет ждать всех на рассвете у столетнего дуба. На этом связь обрывается.
Вы привыкли, что учитель говорит загадками, но вам как программисту и математику не составляет труда их разгадывать. Особенно с помощью волшебного алгоритма Саймона.

Давайте опишем массивом  $x_0, \dots, x_n$ полный список инвентаря мага: например, бит $x_0$ отвечает за волшебный посох, $x_1$ -- за шапку-невидимку, $x_2$ -- за ковёр-самолёт, $x_3$ -- за гитару (какой поход без неё), $x_4$ -- за исцеляющее зелье, $x_5$ -- за чудо-меч и т.д.

Массив $M$ -- это то, что вам одолжит ваш учитель магии. Что-то он точно прихватил, поэтому массив $M$ не может состоять из нулей.

Итак, вы не знаете ничего, вам неизвестна даже тематика похода. Ведь если он военный, то самое необходимое -- это меч и исцеляющее зелье, если туристический -- то ковёр-самолёт и гитара. Можно, конечно, психануть и взять сразу всё, но тогда есть вероятность, что вам придётся тащить слишком много барахла. Особенно если учитель поступил так же. Вот если бы вы узнали комбинацию $M$, вы бы поняли тематику похода и что нужно брать. Вот почему нам интересно расшифровать именно её.

Так как вы и программист, и волшебник, у вас в запасе есть магический _Предсказатель_ в виде функции $f(x)$. Вы понятия не имеете, как устроен этот чёрный ящик, но можете подавать ему на вход различные варианты вектора $X$.


<center>

|                    | $X$   | $M$   | $X^\prime$      |
|--------------------|-------|-------|----------------|
| Волшебный посох    | $x_0$ | $m_0$ | $x^\prime_0$   |
| Шапка-невидимка    | $x_1$ | $m_1$ | $x^ \prime _1$ |
| Ковёр-самолёт      | $x_2$ | $m_2$ | $x^ \prime _2$ |
| Гитара             | $x_3$ | $m_3$ | $x^ \prime _3$ |
| Исцеляющее зелье   | $x_4$ | $m_4$ | $x^ \prime _4$ |
| Чудо-меч           | $x_5$ | $m_5$ | $x^ \prime _5$ |
| Дурманящий эликсир | $x_6$ | $m_6$ | $x^ \prime _6$ |

</center>


Честно говоря, _Предсказатель_ выдаёт совершенно бесполезные эльфийские шифры в виде массива $z^\prime_0, \dots, z^\prime_n$. Это может быть степень успешности похода, или вероятность попасть в неприятности, или вообще счёт за путешествие. Но есть одна закономерность: _Предсказатель_ выдаёт одинаковый результат похода для следующих наборов вещей $X$ и $X^\prime$:

$$f(x) = f(x^\prime)\ \text{тогда и только тогда, когда} \ x^\prime = x \oplus m.$$

Что ж, давайте выберем любую комбинацию $X$ и попробуем с помощью _Предсказателя_ подобрать ей пару $X^\prime$, помня, что он выдаст для них одинаковые значения функций $f(x) = f(x^\prime)$.

Предположим, что поход ожидается военный, а значит, нам нужны меч и исцеляющее зелье. Наш массив $X$ будет выглядеть так:

|                    | $X$   |
|--------------------|-------|
| Волшебный посох    | $0$ |
| Шапка-невидимка    | $0$ |
| Ковёр-самолёт      | $0$ |
| Гитара             | $0$ |
| Исцеляющее зелье   | $1$ |
| Чудо-меч           | $1$ |
| Дурманящий эликсир | $0$ |


Спустя $k \leq 2^{n-1}+1$ расспросов (_вопрос слушателю – почему именно столько?_), подавая Предсказателю различные комбинации $X$, мы наконец подобрали пару $X^\prime$ и выяснили, что результат похода будет точно такой же, если вы возьмёте ещё и гитару и ковёр-самолёт, а зелье оставите дома:

|                    | $X^\prime$ |
|--------------------|------------|
| Волшебный посох    | $0$        |
| Шапка-невидимка    | $0$        |
| Ковёр-самолёт      | $1$        |
| Гитара             | $1$        |
| Исцеляющее зелье   | $0$        |
| Чудо-меч           | $1$        |
| Дурманящий эликсир | $0$        |

Помня, что $X^\prime = X \oplus M$, мы без труда вычисляем $M$:

|                    | $X$ | $M$ | $X^\prime$ |
|--------------------|-----|-----|------------|
| Волшебный посох    | $0$ | $0$ | $0$        |
| Шапка-невидимка    | $0$ | $0$ | $0$        |
| Ковёр-самолёт      | $0$ | $1$ | $1$        |
| Гитара             | $0$ | $1$ | $1$        |
| Исцеляющее зелье   | $1$ | $1$ | $0$        |
| Чудо-меч           | $1$ | $0$ | $1$        |
| Дурманящий эликсир | $0$ | $0$ | $0$        |

Что ж, учитель притащит ковёр и гитару – поход обещает быть туристическим. И раз учитель магии позаботился и об исцеляющем зелье, можно предположить, что будет весело -- так что несите тайком дурманящий эликсир.

_Предсказатель_ не соврал: всё равно, взяли бы вы с собой набор $X$ или $X^\prime$, результат был бы одинаковый, потому что и в том и в этом случае у вас окажется один и тот же набор уникальных вещей.

А теперь давайте вернёмся к вопросу: сколько раз вам бы пришлось вызывать _Предсказатель_? Если вещей $n$, то в худшем случае вам придётся подать ему на вход $2^{n-1} + 1$ комбинаций вектора $X$, прежде чем вы найдёте $f(X_i) = f(X_j)$ (_Почему именно столько?_).

## Квантовая схема, реализующая алгоритм Саймона

Чем же хороша магия алгоритма Саймона? Давайте увидим своими глазами.

Чтобы упростить схему, зададим $n = 2$. И ещё заранее будем знать, что $M = | 01 \rangle$.


```{figure} /_static/qcblock/simon_algorithm/simon_algo_circuit.png
:name: simon_algo_circuit
:width: 600px
```

Все кубиты инициализируем в состояние $|0\rangle$, а верхние два пропустим через уже, надеюсь, известные вам гейты преобразования Адамара. Также надеюсь, что вы уже прочувствовали, для чего мы это делаем из алгоритма в алгоритм. Если бы мы не использовали матрицы Адамара, то за один вызов _Предсказателя_ смогли бы проверить лишь одно состояние: $|00\rangle$. Но именно благодаря квантовой суперпозиции за один вызов мы проверяем все возможные состояния системы сразу!

$$
\left(\begin{array}{rrrr}
1 & 1 & 1 & 1 \\
1 & -1 & 1 & -1 \\
1 & 1 & -1 & -1 \\
1 & -1 & -1 & 1
\end{array}
\right)
\left(\begin{array}{l}
1 \\
0 \\
0 \\
0
\end{array}\right) = \left( \begin{array}{l}
1 \\
1 \\
1 \\
1
\end{array}\right)
$$

Далее все 4 кубита проходят через новый _Предсказатель_ со звёздочкой, который совершает следующие преобразования с нижними двумя кубитами:

$$X^\prime = X^\prime \oplus F^*(X)$$

и равное просто $F^*(x_i)$.

Верхние кубиты проходят через _Предсказатель_ без изменений. Без изменений, да не совсем. Иначе какой смысл в алгоритме? Мы к этому сейчас вернёмся, а вам я советую факультативно подумать и прочувствовать, как изменение одних кубитов могут повлиять на состояния других? Проанализируйте состояния кубитов после выхода из функции _Предсказателя_:

$$|00\rangle \otimes | F^*(00) \rangle + |01\rangle  \otimes | F^*(01) \rangle + |10\rangle  \otimes | F^*(10) \rangle + |11\rangle  \otimes | F^*(11) \rangle.$$

Тем временем мы вновь пропускаем верхние кубиты через «Адамаров» и производим измерение финального состояния, представленного чуть ниже.

Так вот. Преобразуем мы нижние кубиты, а замеряем верхние, которые прошли через _Предсказатель_ без преобразований. Почему? Нет ли здесь ещё одного замечательного «квантового» свойства кубитов?

Не забывайте, что преобразования нижних кубитов сами зависят от значений верхних. Выходит, что они запутаны? Посмотрите ещё раз на формулу состояния после выхода из _Предсказателя_. Если бы верхние кубиты не были запутаны с нижними, что бы стало с верхними после повторного преобразования Адамара? Мы бы просто сняли с них магию суперпозиции повторным преобразованием Адамара и вернули в начальное состояние $|00\rangle$.

А что произойдёт в действительности? Мы создали ещё по одной суперпозиции -- для каждого запутанного состояния!

$$
\frac{1}{4} \Big[ |00\rangle \otimes \sum_{x=0}^{2^{n-1}}(-1)^{00 \cdot X_0 X_1} F^*(x_0 x_1) +
|01\rangle \otimes \sum_{x=0}^{2^{n-1}}(-1)^{01 \cdot X_0 X_1} F^*(x_0 x_1) + \\
|10\rangle \otimes \sum_{x=0}^{2^{n-1}}(-1)^{10 \cdot X_0 X_1} F^*(x_0 x_1)  +
|11\rangle \otimes \sum_{x=0}^{2^{n-1}}(-1)^{11 \cdot X_0 X_1} F^*(x_0 x_1)  \Big]
$$



Я предлагаю вам самостоятельно расписать вывод этого состояния.

А теперь попробуйте воспользоваться тем фактом, что $f(a \oplus b) = f(a) \otimes b$ и ответить на вопрос, какие состояния примут верхние кубиты после измерения и почему? Что получится, если наш искомый $M$ окажется равным $|01\rangle$? А если он имеет другое состояние?

Далее вас ждёт совершенно классический поиск, который не должен вызвать у вас трудности как у программистов, тем более волшебников. Произведя немного нудный, но нехитрый анализ, вы без труда ответите на выше поставленные вопросы, а также выясните, сколько раз нужно вызвать алгоритм Саймона.
