#+TITLE: Кубит
#+AUTHOR: Семен Синченко
#+LANGUAGE: ru
#+LATEX_HEADER: \usepackage{polyglossia}
#+LATEX_HEADER: \setmainlanguage[babelshorthands = true]{russian}
#+LATEX_HEADER: \setotherlanguage{english}
#+LATEX_HEADER: \setmainfont{Times New Roman}
#+LATEX_HEADER: \newfontfamily{\cyrillicfont}[Ligatures = TeX, Script=Cyrillic]{Times New Roman}
#+LATEX_HEADER: \newfontfamily{\cyrillicfontsf}[Ligatures = TeX, Script=Cyrillic]{Times New Roman}
#+LATEX_HEADER: \newfontfamily{\cyrillicfonttt}[Ligatures = TeX, Script=Cyrillic]{Times New Roman}
#+LATEX_HEADER: \usepackage{amsmath}
#+LATEX_HEADER: \usepackage{physics}
#+LATEX_HEADER: \usepackage{graphicx}
#+LATEX_HEADER: \usepackage{hyperref}
#+LATEX_HEADER: \usepackage{tikz}
#+HTML_HEAD_EXTRA: <link rel="stylesheet" type="text/css" href="https://tikzjax.com/v1/fonts.css">
#+HTML_HEAD_EXTRA: <script src="https://tikzjax.com/v1/tikzjax.js"></script>


* Описание лекции
Из этой лекции мы узнаем:
- Что такое кубит
- В чем разница между значением и состоянием
- Что такое сфера Блоха
- Какие можно делать операции над кубитами
- Что такое измерение

* Введение
Это первая лекция основного блока нашего курса. Перед тем, как мы начнем детально разбирать, что такое кубит и что с ним можно сделать, давайте попробуем взглянуть на то, как выглядит в целом пайплайн квантовых схем.

#+begin_export html
<div align="center">
<script type="text/tikz">
\begin{tikzpicture}[node distance = 2cm]
    \node[align=center] (init) [rectangle, minimum width=4.5cm, minimum height=1cm, draw=black, fill=orange!30] {Init};
    \node[align=center] (first) [rectangle, rounded corners, minimum width=4.5cm, minimum height=1cm, draw=black, fill=red!30, below of=init] {Unitary};
    \node[align=center] (second) [rectangle, rounded corners, minimum width=4.5cm, minimum height=1cm, draw=black, fill=red!30, below of=first] {Unitary};
    \node[align=center] (third) [rectangle, rounded corners, minimum width=4.5cm, minimum height=1cm, draw=black, fill=red!30, below of=second] {Unitary};
    \node[align=center] (measurements) [rectangle, rounded corners, minimum width=4.5cm, minimum height=1cm, draw=black, fill=green!30, below of=third] {Measure};
    \draw [thick,->,>=stealth] (init) -- (first);
    \draw [thick,->,>=stealth] (first) -- (second);
    \draw [thick,->,>=stealth] (second) -- (third);
    \draw [thick,->,>=stealth] (third) -- (measurements);
\end{tikzpicture}
</script>
</div>
#+end_export

#+begin_export latex
\begin{center}

\begin{tikzpicture}[node distance = 2cm]
    \node[align=center] (init) [rectangle, minimum width=4.5cm, minimum height=1cm, draw=black, fill=orange!30] {Init};
    \node[align=center] (first) [rectangle, rounded corners, minimum width=4.5cm, minimum height=1cm, draw=black, fill=red!30, below of=init] {Unitary};
    \node[align=center] (second) [rectangle, rounded corners, minimum width=4.5cm, minimum height=1cm, draw=black, fill=red!30, below of=first] {Unitary};
    \node[align=center] (third) [rectangle, rounded corners, minimum width=4.5cm, minimum height=1cm, draw=black, fill=red!30, below of=second] {Unitary};
    \node[align=center] (measurements) [rectangle, rounded corners, minimum width=4.5cm, minimum height=1cm, draw=black, fill=green!30, below of=third] {Measure};
    \draw [thick,->,>=stealth] (init) -- (first);
    \draw [thick,->,>=stealth] (first) -- (second);
    \draw [thick,->,>=stealth] (second) -- (third);
    \draw [thick,->,>=stealth] (third) -- (measurements);
\end{tikzpicture}

\end{center}
#+end_export

Любая квантовая схема включает в себя:
- кубиты, инициализируемые в начальное состояние, обычно $\ket{0}$;
- унитарные и обратимые операции над кубитами
- измерение кубитов

Именно разбору этих операций для одного кубита мы и посвятим сегодняшнюю лекцию. И начнем мы с того, а что же такое кубит и чем он отличается от бита классических компьютеров.


* Что такое кубит

Как мы знаем, классический компьютер оперирует двоичными числами (0 и 1). Минимальный объем информации для классического компьютера называется бит. Квантовый компьютер оперирует квантовыми битами, или кубитами. Если мы будем считывать кубит, то он так же как и классический бит, будет иметь лишь два возможных значения (0 и 1). Так в чем же разница с обычным битом? В чем особенности квантовых компьютеров, которые и дают им преимущества над классическими компьютерами?

Вся суть на самом деле в том, что для квантовомеханических систем (и кубитов в частности) их *состояния* и *значения* это не одно и то же!

* Состояние vs значение

** Состояние классического бита
Обычно мы не отличаем состояние классического бита от его значения и считаем, что если бит имеет значение *1*, то и состояние его описывается числом *1*.

** Кот Шредингера
Давайте вспомним известный мысленный эксперимента Шредингера -- кот, который одновременно и жив и мертв. Понятно, что *значение* кота точно одно - он либо жив, либо мертв. Но *состояние* его более сложное -- он находится в *суперпозиции* состояний "жив" и "мертв" одновременно!

#+begin_center
#+caption: Кот Шредингера
#+attr_latex: :width 0.6\textwidth
[[./images/Schrodingers_cat.svg.png]]
#+end_center

** Состояние кубита
Состояние кубита, если можно так сказать, аналогично коту Шредингера. Оно отличается от *значения* кубита и описывается вектором из двух комплексных чисел. Мы будем обозначать состояния (или вектора) символом $\ket{\Psi}$ (кет -- вектор-столбец) -- это широко принятая в квантовой механике и квантовых вычислениях нотация Дирака:
\begin{align*}
\ket{\Psi} = \begin{bmatrix}
c_0 \\
c_1
\end{bmatrix}
\end{align*}


#+begin_export html
<details>
<summary>Почему именно комплексные числа?</summary>
<i>Может возникнуть вопрос, а почему комплексные числа? Ну, во-первых, так сложилось исторически. А во-вторых, надо понимать, что комплексные числа у нас фигурируют лишь в самих состояниях, ну и в операторах. Все наблюдаемые величины, а также все вероятности, как мы дальше увидим, это действительные числа. Так что в целом, никакой принципиальной проблемы в том, что у нас тут "не физичные" комплексные числа, нет. Можно ли было придумать математику квантовой механики без комплексных чисел? Наверное да, но тогда она однозначно была бы более сложной и громоздкой.</i>
</details>
#+end_export

#+begin_export latex

\noindent \dotfill \break
\textit{
Может возникнуть вопрос, а почему комплексные числа? Ну, во-первых, так сложилось исторически. А во-вторых, надо понимать, что комплексные числа у нас фигурируют лишь в самих состояниях, ну и в операторах. Все наблюдаемые величины, а также все вероятности, как мы дальше увидим, это действительные числа. Так что в целом, никакой принципиальной проблемы в том, что у нас тут "не физичные" комплексные числа, нет. Можно ли было придумать математику квантовой механики без комплексных чисел? Наверное да, но тогда она однозначно была бы более сложной и громоздкой.}


\noindent \dotfill \break

#+end_export

Что именно означают числа $c_0$ и $c_1$, мы обсудим чуть далее, а пока запишем наш кубит $\ket{\Psi}$ в коде Python. Возьмем, для начала, $c_0 = c_1 = \frac{1}{\sqrt{2}}$.

#+begin_src python
import numpy as np

qubit = np.array([1 / np.sqrt(2) + 0j, 1 / np.sqrt(2) + 0j]).reshape((2, 1))
#+end_src
Заметьте, что здесь мы создаем именно вектор-столбец размерности $2\times1$.
#+begin_src python
qubit.shape
# (2, 1)
#+end_src

** Связь состояния и значения кубита
А теперь разберем подробнее, что же такое наш вектор $\ket{\Psi}$ и что же значат цифры $c_0, c_1$. Для начала посмотрим на то, а какие состояния имеет кубит, для которого мы точно знаем значение. То есть посмотрим на кота Шредингера, но который точно жив или точно мертв.

*** Базисные состояния
Посмотрим, как выглядят состояния кубитов с точно определенными значениями:
\begin{align*}
\ket{0} = \begin{bmatrix}1 \\ 0\end{bmatrix} \text{\qquad} \ket{1} = \begin{bmatrix}0 \\ 1\end{bmatrix}
\end{align*}

Что мы можем сказать об этих состояниях? Как минимум следующее:
- Они ортогональны ($\ket{0} \perp \ket{1}$)
- Они имеют единичную норму
- Они образуют базис

Что это значит для нас? А то, что любое состояние $\ket{\Psi}$ мы можем записать как линейную комбинацию векторов $\ket{0}$ и $\ket{1}$, причем коэффициенты в этой комбинации будут как раз наши $c_0, c_1$:

#+begin_src python
basis_0 = np.array([1 + 0j, 0 + 0j]).reshape((2, 1))
basis_1 = np.array([0 + 0j, 1 + 0j]).reshape((2, 1))

c0 = c1 = 1 / np.sqrt(2)

np.allclose(qubit, c0 * basis_0 + c1 * basis_1)
# True
#+end_src

*** Амплитуды вероятностей
Квантовая механика устроена таким интересным образом, что если мы будем измерять *значение* кубита, то вероятность каждого из вариантов будет пропорциональна соответствующему коэффициенту в разложении *состояния*. Но так как амплитуды у нас это в общем случае комплексные числа, а вероятности должны быть строго действительные, мы должны домножить амплитуды на комплексно сопряженные значения. В случае наших значений $c_0 = c_1 = \frac{1}{\sqrt{2}}$ мы получаем:
#+begin_src python
p0 = np.conj(c0) * c0
p1 = np.conj(c1) * c1

np.allclose(p0, p1)
# True

np.allclose(p0 + p1, 1.0)
# True
#+end_src

Тут мы сразу видим еще одну важную вещь -- сумма вероятностей всех состояний должна быть равна 100%. Это сразу приводит нас к тому, что состояния это не любые комплексные вектора, а комплексные вектора с единичной нормой:

#+begin_src python
np.allclose(np.conj(qubit).T @ qubit, 1.0)
# True
#+end_src

Мы будем очень часто пользоваться транспонированием и взятием комплексно сопряженного от векторов, и в квантовой механике это имеет специальное обозначение $\bra{\Psi} = \Psi^{T*} = \Psi^\dagger$ (бра - вектор-строка). Тогда наше правило нормировки из =NumPy= кода может быть записано в нотации Дирака так:
\begin{align*}
\left\langle\Psi\middle|\Psi\right\rangle = 1
\end{align*}

* Сфера Блоха
Надо понимать, что описанный нами выше базис $\ket{0}, \ket{1}$ не является единственно возможным базисом. Наши вектора $\ket{0}, \ket{1}$ это лишь самый часто применимый базис, который называют $\mathbf{Z}$ базисом. Но есть и другие варианты.


** Возможные базисы
*** Z-базис
Уже описанные нами $\ket{0}$ и $\ket{1}$.

*** X-базис
Базисные состояния $\ket{+} = \frac{\ket{0} + \ket{1}}{\sqrt{2}}$ и $\ket{-} = \frac{\ket{0} - \ket{1}}{\sqrt{2}}$:
#+begin_src python
plus = (basis_0 + basis_1) / np.sqrt(2)
minus = (basis_0 - basis_1) / np.sqrt(2)
#+end_src

*** Y-базис
Базисные состояния $\ket{R} = \frac{\ket{0} + i\ket{1}}{\sqrt{2}}$ и $\ket{L} = \frac{\ket{0} - i\ket{1}}{\sqrt{2}}$:
#+begin_src python
R = (basis_0 + 1j * basis_1) / np.sqrt(2)
L = (basis_0 - 1j * basis_1) / np.sqrt(2)
#+end_src

Легко убедиться, что все вектора каждого из этих базисов ортогональны:
#+begin_src python
np.allclose(np.conj(basis_0).T @ basis_1, 0)
# True
np.allclose(np.conj(plus).T @ minus, 0)
# True
np.allclose(np.conj(R).T @ L, 0)
# True
#+end_src

Заметьте, что в наших векторных пространствах скалярное произведение это $\vec{a}\vec{b} = \left\langle a\middle| b\right\rangle$ (бра-кет)! Именно поэтому мы должны делать транспонирование и комплексное сопряжение первого вектора в паре.

** Сфера Блоха
Обозначения $\ket{0}, \ket{1}, \ket{+}, \ket{-}, \ket{R}, \ket{L}$ выбраны неслучайно -- они имеют геометрический смысл.

#+begin_center
#+caption: Сфера Блоха
#+attr_latex: :width 0.35\textwidth
[[./images/Blochcolor-alt.png]]
#+end_center

Принято считать, что ось $\mathbf{Z}$ это основная ось, так как физически квантовые компьютеры измеряют именно по этой оси. Ось $\mathbf{X}$, если можно так выразиться, смотрит на нас и поэтому обозначается $\ket{+}$ и $\ket{-}$. А ось $\mathbf{Y}$ направлена как бы вдоль, и поэтому базис обозначают как "право" ($\ket{R}$) и "лево" ($\ket{L}$).

Вектор состояния кубита еще называют волновой функцией и этот вектор может идти в любую точку сферы Блоха. Так как сама сфера имеет единичный радиус, это гарантирует нам, что для всех состояний сумму квадратов амплитуд будет равна единице.

*** Состояние в полярных координатах
Состояние кубита можно выразить через полярные координаты на сфере Блоха:
\begin{align*}
\ket{\Psi} = c_0 \ket{0} + c_1 \ket{1} = \cos\theta\ket{0} + e^{i\phi}\sin\theta \ket{1},
\end{align*}
где $\theta,\phi$ - это как раз угловые координаты на сфере Блоха. В этом смысле сфера Блоха очень удобна для представления состояний одного кубита.

* А что можно делать с таким кубитом?
** Линейные операторы
Любое наше действие, которое мы совершаем с кубитом в состоянии $\ket{\Psi}$, должно переводить его в другое состояние $\ket{\Phi}$. Что переводит один вектор в другой вектор в том же пространстве? Правильно, матрица! Ну или, другими словами, линейный оператор. Мы будем обозначать операторы как $\hat{U}$.

** Унитарность
Как мы уже говорили, квадраты амплитуд это у нас вероятности. Следовательно, волновая функция должна быть нормирована на единицу. А значит, любой оператор, который переводит одно состояние в другое $\hat{U}\ket{\Psi} = \ket{\Phi}$, должен сохранять эту нормировку, то есть должен быть *унитарным*. Более того, это свойство приводит к тому, что любой квантовый оператор еще и сохраняет скалярное произведение:

\begin{align*}
\bra{\Psi}\hat{U}^\dagger\hat{U}\ket{\Psi} = \bra{\Psi}\ket{\Psi}
\end{align*}

Другими словами, унитарный оператор удовлетворяет условию $\hat{U}^\dagger \hat{U} = \hat{I}$.

** Обратимость
Одно из важных следствий унитарности операций над кубитами -- это их обратимость. Если вы сделали какую-то последовательность унитарных операций над кубитами $\hat{U}$, то их можно вернуть в начальное состояние, ведь у унитарного оператора всегда есть обратный оператор $\hat{U}^{-1} = \hat{U}^\dagger$.


На самом деле, квантовый компьютер должен уметь делать не только унитарные операции, но и несколько неунитарных, например, инициализацию кубита в определенное состояние (например, $\ket{0}$), и считывание состояния кубитов. Такие неунитарные операции приводят к потере информации и являются необратимыми.

** Пример оператора
Большое число операторов мы будем разбирать в дальнейших лекциях, так как именно операторы (или квантовые *гейты*) являются основой квантовых вычислений. А пока мы посмотрим один простой пример -- оператор Адамара (*Hadamard gate*), который переводит $\ket{0} \to \ket{+}$.

*** Гейт Адамара
Начнем с того, что пока у нас лишь один кубит. Состояние одного кубита это вектор размерности два, а значит оператор, который переводит вектор размерности два в другой вектор размерности два, это матрица $2\times 2$. Запишем оператор Адамара в матричном виде, а потом убедимся, что он унитарный, а еще, что он действительно переводит состояние $\ket{0} \to \ket{+}$.

\begin{align*}
\hat{H} = \frac{1}{\sqrt{2}}\begin{bmatrix}
1 & 1 \\
1 & -1 \\
\end{bmatrix}
\end{align*}

**** Реализация в Python
#+begin_src python
h = 1 / np.sqrt(2) * np.array([
    [1 + 0j, 1 + 0j],
    [1 + 0j, 0j - 1]
])
#+end_src

**** Унитарность
#+begin_src python
np.allclose(np.conj(h) @ h, np.eye(2))
# True
#+end_src

**** Правильное действие
#+begin_src python
np.allclose(h @ basis_0, plus)
# True
#+end_src

* Измерение
*Измерение* в квантовых вычислениях выделяется отдельно именно потому, что оно "открывает" коробку с котом Шредингера -- мы точно узнаем, жив он или мертв, и уже никогда не сможем это "забыть" обратно. Вся *суперпозиция* его состояния исчезает. То есть *измерение* -- это как раз пример одной из неунитарных операций, которые должен уметь делать квантовый компьютер!

#+begin_export html
<details>
<summary>Немного о парадоксе измерений</summary>
<p><i>Это интересный факт - исчезновение суперпозиции многим кажется парадоксом, именно поэтому и появляются разные интерпретации квантовой механики, например, многомировая интерпретация Эверетта. Действительно, это кажется немного странным, что полностью обратимая квантовая механика и непрерывная динамика волновых функций вдруг "ломаются" и мы получаем такой коллапс, который еще называют редукцией фон Неймана. Доктору Эверетт тоже это не нравилось, и он предложил другую интерпретацию этого процесса. Согласно его теории, когда мы производим измерения, мы как бы "расщепляем" нашу вселенную на две ниточки - в одной кот остается жив, а в другой остается мертв.</i></p>

<p><i>К сожалению, любые такие теории все равно остаются на уровне спекуляций, так как почти невозможно придумать эксперимент, который бы подтверждал или опровергал такую гипотезу. Это скорее вопрос того, как каждый из нас понимает этот процесс, так как математически все такие теории в итоге дают один и тот же результат, который мы можем наблюдать и измерять.</i></p>
</details>
#+end_export


#+begin_export latex

\noindent \dotfill \break
\textit{Это интересный факт -- исчезновение суперпозиции многим кажется парадоксом, именно поэтому и появляются разные интерпретации квантовой механики, например, многомировая интерпретация Эверетта. Действительно, это кажется немного странным, что полностью обратимая квантовая механика и непрерывная динамика волновых функций вдруг "ломаются" и мы получаем такой коллапс, который еще называют редукцией фон Неймана. Доктору Эверетт тоже это не нравилось и он предложил другую интерпретацию этого процесса. Согласно его теории, когда мы производим измерения мы как бы "расщепляем" нашу вселенную на две ниточки -- в одной кот остается жив, а в другой остается мертв.}


\textit{К сожалению, любые такие теории все равно остаются на уровне спекуляций, так как почти невозможно придумать эксперимент, который бы подтверждал или опровергал такую гипотезу. Это скорее вопрос того, как каждый из нас понимает этот процесс, так как математически все такие теории в итоге дают один и тот же результат, который мы можем наблюдать и измерять.}


\noindent \dotfill \break
#+end_export


Как мы уже говорили, у кубита может быть несколько разных базисов: $\ket{0}, \ket{1}$, $\ket{+}, \ket{-}$, $\ket{R}, \ket{L}$. *Значение* кубита в каждом из этих базисов может быть измерено. Но что такое измерение с точки зрения математики?

** Операторы Паули
На самом деле, любая наблюдаемая величина соответствует какому-то оператору. Например, измерения в разных базисах \mathbf{X}, \mathbf{Y}, \mathbf{Z} соответствуют операторам Паули:

\begin{align*}
\hat{\sigma^x} = \begin{bmatrix}0 & 1\\1 & 0\end{bmatrix}\qquad\hat{\sigma^y} = \begin{bmatrix}0 & -i\\i & 0\end{bmatrix}\qquad\hat{\sigma^z} = \begin{bmatrix}1 & 0\\0 & -1\end{bmatrix}
\end{align*}

#+begin_src python
pauli_x = np.array([[0 + 0j, 1 + 0j], [1 + 0j, 0 + 0j]])
pauli_y = np.array([[0 + 0j, 0 - 1j], [0 + 1j, 0 + 0j]])
pauli_z = np.array([[1 + 0j, 0 + 0j], [0 + 0j, 0j - 1]])
#+end_src

Эти операторы очень важны -- рекомендуется знать их наизусть, так как они встречаются в каждой 2-й статье по квантовым вычислениям, а также постоянно фигурируют в документации всех основных библиотек для квантового машинного обучения!

** Собственные значения
Хорошо, мы поняли, что есть какая-то связь между нашими измерениями и операторами. Но какая именно? Что значит, например, что измерения по оси $\mathbf{Z}$ соответствуют оператору $\hat{\sigma^Z}$?

И тут мы приходим к собственным значениям операторов. Оказывается (так устроен наш мир), что *измеряя* какую-то величину в квантовой механике, мы всегда будем получать одно из собственных значений соответствующего оператора, а состояние будет коллапсировать в соответствующий собственный вектор этого оператора. Другими словами, *измеряя* кота Шредингера, мы будем получать значения "жив" или "мертв", а состояние кота будет переходить в состояние, соответствующее одному из этих значений. А еще *измерение* не является обратимой операцией -- однажды открыв коробку с котом и увидев, что он жив или мертв, мы уже не сможем закрыть ее обратно и вернуть кота в суперпозицию.

Важно понимать, что это не просто что-то из квантовой физики -- понимание этих вещей нам очень пригодится потом, когда мы будем говорить о решении практических комбинаторных задач, таких, например, как задача о выделении сообществ в графе.

*** Собственные вектора $\hat{\sigma^Z}$
Вернемся к нашему оператору $\hat{\sigma^Z}$. Легко убедиться, что его собственные значения равны 1 и -1, а соответствующие им собственные вектора это $\begin{bmatrix}1 \\ 0\end{bmatrix}$ и $\begin{bmatrix}0 \\ 1\end{bmatrix}$:
#+begin_src python
np.linalg.eig(pauli_z)
# (array([ 1.+0.j, -1.+0.j]),
# array([[1.+0.j, 0.+0.j],
#        [0.+0.j, 1.+0.j]]))
#+end_src

Таким образом, измерение по оси $\mathbf{Z}$ всегда будет давать нам одно из этих двух значений и переводить состояние кубита в соответствующий собственный вектор.

** Формальная запись
Формально мы можем записать это для любого эрмитова оператора $\hat{U}$, что собственные состояния этого оператора являются его собственными векторами, а собственные значения в этом случае являются наблюдаемыми значениями:
\begin{align*}
\hat{U}\ket{\Psi} = u\ket{\Psi}
\end{align*}

** Другие операторы Паули
Убедимся, что у остальных операторов собственные значения такие же:


#+begin_src python
np.linalg.eig(pauli_x)
# (array([ 1.+0.j, -1.+0.j]),
# array([[ 0.70710678-0.j,  0.70710678+0.j],
#        [ 0.70710678+0.j, -0.70710678+0.j]]))
#+end_src

#+begin_src python
np.linalg.eig(pauli_y)
# (array([ 1.+0.j, -1.+0.j]),
# array([[-0.        -0.70710678j,  0.70710678+0.j        ],
#        [ 0.70710678+0.j        ,  0.        -0.70710678j]]))
#+end_src

#+begin_export html
<details>
<summary>Принцип неопределенности Гейзенберга</summary>
<i>Можно заметить, что у всех операторов Паули нет ни одного общего собственного вектора. Таким образом, мы приходим к ситуации, когда мы не можем одновременно точно измерить два разных оператора, так как наше измерение должно переводить состояние в соответствующий собственный вектор. В квантовой механике это называется принципом неопределенности.</i>
</details>
#+end_export

#+begin_export latex


\noindent \dotfill \break
\textit{
Можно заметить, что у всех операторов Паули нет ни одного общего собственного вектора. Таким образом, мы приходим к ситуации, когда мы не можем одновременно точно измерить два разных оператора, так как наше измерение должно переводить состояние в соответствующий собственный вектор. В квантовой механике это называется \textbf{принципом неопределенности}.}


\noindent \dotfill \break
#+end_export

** Ожидаемое значение при измерении
Мы не будем писать с нуля полный симулятор кубитов, который включает измерения -- это требует введения сложного случайного процесса. Но мы можем легко ответить на другой вопрос. А именно, мы можем сказать, а какое будет *ожидаемое* значение оператора $\hat{U}$ для состояния $\Psi$? Ну или, другими словами, какое будет математическое ожидание большого числа измерений. Это можно записать следующим образом:
\begin{align*}
\mathbf{E}(\hat{U}) = \bra{\Psi}\hat{U}\ket{\Psi}
\end{align*}

Например, оператор $\hat{\sigma^z}$ полностью не определен в состоянии $\ket{+}$, то есть мы будем равновероятно получать значения -1 и 1, а математическое ожидание, соответственно, будет равно нулю:
#+begin_src python
plus.conj().T @ pauli_z @ plus
# array([[0.+0.j]])
#+end_src

С другой стороны, измеряя состояние $\ket{+}$ в *X*-базисе мы всегда будем получать 1:
#+begin_src python
plus.conj().T @ pauli_x @ plus
# array([[1.+0.j]])
#+end_src

** Вероятности битовых строк
Последнее, чего хотелось бы коснуться в части измерений -- это битовых строк и метода Шредингера. Мы много говорили о вероятностной интерпретации волновой функции и аналогиях с классическим битом, но пока этого никак не касались на практике. Как же нам получить вероятность определенной битовой строки для произвольного состояния? На самом деле, если мы возьмем все битовые строки размерности вектора состояния и отсортируем их в лексикографическом порядке (например, $0 < 1$, $00 < 01 < 10 < 11$, и т.д.), то вероятность каждой битовой строки получается следующим выражением:
\begin{align*}
\mathbf{P} = | \bra{\Psi}\ket{\vec{s}} |^2,
\end{align*}
где $\vec{s}$ -- это вектор, каждая компонента которого соответствует порядковой битовой строке, ну или вектор битовых строк, если выражаться иначе. Другими словами, вероятность получить /i/-ю битовую строку равна квадрату /i/-го элемента амплитуды волновой функции. Кажется немного запутанным, но на самом деле все просто -- ведь $|\ket{\Psi}|^2$ это идейно и есть плотность вероятности.

** Еще пара слов об измерениях
*** Измерение как проекция на пространство собственных векторов
Мы уже говорили, что при измерении мы как бы "выбираем" один из собственных векторов наблюдаемой. Более строго такой процесс называется проецированием на пространство собственных векторов. Для собственного вектора $\ket{\Phi}$ проекция на самом деле будет линейным оператором:
\begin{align*}
\hat{P}_{\ket{\Phi}} = \ket{\Phi}\bra{\Phi}
\end{align*}

#+begin_src python
super_position = h @ basis_0
eigenvectors = np.linalg.eig(pauli_z)[1]

proj_0 = eigenvectors[0].reshape((-1, 1)) @ eigenvectors[0].reshape((1, -1))
proj_1 = eigenvectors[1].reshape((-1, 1)) @ eigenvectors[1].reshape((1, -1))
#+end_src


*** Правило Борна
Вероятность наблюдения каждого из собственных значений $\lambda$ какого-то оператора $\hat{U}$ определяется как результат измерения оператора проекции на соответствующий собственный вектор:
\begin{align*}
\mathbf{P}(\lambda_i) = \bra{\Psi} \hat{P_i} \ket{\Psi}
\end{align*}

А считать ожидаемое значение оператора мы уже умеем! Давайте убедимся, что для состояния $\ket{\Psi} = \frac{1}{\sqrt{2}}\begin{bmatrix} 1 \\ 1\end{bmatrix}$ результаты измерений операторов проекций дадут нам 0.5 и совпадут с результатом упражнения, которое мы проделали ранее:

#+begin_src python
p_0 = super_position.conj().T @ proj_0 @ super_position
p_1 = super_position.conj().T @ proj_1 @ super_position

np.allclose(p_0 + p_1, 1.0)
# True
np.allclose(p_0, 0.5)
# True
#+end_src


* Что мы узнали?
- Состояние и значение для кубита не одно и то же
- Состояния -- комплекснозначные вектора
- Квантовые операторы -- унитарные и самосопряженные
- Измеряемые значения -- собственные значения операторов
- Измерение ломает суперпозицию
