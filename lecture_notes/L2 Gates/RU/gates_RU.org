#+TITLE: Гейты
#+AUTHOR: Семен Синченко
#+LANGUAGE: ru
#+LATEX_HEADER: \setmainlanguage{russian}
#+LATEX_HEADER: \setotherlanguage{english}
#+LATEX_HEADER: \setmainfont{Times New Roman}
#+LATEX_HEADER: \usepackage{amsmath}
#+LATEX_HEADER: \usepackage{physics}
#+LATEX_HEADER: \usepackage{graphicx}
#+LATEX_HEADER: \usepackage{hyperref}

#+OPTIONS: tex:dvisvgm

* Описание лекции
Из этой лекции мы узнаем:
- Какие есть основные однокубитные гейты
- Как записывать многокубитные состояния
- Какие есть многокубитные гейты
- Конструирование многокубитных операторов

* Основные однокубитные гейты
В прошлый раз мы познакомились с операторами Паули, а также гейтом Адамара. Теперь давайте посмотрим какие еще однокубитные гейты часто применяются в квантовых вычислениях и квантовом машинном обучнении.

** Гейты поворота вокруг оси
Повротные гейты играют центральную роль в квантовом машинном обучении. Вспомним на секунду, как выглядят наши однокубитные состояния на сфере Блоха:

#+begin_center
#+caption: Сфера Блоха
#+attr_latex: :width 0.35\textwidth
[[./images/Blochcolor-alt.png]]
#+end_center

Гейты $\hat{RX(\phi)}, \hat{RY(\phi)}, \hat{RZ(\phi)}$ осуществляют поворот на определенный угол $\phi$ вокруг соответствующей оси на сфере Блоха.


Давайте внимательно рассмотрим это на примере гейта $\hat{RY}$.



*** Гейт $\hat{RY}$
Сам гейт определяется следующим образом:

\begin{align*}
\hat{RY(\phi)} = \begin{bmatrix}
\cos(\frac{\phi}{2}) & -\sin(\frac{\phi}{2}) \\
\sin(\frac{\phi}{2}) & \cos(\frac{\phi}{2})
\end{bmatrix}
\end{align*}

#+begin_src python
import numpy as np

def ry(state, phi):
    return np.array([
        [np.cos(phi / 2), -np.sin(phi / 2)],
        [np.sin(phi / 2), np.cos(phi /2)]
    ]) @ state
#+end_src

Запишем наше состояние $\ket{0}$

#+begin_src python
basis = np.array([1 + 0j, 0 + 0j]).reshape((2, 1))
#+end_src

Внимательно посмотрев на сферу Блоха, можно заметить, что повернув состояние из $\ket{0}$ на $\pi$ и измерив значение $\hat{\sigma^z}$ мы получим 1, а повернув на $-\pi$ 0:
#+begin_src python
def expval(state, op):
    return state.conj().T @ op @ state

pauli_x = np.array([[0 + 0j, 1 + 0j], [1 + 0j, 0 + 0j]])

np.allclose(expval(ry(basis, np.pi / 2), pauli_x), 1.0)
# True

np.allclose(expval(ry(basis, -np.pi / 2), pauli_x), -1.0)
# True
#+end_src

Убедимся также, что вращение на угол, пропорциональный $2\pi$ не меняет результата измерения. Возьмем случайное состояние:
\begin{align*}
\ket{\Psi} = \begin{bmatrix}
0.42 \\
\sqrt{1 - 0.42^2}
\end{bmatrix}
\end{align*}

#+begin_src python
random_state = np.array([0.42 + 0j, np.sqrt(1 - 0.42**2) + 0j]).reshape((2, 1))
#+end_src

Измерим его по осям $\mathbf{X}$ и $\mathbf{Z}$, затем повернем его на угол $2\pi$ и измерм снова:

#+begin_src python
pauli_z = np.array([[1 + 0j, 0 + 0j], [0 + 0j, 0j - 1]])

expval(random_state, pauli_z)
# array([[-0.6472+0.j]])
expval(random_state, pauli_x)
# array([[0.76232025+0.j]])

expval(ry(random_state, 2 * np.pi), pauli_z)
# array([[-0.6472+0.j]])
expval(ry(random_state, 2 * np.pi), pauli_x)
# array([[0.76232025+0.j]])
#+end_src

*** Другие гейты вращений
Аналогичным образом определяются гейты $\hat{RX}$ и $\hat{RZ}$:
\begin{align*}
\hat{RX(\phi)} = \begin{bmatrix}
\cos(\frac{\phi}{2}) & -i\sin(\frac{\phi}{2}) \\
-i\sin(\frac{\phi}{2}) & \cos(\frac{\phi}{2})
\end{bmatrix} \qquad \hat{RZ(\phi)} = \begin{bmatrix}
e^{-\frac{i\phi}{2}} & 0 \\
0 & e^{\frac{i\phi}{2}}
\end{bmatrix}
\end{align*}

*** Общаяя форма записи гейтов $\hat{R^{\sigma}}$

В общем случае эти гейты могут быть также записаны следующим образом:
\begin{align*}
\hat{R^\sigma} = e^{-\frac{i\phi\sigma}{2}},
\end{align*}
где $\sigma$ -- это один из операторов Пуали $\sigma^x, \sigma^y, \sigma^Z$.

Забегая вперед, можно сказать, что именно гейты вращений являются основным инструментов квантовых вариационных схем -- основного инструмента этого курса.

** Phase-shift гейт
Другой важный гейт -- это так называемый phase-shift гейт, или $\hat{U_1}$ гейт. Его матричная форма имеет следующий вид:
\begin{align*}
\hat{U_1(\phi)} = \begin{bmatrix}
1 & 0 \\
0 & e^{i\phi}
\end{bmatrix}
\end{align*}

#+begin_src python
def u1(state, phi):
    return np.array([[1, 0], [0, np.exp(1j * phi)]]) @ state
#+end_src

Забегая вперед можно сказать, что этот гейт играет важную роль в квантовых ядерных методах.

** $\hat{U_2}$ и $\hat{U_3}$
