#+TITLE: Гейты
#+AUTHOR: Семен Синченко
#+LANGUAGE: ru
#+LATEX_HEADER: \setmainlanguage{russian}
#+LATEX_HEADER: \setotherlanguage{english}
#+LATEX_HEADER: \setmainfont{Times New Roman}
#+LATEX_HEADER: \usepackage{amsmath}
#+LATEX_HEADER: \usepackage{physics}
#+LATEX_HEADER: \usepackage{graphicx}
#+LATEX_HEADER: \usepackage{hyperref}

#+OPTIONS: tex:dvisvgm

* Описание лекции
Из этой лекции мы узнаем:
- Какие есть основные однокубитные гейты
- Как записывать многокубитные состояния
- Какие есть многокубитные гейты
- Конструирование многокубитных операторов
- Первое знакомство с PennyLane

* Введение
Квантовые гейты являются основными "строительными" блоками для любых квантовых схем, в том числе и тех, которые применяются для машинного обучения. Можно сказать, что это такой алфавит квантовых вычислений, он просто необходимо, чтобы сходу понимать, например, что изображено на подобных схемах:
#+begin_center
#+attr_latex: :width 0.35\textwidth
#+caption: Картинка взята из [[https://arxiv.org/abs/2102.05566][Layer-VQE]]
[[./images/Layer-VQE.png]]
#+end_center

* Основные однокубитные гейты
В прошлый раз мы познакомились с операторами Паули, а также гейтом Адамара. Теперь давайте посмотрим какие еще однокубитные гейты часто применяются в квантовых вычислениях и квантовом машинном обучнении.

** Гейты поворота вокруг оси
Повротные гейты играют центральную роль в квантовом машинном обучении. Вспомним на секунду, как выглядят наши однокубитные состояния на сфере Блоха:

#+begin_center
#+caption: Сфера Блоха
#+attr_latex: :width 0.35\textwidth
[[./images/Blochcolor-alt.png]]
#+end_center

Гейты $\hat{RX(\phi)}, \hat{RY(\phi)}, \hat{RZ(\phi)}$ осуществляют поворот на определенный угол $\phi$ вокруг соответствующей оси на сфере Блоха.


Давайте внимательно рассмотрим это на примере гейта $\hat{RY}$.



*** Гейт $\hat{RY}$
Сам гейт определяется следующим образом:

\begin{align*}
\hat{RY(\phi)} = \begin{bmatrix}
\cos(\frac{\phi}{2}) & -\sin(\frac{\phi}{2}) \\
\sin(\frac{\phi}{2}) & \cos(\frac{\phi}{2})
\end{bmatrix}
\end{align*}

#+begin_src python
import numpy as np

def ry(state, phi):
    return np.array([
        [np.cos(phi / 2), -np.sin(phi / 2)],
        [np.sin(phi / 2), np.cos(phi /2)]
    ]) @ state
#+end_src

Запишем наше состояние $\ket{0}$

#+begin_src python
basis = np.array([1 + 0j, 0 + 0j]).reshape((2, 1))
#+end_src

Внимательно посмотрев на сферу Блоха, можно заметить, что повернув состояние из $\ket{0}$ на $\pi$ и измерив значение $\hat{\sigma^z}$ мы получим 1, а повернув на $-\pi$ 0:
#+begin_src python
def expval(state, op):
    return state.conj().T @ op @ state

pauli_x = np.array([[0 + 0j, 1 + 0j], [1 + 0j, 0 + 0j]])

np.allclose(expval(ry(basis, np.pi / 2), pauli_x), 1.0)
# True

np.allclose(expval(ry(basis, -np.pi / 2), pauli_x), -1.0)
# True
#+end_src

Убедимся также, что вращение на угол, пропорциональный $2\pi$ не меняет результата измерения. Возьмем случайное состояние:
\begin{align*}
\ket{\Psi} = \begin{bmatrix}
0.42 \\
\sqrt{1 - 0.42^2}
\end{bmatrix}
\end{align*}

#+begin_src python
random_state = np.array([0.42 + 0j, np.sqrt(1 - 0.42**2) + 0j]).reshape((2, 1))
#+end_src

Измерим его по осям $\mathbf{X}$ и $\mathbf{Z}$, затем повернем его на угол $2\pi$ и измерм снова:

#+begin_src python
pauli_z = np.array([[1 + 0j, 0 + 0j], [0 + 0j, 0j - 1]])

expval(random_state, pauli_z)
# array([[-0.6472+0.j]])
expval(random_state, pauli_x)
# array([[0.76232025+0.j]])

expval(ry(random_state, 2 * np.pi), pauli_z)
# array([[-0.6472+0.j]])
expval(ry(random_state, 2 * np.pi), pauli_x)
# array([[0.76232025+0.j]])
#+end_src

*** Другие гейты вращений
Аналогичным образом определяются гейты $\hat{RX}$ и $\hat{RZ}$:
\begin{align*}
\hat{RX(\phi)} = \begin{bmatrix}
\cos(\frac{\phi}{2}) & -i\sin(\frac{\phi}{2}) \\
-i\sin(\frac{\phi}{2}) & \cos(\frac{\phi}{2})
\end{bmatrix} \qquad \hat{RZ(\phi)} = \begin{bmatrix}
e^{-\frac{i\phi}{2}} & 0 \\
0 & e^{\frac{i\phi}{2}}
\end{bmatrix}
\end{align*}

*** Общаяя форма записи гейтов $\hat{R^{\sigma}}$

В общем случае эти гейты могут быть также записаны следующим образом:
\begin{align*}
\hat{R^\sigma} = e^{-\frac{i\phi\sigma}{2}},
\end{align*}
где $\sigma$ -- это один из операторов Пуали $\sigma^x, \sigma^y, \sigma^Z$.

Забегая вперед, можно сказать, что именно гейты вращений являются основным инструментов квантовых вариационных схем -- основного инструмента этого курса.

** Phase-shift гейт
Другой важный гейт -- это так называемый phase-shift гейт, или $\hat{U_1}$ гейт. Его матричная форма имеет следующий вид:
\begin{align*}
\hat{U_1(\phi)} = \begin{bmatrix}
1 & 0 \\
0 & e^{i\phi}
\end{bmatrix}
\end{align*}

#+begin_src python
def u1(state, phi):
    return np.array([[1, 0], [0, np.exp(1j * phi)]]) @ state
#+end_src

Забегая вперед можно сказать, что этот гейт играет важную роль в квантовых ядерных методах.

** $\hat{U_2}$ и $\hat{U_3}$
Более редкие в QML гейты, которые, однако, все равно встречаются в статьях.

\begin{align*}
\hat{U_2(\phi, \lambda)} = \frac{1}{\sqrt{2}}\begin{bmatrix}
1 & -e^{i\lambda} \\
e^{i\phi} & e^{i(\phi + \lambda)}
\end{bmatrix} = \hat{U_1(\phi + \lambda)}\hat{RZ(-\lambda)}\hat{RY(\frac{\pi}{2})}\hat{RZ(\lambda)}
\end{align*}

Давайте убедимся в справедливости этого выражения:
#+begin_src python
def rz(state, phi):
    return np.array([[np.exp(-1j * phi / 2), 0], [0, np.exp(1j * phi / 2)]]) @ state


def u2_direct(phi, l):
    return (
        1
        / np.sqrt(2)
        * np.array([[1, -np.exp(1j * l)], [np.exp(1j * phi), np.exp(1j * (phi + l))]])
    )


def u2_inferenced(phi, l):
    return (
        u1(np.eye(2), phi + l)
        @ rz(np.eye(2), -l)
        @ ry(np.eye(2), np.pi / 2)
        @ rz(np.eye(2), l)
    )


np.allclose(u2_direct(np.pi / 6, np.pi / 3), u2_inferenced(np.pi / 6, np.pi / 3))
# True
#+end_src

Схожим образом определяется $\hat{U_3(\theta, \phi, \lambda)}$:
\begin{align*}
\hat{U_3(\theta, \phi, \lambda)} = \begin{bmatrix}
\cos(\frac{\theta}{2}) & -e^{1j\lambda}\sin(\frac{\theta}{2}) \\
e^{1j\phi}\sin(\frac{\theta}{2}) & e^{1j(\phi + \lambda)}\cos(\frac{\theta}{2})
\end{bmatrix} = \hat{U_1(\phi + \lambda)}\hat{RZ(-\lambda)}\hat{RY(\theta)}\hat{RZ(\lambda)}
\end{align*}

Читатель может сам легко убедиться, что эти формы записи эквивалентны. Для этого надо написать примерно такой же код, какой мы писали раньше для $\hat{U_2}$.

** Еще пара слов об однокубитных гейтах
На этом мы завершаем обзор основных однокубитных гейтов. Маленькое замечание -- гейты, связанные со свдигом фазы никак не меняют состояние кубита, если оно сейчас $\ket{0}$. Учитывая, что мы всегда предполагаем, что наше начальное состояние кубитов это именно $\ket{0}$, то перед тем как применять, например, гейт $\hat{U_1}$ рекомендуется применить гейт Адамара:

#+begin_src python
np.allclose(u1(basis, np.pi / 6), basis)
# True

h = 1 / np.sqrt(2) * np.array([[1 + 0j, 1 + 0j], [1 + 0j, 0j - 1]])
np.allclose(u1(h @ basis, np.pi / 6), h @ basis)
# False
#+end_src

*** Единичнй гейт
Самое последнее об однокубитных гейтах -- это единичный гейт $\hat{I}$:
\begin{align*}
\hat{I} = \begin{bmatrix}
1 & 0 \\
0 & 1
\end{bmatrix}
\end{align*}

#+begin_src python
i = np.eye(2, dtype=np.complex128)
# array([[1.+0.j, 0.+0.j],
#        [0.+0.j, 1.+0.j]])
#+end_src

Этот гейт не делает с кубитом ровным счетом ничего. Но он все равно нам понадобаится, когда мы будем конструировать многокубитные операторы!
