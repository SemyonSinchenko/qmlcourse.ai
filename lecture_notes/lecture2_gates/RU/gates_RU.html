<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Семен Синченко" />
  <title>Гейты</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  
  
  
  
  
  
  
  
  
  
  
  
  
</head>
<body>
<header>
<h1 class="title">Гейты</h1>
<p class="author">Семен Синченко</p>
</header>
<h1 id="описание-лекции">Описание лекции</h1>
<p>Из этой лекции мы узнаем:</p>
<ul>
<li>Какие есть основные однокубитные гейты</li>
<li>Как записывать многокубитные состояния</li>
<li>Как конструировать многокубитные операторы</li>
<li>Какие есть многокубитные гейты</li>
<li>Как работать с библиотекой PennyLane</li>
</ul>
<h1 id="введение">Введение</h1>
<p>Квантовые гейты являются основными <em>строительными</em> блоками для любых квантовых схем, в том числе и тех, которые применяются для машинного обучения. Можно сказать, что это такой алфавит квантовых вычислений, он просто необходим, чтобы сходу понимать, например, что изображено на подобных схемах:</p>
<div class="center">
<figure>
<img src="./images/Layer-VQE_enlarged.png" alt="Картинка взята из Layer-VQE" width="700" /><figcaption>Картинка взята из <a href="https://arxiv.org/abs/2102.05566">Layer-VQE</a></figcaption>
</figure>
</div>
<h1 id="основные-однокубитные-гейты">Основные однокубитные гейты</h1>
<p>В прошлый раз мы познакомились с операторами Паули, а также гейтом Адамара. Как для обычных квантовых алгоритмов, так и для QML-алгоритмов нужны и другие гейты, потому что одни только эти гейты не позволяют перейти во все возможные квантовые состояния. Теперь давайте посмотрим, какие еще однокубитные гейты часто применяются в квантовых вычислениях и квантовом машинном обучении.</p>
<h2 id="t-гейт">T-гейт</h2>
<p>T-гейт очень популярен в универсальных квантовых вычислениях. Его матрица имеет вид</p>
<span class="math display">\[\begin{align*}
\hat{T} = \begin{bmatrix}
1 &amp; 0 \\
0 &amp; \frac{1+i}{\sqrt{2}}
\end{bmatrix}
\end{align*}
\]</span>
<p>Любой однокубитный гейт можно аппроксимировать последовательностью гейтов Адамара и T-гейтов. Чем точнее требуется аппроксимация, тем длиннее будет аппроксимирующая последовательность.</p>
<p>Помимо важной роли в математике квантовых вычислений, гейт Адамара и T-гейт интересны тем, что именно на них построено большинство предложений по реализации квантовых вычислений с топологической защитой или с коррекцией ошибок. На сегодняшний день эти схемы реально пока не очень работают: никаких топологически защищённых кубитов продемонстрировано не было, а коррекция ошибок не выходит за пределы двух логических кубитов.</p>
<h2 id="гейты-поворота-вокруг-оси">Гейты поворота вокруг оси</h2>
<p>Поворотные гейты играют центральную роль в квантовом машинном обучении. Вспомним на секунду, как выглядят наши однокубитные состояния на сфере Блоха:</p>
<div class="center">
<figure>
<img src="./images/Blochcolor-alt.png" alt="Сфера Блоха" /><figcaption>Сфера Блоха</figcaption>
</figure>
</div>
<p>Любой однокубитный гейт можно представить как вращение луча состояния <span class="math inline">\(\Psi\)</span> на некоторый угол вокруг некоторой оси, проходящей через центр сферы Блоха.</p>
<p>Гейты <span class="math inline">\(\hat{RX}(\phi), \hat{RY}(\phi), \hat{RZ}(\phi)\)</span> осуществляют поворот на определенный угол <span class="math inline">\(\phi\)</span> вокруг соответствующей оси на сфере Блоха.</p>
<p>Давайте внимательно рассмотрим это на примере гейта <span class="math inline">\(\hat{RY}\)</span>.</p>
<h3 id="гейт-hatry">Гейт <span class="math inline">\(\hat{RY}\)</span></h3>
<p>Сам гейт определяется следующим образом:</p>
<span class="math display">\[\begin{align*}
\hat{RY}(\phi) = \begin{bmatrix}
\cos(\frac{\phi}{2}) &amp; -\sin(\frac{\phi}{2}) \\
\sin(\frac{\phi}{2}) &amp; \cos(\frac{\phi}{2})
\end{bmatrix}
\end{align*}
\]</span>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="im">import</span> numpy <span class="im">as</span> np</a>
<a class="sourceLine" id="cb1-2" data-line-number="2"></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="kw">def</span> ry(state, phi):</a>
<a class="sourceLine" id="cb1-4" data-line-number="4">    <span class="cf">return</span> np.array([</a>
<a class="sourceLine" id="cb1-5" data-line-number="5">        [np.cos(phi <span class="op">/</span> <span class="dv">2</span>), <span class="op">-</span>np.sin(phi <span class="op">/</span> <span class="dv">2</span>)],</a>
<a class="sourceLine" id="cb1-6" data-line-number="6">        [np.sin(phi <span class="op">/</span> <span class="dv">2</span>),  np.cos(phi <span class="op">/</span> <span class="dv">2</span>)]</a>
<a class="sourceLine" id="cb1-7" data-line-number="7">    ]) <span class="op">@</span> state</a></code></pre></div>
<p>Запишем наше состояние <span class="math inline">\(\ket{0}\)</span>:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb2-1" data-line-number="1">basis <span class="op">=</span> np.array([<span class="dv">1</span> <span class="op">+</span> 0j, <span class="dv">0</span> <span class="op">+</span> 0j]).reshape((<span class="dv">2</span>, <span class="dv">1</span>))</a></code></pre></div>
<p>Внимательно посмотрев на сферу Блоха, можно заметить, что повернув состояние из <span class="math inline">\(\ket{0}\)</span> на <span class="math inline">\(\pi\)</span> и измерив значение <span class="math inline">\(\hat{\sigma^z}\)</span> мы получим 1, а повернув на <span class="math inline">\(-\pi\)</span> мы получим 0:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">def</span> expval(state, op):</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">    <span class="cf">return</span> state.conj().T <span class="op">@</span> op <span class="op">@</span> state</a>
<a class="sourceLine" id="cb3-3" data-line-number="3"></a>
<a class="sourceLine" id="cb3-4" data-line-number="4">pauli_x <span class="op">=</span> np.array([[<span class="dv">0</span> <span class="op">+</span> 0j, <span class="dv">1</span> <span class="op">+</span> 0j], [<span class="dv">1</span> <span class="op">+</span> 0j, <span class="dv">0</span> <span class="op">+</span> 0j]])</a>
<a class="sourceLine" id="cb3-5" data-line-number="5"></a>
<a class="sourceLine" id="cb3-6" data-line-number="6">np.allclose(expval(ry(basis, np.pi <span class="op">/</span> <span class="dv">2</span>), pauli_x), <span class="fl">1.0</span>)</a>
<a class="sourceLine" id="cb3-7" data-line-number="7"><span class="co"># True</span></a>
<a class="sourceLine" id="cb3-8" data-line-number="8"></a>
<a class="sourceLine" id="cb3-9" data-line-number="9">np.allclose(expval(ry(basis, <span class="op">-</span>np.pi <span class="op">/</span> <span class="dv">2</span>), pauli_x), <span class="fl">-1.0</span>)</a>
<a class="sourceLine" id="cb3-10" data-line-number="10"><span class="co"># True</span></a></code></pre></div>
<p>Убедимся также, что вращение на угол, пропорциональный <span class="math inline">\(2\pi\)</span>, не меняет результата измерения. Возьмем случайное состояние:</p>
<span class="math display">\[\begin{align*}
\ket{\Psi} = \begin{bmatrix}
0.42 \\
\sqrt{1 - 0.42^2}
\end{bmatrix}
\end{align*}
\]</span>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb4-1" data-line-number="1">random_state <span class="op">=</span> np.array([<span class="fl">0.42</span> <span class="op">+</span> 0j, np.sqrt(<span class="dv">1</span> <span class="op">-</span> <span class="fl">0.42</span><span class="op">**</span><span class="dv">2</span>) <span class="op">+</span> 0j]).reshape((<span class="dv">2</span>, <span class="dv">1</span>))</a></code></pre></div>
<p>Измерим его по осям <span class="math inline">\(\mathbf{X}\)</span> и <span class="math inline">\(\mathbf{Z}\)</span>, затем повернем его на угол <span class="math inline">\(2\pi\)</span> и измерим снова:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb5-1" data-line-number="1">pauli_z <span class="op">=</span> np.array([[<span class="dv">1</span> <span class="op">+</span> 0j, <span class="dv">0</span> <span class="op">+</span> 0j], [<span class="dv">0</span> <span class="op">+</span> 0j, 0j <span class="op">-</span> <span class="dv">1</span>]])</a>
<a class="sourceLine" id="cb5-2" data-line-number="2"></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">expval(random_state, pauli_z)</a>
<a class="sourceLine" id="cb5-4" data-line-number="4"><span class="co"># array([[-0.6472+0.j]])</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5">expval(random_state, pauli_x)</a>
<a class="sourceLine" id="cb5-6" data-line-number="6"><span class="co"># array([[0.76232025+0.j]])</span></a>
<a class="sourceLine" id="cb5-7" data-line-number="7"></a>
<a class="sourceLine" id="cb5-8" data-line-number="8">expval(ry(random_state, <span class="dv">2</span> <span class="op">*</span> np.pi), pauli_z)</a>
<a class="sourceLine" id="cb5-9" data-line-number="9"><span class="co"># array([[-0.6472+0.j]])</span></a>
<a class="sourceLine" id="cb5-10" data-line-number="10">expval(ry(random_state, <span class="dv">2</span> <span class="op">*</span> np.pi), pauli_x)</a>
<a class="sourceLine" id="cb5-11" data-line-number="11"><span class="co"># array([[0.76232025+0.j]])</span></a></code></pre></div>
<h3 id="другие-гейты-вращений">Другие гейты вращений</h3>
<p>Аналогичным образом определяются гейты <span class="math inline">\(\hat{RX}\)</span> и <span class="math inline">\(\hat{RZ}\)</span>:</p>
<span class="math display">\[\begin{align*}
\hat{RX}(\phi) = \begin{bmatrix}
\cos(\frac{\phi}{2}) &amp; -i\sin(\frac{\phi}{2}) \\
-i\sin(\frac{\phi}{2}) &amp; \cos(\frac{\phi}{2})
\end{bmatrix} \qquad \hat{RZ}(\phi) = \begin{bmatrix}
e^{-\frac{i\phi}{2}} &amp; 0 \\
0 &amp; e^{\frac{i\phi}{2}}
\end{bmatrix}
\end{align*}
\]</span>
<h3 id="общая-форма-записи-однокубитных-гейтов">Общая форма записи однокубитных гейтов</h3>
<p>В общем случае однокубитные гейты могут быть также записаны следующим образом:</p>
<span class="math display">\[\begin{align*}
\large \hat{R}^\vec{n}(\alpha) = e^{-\frac{i\alpha\hat{\vec{\sigma}}\vec{n}}{2}},
\end{align*}
\]</span>
<p>где <span class="math inline">\(\alpha\)</span> – это угол поворота, <span class="math inline">\(\vec{n}\)</span> – единичный вектор в направлении оси поворота, а <span class="math inline">\(\hat{\vec{\sigma}} = \{\hat{\sigma}^x, \hat{\sigma}^y, \hat{\sigma}^z\}\)</span> – это вектор, составленный из операторов Паули. Если использовать покоординатную запись и <span class="math inline">\(\vec{n} = \{n_x, n_y, n_z\}\)</span> задаёт ось вращения, то</p>
<span class="math display">\[\begin{align*}
\large \hat{R}^\vec{n}(\alpha) = e^{-i\frac{\alpha}{2}\left(\hat{\sigma}^xn_x+\hat{\sigma}^yn_y+\hat{\sigma}^zn_z\right)}.
\end{align*}
\]</span>
<p>Забегая вперед, можно сказать, что именно гейты вращений – это основа квантовых вариационных схем, главного инструмента этого курса.</p>
<h2 id="phase-shift-гейт">Phase-shift гейт</h2>
<p>Другой важный гейт – это так называемый phase-shift гейт, или <span class="math inline">\(\hat{U}_1\)</span> гейт. Его матричная форма имеет следующий вид:</p>
<span class="math display">\[\begin{align*}
\hat{U}_1(\phi) = \begin{bmatrix}
1 &amp; 0 \\
0 &amp; e^{i\phi}
\end{bmatrix}
\end{align*}
\]</span>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">def</span> u1(state, phi):</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">    <span class="cf">return</span> np.array([[<span class="dv">1</span>, <span class="dv">0</span>], [<span class="dv">0</span>, np.exp(1j <span class="op">*</span> phi)]]) <span class="op">@</span> state</a></code></pre></div>
<p>Легко видеть, что с точностью до глобального фазового множителя, который ни на что не влияет, Phase-shift-гейт – это тот же <span class="math inline">\(\hat{RZ}(\phi)\)</span>. Забегая вперед, можно сказать, что этот гейт играет важную роль в квантовых ядерных методах.</p>
<h2 id="hatu_2-и-hatu_3"><span class="math inline">\(\hat{U}_2\)</span> и <span class="math inline">\(\hat{U}_3\)</span></h2>
<p>Более редкие в QML гейты, которые однако все равно встречаются в статьях.</p>
<span class="math display">\[\begin{align*}
\hat{U}_2(\phi, \lambda) = \frac{1}{\sqrt{2}}\begin{bmatrix}
1 &amp; -e^{i\lambda} \\
e^{i\phi} &amp; e^{i(\phi + \lambda)}
\end{bmatrix} = \hat{U}_1(\phi + \lambda)\hat{RZ}(-\lambda)\hat{RY}(\frac{\pi}{2})\hat{RZ}(\lambda)
\end{align*}
\]</span>
<p>Давайте убедимся в справедливости этого выражения:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">def</span> rz(state, phi):</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">    <span class="cf">return</span> np.array([[np.exp(<span class="op">-</span>1j <span class="op">*</span> phi <span class="op">/</span> <span class="dv">2</span>), <span class="dv">0</span>], [<span class="dv">0</span>, np.exp(1j <span class="op">*</span> phi <span class="op">/</span> <span class="dv">2</span>)]]) <span class="op">@</span> state</a>
<a class="sourceLine" id="cb7-3" data-line-number="3"></a>
<a class="sourceLine" id="cb7-4" data-line-number="4"></a>
<a class="sourceLine" id="cb7-5" data-line-number="5"><span class="kw">def</span> u2_direct(phi, l):</a>
<a class="sourceLine" id="cb7-6" data-line-number="6">    <span class="cf">return</span> (</a>
<a class="sourceLine" id="cb7-7" data-line-number="7">        <span class="dv">1</span></a>
<a class="sourceLine" id="cb7-8" data-line-number="8">        <span class="op">/</span> np.sqrt(<span class="dv">2</span>)</a>
<a class="sourceLine" id="cb7-9" data-line-number="9">        <span class="op">*</span> np.array([[<span class="dv">1</span>, <span class="op">-</span>np.exp(1j <span class="op">*</span> l)], [np.exp(1j <span class="op">*</span> phi), np.exp(1j <span class="op">*</span> (phi <span class="op">+</span> l))]])</a>
<a class="sourceLine" id="cb7-10" data-line-number="10">    )</a>
<a class="sourceLine" id="cb7-11" data-line-number="11"></a>
<a class="sourceLine" id="cb7-12" data-line-number="12"></a>
<a class="sourceLine" id="cb7-13" data-line-number="13"><span class="kw">def</span> u2_inferenced(phi, l):</a>
<a class="sourceLine" id="cb7-14" data-line-number="14">    <span class="cf">return</span> (</a>
<a class="sourceLine" id="cb7-15" data-line-number="15">        u1(np.eye(<span class="dv">2</span>), phi <span class="op">+</span> l)</a>
<a class="sourceLine" id="cb7-16" data-line-number="16">        <span class="op">@</span> rz(np.eye(<span class="dv">2</span>), <span class="op">-</span>l)</a>
<a class="sourceLine" id="cb7-17" data-line-number="17">        <span class="op">@</span> ry(np.eye(<span class="dv">2</span>), np.pi <span class="op">/</span> <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb7-18" data-line-number="18">        <span class="op">@</span> rz(np.eye(<span class="dv">2</span>), l)</a>
<a class="sourceLine" id="cb7-19" data-line-number="19">    )</a>
<a class="sourceLine" id="cb7-20" data-line-number="20"></a>
<a class="sourceLine" id="cb7-21" data-line-number="21"></a>
<a class="sourceLine" id="cb7-22" data-line-number="22">np.allclose(u2_direct(np.pi <span class="op">/</span> <span class="dv">6</span>, np.pi <span class="op">/</span> <span class="dv">3</span>), u2_inferenced(np.pi <span class="op">/</span> <span class="dv">6</span>, np.pi <span class="op">/</span> <span class="dv">3</span>))</a>
<a class="sourceLine" id="cb7-23" data-line-number="23"><span class="co"># True</span></a></code></pre></div>
<p>Схожим образом определяется <span class="math inline">\(\hat{U}_3(\theta, \phi, \lambda)\)</span>:</p>
<span class="math display">\[\begin{align*}
\hat{U}_3(\theta, \phi, \lambda) = \begin{bmatrix}
\cos(\frac{\theta}{2}) &amp; -e^{1j\lambda}\sin(\frac{\theta}{2}) \\
e^{1j\phi}\sin(\frac{\theta}{2}) &amp; e^{1j(\phi + \lambda)}\cos(\frac{\theta}{2})
\end{bmatrix} = \hat{U}_1(\phi + \lambda)\hat{RZ}(-\lambda)\hat{RY}(\theta)\hat{RZ}(\lambda)
\end{align*}
\]</span>
<p>Читатель может сам легко убедиться, что эти формы записи эквивалентны. Для этого надо написать примерно такой же код, какой мы писали раньше для <span class="math inline">\(\hat{U}_2\)</span>.</p>
<h2 id="еще-пара-слов-об-однокубитных-гейтах">Еще пара слов об однокубитных гейтах</h2>
<p>На этом мы завершаем обзор основных однокубитных гейтов. Маленькое замечание – гейты, связанные со сдвигом фазы, никак не меняют состояние кубита, если оно сейчас <span class="math inline">\(\ket{0}\)</span>. Учитывая, что мы всегда предполагаем, что наше начальное состояние кубитов это именно <span class="math inline">\(\ket{0}\)</span>, то перед тем как применять, например, гейт <span class="math inline">\(\hat{U}_1\)</span>, рекомендуется применить гейт Адамара:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb8-1" data-line-number="1">np.allclose(u1(basis, np.pi <span class="op">/</span> <span class="dv">6</span>), basis)</a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="co"># True</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3"></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">h <span class="op">=</span> <span class="dv">1</span> <span class="op">/</span> np.sqrt(<span class="dv">2</span>) <span class="op">*</span> np.array([[<span class="dv">1</span> <span class="op">+</span> 0j, <span class="dv">1</span> <span class="op">+</span> 0j], [<span class="dv">1</span> <span class="op">+</span> 0j, 0j <span class="op">-</span> <span class="dv">1</span>]])</a>
<a class="sourceLine" id="cb8-5" data-line-number="5">np.allclose(u1(h <span class="op">@</span> basis, np.pi <span class="op">/</span> <span class="dv">6</span>), h <span class="op">@</span> basis)</a>
<a class="sourceLine" id="cb8-6" data-line-number="6"><span class="co"># False</span></a></code></pre></div>
<h3 id="единичный-гейт">Единичный гейт</h3>
<p>Самое последнее об однокубитных гейтах – это единичный гейт <span class="math inline">\(\hat{I}\)</span>:</p>
<span class="math display">\[\begin{align*}
\hat{I} = \begin{bmatrix}
1 &amp; 0 \\
0 &amp; 1
\end{bmatrix}
\end{align*}
\]</span>
<div class="sourceCode" id="cb9"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb9-1" data-line-number="1">i <span class="op">=</span> np.eye(<span class="dv">2</span>, dtype<span class="op">=</span>np.complex128)</a>
<a class="sourceLine" id="cb9-2" data-line-number="2"><span class="co"># array([[1.+0.j, 0.+0.j],</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3"><span class="co">#        [0.+0.j, 1.+0.j]])</span></a></code></pre></div>
<p>Этот гейт не делает с кубитом ровным счетом ничего. Но он все равно нам понадобится, когда мы будем конструировать многокубитные операторы!</p>
<h1 id="многокубитные-состояния-и-гейты">Многокубитные состояния и гейты</h1>
<p>Очевидно, что с одним кубитом мы ничего интересного (ну кроме генератора истинно-случайных чисел) мы не сделаем. Давайте для начала разберемся, как выглядят состояния для многокубитных систем.</p>
<h2 id="многокубитные-состояния">Многокубитные состояния</h2>
<p>В классическом компьютере 1 бит имеет два значения – 0 и 1; 2 бита имеют 4 – 00, 01, 10, 11; 3 бита 8 значений и т.д. По аналогии, состояние двух кубит – это вектор в пространстве <span class="math inline">\(\mathbf{C}^4\)</span>; состояние трех кубит, соответственно, в пространстве <span class="math inline">\(\mathbf{C}^8\)</span> и т.д., то есть состояние <span class="math inline">\(N\)</span> кубит описывается вектором размерности <span class="math inline">\(2^N\)</span> в комплексном пространстве. Вероятности каждой из возможных битовых строк (<span class="math inline">\(0000...00\)</span>, <span class="math inline">\(0000...01\)</span>, <span class="math inline">\(0000...10\)</span>, и т.д.) получаются по методу Шрёдингера, который мы обсуждали в конце прошлой лекции:</p>
<span class="math display">\[\begin{align*}
\mathbf{P}(\vec{s}) = | \bra{\Psi}\ket{\vec{s}} |^2
\end{align*}
\]</span>
<p>Напомню, что по сути мы должны отсортировать наши битовые строки в лексикографическом порядке и вероятность <em>i</em>-й битовой строки будет равна квадрату <em>i</em>-го элемента вектора <span class="math inline">\(\ket{\Psi}\)</span>.</p>
<p>Формально, многокубитные состояния описываются с помощью математического концепта так называемого тензорного произведения, или по-другому, произведения Кронекера, обозначаемого значком <span class="math inline">\(\otimes\)</span>. Так, если <span class="math inline">\(\ket{\Psi}_A \in \mathrm{H}_A\)</span> и <span class="math inline">\(\ket{\Psi}_B \in \mathrm{H}_B\)</span>, то <span class="math inline">\(\ket{\Psi}_{AB} = \ket{\Psi}_A \otimes \ket{\Psi}_B \in \mathrm{H}_{AB} = \mathrm{H}_{A} \otimes \mathrm{H}_{B}\)</span>. Как элементы вектора <span class="math inline">\(\ket{\Psi}_{AB}\)</span> выражаются через элементы векторов <span class="math inline">\(\ket{\Psi}_{A}\)</span> и <span class="math inline">\(\ket{\Psi}_{B}\)</span>, можно прочитать на Википедии в статье <a href="https://ru.wikipedia.org/wiki/Произведение_Кронекера/">&quot;Произведение Кронекера&quot;</a>.</p>
<h2 id="многокубитные-операторы">Многокубитные операторы</h2>
<p>Как мы уже обсуждали, квантовые операторы должны переводить наше состояние в новое состояние в том же пространстве и сохранять нормировку, а еще должны быть обратимыми. И, значит, оператор для состояния из <span class="math inline">\(N\)</span> кубит – это унитарная комплексная матрица размерности <span class="math inline">\(2^N \times 2^N\)</span>.</p>
<h2 id="конструирование-многокубитных-операторов">Конструирование многокубитных операторов</h2>
<p>Прежде чем мы начнем обсуждать двухкубитные операторы, давайте рассмотрим другую ситуацию. Представим, что у нас есть состояние из 2-х кубитов и мы хотим подействовать на первый кубит, например, оператором Адамара. Как же тогда нам написать такой двухкубитный оператор? Ок, мы действуем на 1-й кубит оператором, а что происходит со вторым кубитом? А ничего не происходит, и это эквивалентно тому, что мы действуем на 2-й кубит единичным оператором. А финальный оператор <span class="math inline">\(2^2 \times 2^2\)</span> записывается через <a href="https://ru.wikipedia.org/wiki/Произведение_Кронекера/">произведение Кронекера</a>:</p>
<span class="math display">\[\begin{align*}
\hat{H} \otimes \hat{I} = \frac{1}{\sqrt{2}}\begin{bmatrix}
1 &amp; 1 \\
1 &amp; -1
\end{bmatrix} \otimes \begin{bmatrix}
1 &amp; 0 \\
0 &amp; 1
\end{bmatrix} = \frac{1}{\sqrt{2}} \begin{bmatrix}
\hat{I} &amp; \hat{I} \\
\hat{I} &amp; -\hat{I}
\end{bmatrix} = \frac{1}{\sqrt{2}} \begin{bmatrix}
1 &amp; 0 &amp; 1 &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; 1 \\
1 &amp; 0 &amp; -1 &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; -1
\end{bmatrix}
\end{align*}
\]</span>
<p>Учитывая, что многокубитные состояния конструируются аналогичным образом через произведение Кронекера, мы можем явно убедиться в верности нашего вывода:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb10-1" data-line-number="1">np.allclose(np.kron(h <span class="op">@</span> basis, basis), np.kron(h, i) <span class="op">@</span> np.kron(basis, basis))</a>
<a class="sourceLine" id="cb10-2" data-line-number="2"><span class="co"># True</span></a></code></pre></div>
<h2 id="наблюдаемые-для-многокубитных-гейтов">Наблюдаемые для многокубитных гейтов</h2>
<p>Аналогичным образом можно сконструировать и наблюдаемые. Например, если мы хотим измерять одновременно два спина по оси <span class="math inline">\(\mathbf{Z}\)</span>, то наблюдаемая будет выглядеть так:</p>
<span class="math display">\[\begin{align*}
\mathbf{ZZ} = \hat{\sigma^z} \otimes \hat{\sigma^z} = \begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; -1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; -1 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix}
\end{align*}
\]</span>
<div class="sourceCode" id="cb11"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb11-1" data-line-number="1">np.kron(basis, basis).conj().T <span class="op">@</span> np.kron(pauli_z, pauli_z) <span class="op">@</span> np.kron(basis, basis)</a>
<a class="sourceLine" id="cb11-2" data-line-number="2"><span class="co"># array([[1.+0.j]])</span></a></code></pre></div>
<h1 id="основные-двухкубитные-гейты">Основные двухкубитные гейты</h1>
<p>Основные многокубитные гейты, которые предоставляют современные квантовые компьютеры, это двухкубитные гейты.</p>
<h2 id="cnot-cx">CNOT (CX)</h2>
<p>Квантовый гейт контролируемого инвертирования – это гейт, который действует на два кубита – <em>рабочий</em> и <em>контрольный</em>. В зависимости от того, имеет ли контрольный кубит значение 1 или 0, этот гейт инвертирует или не инвертирует рабочий кубит.</p>
<div class="center">
<figure>
<img src="./images/CNOT_gate.svg.png" alt="CNOT (CX)" /><figcaption>CNOT (CX)</figcaption>
</figure>
</div>
<p>Иногда этот гейт также называют гейтом CX. В матричном виде этот оператор можно записать так:</p>
<span class="math display">\[\begin{align*}
\hat{CNOT} = \begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; 0\\
0 &amp; 1 &amp; 0 &amp; 0\\
0 &amp; 0 &amp; 0 &amp; 1\\
0 &amp; 0 &amp; 1 &amp; 0
\end{bmatrix}
\end{align*}
\]</span>
<div class="sourceCode" id="cb12"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb12-1" data-line-number="1">cnot <span class="op">=</span> (<span class="dv">1</span> <span class="op">+</span> 0j) <span class="op">*</span> np.array(</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">    [</a>
<a class="sourceLine" id="cb12-3" data-line-number="3">        [<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>],</a>
<a class="sourceLine" id="cb12-4" data-line-number="4">        [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>],</a>
<a class="sourceLine" id="cb12-5" data-line-number="5">        [<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>],</a>
<a class="sourceLine" id="cb12-6" data-line-number="6">        [<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>],</a>
<a class="sourceLine" id="cb12-7" data-line-number="7">    ]</a>
<a class="sourceLine" id="cb12-8" data-line-number="8">)</a>
<a class="sourceLine" id="cb12-9" data-line-number="9"></a>
<a class="sourceLine" id="cb12-10" data-line-number="10">np.allclose(cnot <span class="op">@</span> np.kron(basis, basis), np.kron(basis, basis))</a>
<a class="sourceLine" id="cb12-11" data-line-number="11"><span class="co"># True</span></a>
<a class="sourceLine" id="cb12-12" data-line-number="12"></a>
<a class="sourceLine" id="cb12-13" data-line-number="13">np.allclose(</a>
<a class="sourceLine" id="cb12-14" data-line-number="14">    cnot <span class="op">@</span> np.kron(pauli_x <span class="op">@</span> basis, basis), np.kron(pauli_x <span class="op">@</span> basis, pauli_x <span class="op">@</span> basis)</a>
<a class="sourceLine" id="cb12-15" data-line-number="15">)</a>
<a class="sourceLine" id="cb12-16" data-line-number="16"><span class="co"># True</span></a></code></pre></div>
<p>Заметьте, тут мы воспользовались тем, что <span class="math inline">\(\hat{\sigma^x}\)</span> работает так же, как инвертор кубитов – он превращает <span class="math inline">\(\ket{0}\)</span> в <span class="math inline">\(\ket{1}\)</span> и наоборот!</p>
<h2 id="гейты-cy-и-cz">Гейты CY и CZ</h2>
<p>Схожие по принципу гейты – это гейты <span class="math inline">\(\hat{CY}\)</span> и <span class="math inline">\(\hat{CZ}\)</span>. В зависимости от значения <em>управляющего</em> кубита к <em>рабочему</em> кубиту применяют соответствующий оператор Паули:</p>
<span class="math display">\[\begin{align*}
\hat{CY} = \begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; 0\\
0 &amp; 1 &amp; 0 &amp; 0\\
0 &amp; 0 &amp; 0 &amp; -i\\
0 &amp; 0 &amp; i &amp; 0
\end{bmatrix} \qquad \hat{CZ} = \begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; 0\\
0 &amp; 1 &amp; 0 &amp; 0\\
0 &amp; 0 &amp; 1 &amp; 0\\
0 &amp; 0 &amp; 0 &amp; -1
\end{bmatrix}
\end{align*}
\]</span>
<h2 id="гейт-iswap">Гейт iSWAP</h2>
<p>Гейты <span class="math inline">\(\hat{CX}\)</span>, <span class="math inline">\(\hat{CY}\)</span> и <span class="math inline">\(\hat{CZ}\)</span> эквивалентны с точностью до однокубитных гейтов. Это означает, что любой из них можно получить добавив необходимые однокубитные гейты до и после другого гейта. Так, например,</p>
<span class="math display">\[\begin{align*}
\hat{CZ} = \left(\hat{I}\times\hat{H}\right)\hat{CX}\left(\hat{I}\times\hat{H}\right).
\end{align*}
\]</span>
<p>Этим свойством обладают отнюдь не все двухкубитные гейты! Например, таковым является гейт iSWAP:</p>
<span class="math display">\[\begin{align*}
\mathrm{iSWAP} = \begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; 0\\
0 &amp; 0 &amp; -i &amp; 0\\
0 &amp; -i &amp; 0 &amp; 0\\
0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix}
\end{align*}
\]</span>
<h2 id="гейт-fsim">Гейт fSim</h2>
<p>Для разных архитектур квантовых процессоров &quot;естественный&quot; гейт может выглядеть по-разному. Так, например, в квантовом процессоре Google Sycamore естественным является так называемый fermionic simulation gate, или fSim. Это двухпараметрическое семейство гейтов вида</p>
<span class="math display">\[\begin{align*}
\mathrm{fSim}(\theta, \phi) = \begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; 0\\
0 &amp; \cos\theta &amp; -i\sin\theta &amp; 0\\
0 &amp; -i\sin\theta &amp; \cos\theta &amp; 0\\
0 &amp; 0 &amp; 0 &amp; e^{-i\phi}
\end{bmatrix}.
\end{align*}
\]</span>
<p>Впрочем, и fSim-гейт не является эквивалентным всему множеству двухкубитных гейтов. В общем случае, чем больше кубитов, тем сложнее будет выглядеть декомпозиция произвольного гейта на физически реализуемые в железе.</p>
<h1 id="первое-знакомство-с-pennylane">Первое знакомство с PennyLane</h1>
<p>На сегодня существует уже достаточно много фреймворков для программирования квантовых компьютеров. Для целей этого курса мы будем использовать <a href="https://pennylane.ai/">PennyLane</a>. Он предоставляет высокоуровневый <code>Python API</code> и создан специально для решения задач квантового машинного обучения.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="im">import</span> pennylane <span class="im">as</span> qml</a></code></pre></div>
<h2 id="device">Device</h2>
<p>Для объявления квантового устройства используется класс <code>Device</code>. <code>PennyLane</code> поддерживает работу с большинством существующих сегодня квантовых компьютеров, но для целей курса мы будем запускать все наши программы лишь на самом простом симуляторе идеального квантового компьютера:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb14-1" data-line-number="1">device <span class="op">=</span> qml.device(<span class="st">&quot;default.qubit&quot;</span>, <span class="dv">2</span>)</a></code></pre></div>
<p>Первый аргумент тут – указание устройства, а второй – число кубит.</p>
<h2 id="qnode">QNode</h2>
<p>Основной <em>строительный блок</em> в <code>PennyLane</code> – это <code>qnode</code>. Это функция, которая отмечена специальным декоратором и включает в себя несколько операций с кубитами. Результатом такой функции всегда является измерение. Напишем функцию, которая поворачивает первый кубит на <span class="math inline">\(45^o\)</span>, после чего измеряет оба кубита по оси <span class="math inline">\(\mathbf{Z}\)</span>.</p>
<h3 id="сначала-на-numpy">Сначала на NumPy</h3>
<div class="sourceCode" id="cb15"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb15-1" data-line-number="1">state <span class="op">=</span> np.kron(basis, basis)</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">op <span class="op">=</span> np.kron(ry(np.eye(<span class="dv">2</span>), np.deg2rad(<span class="dv">45</span>)), np.eye(<span class="dv">2</span>, dtype<span class="op">=</span>np.complex128))</a>
<a class="sourceLine" id="cb15-3" data-line-number="3">measure <span class="op">=</span> np.kron(pauli_z, pauli_z)</a>
<a class="sourceLine" id="cb15-4" data-line-number="4"></a>
<a class="sourceLine" id="cb15-5" data-line-number="5">(op <span class="op">@</span> state).conj().T <span class="op">@</span> measure <span class="op">@</span> (op <span class="op">@</span> state)</a>
<a class="sourceLine" id="cb15-6" data-line-number="6"><span class="co"># array([[0.70710678+0.j]])</span></a></code></pre></div>
<h3 id="теперь-через-qnode">Теперь через QNode</h3>
<div class="sourceCode" id="cb16"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="at">@qml.qnode</span>(device)</a>
<a class="sourceLine" id="cb16-2" data-line-number="2"><span class="kw">def</span> test(angle):</a>
<a class="sourceLine" id="cb16-3" data-line-number="3">    qml.RY(angle, wires<span class="op">=</span><span class="dv">0</span>)</a>
<a class="sourceLine" id="cb16-4" data-line-number="4">    <span class="cf">return</span> qml.expval(qml.PauliZ(<span class="dv">0</span>) <span class="op">@</span> qml.PauliZ(<span class="dv">1</span>))</a>
<a class="sourceLine" id="cb16-5" data-line-number="5"></a>
<a class="sourceLine" id="cb16-6" data-line-number="6"></a>
<a class="sourceLine" id="cb16-7" data-line-number="7">test(np.deg2rad(<span class="dv">45</span>))</a>
<a class="sourceLine" id="cb16-8" data-line-number="8"><span class="co"># 0.7071067811865475</span></a></code></pre></div>
<h1 id="заключение">Заключение</h1>
<p>Это последняя вводная лекция, где мы сами писали операторы и операции на чистом <code>NumPy</code>. Это могло казаться скучным, но зато должно помочь лучше понять ту математику, которая лежит под капотом у квантовых вычислений. Дальше мы будем пользоваться только <code>PennyLane</code> и будет отдельная лекция, которая рассказывает, как работать с этим фреймворком.</p>
<ul>
<li>Мы знаем что такое кубит</li>
<li>Мы понимаем линейную алгебру, которая описывает квантовые вычисления</li>
<li>Мы понимаем, как можно сконструировать нужный нам оператор и как применить его</li>
<li>Мы знаем, что такое измерение и наблюдаемые</li>
</ul>
<p>Теперь мы готовы к тому, чтобы знакомиться с квантовыми вариационными схемами и переходить непосредственно к построению моделей квантового машинного обучения!</p>
<h1 id="задачи">Задачи</h1>
<ul>
<li>Как связаны ось и угол вращения на сфере Блоха с собственными значениями и собственными векторами матрицы однокубитного гейта? Для этого найдите собственные векторы и собственные значения гейта <span class="math inline">\(R^\vec{n}\left(\alpha\right)\)</span>.</li>
<li>Вокруг какой оси и на какой угол вращает состояние гейт Адамара?</li>
<li>Гейт SWAP меняет кубиты местами. Его унитарная матрица имеет вид</li>
</ul>
<span class="math display">\[\begin{align*}
\mathrm{SWAP} =
\begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 1 &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix}.
\end{align*}
\]</span>
<p>Попробуйте составить последовательность гейтов, реализующую <span class="math inline">\(\mathrm{SWAP}\)</span>, из гейтов <span class="math inline">\(\mathrm{iSWAP}\)</span>, <span class="math inline">\(\hat{CZ}\)</span> и <span class="math inline">\(\hat{RZ}(\phi)\)</span>.</p>
</body>
</html>
