%% Generated by Sphinx.
\def\sphinxdocclass{jupyterBook}
\documentclass[letterpaper,10pt,english]{jupyterBook}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}
%% turn off hyperref patch of \index as sphinx.xdy xindy module takes care of
%% suitable \hyperpage mark-up, working around hyperref-xindy incompatibility
\PassOptionsToPackage{hyperindex=false}{hyperref}
%% memoir class requires extra handling
\makeatletter\@ifclassloaded{memoir}
{\ifdefined\memhyperindexfalse\memhyperindexfalse\fi}{}\makeatother

\PassOptionsToPackage{warn}{textcomp}

\catcode`^^^^00a0\active\protected\def^^^^00a0{\leavevmode\nobreak\ }
\usepackage{cmap}
\usepackage{fontspec}
\defaultfontfeatures[\rmfamily,\sffamily,\ttfamily]{}
\usepackage{amsmath,amssymb,amstext}
\usepackage{polyglossia}
\setmainlanguage{english}



\setmainfont{FreeSerif}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Italic,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldItalic
]
\setsansfont{FreeSans}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Oblique,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldOblique,
]
\setmonofont{FreeMono}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Oblique,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldOblique,
]



\usepackage[Bjarne]{fncychap}
\usepackage[,numfigreset=1,mathnumfig]{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\contentsname}{Введение}}

\usepackage{sphinxmessages}



        % Start of preamble defined in sphinx-jupyterbook-latex %
         \usepackage[Latin,Greek]{ucharclasses}
        \usepackage{unicode-math}
        % fixing title of the toc
        \addto\captionsenglish{\renewcommand{\contentsname}{Contents}}
        \hypersetup{
            pdfencoding=auto,
            psdextra
        }
        % End of preamble defined in sphinx-jupyterbook-latex %
        

\title{QMLCourse}
\date{Dec 14, 2022}
\release{}
\author{ODS Quantum Community}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{book/index::doc}}




\begin{sphinxuseclass}{sd-container-fluid}
\begin{sphinxuseclass}{sd-sphinx-override}
\begin{sphinxuseclass}{sd-mb-4}
\begin{sphinxuseclass}{sd-row}
\begin{sphinxuseclass}{sd-col}
\begin{sphinxuseclass}{sd-d-flex-row}
\begin{sphinxuseclass}{sd-card}
\begin{sphinxuseclass}{sd-sphinx-override}
\begin{sphinxuseclass}{sd-w-100}
\begin{sphinxuseclass}{sd-shadow-sm}
\begin{sphinxuseclass}{sd-card-body}
\begin{sphinxuseclass}{sd-card-title}
\begin{sphinxuseclass}{sd-font-weight-bold}Почему именно этот курс?
\end{sphinxuseclass}
\end{sphinxuseclass}
\sphinxAtStartPar
Наш курс отличается от других курсов по квантовым вычислениям, потому что он:
\begin{itemize}
\item {} 
\sphinxAtStartPar
адаптивный и содержит лекции разных уровней сложности и глубины;

\item {} 
\sphinxAtStartPar
практический, а все объяснения подкрепляются кодом;

\item {} 
\sphinxAtStartPar
про реальные методы, которые будут актуальны ближайшие 10\sphinxhyphen{}15 лет.

\end{itemize}

\sphinxAtStartPar
Основатель курса \sphinxhref{https://github.com/SemyonSinchenko}{Синченко Семён}:
\begin{quote}

\sphinxAtStartPar
Я очень люблю квантовые технологии и являюсь их большим энтузиастом. При этом моя основная работа связана с машинным обучением, поэтому идею сделать курс по QML я вынашивал очень давно. В сообществе ODS мне удалось найти единомышленников, и вместе мы подготовили для вас набор лекций и домашних заданий, которые проведут вас через удивительный мир кубитов, гейтов и квантовых нейросетей. Мы очень хотели сделать курс одновременно простым и понятным, но также строгим и глубоким с технической точки зрения и, надеюсь, у нас это получилось. В основном мы будем обсуждать темы, которые будут перспективны в ближайшие годы, а также максимально ориентироваться на практической стороне вопроса. Я лично верю, что квантовые технологии по мере их развития произведут не меньшую революцию, чем, например, распространение вычислений на видеокартах, а также позволят по\sphinxhyphen{}другому подойти к задачам, которые мы раньше не умели решать . Надеюсь, что после прохождения этого курса поверите и вы! В любом случае, я уверен, что тема QML и квантовых вычислений как минимум стоит того, чтобы с ней познакомиться. Надеюсь, что вам будет интересно!
\end{quote}

\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\begin{sphinxuseclass}{sd-col}
\begin{sphinxuseclass}{sd-d-flex-row}
\begin{sphinxuseclass}{sd-card}
\begin{sphinxuseclass}{sd-sphinx-override}
\begin{sphinxuseclass}{sd-w-100}
\begin{sphinxuseclass}{sd-shadow-sm}
\begin{sphinxuseclass}{sd-card-body}
\begin{sphinxuseclass}{sd-card-title}
\begin{sphinxuseclass}{sd-font-weight-bold}Why this course?
\end{sphinxuseclass}
\end{sphinxuseclass}
\sphinxAtStartPar
Our course is different from other courses on quantum computing because it is:
\begin{itemize}
\item {} 
\sphinxAtStartPar
adaptive and contains lectures of different levels of complexity and depth;

\item {} 
\sphinxAtStartPar
practical, and all explanations are backed up by code;

\item {} 
\sphinxAtStartPar
about real methods that will be relevant in the next 10\sphinxhyphen{}15 years.

\end{itemize}

\sphinxAtStartPar
Course Founder \sphinxhref{https://github.com/SemyonSinchenko}{Sinchenko Semyon}:
\begin{quote}

\sphinxAtStartPar
I love quantum technologies and am a great enthusiast of them. At the same time my main job is associated with machine learning, so the idea to make a course on QML I hatched a long time ago. In the ODS community I’ve managed to find like\sphinxhyphen{}minded people, and together we have prepared a set of lectures and homework assignments that will lead you through the wonderful world of qubits, gates and quantum neural networks. We really wanted to make the course both simple and clear, but also rigorous and deep from a technical point of view, and hopefully we succeeded. Basically, we will discuss topics that will be promising in the coming years, as well as focus on the practical side of the issue as much as possible. I personally believe that quantum technologies, as they develop, will produce no less of a revolution than, for example, the spread of video\sphinxhyphen{}card computing, as well as allow us to approach problems that we did not know how to solve before in a different way. I hope that after taking this course, you will too! In any case, I am convinced that the topic of QML and quantum computing at least worth getting acquainted with it. I hope that you will be interesting!
\end{quote}

\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\begin{sphinxuseclass}{sd-container-fluid}
\begin{sphinxuseclass}{sd-sphinx-override}
\begin{sphinxuseclass}{sd-mb-4}
\begin{sphinxuseclass}{sd-row}
\begin{sphinxuseclass}{sd-col}
\begin{sphinxuseclass}{sd-d-flex-row}
\begin{sphinxuseclass}{sd-card}
\begin{sphinxuseclass}{sd-sphinx-override}
\begin{sphinxuseclass}{sd-w-100}
\begin{sphinxuseclass}{sd-shadow-sm}
\begin{sphinxuseclass}{sd-card-body}
\begin{sphinxuseclass}{sd-card-title}
\begin{sphinxuseclass}{sd-font-weight-bold}Как устроен курс?
\end{sphinxuseclass}
\end{sphinxuseclass}
\sphinxAtStartPar
Наш курс разделен на логические блоки, каждый из которых содержит лекции разных уровней сложности:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{ГОЛУБОЙ} – вводные лекции;

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{ЗЕЛЕНЫЙ} – лекции “основного” блока курса;

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{ЖЕЛТЫЙ} – лекции, глубже раскрывающие темы блоков;

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{КРАСНЫЙ} – лекции про физику и математику, которая стоит за всем этим;

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{БЕЛЫЙ} – факультативные лекции.

\end{itemize}

\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\begin{sphinxuseclass}{sd-col}
\begin{sphinxuseclass}{sd-d-flex-row}
\begin{sphinxuseclass}{sd-card}
\begin{sphinxuseclass}{sd-sphinx-override}
\begin{sphinxuseclass}{sd-w-100}
\begin{sphinxuseclass}{sd-shadow-sm}
\begin{sphinxuseclass}{sd-card-body}
\begin{sphinxuseclass}{sd-card-title}
\begin{sphinxuseclass}{sd-font-weight-bold}How does the course work?
\end{sphinxuseclass}
\end{sphinxuseclass}
\sphinxAtStartPar
Our course is divided into logical blocks, each containing lectures of different levels of difficulty:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{CYAN} – introductory lectures;

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{GREEN} – lectures in the “main” block of the course;

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{YELLOW} – lectures that go deeper into the units;

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{RED} – lectures on the physics and mathematics behind it all;

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{WHITE} – elective lectures.

\end{itemize}

\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{program}.png}
\caption{Программа курса / Course program}\label{\detokenize{book/index:course-program}}\end{figure}

\begin{sphinxuseclass}{sd-container-fluid}
\begin{sphinxuseclass}{sd-sphinx-override}
\begin{sphinxuseclass}{sd-mb-4}
\begin{sphinxuseclass}{sd-row}
\begin{sphinxuseclass}{sd-col}
\begin{sphinxuseclass}{sd-d-flex-row}
\begin{sphinxuseclass}{sd-card}
\begin{sphinxuseclass}{sd-sphinx-override}
\begin{sphinxuseclass}{sd-w-100}
\begin{sphinxuseclass}{sd-shadow-sm}
\begin{sphinxuseclass}{sd-card-body}
\begin{sphinxuseclass}{sd-card-title}
\begin{sphinxuseclass}{sd-font-weight-bold}Как проходить этот курс?
\end{sphinxuseclass}
\end{sphinxuseclass}
\sphinxAtStartPar
Рекомендуется проходить курс в том порядке, который обозначен на схеме. У курса есть {\hyperref[\detokenize{book/intro/ru/prerequisite::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{пререквизиты}}}} –\sphinxhyphen{} программирование на Python, основы линейной алгебры и машинного обучения, советуем с ними ознакомиться и (опционально) проверить себя с помощью \sphinxhref{https://ods.ai/tracks/qmlcourse/blocks/ee9f2a26-6234-4a72-84a6-a05de035bb1a}{входного теста}.

\sphinxAtStartPar
Курс обсуждается в \sphinxhref{https://ods.ai/tracks/odsmatrix101}{matrix.ods.ai} в канале \sphinxcode{\sphinxupquote{{[}course{]} quantum ml}}.

\sphinxAtStartPar
\sphinxstylestrong{Желаем успехов!}

\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\begin{sphinxuseclass}{sd-col}
\begin{sphinxuseclass}{sd-d-flex-row}
\begin{sphinxuseclass}{sd-card}
\begin{sphinxuseclass}{sd-sphinx-override}
\begin{sphinxuseclass}{sd-w-100}
\begin{sphinxuseclass}{sd-shadow-sm}
\begin{sphinxuseclass}{sd-card-body}
\begin{sphinxuseclass}{sd-card-title}
\begin{sphinxuseclass}{sd-font-weight-bold}How to take this course?
\end{sphinxuseclass}
\end{sphinxuseclass}
\sphinxAtStartPar
It is recommended to take the course in the order indicated in the diagram. The course has {\hyperref[\detokenize{book/intro/en/prerequisite::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{prerequisites}}}} – programming in Python, basics of linear algebra and machine learning, we advise to read them and (optionally) check yourself with \sphinxhref{https://ods.ai/tracks/qmlcourse/blocks/ee9f2a26-6234-4a72-84a6-a05de035bb1a}{input test}.

\sphinxAtStartPar
The course is discussed in \sphinxhref{https://ods.ai/tracks/odsmatrix101}{matrix.ods.ai} in the \sphinxcode{\sphinxupquote{{[}course{]} quantum ml}} channel.

\sphinxAtStartPar
All English version course you can found below start from {\hyperref[\detokenize{book/intro/en/intro::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{here}}}}.

\sphinxAtStartPar
\sphinxstylestrong{Good luck!}

\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\begin{sphinxuseclass}{sd-container-fluid}
\begin{sphinxuseclass}{sd-sphinx-override}
\begin{sphinxuseclass}{sd-mb-4}
\begin{sphinxuseclass}{sd-row}
\begin{sphinxuseclass}{sd-col}
\begin{sphinxuseclass}{sd-d-flex-row}
\begin{sphinxuseclass}{sd-card}
\begin{sphinxuseclass}{sd-sphinx-override}
\begin{sphinxuseclass}{sd-w-100}
\begin{sphinxuseclass}{sd-shadow-sm}
\begin{sphinxuseclass}{sd-card-body}
\begin{sphinxuseclass}{sd-card-title}
\begin{sphinxuseclass}{sd-font-weight-bold}Как можно помочь?
\end{sphinxuseclass}
\end{sphinxuseclass}
\sphinxAtStartPar
Помочь можно словом и делом. Если знаете людей, интересующихся квантовыми вычислениями –\sphinxhyphen{} замолвите словечко. Курс разрабатывается сообществом OpenDataScience, такими же “больными”, как и организаторы. Если горите желанием в чем\sphinxhyphen{}то помочь, то создавайте Issue, а лучше сразу Pull Request в \sphinxhref{http://github.com/quantum-ods/qmlcourse/}{репозитории курса} (\sphinxhref{https://github.com/quantum-ods/qmlcourse/blob/master/CONTRIBUTING.md}{Contributing guide}).

\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\begin{sphinxuseclass}{sd-col}
\begin{sphinxuseclass}{sd-d-flex-row}
\begin{sphinxuseclass}{sd-card}
\begin{sphinxuseclass}{sd-sphinx-override}
\begin{sphinxuseclass}{sd-w-100}
\begin{sphinxuseclass}{sd-shadow-sm}
\begin{sphinxuseclass}{sd-card-body}
\begin{sphinxuseclass}{sd-card-title}
\begin{sphinxuseclass}{sd-font-weight-bold}How can you help?
\end{sphinxuseclass}
\end{sphinxuseclass}
\sphinxAtStartPar
You can help in word and deed. If you know people interested in quantum computing, put in a word. The course is developed by the OpenDataScience community, the same “sick” people as the organizers. If you’re eager to help with something, then create an Issue, or better yet a Pull Request in \sphinxhref{http://github.com/quantum-ods/qmlcourse/}{course repository} (\sphinxhref{https://github.com/quantum-ods/qmlcourse/blob/master/CONTRIBUTING.md}{Contributing guide}).

\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}


\sphinxstepscope


\part{Введение}

\sphinxstepscope


\chapter{О квантовых компьютерах, биткоине и превосходстве}
\label{\detokenize{book/intro/ru/intro:intro-ru}}\label{\detokenize{book/intro/ru/intro:id1}}\label{\detokenize{book/intro/ru/intro::doc}}
\sphinxAtStartPar
Автор(ы):
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/SemyonSinchenko}{Синченко Семен}

\end{itemize}


\section{Описание лекции}
\label{\detokenize{book/intro/ru/intro:id2}}
\sphinxAtStartPar
Эта лекция не несет в себе образовательного смысла, а лишь пытается ответить на вопросы, которые обычно возникают у тех, кто впервые сталкивается с темой квантовых вычислений. А именно:
\begin{itemize}
\item {} 
\sphinxAtStartPar
что это за вычисления такие?

\item {} 
\sphinxAtStartPar
зачем вообще это все нужно?

\item {} 
\sphinxAtStartPar
и когда взломают биткоин?

\item {} 
\sphinxAtStartPar
что за превосходство, о котором все говорят?

\end{itemize}


\section{Что это вообще за компьютеры такие?}
\label{\detokenize{book/intro/ru/intro:id3}}

\subsection{Количественная эволюция компьютеров}
\label{\detokenize{book/intro/ru/intro:id4}}
\sphinxAtStartPar
Сегодня классические компьютеры, построенные на идеях Тьюринга, фон Неймана и Шокли, стали неотъемлемой частью нашей жизни. Все мы привыкли к тому, что с каждым годом наши компьютеры становятся все мощнее и мощнее. И то, что сегодня является бюджетным ноутбуком 15 лет назад было аналогом суперкомпьютера!

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{Moores_Law}.png}
\caption{Иллюстрация закона Мура — рост числа транзисторов с 1970\sphinxhyphen{}х}\label{\detokenize{book/intro/ru/intro:id21}}\end{figure}

\sphinxAtStartPar
Так называемый закон Мура, сформулированный Гордоном Муром еще в конце 60\sphinxhyphen{}х годов, говорит нам о том, что число транзисторов на кристалле интегральной схемы будет удваиваться каждые два года. И этот закон стабильно выполняется.


\subsection{Качественная эволюция компьютеров}
\label{\detokenize{book/intro/ru/intro:id5}}
\sphinxAtStartPar
Но, к сожалению, по сугубо физическим причинам, выполнение закона Мура не может длиться вечно — рано или поздно, но прямое увеличение количества транзисторов станет невозможно. Поэтому сегодня все чаще можно услышать слова о том, что современным компьютеры ждет качественная революция. Кто\sphinxhyphen{}то говорит о переходе на новые материалы для изготовления транзисторов. Кто\sphinxhyphen{}то говорит о создании транзисторов на новых принципах, например, об оптических компьютерах. Но часто можно услышать слова о том, что следующим революционным прорывом станет создание квантовых компьютеров. О них мы и будем говорить.


\subsection{Идея о квантовом компьютере}
\label{\detokenize{book/intro/ru/intro:id6}}
\sphinxAtStartPar
Сегодня существует несколько версий о том, кто же первым высказал идею о квантовом компьютере. Как это часто бывает, сразу несколько ученых одновременно и независимо пришли к одной и той же идее. Одним из таких ученых был Ричард Фейнман.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{Feinman}.jpg}
\caption{Ричард Фейнман, 1918\sphinxhyphen{}1988}\label{\detokenize{book/intro/ru/intro:id22}}\end{figure}

\sphinxAtStartPar
В 1981\sphinxhyphen{}м году, когда шло очень активное развитие одновременно классических компьютеров и вычислительной квантовой механики, он высказал идею о том, что для решения задач квантовой физики нам нужен квантовый компьютер.


\subsection{Что это за компьютер такой?}
\label{\detokenize{book/intro/ru/intro:id7}}
\sphinxAtStartPar
Этот вопрос на самом деле крайне сложный и именно ему будет посвящена первая половина нашего курса. Кажется странным, если вопрос, которому будет посвящено несколько полноценных лекций с формулами можно было бы раскрыть в одном абзаце. Было бы ошибкой пытаться сказать, что обычные компьютеры работают на законах классической физики, а квантовые на основе квантовой механики — ведь нормально объяснить работу транзистора можно лишь с привлечением уровня Ферми и прочих сложных штук из квантовой физики. Также неправильно было бы говорить о том, что в отличии от классических компьютеров, где есть лишь \(0\) и \(1\) в квантовых есть все состояния сразу. Ведь ничего не мешает сделать так называемую вероятностную машину Тьюринга, другими словами, классический компьютер, который оперирует многими состояниями сразу. Особенно не хочется сразу сыпать на читателя кучу непонятных терминов, типа квантовой суперпозиции, кубита или запутанности, ведь для тех, кто не знает что такое квантовые компьютеры эти термины, вероятнее всего, тоже ничего не дадут. Для начала, давайте просто условимся, что квантовые компьютеры это, в отличии от фотонных, графеновых, или других перспективных “новых” компьютеров, не только использование новых материалов или технической базы, а еще и использование новой, отличной от заложенной Тьюрингом концепции вычислений, представления и обработки информации.


\section{А зачем это вообще нужно?}
\label{\detokenize{book/intro/ru/intro:id8}}

\subsection{Факторизация больших чисел}
\label{\detokenize{book/intro/ru/intro:id9}}
\sphinxAtStartPar
Мне кажется, что именно открытие алгоритма Шора для эффективного решения задачи факторизации послужило наибольшим толчком в популяризации квантовых вычислений. Именно после этого большое число специалистов устремилось в эту область, военные и корпорации начали вкладывать деньги, а журналисты стали писать о будущем крахе банковских платежей и вообще всего мира. Вероятно, алгоритм Шора является самым раскрученным квантовым алгоритмом.

\sphinxAtStartPar
Дело в том, что большая часть всей современной криптографии держится на одном простом предположении о невозможности эффективно решать задачу факторизации больших чисел. Ну или по простому, если у нас есть число, которое является произведением двух относительно больших простых чисел, то мы будем до бесконечности искать эти числа и скорее всего так и не найдем их. Но это для классического компьютера. А вот для квантового компьютера в 1994\sphinxhyphen{}м Питером Шором был предложен алгоритм, который решает эту задачу эффективно, за относительно короткий промежуток времени.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{Shor}.png}
\caption{Питер Шор, тот, кто переполошил весь мир своим алгоритмом}\label{\detokenize{book/intro/ru/intro:id23}}\end{figure}

\sphinxAtStartPar
Именно этот алгоритм в будущем взломает биткоин и обрушит банковскую систему, но не все так плохо – развитие квантовых компьютеров подтолкнуло ученых в области криптографии к созданию новых, так называемых \sphinxstyleemphasis{пост\sphinxhyphen{}квантовых} алгоритмов шифрования, которые нельзя взломать за разумное время и на классическом, и на квантовом компьютере.


\subsection{Комбинаторные и NP\sphinxhyphen{}трудные задачи}
\label{\detokenize{book/intro/ru/intro:np}}
\sphinxAtStartPar
Помимо уже озвученных проблем с выполнением закона Мура, есть также и другая проблема. А именно то, что существуют задачи, которые скорее всего никогда не получится эффективно решать на классическом компьютере Тьюринга. Даже на фотонном или графеновом. Хороший пример это задача о рюкзаке. Когда у нас есть рюкзак ограниченного объема, а также есть много предметов разного веса и стоимости. И нам надо наполнить наш рюкзак так, чтобы предметы внутри него имели максимальную суммарную стоимость. Задача кажется легкой, но она относится к так называемым \sphinxhref{https://ru.wikipedia.org/wiki/NP-\%D0\%BF\%D0\%BE\%D0\%BB\%D0\%BD\%D0\%B0\%D1\%8F\_\%D0\%B7\%D0\%B0\%D0\%B4\%D0\%B0\%D1\%87\%D0\%B0}{\(NP\)\sphinxhyphen{}полным задачам}. Такие задачи, например, в случае большого рюкзака и набора предметов, невозможно точно решить за разумное время. Да и вообще их решить с приемлемой точностью, пусть даже \sphinxstyleemphasis{приближенно} это сегодня большая проблема!

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Здесь я не зря написал “скорее всего”. Дело в том, что этот вопрос является одним из \sphinxhref{https://ru.wikipedia.org/wiki/\%D0\%A0\%D0\%B0\%D0\%B2\%D0\%B5\%D0\%BD\%D1\%81\%D1\%82\%D0\%B2\%D0\%BE\_\%D0\%BA\%D0\%BB\%D0\%B0\%D1\%81\%D1\%81\%D0\%BE\%D0\%B2\_P\_\%D0\%B8\_NP}{так называемых вопросов тысячелетия}. Так, для известной задачи о наполнении рюкзака, мы не знаем сегодня эффективного алгоритма решения на классическом компьютере. Но мы также и не можем пока доказать, что такого алгоритма не существует. Ну то есть скорее всего такого алгоритма и правда не существует, а также скорее всего \(P \neq NP\), но доказать это пока ни у кого не вышло. Но это скорее лирическое отступление.
\end{sphinxadmonition}

\sphinxAtStartPar
Так вот, дело в том, что для квантовых компьютеров уже сегодня известны алгоритмы, которые позволяют потенциально эффективно, пусть и \sphinxstyleemphasis{приближенно} решать такие задачи на квантовом компьютере. Это задача коммивояжера, задача о рюкзаке, задача кластеризации графа и много других задач комбинаторной оптимизации. В нашем курсе будет целый блок, посвященный таким квантовым алгоритмам как \sphinxstyleemphasis{Variational Quantum Eigensolver} и \sphinxstyleemphasis{Quantum Approximate Optimization Algorithm}.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{Salesman}.png}
\caption{Визуализация решения задачи коммивояжера – кратчайший путь, чтобы объехать 12 немецких городов – очень важная задача современной логистики}\label{\detokenize{book/intro/ru/intro:id24}}\end{figure}


\subsection{Симуляция квантовой механики}
\label{\detokenize{book/intro/ru/intro:id10}}
\sphinxAtStartPar
Это то, ради чего Фейнман предложил создать квантовые компьютеры. Это отдельная большая тема, где много квантовой механики. Ей будет посвящено сразу несколько отдельных лекций нашего курса. Но попробуем объяснить в двух словах, не вдаваясь в детали.

\sphinxAtStartPar
Дело в том, что задачи квантовой механики не получается решать аналитически. Казалось бы, в чем проблема, законы Ньютона уже для трех тел тоже аналитически не решаются, но это не мешает нам летать в космос, ведь такую задачу можно решить \sphinxstyleemphasis{численно}. Но ту приходит вторая проблема, а именно, что явно интегрировать уравнение Шредингера по времени, или, по простому, решать квантовую механику \sphinxstyleemphasis{численно} тоже вычислительно почти невозможно более чем для двух частиц.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=350\sphinxpxdimen]{{Schrodinger}.jpg}
\caption{Эрвин Шредингер, 1887\sphinxhyphen{}1961, создатель знаменитого уравнения и мема про кота}\label{\detokenize{book/intro/ru/intro:id25}}\end{figure}

\sphinxAtStartPar
Казалось бы, что нам с этого. Ведь квантовая механика это удел теоретиков. Но вот проблема, квантовая механика лежит в основе квантовой химии, а та, в свою очередь, лежит в основе вообще всей химии и таких ее прикладных направлений, как создание новых лекарств, разработка новых аккумуляторов для автомобилей Tesla и многого другого. И сегодня мы вынуждены использовать лишь очень приближенные решения и концепции, точности которых часто не хватает.

\sphinxAtStartPar
Квантовые компьютеры в этом случае могут сделать реальный прорыв. Ведь в силу своей физической природы, квантовый компьютер идеально подходит для симуляции квантовой механики, а значит и решения столь важных сегодня задач из области разработки лекарств и дизайна новых материалов.


\subsection{Машинное обучение и искусственный интеллект}
\label{\detokenize{book/intro/ru/intro:id11}}
\sphinxAtStartPar
За последние 10\sphinxhyphen{}15 лет машинное обучение достигло поистине небывалых высот в своем развитии. Многие задачи, решение которых силами компьютера, раньше казалось невозможным сегодня успешно решаются при помощи машинного обучения. Примеры таких задач это, например, игра в Go, различение пород чихуахуа по фотографии, распознавание лиц в видеопотоке, составление относительно осмысленных текстов и генерация картин в стиле Пикассо из простых фотографий. Но оно все еще очень далеко от возможностей человеческого мозга. Так, наиболее масштабные искусственные нейронные сети, по примерным оценкам, имеют сегодня размер, эквивалентный 15 миллионам нейронов, в то время как человеческий мозг имеет порядка 85 миллиардов! Вызывает вопросы также и скорость обучения современных нейронных сетей. Так, самые большие языковые модели сегодня обучаются неделями на кластерах из тысяч видеокарт, в то время как человек с его относительно скромными вычислительными возможностями учится говорить всего 2\sphinxhyphen{}3 года.

\sphinxAtStartPar
И тут тоже на помощь могут прийти квантовые компьютеры. В данном случае, квантовые аналоги нейронных сетей, а также их комбинации с классическими нейронными сетями уже сегодня показывают впечатляющие результаты. Так, есть работы, где показано, что 4 квантовых нейрона по своей выразительности эквивалентны классической искусственной нейронной сети с \(\sim 250\) нейронами!

\sphinxAtStartPar
Именно квантовому машинному обучению, а также способам его применения и будет посвящена большая часть нашего курса. Мы постараемся рассмотреть все вопросы по этой теме, начиная от теории того, как можно строить квантовые алгоритмы машинного обучения и заканчивая тем, как их можно запрограммировать на современных языках квантового программирования. Если эта тема вам интересна, то этот курс точно для вас!


\section{Ну и когда взломают биткоин?}
\label{\detokenize{book/intro/ru/intro:id12}}
\sphinxAtStartPar
Наверное это один из главных вопросов, которые возникают при чтении подобных статей. И ответим сразу: взломают нескоро, времени еще много, 10 лет точно есть.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=350\sphinxpxdimen]{{Bitcoin}.jpg}
\caption{Биткоин, как и многие другие электронные средства вынуждены будут перейти на пост\sphinxhyphen{}квантовую криптографию}\label{\detokenize{book/intro/ru/intro:id26}}\end{figure}


\subsection{Сколько нужно кубитов под разные задачи?}
\label{\detokenize{book/intro/ru/intro:id13}}
\sphinxAtStartPar
Наверное сразу стоит оценить тот размер, который квантовый компьютер должен иметь для эффективного решения описанных выше задач. Примерно цифры такие:
\begin{itemize}
\item {} 
\sphinxAtStartPar
алгоритм Шора и взлом современной криптографии (включая биткоин): \(\sim 20\cdot 10^6\) (20 миллионов) кубит

\item {} 
\sphinxAtStartPar
задачи оптимизации: \(\sim 100 \cdot 10^3\) (100 тысяч) кубит

\item {} 
\sphinxAtStartPar
первые полезные задачи в квантовой химии: \(\sim 1\cdot 10^3\) (1 тысяча) кубит

\item {} 
\sphinxAtStartPar
квантовое машинное обучение: \(\sim 100-500\) кубит

\end{itemize}

\sphinxAtStartPar
Это кстати одна из причин, почему наш курс посвящен по большей части именно квантовому машинному обучению.


\subsection{Логические vs Физические кубиты}
\label{\detokenize{book/intro/ru/intro:vs}}
\sphinxAtStartPar
Есть еще такая проблема, что вся квантовая механика вероятностная. А еще, что квантовые компьютеры работают в области микромира и очень чувствительны к любым шумам извне. Это ведет к совершенно недопустимому уровню ошибок в вычислениях и их низкой детерминированности. Например, сегодня хорошим уровнем точности для квантовых компьютеров является 99\% на одну операцию. Но ведь каждый алгоритм включает в себя сотни или даже тысячи операций! И тогда уровень ошибок становится совсем печальным.

\sphinxAtStartPar
Но есть и хорошие новости. Сегодня существует очень много классных алгоритмов коррекции ошибок, которые позволяют используя несколько физических кубит с высоким уровнем ошибок создать один логический кубит, имеющий очень низкий уровень ошибок. То есть программист будет писать код, который производит операции над одним кубитом, а на физическом уровне это будет операция над несколькими кубитами. В общем вопрос вполне решаемый. Вот только для создания одного качественного логического кубита может потребоваться до тысячи физических кубит! А те оценки, которые мы привели выше, они как раз про логические кубиты, то есть кубиты с очень высокой точностью операций на уровне классических компьютеров.


\subsection{Сколько кубит есть сегодня?}
\label{\detokenize{book/intro/ru/intro:id14}}
\sphinxAtStartPar
Скажем сразу, сегодня уже существуют квантовые компьютеры. Вот только все производители, когда пишут о новом рекорде, имеют в виду чаще всего именно физические кубиты.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=350\sphinxpxdimen]{{quantum_computer}.jpg}
\caption{Квантовый компьютер компании IBM выглядит примерно так}\label{\detokenize{book/intro/ru/intro:id27}}\end{figure}

\sphinxAtStartPar
Есть квантовые компьютеры с разной архитектурой. Одни имеют больше кубит, но и более высокий уровень ошибок. Другие имеют низкий уровень ошибок, но их трудно масштабировать. Теме квантового железа в этом курсе будет посвящен отдельный блок из нескольких лекций. Но если кратко, то можно назвать примерно такие цифры:
\begin{itemize}
\item {} 
\sphinxAtStartPar
рекорд в относительно легко масштабируемых, но шумных квантовых компьютерах это \(\sim 55\) кубит

\item {} 
\sphinxAtStartPar
рекорд в относительно точных, но медленных и плохо масштабируемых компьютерах это \(\sim 20\) кубит

\item {} 
\sphinxAtStartPar
рекорд в точных и масштабируемых, но очень трудно программируемых компьютерах это \(\sim 25\) кубит

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Тут имеем ввиду соответственно:
\begin{itemize}
\item {} 
\sphinxAtStartPar
сверхпроводящие кубиты, которые сегодня проще всего масштабировать

\item {} 
\sphinxAtStartPar
ионы в ловушках, которые имеют одну из самых высоких точностей

\item {} 
\sphinxAtStartPar
фотоны, которые вроде всем хороши, кроме того, что на них программирование это юстировка линз и лазеров на оптическом столе

\end{itemize}
\end{sphinxadmonition}

\sphinxAtStartPar
Стоит добавить, что рекорд в точных и масштабируемых, а также программируемых (топологических) кубитах сегодня это ровно 2 кубита. Серьезно, взаимодействие двух логических кубит было опубликовано в \sphinxcode{\sphinxupquote{Nature}} в этом году (2021).


\subsection{Какие планы имеют ведущие игроки на этом рынке?}
\label{\detokenize{book/intro/ru/intro:id15}}
\sphinxAtStartPar
Казалось бы, с такими масштабами биткоину боятся нечего, да и в целом область выглядит не самой перспективной. Но есть один нюанс. Все крупные игроки на рынке создания квантовых компьютеров (\sphinxstyleemphasis{Google Quantum}, \sphinxstyleemphasis{IBM Quantum}, \sphinxstyleemphasis{IonQ}, \sphinxstyleemphasis{Xanadu}) озвучили планы к 2030\sphinxhyphen{}му году иметь порядка одного миллиона физических кубит, что эквивалентно порядка тысячи логических кубит. Для криптографии это еще не страшно, но вот многие полезные задачи уже можно будет попробовать решать. Ну и стоит еще раз посмотреть на график закона Мура для классических компьютеров, которые каждые десять лет показывают примерно такой же прогресс!


\section{О квантовом превосходстве}
\label{\detokenize{book/intro/ru/intro:id16}}
\sphinxAtStartPar
Очень часто можно услышать разговоры о том, что достигнуто или опровергнуто квантовое превосходство. Попробуем под конец лекции разобраться, что же это такое и почему это важно (или не важно).


\subsection{Понятие квантового превосходства}
\label{\detokenize{book/intro/ru/intro:id17}}
\sphinxAtStartPar
Само понятие было сформулировано еще в 2012\sphinxhyphen{}м году известным физиком теоретиком Джоном Прескиллом.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=350\sphinxpxdimen]{{Preskill}.jpg}
\caption{Джон Прескил, который и придумал этот термин. Еще он известен своим знаменитым пари с другим физиком Стивеном Хокингом (которое Хокинг проиграл)}\label{\detokenize{book/intro/ru/intro:id28}}\end{figure}

\sphinxAtStartPar
Квантовое превосходство это решение на квантовом компьютере задачи, которую нельзя решить на классическом компьютере за разумное время (10 тысяч лет разумным временем не считается). Достижение квантового превосходства это однозначно новый уровень в развитии квантовых вычислений. Но есть один подвох. Дело в том, что речь идет о совершенно любой задаче, независимо от того, насколько она полезна или бесполезна.

\sphinxAtStartPar
Так что когда кто\sphinxhyphen{}то заявляет о достижении квантового превосходства, то это важный повод для ученых и разработчиков квантовых компьютеров, но скорее всего это очень малозначимый факт, с точки зрения простого обывателя.


\subsection{Хронология событий}
\label{\detokenize{book/intro/ru/intro:id18}}
\sphinxAtStartPar
Ну и в конце приводим краткую хронологию событий.
\begin{itemize}
\item {} 
\sphinxAtStartPar
2019 год, компания \sphinxstyleemphasis{Google} заявляет о достижении квантового превосходства. Задача выбрана максимально удобная для квантового компьютера и полностью лишенная практического смысла. По словам разработчиков из \sphinxstyleemphasis{Google} их квантовый компьютер за 4 минуты решил задачу, которую классический суперкомпьютер решал бы 10 тысяч лет. Их квантовый компьютер имел 54 кубита

\item {} 
\sphinxAtStartPar
2019 год, компания \sphinxstyleemphasis{IBM} заявляет, что \sphinxstyleemphasis{Google} не учли, что их задачу можно решать на классическом компьютере более оптимально, но без экспериментов

\item {} 
\sphinxAtStartPar
2020 год, компания \sphinxstyleemphasis{Alibaba} реализует алгоритм \sphinxstyleemphasis{IBM} на своем суперкомпьютере и решает задачу за \(\sim 20\) дней

\item {} 
\sphinxAtStartPar
2021 год, группа китайских ученых оптимизирует классический алгоритм и решает задачу на 60 видеокартах \sphinxstyleemphasis{NVIDIA} за 7 дней

\item {} 
\sphinxAtStartPar
2021 год, группа других китайских ученых заявляет, что достигла нового превосходства на квантовом компьютере из 56 кубит

\end{itemize}

\sphinxAtStartPar
В общем сейчас идет довольно интересный процесс войны меча и щита. Пока одни ученые строят более мощные квантовые компьютеры, другие придумывают более продвинутые алгоритмы их симуляции. Хотя конечно все ученые говорят, что уже где\sphinxhyphen{}то на 60\sphinxhyphen{}70 кубитах эта история окончательно закончится в пользу квантовых компьютеров.


\section{А как это вообще выглядит? И сколько стоит?}
\label{\detokenize{book/intro/ru/intro:id19}}
\sphinxAtStartPar
На сегодня почти все известные технологии создания квантовых компьютеров требуют чего\sphinxhyphen{}то из:
\begin{itemize}
\item {} 
\sphinxAtStartPar
сверхнизкие температуры

\item {} 
\sphinxAtStartPar
сверхвысокий вакуум

\item {} 
\sphinxAtStartPar
сверхточная юстировка лазеров на оптическом столе

\end{itemize}

\sphinxAtStartPar
Или даже всего сразу. Поэтому сегодня почти все квантовые компьютеры продаются через облачные сервисы. Например, относительно недавно ведущий поставщик облачных технологий – компания \sphinxstyleemphasis{Amazon} добавила в свой сервис \sphinxcode{\sphinxupquote{AWS}} новый продукт \sphinxhref{https://aws.amazon.com/braket/}{Amazon Braket}. Этот продукт позволяет взять в аренду самый настоящий компьютер точно также, как мы привыкли брать в аренду процессоры, видеокарты или жесткие диски. Аналогичные продукты сейчас предоставляют и другие крупные игроки на рынке облачных услуг. Хотя это все пока исключительно для целей исследования. Ведь как мы уже поняли, сегодня квантовые компьютеры еще не способны решать реальные задачи. Стоит такое развлечение не очень дорого, например, можно запустить свою квантовую программу на 32\sphinxhyphen{}х кубитном компьютере \sphinxcode{\sphinxupquote{Aspen\sphinxhyphen{}9}} всего за \$0.3 (per\sphinxhyphen{}task).

\sphinxAtStartPar
Некоторые производители идут дальше и предлагают относительно компактные решения. Так, недавно \sphinxhref{https://phys.org/news/2021-06-compact-quantum-server-centers.amp?\_\_twitter\_impression=true}{было представлено 24\sphinxhyphen{}х кубитное решение}, которое помещается в две стандартных серверных стойки. Но масштабируемость таких устройств вызывает вопросы.

\sphinxAtStartPar
В любом случае, в ближайшие 15\sphinxhyphen{}20 лет точно не стоит ждать появление карманного квантового компьютера, или хотя бы квантового сопроцессора в домашнем ПК. Да и в этом нет особого смысла, ведь мало кому дома нужно взламывать биткоин, решать логистическую проблему или разрабатывать высокотемпературный сверхпроводник.


\section{Заключение}
\label{\detokenize{book/intro/ru/intro:id20}}
\sphinxAtStartPar
Это вводная лекция, она не даст вам каких\sphinxhyphen{}то особых знаний. Скорее, ее цель заинтересовать читателя. Самое интересное будет в основной части курса, где мы будем разбирать квантовые алгоритмы, пытаться симулировать квантовую механику и обучать самые настоящие квантовые нейросети! Ждем вас на курсе!



\sphinxstepscope


\chapter{Пререквизиты для прохождения курса QML}
\label{\detokenize{book/intro/ru/prerequisite:qml}}\label{\detokenize{book/intro/ru/prerequisite:prerequisite-ru}}\label{\detokenize{book/intro/ru/prerequisite::doc}}
\sphinxAtStartPar
Настоящий курс совмещает в себе как теорию для глубинного понимания материала, так и большое количество практики для закрепления навыков и проработки неочевидных ситуаций/проблем. Поэтому предполагается, что некоторые базовые знания у вас уже есть. Проверить себя можно с помощью опционального \sphinxhref{https://ods.ai/tracks/qmlcourse/blocks/ee9f2a26-6234-4a72-84a6-a05de035bb1a}{входного теста}, который поможет понять, нужно ли проходить вводные “голубые” лекции –\sphinxhyphen{} по Python, математике и машинному обучению (15 вопросов всего, по 5 на блок). Тест довольно простой, так что если вы его прошли без ошибок или почти без ошибок – это мало о чем говорит, все равно дальше может быть сложно. А вот если ошибок много, тогда вам стоит обратиться ко вводным “голубым” блокам.


\section{Python, Poetry и среда разработки}
\label{\detokenize{book/intro/ru/prerequisite:python-poetry}}
\sphinxAtStartPar
Для успешного прохождения курса вы должны уметь делать и понимать такие вещи, как:
\begin{itemize}
\item {} 
\sphinxAtStartPar
копирование файлов с GitHub;

\item {} 
\sphinxAtStartPar
установка \sphinxcode{\sphinxupquote{Poetry}} и библиотек \sphinxcode{\sphinxupquote{Python}};

\item {} 
\sphinxAtStartPar
как запустить \sphinxcode{\sphinxupquote{Jupyter Notebook}};

\item {} 
\sphinxAtStartPar
основные сочетания клавиш в \sphinxcode{\sphinxupquote{Jupyter Notebook}};

\item {} 
\sphinxAtStartPar
как запускать код в \sphinxcode{\sphinxupquote{Jupyter Notebook}};

\item {} 
\sphinxAtStartPar
какие простые типы данных существуют в \sphinxcode{\sphinxupquote{Python}};

\item {} 
\sphinxAtStartPar
как работать со сложными типами\sphinxhyphen{}контейнерами (\sphinxcode{\sphinxupquote{list}}, \sphinxcode{\sphinxupquote{dict}}, \sphinxcode{\sphinxupquote{tuple}}), включая самые популярные методы каждого из них;

\item {} 
\sphinxAtStartPar
как работает арифметика \sphinxcode{\sphinxupquote{Python}} и как переменные разных типов соотносятся друг с другом;

\item {} 
\sphinxAtStartPar
что такое условные конструкции и ветвление логики;

\item {} 
\sphinxAtStartPar
что такое блок кода в \sphinxcode{\sphinxupquote{Python}} и зачем нужны отступы (табуляции);

\item {} 
\sphinxAtStartPar
что такое циклы и как их можно использовать применительно к сложным типам данных;

\item {} 
\sphinxAtStartPar
как писать функции в \sphinxcode{\sphinxupquote{Python}}, что такое аргументы функции и какими они бывают;

\item {} 
\sphinxAtStartPar
что такое декоратор и как его использовать;

\item {} 
\sphinxAtStartPar
базовый ООП: объявление классов, понятие объекта класса, умение писать методы класса.

\end{itemize}

\sphinxAtStartPar
Если какая либо из тем вызывает у вас непонимание, то настоятельно рекомендуется освежить знания (или даже их приобрести), пройдя соответствующие уроки в блоке “Основы Python”. Даже если у вас есть опыт работы с ним и написания кода, то предлагается ознакомиться с процессом установки всех необходимых зависимостей и библиотек, а также горячими клавишами и разнообразными функциями в \sphinxcode{\sphinxupquote{Jupyter Notebook}}.


\section{Линейная алгебра и \sphinxstyleliteralintitle{\sphinxupquote{Numpy}}}
\label{\detokenize{book/intro/ru/prerequisite:numpy}}
\sphinxAtStartPar
Для понимания базовых квантовых алгоритмов и алгоритмов квантового машинного обучения, как и в классическом машинном обучении, не обойтись без линейной алгебры. Если есть время взяться за математику по\sphinxhyphen{}серьезному, рекомендуем \sphinxhref{https://ocw.mit.edu/courses/18-06-linear-algebra-spring-2010/}{курс Gilbert Strang} или \sphinxhref{https://www.litres.ru/d-v-beklemishev/kurs-analiticheskoy-geometrii-i-lineynoy-algebry-66005405/}{Д.В. Беклемишева}, а также \sphinxhref{https://biblio.mccme.ru/node/2192}{задачник А.И. Кострикина}. А если Вы это когда\sphinxhyphen{}то изучали линейную алгебру, но подзабыли ее, то поможет блок нашего курса. Хочется, чтобы у Вас не было проблем с такими понятиями как:
\begin{itemize}
\item {} 
\sphinxAtStartPar
вектор\sphinxhyphen{}строка и вектор\sphinxhyphen{}столбец;

\item {} 
\sphinxAtStartPar
линейная зависимость векторов;

\item {} 
\sphinxAtStartPar
системы линейных уравнений;

\item {} 
\sphinxAtStartPar
матрицы, определитель и след матрицы;

\item {} 
\sphinxAtStartPar
линейный оператор;

\item {} 
\sphinxAtStartPar
комплексное и эрмитово сопряжение;

\item {} 
\sphinxAtStartPar
скалярное и векторное произведения;

\item {} 
\sphinxAtStartPar
гильбертово пространство.

\end{itemize}

\sphinxAtStartPar
Список явно не исчерпывающий и скорее всего явно так и не перечислишь все то, что может встретиться по мере изучения квантовых алгоритмов.


\section{Машинное обучение}
\label{\detokenize{book/intro/ru/prerequisite:id1}}
\sphinxAtStartPar
Наконец, чтобы говорить о квантовом машинном обучении, надо иметь неплохое представление о собственно машинном обучении. {\hyperref[\detokenize{book/ml/ru/ml_intro::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{Блок этого курса}}}} рассказывает о том, что общего у разных задач машинного обучения и как из основных компонентов, подобно пазлу, складываются различные применения моделей машинного обучения. Этот блок, впрочем, не заменяет хорошей книги или курса по машинному обучению (как \sphinxhref{https://www.coursera.org/learn/machine-learning}{курс Andrew Ng}, \sphinxhref{https://datasciencecourse.ru/}{специализация Яндекса и МФТИ}, \sphinxhref{https://mlcourse.ai}{mlcourse.ai}, \sphinxhref{https://github.com/esokolov/ml-course-hse}{курс “Машинное обучение” на ФКН ВШЭ – Соколов Е. А.}) или \sphinxhref{https://ml-handbook.ru/}{учебник по машинному обучению от ШАД}, покрывающего такие темы как:
\begin{itemize}
\item {} 
\sphinxAtStartPar
обучение с учителем и без учителя, обучение с подкреплением;

\item {} 
\sphinxAtStartPar
метрики качества в задачах обучения с учителем;

\item {} 
\sphinxAtStartPar
функции потерь и сведение задач машинного обучения к задачам оптимизации;

\item {} 
\sphinxAtStartPar
обработка и построение признаков;

\item {} 
\sphinxAtStartPar
оценка качества модели и кросс\sphinxhyphen{}валидация;

\item {} 
\sphinxAtStartPar
алгоритмы классификации и регрессии: деревья решений, лес, бустинг, логистическая регрессия и др.;

\item {} 
\sphinxAtStartPar
алгоритмы ранжирования, метрики качества ранжирования;

\item {} 
\sphinxAtStartPar
обучение без учителя: снижение размерности, кластеризация, поиск аномалий;

\item {} 
\sphinxAtStartPar
байесовский взгляд на машинное обучение;

\item {} 
\sphinxAtStartPar
обучение представлению.

\end{itemize}

\sphinxAtStartPar
Опять же, это не исчерпывающий список, к тому же покрывающий только “классику”, игнорируя глубокое обучение. Но если что\sphinxhyphen{}то из перечисленного вызывает недоумение или если со входным \sphinxhref{https://ods.ai/tracks/qmlcourse/blocks/ee9f2a26-6234-4a72-84a6-a05de035bb1a}{тестом} не задалось, возможно, стоит обратиться к упомянутым курсам.

\sphinxstepscope


\part{Основы Python}

\sphinxstepscope


\chapter{О блоке “Python”}
\label{\detokenize{book/python/ru/python_intro:python}}\label{\detokenize{book/python/ru/python_intro:python-intro}}\label{\detokenize{book/python/ru/python_intro::doc}}
\sphinxAtStartPar
Включает:
\begin{itemize}
\item {} 
\sphinxAtStartPar
описание процесса установки среды разработки для прохождения курса;

\item {} 
\sphinxAtStartPar
описание синтаксиса языка программирования Python;

\item {} 
\sphinxAtStartPar
разбор типовых синтаксических конструкций при программировании на Python;

\item {} 
\sphinxAtStartPar
примеры анализа возникающих ошибок, помогающие в дальнейшем прохождении курса.

\end{itemize}

\sphinxAtStartPar
Об этом всём можете почитать в курсе о python от международного сообщества \DUrole{xref,myst}{ods.ai} – \sphinxhref{https://open-data-science.github.io/pycourse/base/}{“основы python”}

\sphinxstepscope


\part{Линейная алгебра и numpy}

\sphinxstepscope


\chapter{О блоке “Линейная алгебра и NumPy”}
\label{\detokenize{book/linalg/ru/linalg_intro:numpy}}\label{\detokenize{book/linalg/ru/linalg_intro:linalg-intro-ru}}\label{\detokenize{book/linalg/ru/linalg_intro::doc}}
\sphinxAtStartPar
Блок задуман для обсуждения основных понятий и идей линейной алгебры и представляет собой краткое пособие. Данный блок \sphinxstylestrong{не является} полноценным учебником по линейной алгебре. Для более детального погружения в тему рекомендуем учебник Тыртышникова Е. Е. \sphinxhref{https://www.inm.ras.ru/wp-content/uploads/library/Monographies/all.pdf}{“Матричный анализ и линейная алгебра”} или \sphinxhref{http://www.cse.zju.edu.cn/eclass/attachments/2015-10/01-1446086008-145421.pdf}{“Matrix Analysis”} by Roger A. Horn, Charles R. Johnson.

\sphinxAtStartPar
В рамках блока:
\begin{itemize}
\item {} 
\sphinxAtStartPar
обсудим основные понятия и идеи, такие как \sphinxstylestrong{векторы} и \sphinxstylestrong{матрицы};

\item {} 
\sphinxAtStartPar
познакомимся с инструментами для работы с векторами и матрицами;

\item {} 
\sphinxAtStartPar
попробуем что\sphinxhyphen{}нибудь посчитать!

\end{itemize}

\sphinxAtStartPar
Обозначения:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\(a\) – число (скаляр);

\item {} 
\sphinxAtStartPar
\(\mathbf{a}\) – вектор;

\item {} 
\sphinxAtStartPar
\(\mathbf{A}\) – матрица.

\end{itemize}

\sphinxAtStartPar
Полезные материалы:
\begin{itemize}
\item {} 
\sphinxAtStartPar
MathProfi: \sphinxhref{http://mathprofi.ru/vektory\_dlya\_chainikov.html}{Аналитическая геометрия}.

\item {} 
\sphinxAtStartPar
3Blue1Brown: \sphinxhref{https://youtube.com/playlist?list=PLZHQObOWTQDPD3MizzM2xVFitgF8hE\_ab}{Essence of linear algebra}.

\end{itemize}

\sphinxstepscope


\chapter{Векторы}
\label{\detokenize{book/linalg/ru/vectors:vectors-ru}}\label{\detokenize{book/linalg/ru/vectors:id1}}\label{\detokenize{book/linalg/ru/vectors::doc}}
\sphinxAtStartPar
Автор(ы):
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{http://github.com/dayyass}{Эль\sphinxhyphen{}Айясс Дани}

\end{itemize}


\section{Определение}
\label{\detokenize{book/linalg/ru/vectors:id2}}
\sphinxAtStartPar
Вектор – это термин, который имеет несколько различных интерпретаций: математическую, геометрическую, физическую и др. Точный смысл данного термина зависит от контекста.

\sphinxAtStartPar
Формально вектор определяется как элемент векторного пространства – множества, на котором определены операции \sphinxstylestrong{сложения} и \sphinxstylestrong{умножения вектора на число (скаляр)}, которые должны удовлетворять \sphinxhref{https://ru.wikipedia.org/wiki/\%D0\%92\%D0\%B5\%D0\%BA\%D1\%82\%D0\%BE\%D1\%80\%D0\%BD\%D0\%BE\%D0\%B5\_\%D0\%BF\%D1\%80\%D0\%BE\%D1\%81\%D1\%82\%D1\%80\%D0\%B0\%D0\%BD\%D1\%81\%D1\%82\%D0\%B2\%D0\%BE}{8 аксиомам}.

\sphinxAtStartPar
Для простоты понимания рассмотрим знакомую нам со школьных времен прямоугольную (Декартову) систему координат на плоскости – две перпендикулярные друг другу оси \(x\) и \(y\), выбранные на них единичные векторы (орты) \(\mathbf{e}_1\), \(\mathbf{e}_2\) и начало координат.

\sphinxAtStartPar
Вектор \(\mathbf{a}\) в такой системе координат можно записать следующим образом: \(\mathbf{a} = a_1 \mathbf{e}_1 + a_2 \mathbf{e}_2 = \begin{pmatrix} a_1 \\ a_2 \end{pmatrix}\)

\sphinxAtStartPar
\sphinxstylestrong{Замечание 1}: Координаты вектора не определяют однозначно его положение на плоскости, а лишь положение конца вектора относительно его начала. Например, вектор \(\begin{pmatrix} 3 \\ 4 \end{pmatrix}\) может быть отложен как из точки начала координат \(\begin{pmatrix} 0 , 0 \end{pmatrix}\) с концом в точке \(\begin{pmatrix} 3 , 4 \end{pmatrix}\), так и из произвольной точки, например, \(\begin{pmatrix} 1 , 1 \end{pmatrix}\) с концом в точке \(\begin{pmatrix} 4 , 5 \end{pmatrix}\). Оба этих вектора соответствую 3 ортам на оси \(x\) и 4 на оси \(y\). Обычно, если не сказано иное, предполагается, что вектор отложен из начала координат.

\sphinxAtStartPar
\sphinxstylestrong{Замечание 2}: Вектор можно представить либо как вектор\sphinxhyphen{}столбец \(\begin{pmatrix} a_1 \\ a_2 \end{pmatrix}\), либо как вектор\sphinxhyphen{}строку \(\begin{pmatrix} a_1 \ a_2 \end{pmatrix}\). Здесь и далее под вектором будем подразумевать вектор\sphinxhyphen{}столбец, если не сказано иного.

\sphinxAtStartPar
Понятие вектора на плоскости можно обобщить на 3\sphinxhyphen{}мерное пространство, и, в общем случае, на \(n\)\sphinxhyphen{}мерное пространство (которое уже не получится визуализировать):
\begin{equation*}
\begin{split}
    \mathbf{a} = a_1 \mathbf{e}_1 + a_2 \mathbf{e}_2 + ... + a_n \mathbf{e}_n = \begin{pmatrix} a_1 \\ a_2 \\ ... \\ a_n \end{pmatrix}
\end{split}
\end{equation*}

\section{Операции с векторами}
\label{\detokenize{book/linalg/ru/vectors:id3}}
\sphinxAtStartPar
Как было сказано ранее, в формальном определении существуют две основные операции над векторами:
\begin{itemize}
\item {} 
\sphinxAtStartPar
сложение:

\end{itemize}
\begin{equation*}
\begin{split}
    \mathbf{a} + \mathbf{b} = (a_1 + b_1) \mathbf{e}_1 + (a_2 + b_2) \mathbf{e}_2 + ... + (a_n + b_n) \mathbf{e}_n = \\ = \begin{pmatrix} a_1 \\ a_2 \\ ... \\ a_n \end{pmatrix} + \begin{pmatrix} b_1 \\ b_2 \\ ... \\ b_n \end{pmatrix} = \begin{pmatrix} a_1 + b_1 \\ a_2 + b_2 \\ ... \\ a_n + b_n \end{pmatrix}
\end{split}
\end{equation*}\begin{itemize}
\item {} 
\sphinxAtStartPar
умножения вектора на число (скаляр):

\end{itemize}
\begin{equation*}
\begin{split}
    \lambda \mathbf{a} = \lambda a_1 \mathbf{e}_1 + \lambda a_2 \mathbf{e}_2 + ... + \lambda a_n \mathbf{e}_n = \lambda  \begin{pmatrix} a_1 \\ a_2 \\ ... \\ a_n \end{pmatrix} = \begin{pmatrix} \lambda a_1 \\ \lambda a_2 \\ ... \\ \lambda a_n \end{pmatrix}
\end{split}
\end{equation*}
\sphinxAtStartPar
Операцию умножения вектора на число можно интерпретировать геометрически, как сжатие / растяжение вектора.

\sphinxAtStartPar
Используя эти две операции, мы можем считать \sphinxstylestrong{линейные комбинации векторов}: \(\alpha_1 \mathbf{a}_1 + \alpha_2 \mathbf{a}_2 + ... + \alpha_n \mathbf{a}_n ,\) где \(\mathbf{a}_1, \mathbf{a}_2, ..., \mathbf{a}_n\) – векторы, а \(\alpha_1, \alpha_2, ..., \alpha_n\) – числа.


\section{Норма (длина) вектора}
\label{\detokenize{book/linalg/ru/vectors:id4}}
\sphinxAtStartPar
В линейной алгебре для обобщения понятия длины вектора используется термин \sphinxstylestrong{норма}. Можно сказать, что понятия длины и нормы эквивалентны.

\sphinxAtStartPar
Формально норма определяется как функционал в векторном пространстве, удовлетворяющий \sphinxhref{https://ru.wikipedia.org/wiki/\%D0\%9D\%D0\%BE\%D1\%80\%D0\%BC\%D0\%B0\_(\%D0\%BC\%D0\%B0\%D1\%82\%D0\%B5\%D0\%BC\%D0\%B0\%D1\%82\%D0\%B8\%D0\%BA\%D0\%B0)}{3 аксиомам} и отображающий элементы этого пространства (векторы) в множество неотрицательных вещественных чисел.

\sphinxAtStartPar
Данному определению нормы удовлетворяет множество функционалов, но мы будем рассматривать наиболее часто используемый – \sphinxstylestrong{Евклидову норму}.

\sphinxAtStartPar
Для простоты понимания рассмотрим вектор на плоскости. С геометрической точки зрения он представляет собой направленный отрезок. Направленность вектора никак не влияет на его длину, поэтому, при расчете длины, мы можем работать с ним как с отрезком на плоскости и посчитать длину по школьным формулам.
Заметим тот факт, что координаты вектора соответствуют числам, умноженным на орты координатных осей, поэтому формула длины вектора выглядит следующим образом: \(\lVert \mathbf{a} \rVert = \sqrt{a_1^2 + a_2^2}\). Соответственно, в общем случае формула выглядит следующим образом: \(\lVert \mathbf{a} \rVert = \sqrt{a_1^2 + a_2^2 + ... + a_n^2}\)


\section{Скалярное произведение}
\label{\detokenize{book/linalg/ru/vectors:id5}}
\sphinxAtStartPar
Одной из самых распространенных операций над двумя векторами является так называемое \sphinxstylestrong{скалярное произведение}, результатом которого является число (скаляр) – отсюда и название операции.

\sphinxAtStartPar
\sphinxstylestrong{Замечание}: Кроме скалярного произведения существует также \sphinxhref{https://ru.wikipedia.org/wiki/\%D0\%92\%D0\%B5\%D0\%BA\%D1\%82\%D0\%BE\%D1\%80\%D0\%BD\%D0\%BE\%D0\%B5\_\%D0\%BF\%D1\%80\%D0\%BE\%D0\%B8\%D0\%B7\%D0\%B2\%D0\%B5\%D0\%B4\%D0\%B5\%D0\%BD\%D0\%B8\%D0\%B5}{векторное произведение} над парой векторов, результатом которого являются вектор. Также существует \sphinxhref{https://ru.wikipedia.org/wiki/\%D0\%A1\%D0\%BC\%D0\%B5\%D1\%88\%D0\%B0\%D0\%BD\%D0\%BD\%D0\%BE\%D0\%B5\_\%D0\%BF\%D1\%80\%D0\%BE\%D0\%B8\%D0\%B7\%D0\%B2\%D0\%B5\%D0\%B4\%D0\%B5\%D0\%BD\%D0\%B8\%D0\%B5}{смешанное произведение} над тройкой векторов, результатом которого является число. Данные операции в рамках курса рассматриваться не будут.

\sphinxAtStartPar
Скалярное произведение используется в определении длины векторов и угла между ними. Данная операция имеет два определения:
\begin{itemize}
\item {} 
\sphinxAtStartPar
алгебраическое: \( \mathbf{a} \cdot \mathbf{b} = a_1  b_1 + a_2  b_2 + ... + a_n b_n\)

\item {} 
\sphinxAtStartPar
геометрическое: \(\mathbf{a} \cdot \mathbf{b} = \lVert \mathbf{a} \rVert \lVert \mathbf{b} \rVert \cos{\theta},\) где \(\theta\) – угол между векторами \(\mathbf{a}\) и \(\mathbf{b}\).

\end{itemize}

\sphinxAtStartPar
Используя оба эти определения можно вывести формулу для расчета косинуса угла между векторами:
\begin{equation*}
\begin{split}
    \cos{\theta} = \frac{\mathbf{a} \cdot \mathbf{b}}{\lVert \mathbf{a} \rVert \lVert \mathbf{b} \rVert} = \frac{a_1  b_1 + a_2  b_2 + ... + a_n b_n}{\sqrt{a_1^2 + a_2^2 + ... + a_n^2} \sqrt{b_1^2 + b_2^2 + ... + b_n^2}}
\end{split}
\end{equation*}
\sphinxAtStartPar
С помощью данной формулы можно прийти к одному из главных свойств скалярного произведения, которое заключается в том, что \sphinxstylestrong{два вектора перпендикулярны тогда и только тогда, как их скалярное произведение равно 0}: \(\mathbf{a} \perp \mathbf{b} \leftrightarrow \cos{\theta} = 0 \leftrightarrow \mathbf{a} \cdot \mathbf{b} = 0\)

\sphinxAtStartPar
Скалярное произведение можно использовать для расчета нормы вектора следующим образом: \(\lVert \mathbf{a} \rVert = \sqrt{\mathbf{a} \cdot \mathbf{a}}\)


\section{Линейная независимость}
\label{\detokenize{book/linalg/ru/vectors:id6}}
\sphinxAtStartPar
Одним из основополагающих понятий линейной алгебры является \sphinxstylestrong{линейная зависимость/независимость}.

\sphinxAtStartPar
Для определения данного понятия рассмотрим набор из нескольких векторов. Набор векторов является \sphinxstylestrong{линейно зависимым}, если существует такая ненулевая линейная комбинация векторов данного набора (как минимум один элемент данной комбинации не равен 0) равная нулевому вектору (вектор, состоящий только из 0):
\begin{equation*}
\begin{split}
    \lambda_1 \mathbf{a}_1 + \lambda_2 \mathbf{a}_2 + ... + \lambda_m \mathbf{a}_m = \begin{pmatrix} 0 \\ 0 \\ ... \\ 0 \end{pmatrix}, \\ \exists j, \, \lambda_j \not = {0}
\end{split}
\end{equation*}
\sphinxAtStartPar
Если набор векторов не является линейно зависимым, то есть не существует ненулевой линейной комбинации векторов данного набора равной нулевому вектору, то такой набор векторов называется \sphinxstylestrong{линейно независимым}.

\sphinxAtStartPar
\sphinxstylestrong{Пример}:
\begin{itemize}
\item {} 
\sphinxAtStartPar
линейно независимый набор векторов (только нулевые коэффициенты линейно комбинации приводят к нулевому вектору):

\end{itemize}
\begin{equation*}
\begin{split}
    \begin{pmatrix} 1 \\ 0 \\ 0 \end{pmatrix} \begin{pmatrix} 0 \\ 1 \\ 0 \end{pmatrix} \begin{pmatrix} 0 \\ 0 \\ 1 \end{pmatrix} \rightarrow 0 \cdot \begin{pmatrix} 1 \\ 0 \\ 0 \end{pmatrix} + 0 \cdot \begin{pmatrix} 0 \\ 1 \\ 0 \end{pmatrix} + 0 \cdot \begin{pmatrix} 0 \\ 0 \\ 1 \end{pmatrix} = \begin{pmatrix} 0 \\ 0 \\ 0 \end{pmatrix}
\end{split}
\end{equation*}\begin{itemize}
\item {} 
\sphinxAtStartPar
линейно зависимый набор векторов (существуют ненулевые коэффициенты линейно комбинации, которые приводят к нулевому вектору):

\end{itemize}
\begin{equation*}
\begin{split}
    \begin{pmatrix} 1 \\ 0 \\ 0 \end{pmatrix} \begin{pmatrix} 0 \\ 1 \\ 0 \end{pmatrix} \begin{pmatrix} 2 \\ 3 \\ 0 \end{pmatrix} \rightarrow 2 \cdot \begin{pmatrix} 1 \\ 0 \\ 0 \end{pmatrix} + 3 \cdot \begin{pmatrix} 0 \\ 1 \\ 0 \end{pmatrix} - 1 \cdot\begin{pmatrix} 2 \\ 3 \\ 0 \end{pmatrix} = \begin{pmatrix} 0 \\ 0 \\ 0 \end{pmatrix}
\end{split}
\end{equation*}
\sphinxAtStartPar
Из определения линейной зависимости можно вывести следующее свойство:
Набор векторов линейно зависим тогда и только тогда, когда один из элементов этого набора может быть выражен через оставшиеся.

\sphinxAtStartPar
\sphinxstylestrong{Замечание}: Если векторы рассматривать как какие\sphinxhyphen{}то характеристики объектов, то линейную зависимость можно интерпретировать как избыточность данных.

\sphinxAtStartPar
С помощью понятия линейной независимости вводится понятие \sphinxstylestrong{размерности} векторного пространства – это максимальное число линейно независимых векторов в нем.


\section{Базис}
\label{\detokenize{book/linalg/ru/vectors:id7}}
\sphinxAtStartPar
В формальном определении вектора не присутствуют никакие его количественные интерпретации, а лишь две операции над векторами и 8 аксиом.

\sphinxAtStartPar
Откуда же появляются количественные измерения? Для того, чтобы это стало понятно, нужно ввести понятия \sphinxstylestrong{базиса}.

\sphinxAtStartPar
Базис – это конечный набор векторов в векторном пространстве, такой, что любой вектор этого пространства может быть единственным образом представлен в виде линейной комбинации векторов этого набора.

\sphinxAtStartPar
Вспомним один из примеров выше, где мы представляли прямоугольную систему координат на плоскости и единичные векторы (орты) \(\mathbf{e}_1\), \(\mathbf{e}_2\). \(\mathbf{e}_1 = \begin{pmatrix} 1 \\ 0 \end{pmatrix}, \mathbf{e}_2 = \begin{pmatrix} 0 \\ 1 \end{pmatrix}\)
В данном примере мы разложили произвольный вектор \(\mathbf{a}\) следующим образом:
\begin{equation*}
\begin{split}
    \mathbf{a} = a_1 \mathbf{e}_1 + a_2 \mathbf{e}_2 = a_1 \begin{pmatrix} 1 \\ 0 \end{pmatrix} + a_2 \begin{pmatrix} 0 \\ 1 \end{pmatrix} = \begin{pmatrix} a_1 \\ 0 \end{pmatrix} + \begin{pmatrix} 0 \\ a_2 \end{pmatrix} = \begin{pmatrix} a_1 \\ a_2 \end{pmatrix}
\end{split}
\end{equation*}
\sphinxAtStartPar
Получается, что орты \(\mathbf{e}_1\), \(\mathbf{e}_2\) \sphinxstylestrong{являются базисом двумерного векторного пространства}, и с помощью линейной комбинации этих векторов мы можем единственным образом представить любой вектор этого пространства.

\sphinxAtStartPar
Возникает вопрос, данный базис является единственным в двумерном пространстве, или нет?

\sphinxAtStartPar
Ответ на этот вопрос – нет. На самом деле можно взять два любых вектора (\sphinxstylestrong{почти любых}), и они тоже будут являться базисом, при условии, что любой вектор можно разложить с помощью их линейной комбинации.

\sphinxAtStartPar
\sphinxstylestrong{Пример}.

\sphinxAtStartPar
Пусть у нас есть вектор \(\begin{pmatrix} 2 \\ 3 \end{pmatrix}\) в базисе единичных орт, и мы хотим разложить его по другому базису \(\begin{pmatrix} -2 \\ 0 \end{pmatrix} \begin{pmatrix} 0 \\ -3 \end{pmatrix}\):
\begin{equation*}
\begin{split}
    \alpha_1 \begin{pmatrix} -2 \\ 0 \end{pmatrix} + \alpha_2 \begin{pmatrix} 0 \\ -3 \end{pmatrix} = \begin{pmatrix} 2 \\ 3 \end{pmatrix}
\end{split}
\end{equation*}
\sphinxAtStartPar
Откуда мы можем найти, что \(\alpha_1 = -1\), \(\alpha_2 = -1\):
\begin{equation*}
\begin{split}
    -1 \begin{pmatrix} -2 \\ 0 \end{pmatrix} + -1 \begin{pmatrix} 0 \\ -3 \end{pmatrix} = \begin{pmatrix} 2 \\ 0 \end{pmatrix} + \begin{pmatrix} 0 \\ 3 \end{pmatrix} = \begin{pmatrix} 2 \\ 3 \end{pmatrix}
\end{split}
\end{equation*}
\sphinxAtStartPar
Таким образом, вектор \(\begin{pmatrix} 2 \\ 3 \end{pmatrix}\) в базисе единичных орт представляется как \(\begin{pmatrix} -1 \\ -1 \end{pmatrix}\) в базисе \(\begin{pmatrix} -2 \\ 0 \end{pmatrix} \begin{pmatrix} 0 \\ -3 \end{pmatrix}\).

\sphinxAtStartPar
Но для базиса, как было сказано ранее, подойдет \sphinxstylestrong{не любой набор векторов}.

\sphinxAtStartPar
Например через набор векторов \(\begin{pmatrix} -2 \\ 0 \end{pmatrix} \begin{pmatrix} -3 \\ 0 \end{pmatrix}\) нельзя разложить вектор \(\begin{pmatrix} 2 \\ 3 \end{pmatrix}\), поэтому данный набор векторов не является базисом.

\sphinxAtStartPar
В чем же принципиальная разница между этими базисами, и может ли базис двумерного пространства состоять, например, из большего или меньшего числа векторов, чем 2?

\sphinxAtStartPar
У линейной алгебры есть на это ответ:
\sphinxstylestrong{Любые \(n\) линейно независимых векторов \(n\)\sphinxhyphen{}мерного векторного пространства образуют базис этого пространства.}

\sphinxAtStartPar
Именно из\sphinxhyphen{}за линейной зависимости векторов \(\begin{pmatrix} -2 \\ 0 \end{pmatrix} \begin{pmatrix} -3 \\ 0 \end{pmatrix}\) они не могут являться базисом двумерного пространства.


\section{Что мы узнали?}
\label{\detokenize{book/linalg/ru/vectors:id8}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Определение вектора

\item {} 
\sphinxAtStartPar
Операции с векторами

\item {} 
\sphinxAtStartPar
Норма (длина) вектора

\item {} 
\sphinxAtStartPar
Скалярное произведение

\item {} 
\sphinxAtStartPar
Линейная независимость

\item {} 
\sphinxAtStartPar
Базис

\end{itemize}

\sphinxstepscope


\chapter{Скобки}
\label{\detokenize{book/linalg/ru/bra-ket:bra-ket}}\label{\detokenize{book/linalg/ru/bra-ket:id1}}\label{\detokenize{book/linalg/ru/bra-ket::doc}}
\sphinxAtStartPar
Автор(ы):
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/m12sl}{Озерин Алексей}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/alexey-pronkin}{Пронькин Алексей}

\end{itemize}

\sphinxAtStartPar
Дисклеймер: нам нужен инструментарий для работы с более абстрактными пространствами!

\sphinxAtStartPar
Символ Кронекера и остальные специальные тензора – это удобные примитивы для низкоуровневой работы с матрицами и векторами. Физики смогли придумать поверх примитивов линейной алгебры отличный синтаксический сахар, т.н. нотацию Дирака. Но давайте начнем с определения гильбертова пространства.


\section{Гильбертово пространство}
\label{\detokenize{book/linalg/ru/bra-ket:id2}}
\sphinxAtStartPar
Гильбертово пространство – это полное линейное векторное пространство, определяемое:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
скалярным произведением \((u, v)\), в простейшем частном случае \sphinxhyphen{} \((u, v) = u^{\dagger} v\);

\item {} 
\sphinxAtStartPar
зафиксированной нормой вида \(||v|| = \sqrt{(v,v)}\);

\item {} 
\sphinxAtStartPar
метрикой \(d(u,v) = ||u-v|| = \sqrt{(u-v,u-v)}\).

\end{enumerate}


\section{Полное пространство}
\label{\detokenize{book/linalg/ru/bra-ket:id3}}
\sphinxAtStartPar
При нахождении предела некоторой последовательности полное метрическое пространство дает возможность не думать о принадлежности этого предела данному пространству, то есть по своей сути разрешает предельный переход и позволяет доказать множество красивых теорем. Подробнее строгое определение можно посмотреть \sphinxhref{https://ru.wikipedia.org/wiki/\%D0\%9F\%D0\%BE\%D0\%BB\%D0\%BD\%D0\%BE\%D0\%B5\_\%D0\%BC\%D0\%B5\%D1\%82\%D1\%80\%D0\%B8\%D1\%87\%D0\%B5\%D1\%81\%D0\%BA\%D0\%BE\%D0\%B5\_\%D0\%BF\%D1\%80\%D0\%BE\%D1\%81\%D1\%82\%D1\%80\%D0\%B0\%D0\%BD\%D1\%81\%D1\%82\%D0\%B2\%D0\%BE}{тут}.


\section{Нотация Дирака, или Bra\sphinxhyphen{}Ket нотация}
\label{\detokenize{book/linalg/ru/bra-ket:id4}}
\sphinxAtStartPar
Напомним, что в гильбертовом пространстве для пространства \(H\) определено сопряженное пространство \(H^{\dagger}\).
Тогда можно рассмотреть обозначение Ket для элемента \(v\) из \(H\) как вектор\sphinxhyphen{}столбец:
\begin{equation*}
\begin{split}
\ket{v} = \begin{bmatrix} v_1 \\ v_2 \\ \vdots \\ v_N \end{bmatrix}
\end{split}
\end{equation*}
\sphinxAtStartPar
и обозначение Bra для элемента \(u\) из сопряженного пространства \(H^*\) как сопряженную вектор\sphinxhyphen{}строку
\begin{equation*}
\begin{split}
\bra{u}= \begin{bmatrix} u_1^* & u_2^* & \cdots & u_N^* \end{bmatrix}
\end{split}
\end{equation*}
\sphinxAtStartPar
Bra\sphinxhyphen{}ket \(u\) и \(v\) просто задает скалярное произведение между этими элементами:
\begin{equation*}
\begin{split}
\bra{u} \ket{v} = u_1^* v_1 + u_2^* v_2 + \cdots + u_N^* v_N =
\begin{bmatrix} u_1^* & u_2^* & \cdots & u_N^* \end{bmatrix}
\begin{bmatrix} v_1 \\ v_2 \\ \vdots \\ v_N \end{bmatrix}
\end{split}
\end{equation*}
\sphinxAtStartPar
Часто, например, требуется показать два граничных  состояния кубита \(\ket{0}\), \(\ket{1}\), тогда мы можем записать их просто как вектор\sphinxhyphen{}столбцы: \(\ket{0} = \begin{bmatrix} 1 \\ 0 \end{bmatrix}\) и \(\ket{1} = \begin{bmatrix} 0 \\ 1 \end{bmatrix}\). В следующей лекции этот вопрос будет рассмотрен детальнее.


\section{Внешнее произведение (outer\sphinxhyphen{}product)}
\label{\detokenize{book/linalg/ru/bra-ket:outer-product}}
\sphinxAtStartPar
Также имеет смысл и переставленная запись Ket\sphinxhyphen{}Bra, которая называется \sphinxhref{https://en.wikipedia.org/wiki/Outer\_product}{\sphinxstyleemphasis{внешним произведением}}:
\begin{equation*}
\begin{split}
\ket{u} \bra{v} = \begin{bmatrix} u_1^* \\ u_2^* \\ \cdots \\ u_N^* \end{bmatrix} \begin{bmatrix} v_1 & v_2 & \vdots & v_N \end{bmatrix} = \begin{bmatrix}
  u_1^* v_1 & u_1^* v_2 & \cdots & u_1^* v_N \\
  u_2^* v_1 & u_2^* v_2 & \cdots & u_2^* v_N \\
  \vdots & \cdots &  \ddots & \vdots\\
  u_N^* v_1 & \cdots & \cdots & u_N^* v_N
\end{bmatrix}
\end{split}
\end{equation*}
\sphinxAtStartPar
По сути это матрица \(N \times N\), то есть новый оператор в гильбертовом пространстве. Не все перестановки имеют смысл, например, нельзя записать \(\bra{v} \bra{v}\) или \(\ket{u} \ket{v}\).

\sphinxAtStartPar
Мы вернемся к Ket\sphinxhyphen{}Bra чуть ниже, когда будем говорить про операторы проекции.


\section{Эрмитов оператор}
\label{\detokenize{book/linalg/ru/bra-ket:id5}}
\sphinxAtStartPar
Оператор \(U\) называется \sphinxhref{https://ru.wikipedia.org/wiki/\%D0\%AD\%D1\%80\%D0\%BC\%D0\%B8\%D1\%82\%D0\%BE\%D0\%B2\_\%D0\%BE\%D0\%BF\%D0\%B5\%D1\%80\%D0\%B0\%D1\%82\%D0\%BE\%D1\%80}{\sphinxstyleemphasis{эрмитовым}}, если он удовлетворяет равенству \((Uv,u) = (v,Uu)\) для всех \(u\), \(v\) из \(H\) или в матричном виде:
\begin{equation*}
\begin{split}
U=U^{\dagger}
\end{split}
\end{equation*}

\section{Унитарный оператор}
\label{\detokenize{book/linalg/ru/bra-ket:id6}}
\sphinxAtStartPar
\sphinxhref{https://en.wikipedia.org/wiki/Unitary\_operator}{\sphinxstyleemphasis{Унитарный оператор}} \(\hat{U}:H \rightarrow H\) на гильбертовом пространстве \(H\) – это линейный оператор, который удовлетворяет следующему равенству \((Uv, Uu) = (u,v)\) для любых \(v \in H\), \(u \in H\). Или в матричной форме:
\begin{equation*}
\begin{split}
\hat{U}^{\dagger}\hat{U}=\hat{U}\hat{U}^{\dagger}=I
\end{split}
\end{equation*}
\sphinxAtStartPar
Напомним, что операция \(\hat{U}^\dagger\) (другое частое обозначение в работах – звездочка или \(H\hat{U}^{*}=\hat{U}^{H}\)) в матричных терминах является последовательным применением операции транспонирования и последующего комплексного сопряжения элементов этой матрицы \(\hat{U}^\dagger = \overline{\hat{U}}^T\) (порядок этих операций, естественно, не влияет на результат).

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{scipy} \PYG{k}{as} \PYG{n+nn}{sp}
\PYG{k+kn}{from} \PYG{n+nn}{scipy} \PYG{k+kn}{import} \PYG{n}{linalg}

\PYG{n}{U\PYGZus{}hat} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}
    \PYG{p}{[}\PYG{l+m+mi}{1} \PYG{o}{+} \PYG{l+m+mi}{0}\PYG{n}{j}\PYG{p}{,} \PYG{l+m+mi}{0} \PYG{o}{+} \PYG{l+m+mi}{0}\PYG{n}{j}\PYG{p}{]}\PYG{p}{,}
    \PYG{p}{[}\PYG{l+m+mi}{0} \PYG{o}{+} \PYG{l+m+mi}{0}\PYG{n}{j}\PYG{p}{,} \PYG{l+m+mi}{1} \PYG{o}{+} \PYG{l+m+mi}{0}\PYG{n}{j}\PYG{p}{]}
    \PYG{p}{]}\PYG{p}{)}

\PYG{n}{U\PYGZus{}hat\PYGZus{}star\PYGZus{}byhands} \PYG{o}{=} \PYG{n}{U\PYGZus{}hat}\PYG{o}{.}\PYG{n}{conj}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{T}
\PYG{n}{U\PYGZus{}hat\PYGZus{}star\PYGZus{}long} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{conjugate}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{transpose}\PYG{p}{(}\PYG{n}{U\PYGZus{}hat}\PYG{p}{)}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{allclose}\PYG{p}{(}\PYG{n}{U\PYGZus{}hat\PYGZus{}star\PYGZus{}long}\PYG{p}{,} \PYG{n}{U\PYGZus{}hat\PYGZus{}star\PYGZus{}byhands}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
True
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Также в \sphinxcode{\sphinxupquote{Python}} для многих операций есть соответствующие методы вместо функций и их сокращения, например \sphinxcode{\sphinxupquote{U.transpose()}} – то же самое, что \sphinxcode{\sphinxupquote{U.T}}, а \sphinxcode{\sphinxupquote{U.conjugate()}} – \sphinxcode{\sphinxupquote{U.conj()}}.

\sphinxAtStartPar
Важное свойство, что любой эрмитов оператор \(U\) можно привести к унитарному оператору с помощью взятия матричной экспоненты от матрицы оператора, умноженного на мнимую единицу:
\begin{equation*}
\begin{split}
\hat{U} = e^{iU}
\end{split}
\end{equation*}
\sphinxAtStartPar
Давайте докажем быстро этот факт: для эрмитовых квадратных матриц можно определить матричные функции через спектральное разложение матрицы, которое в силу свойств эрмитовых матриц имеет вид: \(U=S \Lambda S^{\dagger}\), где \(S\) – унитарная матрица перехода к тому базису, где изначальный оператор выражается диагональной матрицей. Тогда матричная функция \(f(U) = S f(\Lambda) S^{\dagger}\), т.е. мы диагонализируем матрицу и применяем функцию ко всем диагональным элементам, а потом возвращаемся в исходный базис унитарным преобразованием. Соответственно, для экспоненты:
\begin{equation*}
\begin{split}
e^V = S e^{\Lambda} S^\dagger.
\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
В качестве упражнения для самопроверки можете показать, что такое определение эквивалентно определению через степенной ряд: \(e^U = \sum_{k=0}^\infty{1 \over k!}U^k\)
\end{sphinxadmonition}

\sphinxAtStartPar
Доказательство:
Проверим определение унитарной матрицы: \(\hat{U}^{\dagger}\hat{U} = (S \exp (i*\Lambda) S^\dagger)^\dagger S \exp (i*\Lambda) S^\dagger\).
Пользуясь тем, что эрмитово сопряжение произведения это произведение эрмитовых сопряжений в обратном порядке (\((AB)^\dagger=B^\dagger A^\dagger\)) и что эрмитово сопряжение является обратной операцией к себе (\((A^\dagger)^\dagger = A\)), а также тем, что \(S\) – унитарная матрица (то есть \(S \cdot S^{\dagger}=I\)), получаем:
\begin{equation*}
\begin{split}
(S \exp (i*\Lambda) S^\dagger)^\dagger S \exp (i*\Lambda) S^\dagger = S \exp(-i*\Lambda) S^\dagger S \exp (i*\Lambda) S^\dagger = S \exp(-i*\Lambda) \exp (i*\Lambda) S^\dagger
\end{split}
\end{equation*}
\sphinxAtStartPar
Заметим, что теперь у нас уже скалярная экспонента, которая применяется к элементам диагональной матрицы, и мы можем воспользоваться тем, что произведение экспонент превращается в экспоненту от суммы степеней:
\begin{equation*}
\begin{split}
S \exp(-i \Lambda  + i \Lambda) S^\dagger = S \exp(O) S^\dagger = S I S^\dagger = I
\end{split}
\end{equation*}
\sphinxAtStartPar
В конце мы еще раз воспользовались тем, что \(S\) – унитарная. Абсолютно так же доказывается, что \(\hat{U}\hat{U}^{\dagger} = I.\)

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Кстати, любая матрица вида \(HH^{\dagger}\) является эрмитовой.
\end{sphinxadmonition}

\sphinxAtStartPar
Давайте продемонстрируем доказанный факт на примере матрицы дискретного преобразования Фурье без нормировочного коэффициента \(\frac{1}{N}\), \(N=3\), преобразованной к \(DD^{\dagger}\):

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{N} \PYG{o}{=} \PYG{l+m+mi}{3}
\PYG{n}{w} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{n}{j} \PYG{o}{*} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi} \PYG{o}{/} \PYG{n}{N}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{D} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}
    \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}
    \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{w}\PYG{p}{,} \PYG{n}{w} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}
    \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{w} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{w} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{4}\PYG{p}{]}
    \PYG{p}{]}\PYG{p}{)}

\PYG{n}{U} \PYG{o}{=} \PYG{n}{D} \PYG{o}{@} \PYG{n}{D}\PYG{o}{.}\PYG{n}{conj}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{T}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{U} \PYG{l+s+si}{= \PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{D} \PYG{l+s+si}{= \PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{np}\PYG{o}{.}\PYG{n}{allclose}\PYG{p}{(}\PYG{n}{U} \PYG{o}{@} \PYG{n}{U}\PYG{o}{.}\PYG{n}{T}\PYG{o}{.}\PYG{n}{conj}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{eye}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{)} \PYG{l+s+si}{= \PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} no}

\PYG{n}{U\PYGZus{}hat} \PYG{o}{=} \PYG{n}{linalg}\PYG{o}{.}\PYG{n}{expm}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{n}{j} \PYG{o}{*} \PYG{n}{U}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{np}\PYG{o}{.}\PYG{n}{allclose}\PYG{p}{(}\PYG{n}{U\PYGZus{}hat} \PYG{o}{@} \PYG{n}{U\PYGZus{}hat}\PYG{o}{.}\PYG{n}{conj}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{T}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{eye}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{)} \PYG{l+s+si}{= \PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{np}\PYG{o}{.}\PYG{n}{allclose}\PYG{p}{(}\PYG{n}{U\PYGZus{}hat}\PYG{o}{.}\PYG{n}{conj}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{T} \PYG{o}{@} \PYG{n}{U\PYGZus{}hat}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{eye}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{)} \PYG{l+s+si}{= \PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
U = array([[ 3.00000000e+00+0.00000000e+00j,  1.00000000e+00+1.73205081e+00j,
        \PYGZhy{}1.11022302e\PYGZhy{}16+7.77156117e\PYGZhy{}16j],
       [ 1.00000000e+00\PYGZhy{}1.73205081e+00j,  3.00000000e+00\PYGZhy{}3.98552134e\PYGZhy{}18j,
         1.00000000e+00+1.73205081e+00j],
       [\PYGZhy{}1.11022302e\PYGZhy{}16\PYGZhy{}7.77156117e\PYGZhy{}16j,  1.00000000e+00\PYGZhy{}1.73205081e+00j,
         3.00000000e+00\PYGZhy{}1.88596895e\PYGZhy{}17j]])
D = array([[ 1. +0.j       ,  1. +0.j       ,  1. +0.j       ],
       [ 1. +0.j       ,  0.5\PYGZhy{}0.8660254j, \PYGZhy{}0.5\PYGZhy{}0.8660254j],
       [ 1. +0.j       , \PYGZhy{}0.5\PYGZhy{}0.8660254j, \PYGZhy{}0.5+0.8660254j]])
np.allclose(U @ U.T.conj(), np.eye(N)) = False

np.allclose(U\PYGZus{}hat @ U\PYGZus{}hat.conj().T, np.eye(N)) = True

np.allclose(U\PYGZus{}hat.conj().T @ U\PYGZus{}hat, np.eye(N)) = True
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Пример: оператор\sphinxhyphen{}проектор}
\label{\detokenize{book/linalg/ru/bra-ket:id7}}
\sphinxAtStartPar
Оператором проекции является оператор \(P\) со свойством \(P^2=P\).

\sphinxAtStartPar
Покажем, что Ket\sphinxhyphen{}Bra вида \(\ket{\Psi} \bra{\Psi}\) обладает этим свойством.
\begin{equation*}
\begin{split}(\ket{\Psi} \bra{\Psi})^2 = \ket{\Psi} \bra{\Psi} \ket{\Psi} \bra{\Psi} = \ket{\Psi} (\bra{\Psi} \ket{\Psi}) \bra{\Psi} = \ket{\Psi} \bra{\Psi},\end{split}
\end{equation*}
\sphinxAtStartPar
поскольку вектор состояния – нормированный: \(\bra{\Psi} \ket{\Psi} = 1\).

\sphinxAtStartPar
Оператор Ket\sphinxhyphen{}Bra с вектором состояния \(\ket{\Psi}\), то есть \(\ket{\Psi} \bra{\Psi}\)рассматривается во {\hyperref[\detokenize{book/qc/ru/qubit::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{вводной лекции про кубиты}}}}, а также пригодится позже, когда речь зайдет о {\hyperref[\detokenize{book/qc/ru/mixedstates::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{смешанных состояниях}}}}.


\subsection{Пример: оператор поворота}
\label{\detokenize{book/linalg/ru/bra-ket:id8}}
\sphinxAtStartPar
Оператором поворота по оси вращения \(v=(x,y,z)\) на угол \(\theta\) является
\begin{equation*}
\begin{split}
M(v,\theta) = \begin{bmatrix}
   \cos \theta + (1 - \cos \theta) x^2
 & (1 - \cos \theta) x y - (\sin \theta) z
 & (1 - \cos \theta) x z + (\sin \theta) y  
\\
   (1 - \cos \theta) y x + (\sin \theta) z
 & \cos \theta + (1 - \cos \theta) y^2
 & (1 - \cos \theta) y z - (\sin \theta) x
\\
   (1 - \cos \theta) z x - (\sin \theta) y
 & (1 - \cos \theta) z y + (\sin \theta) x
 & \cos \theta + (1 - \cos \theta) z^2
\end{bmatrix}
\end{split}
\end{equation*}
\sphinxAtStartPar
Например, матрица поворота относительно оси \(x\) на \(90^\degree\): \(x=1\), \(y=0\), \(z=0\), \(\theta = \frac{\pi}{2}\), будет иметь вид:
\begin{equation*}
\begin{split}
M = \begin{bmatrix}
1 & 0 & 0 \\
0 & \cos{\frac{\pi}{2}} & -\sin{\frac{\pi}{2}} \\
0 & \sin{\frac{\pi}{2}} & 1 \end{bmatrix}
\end{split}
\end{equation*}
\sphinxAtStartPar
Если у нас больше измерений, то по тем измерениям, которые не затрагиваются этим поворотом, у нас в строке и столбце стоят нули, кроме пересечения строки и столбца, отвечающих за это измерение \sphinxhyphen{} там стоит единица.

\sphinxAtStartPar
Операторы поворота очень важны в квантовых вычислениях. Они рассматриваются отдельно в {\hyperref[\detokenize{book/qc/ru/gates::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{лекции про квантовые гейты}}}} и далее используются в {\hyperref[\detokenize{book/vqc/ru/vqc::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{вариационных квантовых схемах}}}} для кодирования классических данных в квантовые операторы.


\subsection{Пример: оператор дифференцирования}
\label{\detokenize{book/linalg/ru/bra-ket:id9}}
\sphinxAtStartPar
В пространстве многочленов \(P\) с базисом \(\{1,t,t^2,...,t^n\}\) можно задать оператор дифференцирования \(\mathcal{D} \colon P_n \to P_{n-1}\) в виде матрицы:
\begin{equation*}
\begin{split}
D=\begin{bmatrix}
0 & 1 & 0 & 0 & \cdots & 0 \\
0 & 0 & 2 & 0 & \cdots & 0 \\
0 & 0 & 0 & 3 &\cdots & 0 \\
\cdots & \cdots & \cdots & \cdots &\cdots & \cdots \\
0 & 0 & 0 & 0 &\cdots & n \\
\end{bmatrix}
\end{split}
\end{equation*}
\sphinxAtStartPar
Тогда производная многочлена \(p = a_0 + a_1 t  + \cdots + a_n t^{n} = \begin{bmatrix} a_0 & a_1 & \cdots & a_n \end{bmatrix} \cdot \begin{bmatrix} 1 \\ t \\ \vdots \\ t^{n} \end{bmatrix}\)
\begin{equation*}
\begin{split}
\mathcal{D}(p)  = \begin{bmatrix} a_0 & a_1 & \cdots & a_n \end{bmatrix} D \begin{bmatrix} 1 \\ t \\ \vdots \\ t^{n-1} \end{bmatrix} = a_1 + 2 a_2 t+\cdots+n a_n t^{n-1}.
\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Про разницу между оператором и матрицей преобразования}

\sphinxAtStartPar
Мы с вами рассматривали операторы через конечные матрицы, но на самом деле гильбертово пространство было придумано как раз, чтобы можно было работать с бесконечномерными векторами и применять непрерывные операторы. Можно считать, что есть некоторый дуализм между непрерывным оператором и пределом бесконечной матрицы. Иногда удобнее работать с матрицей, а иногда – с абстрактным оператором.
\end{sphinxadmonition}


\section{Произведение Кронекера}
\label{\detokenize{book/linalg/ru/bra-ket:id10}}
\sphinxAtStartPar
Давайте рассмотрим еще одну интересную операцию, которая называется матричным тензорным произведением (является тензорным произведением для линейных операторов) или произведением Кронекера.

\sphinxAtStartPar
Проще всего его необходимость можно продемонстрировать на примере двух игр: Орел/Решка и бросок кубика.
Мы можем записать состояния этих игр через вероятности событий и давайте возьмем монетку со смешенным центром тяжести и такой же кубик:

\sphinxAtStartPar
\(\text{coin} = \begin{bmatrix} \frac{1}{3} && \frac{2}{3} \end{bmatrix}\) для нашей монетки и \(\text{dice}=\begin{bmatrix} \frac{1}{4} && \frac{1}{5} && \frac{1}{7} && \frac{1}{11} && \frac{1}{13} && \frac{4791}{20020} \end{bmatrix}\) для нашей игральной кости. Тогда если мы захотим сыграть в игру, когда сначала подкидывается монетка, а потом \sphinxhyphen{} игральный кубик, нам будет удобно записать это в виде либо очень длинного вектора:
\begin{equation*}
\begin{split}
\text{game}_{\text{vec}} = \begin{bmatrix} \frac{1}{3} \times \frac{1}{4} && \frac{1}{3} \times \frac{1}{5} && \frac{1}{3} \times \frac{1}{7} && \frac{1}{3} \times \frac{1}{11} && \frac{1}{3} \times \frac{1}{13} && \frac{1}{3} \times \frac{4791}{20020}&& \frac{2}{3} \times \frac{1}{4} && \frac{2}{3} \times \frac{1}{5} && \frac{2}{3} \times \frac{1}{7} && \frac{2}{3} \times \frac{1}{11} && \frac{2}{3} \times \frac{1}{13} && \frac{2}{3} \times \frac{4791}{20020} \end{bmatrix}
\end{split}
\end{equation*}
\sphinxAtStartPar
Либо в виде матрицы, где по строкам будут события монетки, а по столбцам – кубика:
\begin{equation*}
\begin{split}
\text{game}_{\text{matrix}} = \begin{bmatrix} \frac{1}{3} \times \frac{1}{4} && \frac{1}{3} \times \frac{1}{5} && \frac{1}{3} \times \frac{1}{7} && \frac{1}{3} \times \frac{1}{11} && \frac{1}{3} \times \frac{1}{13} && \frac{1}{3} \times \frac{4791}{20020}\\
 \frac{2}{3} \times \frac{1}{4} && \frac{2}{3} \times \frac{1}{5} && \frac{2}{3} \times \frac{1}{7} && \frac{2}{3} \times \frac{1}{11} && \frac{2}{3} \times \frac{1}{13} && \frac{2}{3} \times \frac{4791}{20020} \end{bmatrix}
\end{split}
\end{equation*}
\sphinxAtStartPar
С помощью произведения Кронекера (или, повторимся, – матричного тензорного произведения) похожие огромные вектора и матрицы можно очень компактно записать:
\begin{equation*}
\begin{split}
\text{game}_{\text{vec}} = \text{coin} \otimes \text{dice} \\
\text{game}_{\text{matrix}} = \text{coin}^T \otimes \text{dice}
\end{split}
\end{equation*}
\sphinxAtStartPar
В общем случае,
\begin{equation*}
\begin{split}
A \otimes B = \begin{bmatrix} a_{11} B & \cdots & a_{1n}B \\ \vdots & \ddots & \vdots \\ a_{m1} B & \cdots & a_{mn} B \end{bmatrix} =\begin{bmatrix}
   a_{11} b_{11} & a_{11} b_{12} & \cdots & a_{11} b_{1q} & \cdots & \cdots & a_{1n} b_{11} & a_{1n} b_{12} & \cdots & a_{1n} b_{1q} \\
   a_{11} b_{21} & a_{11} b_{22} & \cdots & a_{11} b_{2q} & \cdots & \cdots & a_{1n} b_{21} & a_{1n} b_{22} & \cdots & a_{1n} b_{2q} \\
   \vdots & \vdots & \ddots & \vdots & & & \vdots & \vdots & \ddots & \vdots \\
   a_{11} b_{p1} & a_{11} b_{p2} & \cdots & a_{11} b_{pq} & \cdots & \cdots & a_{1n} b_{p1} & a_{1n} b_{p2} & \cdots & a_{1n} b_{pq} \\
   \vdots & \vdots & & \vdots & \ddots & & \vdots & \vdots & & \vdots \\
   \vdots & \vdots & & \vdots & & \ddots & \vdots & \vdots & & \vdots \\
   a_{m1} b_{11} & a_{m1} b_{12} & \cdots & a_{m1} b_{1q} & \cdots & \cdots & a_{mn} b_{11} & a_{mn} b_{12} & \cdots & a_{mn} b_{1q} \\
   a_{m1} b_{21} & a_{m1} b_{22} & \cdots & a_{m1} b_{2q} & \cdots & \cdots & a_{mn} b_{21} & a_{mn} b_{22} & \cdots & a_{mn} b_{2q} \\
   \vdots & \vdots & \ddots & \vdots & & & \vdots & \vdots & \ddots & \vdots \\
   a_{m1} b_{p1} & a_{m1} b_{p2} & \cdots & a_{m1} b_{pq} & \cdots & \cdots & a_{mn} b_{p1} & a_{mn} b_{p2} & \cdots & a_{mn} b_{pq}
\end{bmatrix}\end{split}
\end{equation*}
\sphinxAtStartPar
Основные его свойства вы можете прочитать в статье: \sphinxhref{https://ru.wikipedia.org/wiki/\%D0\%9F\%D1\%80\%D0\%BE\%D0\%B8\%D0\%B7\%D0\%B2\%D0\%B5\%D0\%B4\%D0\%B5\%D0\%BD\%D0\%B8\%D0\%B5\_\%D0\%9A\%D1\%80\%D0\%BE\%D0\%BD\%D0\%B5\%D0\%BA\%D0\%B5\%D1\%80\%D0\%B0}{\sphinxstyleemphasis{Произведение Кронекера}}

\sphinxAtStartPar
Есть и другие нужные тензорные операции, например, чуть больший список вы можете найти в \sphinxhref{https://habr.com/ru/post/369925/}{этой статье} или в рекомендованной литературе по квантовой механике.


\section{Рекомендованная литература}
\label{\detokenize{book/linalg/ru/bra-ket:id11}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Quantum Mechanics: The Theoretical Minimum Illustrated Edition by Leonard Susskind, Art Friedman {[}\hyperlink{cite.book/bibliography:id66}{SF14}{]} или его русский перевод {[}\hyperlink{cite.book/bibliography:id67}{15b}{]}. Книга сочетает в себе довольно строгий формализм вместе с интуицией квантовой механики. Главы построены в виде конкретных примеров или задач, которые понимают, зачем та или иная теория необходима.

\item {} 
\sphinxAtStartPar
Mathematics for machine learning by Marc Peter Deisenroth, A. Aldo Faisal, and Cheng Soon Ong {[}\hyperlink{cite.book/bibliography:id26}{DFO20}{]} \sphinxhyphen{} отличная книжка чтобы освежить воспоминания о базовых алгоритмах в машинном обучении и о математике, которая применяется в них. \sphinxhref{https://mml-book.github.io/book/mml-book.pdf}{\sphinxstyleemphasis{Доступна бесплатная электронная версия}}.

\item {} 
\sphinxAtStartPar
Deep Learning by Ian Goodfellow, Yoshua Bengio, Aaron Courville {[}\hyperlink{cite.book/bibliography:id4}{GBC16}{]} \sphinxhyphen{} отличная книжка, чтобы разобраться в основах глубокого обучения, чем\sphinxhyphen{}то может заменить предыдущую книгу, отличный старт, если вы хотите разобраться в автоэнкодерах или в других нейросетевых моделях.
\sphinxhref{https://www.deeplearningbook.org/}{\sphinxstyleemphasis{Доступна бесплатная электронная версия}}.

\end{itemize}


\section{Что мы узнали}
\label{\detokenize{book/linalg/ru/bra-ket:id16}}\begin{itemize}
\item {} 
\sphinxAtStartPar
произвол со скобками

\item {} 
\sphinxAtStartPar
Гильбертовы пространства

\item {} 
\sphinxAtStartPar
Эрмитовый оператор

\item {} 
\sphinxAtStartPar
Унитарный оператор

\item {} 
\sphinxAtStartPar
Примеры различных операторов

\end{itemize}

\sphinxstepscope


\chapter{Матрицы}
\label{\detokenize{book/linalg/ru/matrices:matrices}}\label{\detokenize{book/linalg/ru/matrices:id1}}\label{\detokenize{book/linalg/ru/matrices::doc}}
\sphinxAtStartPar
Автор(ы):
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{http://github.com/dayyass}{Эль\sphinxhyphen{}Айясс Дани}

\end{itemize}


\section{Определение}
\label{\detokenize{book/linalg/ru/matrices:id2}}
\sphinxAtStartPar
Матрица – это математический объект, представляющий собой прямоугольную таблицу чисел.

\sphinxAtStartPar
У каждой матрицы есть размер, который характеризуется двумя числами – количеством строк и количеством столбцов. Матрицу, состоящую из \(n\) строк \(m\) столбцов будем называть матрицей размера \(n \times m\). Пространство вещественных матриц \(n \times m\) обозначается \(\mathbf{R}^{n \times m}\). Мы будем рассматривать матрицу либо как набор \(n\) вектор\sphinxhyphen{}строк, либо как набор \(m\) вектор\sphinxhyphen{}столбцов.

\sphinxAtStartPar
\sphinxstylestrong{Замечание}: Вектор\sphinxhyphen{}строку из \(n\) элементов можно рассматривать как матрицу размера \(1 \times n\), а аналогичного размера вектор\sphinxhyphen{}столбец – как матрицу размера \(n \times 1\).

\sphinxAtStartPar
Рассмотрим произвольную матрицу \(\mathbf{A}\):
\begin{equation*}
\begin{split}
\mathbf{A} = \begin{pmatrix} a_{11} & a_{12} & ... & a_{1m} \\ a_{21} & a_{22} & ... & a_{2m} \\ ... & ... & ... & ... \\ a_{n1} & a_{n2} & ... & a_{nm} \end{pmatrix}
\end{split}
\end{equation*}
\sphinxAtStartPar
Элемент матрицы \(\mathbf{A}\), стоящий на пересечение строки \(i\) и столбца \(j\) будем обозначать \(a_{ij}\).

\sphinxAtStartPar
В машинном обучении часто приходится иметь дело с матрицей объекты\sphinxhyphen{}признаки. Объекты, как и признаки – это набор числовых характеристик (точки в многомерном пространстве), которые обычно рассматриваются как векторы.


\section{Операции с матрицами}
\label{\detokenize{book/linalg/ru/matrices:id3}}
\sphinxAtStartPar
Аналогично векторным операциям, для матриц определены операции \sphinxstylestrong{сложения} и \sphinxstylestrong{умножения на число}:
\begin{itemize}
\item {} 
\sphinxAtStartPar
сложение:

\end{itemize}
\begin{equation*}
\begin{split}
\mathbf{A} + \mathbf{B} = \begin{pmatrix} a_{11} & a_{12} & ... & a_{1m} \\ a_{21} & a_{22} & ... & a_{2m} \\ ... & ... & ... & ... \\ a_{n1} & a_{n2} & ... & a_{nm} \end{pmatrix} + \begin{pmatrix} b_{11} & b_{12} & ... & b_{1m} \\ b_{21} & b_{22} & ... & b_{2m} \\ ... & ... & ... & ... \\ b_{n1} & b_{n2} & ... & b_{nm} \end{pmatrix} = \begin{pmatrix} a_{11} + b_{11} & a_{12} + b_{12} & ... & a_{1m} + b_{1m} \\ a_{21} + b_{21} & a_{22} + b_{22} & ... & a_{2m} + b_{2m} \\ ... & ... & ... & ... \\ a_{n1} + b_{n1} & a_{n2} + b_{n2} & ... & a_{nm} + b_{nm} \end{pmatrix}
\end{split}
\end{equation*}\begin{itemize}
\item {} 
\sphinxAtStartPar
умножения матрицы на число (скаляр):

\end{itemize}
\begin{equation*}
\begin{split}
\lambda \cdot \mathbf{A} = \lambda \cdot \begin{pmatrix} a_{11} & a_{12} & ... & a_{1m} \\ a_{21} & a_{22} & ... & a_{2m} \\ ... & ... & ... & ... \\ a_{n1} & a_{n2} & ... & a_{nm} \end{pmatrix} = \begin{pmatrix} \lambda \cdot a_{11} & \lambda \cdot a_{12} & ... & \lambda \cdot a_{1m} \\ \lambda \cdot a_{21} & \lambda \cdot a_{22} & ... & \lambda \cdot a_{2m} \\ ... & ... & ... & ... \\ \lambda \cdot a_{n1} & \lambda \cdot a_{n2} & ... & \lambda \cdot a_{nm} \end{pmatrix}
\end{split}
\end{equation*}\begin{itemize}
\item {} 
\sphinxAtStartPar
транспонирование (строки и столбцы меняются местами):

\end{itemize}
\begin{equation*}
\begin{split}
\mathbf{A} = \begin{pmatrix} a_{11} & a_{12} & ... & a_{1m} \\ a_{21} & a_{22} & ... & a_{2m} \\ ... & ... & ... & ... \\ a_{n1} & a_{n2} & ... & a_{nm} \end{pmatrix} \rightarrow \mathbf{A}^{T} = \begin{pmatrix} a_{11} & a_{21} & ... & a_{m1} \\ a_{12} & a_{22} & ... & a_{m2} \\ ... & ... & ... & ... \\ a_{1n} & a_{2n} & ... & a_{mn} \end{pmatrix}
\end{split}
\end{equation*}
\sphinxAtStartPar
Но наибольший интерес представляет операция умножения матриц, которая определяется не самым интуитивным способом.

\sphinxAtStartPar
Рассмотрим операцию скалярного произведения как умножение матрицы размера \(1 \times n\) (вектор\sphinxhyphen{}строка) на матрицу размера \(n \times 1\) (вектор\sphinxhyphen{}столбец). Результатом данной операции получается матрица размера \(1 \times 1\) (скаляр).

\sphinxAtStartPar
Таким образом для получения значения \(c_{11}\) результирующей матрицы \(\mathbf{С}\) мы скалярно умножили 1\sphinxhyphen{}ю строку \(\mathbf{a_{1:}}\) матрицы \(\mathbf{A}\) (вектор) на 1\sphinxhyphen{}й столбец \(\mathbf{b_{:1}}\) матрицы \(\mathbf{B}\) (вектор).

\sphinxAtStartPar
Из примере выше мы можем прийти к следующим заключениям:
\begin{itemize}
\item {} 
\sphinxAtStartPar
для умножения матриц необходимо, чтобы количество столбцов первой матрицы было равно количеству строк второй, иначе нельзя посчитать скалярное произведение

\item {} 
\sphinxAtStartPar
операция умножения матриц не является коммутативной, то есть \(\mathbf{A} \mathbf{B} \not = \mathbf{B} \mathbf{A}\)

\end{itemize}

\sphinxAtStartPar
Развивая логику примера выше мы можем перейти к определению операции умножения матриц. Рассмотрим матрицы \(\mathbf{A} \in \mathbf{R}^{n \times p}\) и \(\mathbf{B} \in \mathbf{R}^{p \times m}\). Результатом произведения этих матриц будем матрица \(\mathbf{A} \mathbf{B} = \mathbf{C} \in \mathbf{R}^{n \times m}\), где значение \(c_{ij}\) получится путем скалярного произведения \(i\)\sphinxhyphen{}й строки \(\mathbf{a_{i:}}\) матрицы \(\mathbf{A}\) (вектор) на \(j\)\sphinxhyphen{}й столбец \(\mathbf{b_{:j}}\) матрицы \(\mathbf{B}\) (вектор):
\begin{equation*}
\begin{split}
c_{ij} = \mathbf{a_{i:}} \cdot \mathbf{b_{:j}} = a_{i1}  b_{1j} + a_{i2}  b_{2j} + ... + a_{ip} b_{pj}
\end{split}
\end{equation*}
\sphinxAtStartPar
\sphinxstylestrong{Замечание 1}: В результате умножения квадратных матриц размера \(n \times n\) получается квадратная матрица того же размера.

\sphinxAtStartPar
\sphinxstylestrong{Замечание 2}: Частными случаями матричного умножения являются операции умножения вектор\sphinxhyphen{}строки на матрицу и матрицы на вектор\sphinxhyphen{}столбец, в результате которых получаются вектор\sphinxhyphen{}строка и вектор\sphinxhyphen{}столбец соответственно.

\sphinxAtStartPar
Рассмотрим пример, почему удобно представлять операцию умножения матриц именно таким образом. Пусть имеется система линейных уравнений:
\begin{equation*}
\begin{split}
\begin{cases}
    a_{11} x_{1} + a_{12} x_{2} + ... + a_{1m} x_{m} = b_{1} \\
    a_{21} x_{1} + a_{22} x_{2} + ... + a_{2m} x_{m} = b_{2} \\
    ... \\
    a_{n1} x_{1} + a_{n2} x_{2} + ... + a_{nm} x_{m} = b_{n}
\end{cases}
\end{split}
\end{equation*}
\sphinxAtStartPar
Представим данную систему в матричном виде:
\begin{equation*}
\begin{split}
\mathbf{A} \mathbf{x} = \mathbf{b} \rightarrow \begin{pmatrix} a_{11} & a_{12} & ... & a_{1m} \\ a_{21} & a_{22} & ... & a_{2m} \\ ... & ... & ... & ... \\ a_{n1} & a_{n2} & ... & a_{nm} \end{pmatrix} \begin{pmatrix} x_{1} \\ x_{2} \\ ... \\ x_{m} \end{pmatrix} = \begin{pmatrix} b_{1} \\ b_{2} \\ ... \\ b_{n} \end{pmatrix}
\end{split}
\end{equation*}

\section{Норма матрицы}
\label{\detokenize{book/linalg/ru/matrices:id4}}
\sphinxAtStartPar
Понятие матричной нормы несколько сложнее, чем векторной. Обычно принято рассматривать так называемые \sphinxstylestrong{операторные нормы}. Такая норма показывает насколько максимально растягивается произвольный вектор \(\mathbf{x}\) при отображении \(y = \mathbf{Ax}\). Формально операторная норма определяется следующим образом:
\begin{equation*}
\begin{split}
\lVert \mathbf{A} \rVert_{p} = \sup_{\mathbf{x} \neq 0}\frac{\lVert \mathbf{Ax} \rVert_{p}}{\lVert \mathbf{x} \rVert_{p}}
\end{split}
\end{equation*}
\sphinxAtStartPar
Существует множество матричных норм, но наиболее полезной является \sphinxstylestrong{спектральная норма}. Опуская математические выкладки, можно показать, что спектральная норма равна максимальному собственному числу матрицы \(\mathbf{A}^T\mathbf{A}\):
\begin{equation*}
\begin{split}
\lVert \mathbf{A} \rVert_{2} =\sqrt{\lambda_{max}(\mathbf{A}^T\mathbf{A})}
\end{split}
\end{equation*}
\sphinxAtStartPar
Про собственные числа поговорим позже, а пока вернемся к нормам. Иногда также рассматривают \sphinxstylestrong{поэлементные нормы} матриц. Такая норма определяется тем же образом, что и для векторов. Наиболее распространенной из данного вида является \sphinxstylestrong{Евклидова норма}, она же \sphinxstylestrong{норма Фробениуса}:
\begin{equation*}
\begin{split}
\lVert \mathbf{A} \rVert_{F} = \sqrt{\sum_{i}\sum_{j}a_{ij}^2}
\end{split}
\end{equation*}

\section{Ранг матрицы}
\label{\detokenize{book/linalg/ru/matrices:id5}}
\sphinxAtStartPar
Вспомним, что матрицу можно рассматривать либо как набор вектор\sphinxhyphen{}строк, либо как набор вектор\sphinxhyphen{}столбцов, а для набор векторов определенно понятие линейной независимости.

\sphinxAtStartPar
Таким образом мы приходим двум следующим понятиям:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{строчный ранг} матрицы – это максимальное число линейно независимых строк (вектор\sphinxhyphen{}строк)

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{столбцовый ранг} матрицы – это максимальное число линейно независимых столбцов (вектор\sphinxhyphen{}столбцов)

\end{itemize}

\sphinxAtStartPar
Тут мы можем задаться вопрос о том, равны ли эти ранги между собой, и если равны, то при каких условиях, и на помощь нам приходит \sphinxstylestrong{фундаментальная теорема “о ранге матрицы”}, которая говорит, что ранг, посчитанный по строкам всегда равен рангу, посчитанному по столбцам. Поэтому обычно говорят просто о ранге матрицы.


\section{Линейные преобразования}
\label{\detokenize{book/linalg/ru/matrices:id6}}
\sphinxAtStartPar
В рамках школьной программы все знакомы с понятием функции. Функция – это соответствием между элементами двух множеств.

\sphinxAtStartPar
Например, линейная функция вида \(y = f(x) = kx + b\) отображает элементы множества вещественных чисел \(x \in \mathbf{R}\) в себя \(y \in \mathbf{R}\) :
\begin{equation*}
\begin{split}
f: \mathbf{R} \rightarrow \mathbf{R}
\end{split}
\end{equation*}
\sphinxAtStartPar
Парабола \(y = f(x) = x^2\) отображает элементы множества вещественных чисел \(x \in \mathbf{R}\) во множество неотрицательных вещественных чисел \(y \in \mathbf{R}^{+} \cup \{0\}\) :
\begin{equation*}
\begin{split}
f: \mathbf{R} \rightarrow \mathbf{R}^{+} \cup \{0\}
\end{split}
\end{equation*}
\sphinxAtStartPar
Среди всего множества функций есть определенный класс функций, называемых линейными. Этот класс является самым простым среди множества всех функций. Основным свойством линейных функций является пропорциональность \(x\) и \(y\): изменение значения функции \(y\) пропорционально изменению значения аргумента \(x\). Графиком линейной функции является прямая.

\sphinxAtStartPar
Обобщая идею линейных функций на матрицы и вектора мы можем прийти к понятиям \sphinxstylestrong{линейных отображений} и \sphinxstylestrong{линейных преобразований}.

\sphinxAtStartPar
Линейное отображение – это обобщение линейной функции, которое принимает на вход вектор и возвращает вектор. Вектор может быть как той же размерности, так и другой.

\sphinxAtStartPar
Формально, линейное отображение – это отображение множества элементов одного векторного пространства \(V\) в другое \(W\)
\begin{equation*}
\begin{split}
f: V \rightarrow W ,
\end{split}
\end{equation*}
\sphinxAtStartPar
удовлетворяющее так называемым \sphinxhref{https://ru.wikipedia.org/wiki/\%D0\%9B\%D0\%B8\%D0\%BD\%D0\%B5\%D0\%B9\%D0\%BD\%D0\%BE\%D0\%B5\_\%D0\%BE\%D1\%82\%D0\%BE\%D0\%B1\%D1\%80\%D0\%B0\%D0\%B6\%D0\%B5\%D0\%BD\%D0\%B8\%D0\%B5\#cite\_note-\_5e0d87b5e4a6def2-2}{условиям линейности}.

\sphinxAtStartPar
Если \(V\) и \(W\) — это одно и то же векторное пространство, то \(f\) называют не просто линейным отображением, а \sphinxstylestrong{линейным преобразованием}.

\sphinxAtStartPar
Отображения и преобразования удобно рассматривать как движение в векторном пространстве.

\sphinxAtStartPar
Ранее упоминалось, что при умножении вектора на матрицу мы получаем вектор, поэтому матрица задает преобразование, которое, если проверить условия линейности, является линейным. Соответственно, \sphinxstylestrong{матрица задает линейное отображение}.

\sphinxAtStartPar
Например, матрица \(\mathbf{A} \in \mathbf{R}^{n \times m}\) задает преобразование из векторного пространства размерности \(n\) в векторное пространство размерности \(m\).

\sphinxAtStartPar
\sphinxstylestrong{Замечание 1}: Для того, чтобы матрица задавала линейное преобразование, она должна быть квадратной, т.к. в результате умножение вектора на квадратную матрицу его размерность не меняется. Таким образом вектор, как элемент векторного пространства, отображается в то же векторное пространство.

\sphinxAtStartPar
\sphinxstylestrong{Замечание 2}: Пусть имеются две матрицы \(\mathbf{A} \in \mathbf{R}^{n \times p}\) и \(\mathbf{B} \in \mathbf{R}^{p \times m}\). Умножив матрицу \(\mathbf{A}\) на матрицу \(\mathbf{B}\) мы получим матрицу \(\mathbf{C} \in \mathbf{R}^{n \times m}\). Матрица \(\mathbf{C}\) задает линейное отображение, равное последовательному применению отображений, задаваемых матрицами \(\mathbf{A}\) и \(\mathbf{B}\). Таким образом операция умножения матриц имеет простую интерпретацию \sphinxhyphen{} последовательное применение линейных отображений.

\sphinxAtStartPar
Рассмотрим некоторые примеры линейных преобразований на плоскости, задаваемых матрицами размера \(2 \times 2\):
\begin{itemize}
\item {} 
\sphinxAtStartPar
Вращение / поворот:
\begin{itemize}
\item {} 
\sphinxAtStartPar
на 90 градусов против часовой стрелки: \(\mathbf{A} = \begin{pmatrix} 0 & -1 \\ 1 & 0 \end{pmatrix}\)

\item {} 
\sphinxAtStartPar
на угол \(\theta\) против часовой стрелки: \(\mathbf{A} = \begin{pmatrix} \cos \theta & -\sin \theta \\ \sin \theta & \cos \theta \end{pmatrix}\)

\end{itemize}

\item {} 
\sphinxAtStartPar
Отражение:
\begin{itemize}
\item {} 
\sphinxAtStartPar
относительно оси \(x\): \( \mathbf{A} = \begin{pmatrix} 1 & 0 \\ 0 & -1 \end{pmatrix}\)

\item {} 
\sphinxAtStartPar
относительно оси \(y\): \(\mathbf{A} = \begin{pmatrix} -1 & 0 \\ 0 & 1 \end{pmatrix}\)

\item {} 
\sphinxAtStartPar
относительно линии, образующей угол \(\theta\) с началом координат: \(\mathbf{A} = \begin{pmatrix} \cos 2\theta & \sin 2\theta \\ \sin 2\theta & -\cos 2\theta \end{pmatrix}\)

\end{itemize}

\item {} 
\sphinxAtStartPar
Масштабирование:
\begin{itemize}
\item {} 
\sphinxAtStartPar
в 2 раза по всем направлениям: \(\mathbf{A} = \begin{pmatrix} 2 & 0 \\ 0 & 2 \end{pmatrix}\)

\end{itemize}

\item {} 
\sphinxAtStartPar
Проекция:
\begin{itemize}
\item {} 
\sphinxAtStartPar
на ось \(y\): \(\mathbf{A} = \begin{pmatrix} 0 & 0 \\ 0 & 1 \end{pmatrix}\)

\end{itemize}

\end{itemize}


\section{Обратная матрица}
\label{\detokenize{book/linalg/ru/matrices:id7}}
\sphinxAtStartPar
Рассмотрим особую матрицу линейного преобразования, которая переводит каждый вектор сам в себя, т.е. никак его не изменяет. Данное преобразование задается так называемой \sphinxstylestrong{единичной матрицей}:
\begin{equation*}
\begin{split}
\mathbf{E} = \begin{pmatrix} 1 & 0 \\ 0 & 1 \end{pmatrix}
\end{split}
\end{equation*}
\sphinxAtStartPar
Произведение любой матрицы / вектора и единичной матрицы подходящего размера равно самой матрице / вектору (аналог единицы для операции умножения чисел):
\begin{equation*}
\begin{split}
\mathbf{A} \mathbf{E} = \mathbf{E} \mathbf{A} = \mathbf{A}
\end{split}
\end{equation*}
\sphinxAtStartPar
Появление такого элемента в пространстве вещественных матриц наводит на мысль о том, что для каждой матрицы должен существовать обратный элемент:
\begin{equation*}
\begin{split}
\mathbf{A} \mathbf{A}^{-1} = \mathbf{A}^{-1} \mathbf{A} = \mathbf{E}
\end{split}
\end{equation*}
\sphinxAtStartPar
\sphinxstylestrong{Замечание}: Аналогично операции умножения чисел, если \(a \cdot 1 = 1 \cdot a = a\), то существует \(a^{-1}\), такой, что \(a \cdot a^{-1} = a^{-1} \cdot a = 1\).

\sphinxAtStartPar
Теория линейной алгебры говорит о том, что обратная матрица существует только для \sphinxstylestrong{невырожденных квадратных матриц}, строки и столбцы которых линейно независимы.

\sphinxAtStartPar
Те линейные преобразования, которые были приведены в примерах выше задаются невырожденными квадратными матрицами, поэтому для них существуют обратные преобразования, которые тоже будут линейными.

\sphinxAtStartPar
Например, обратными к преобразованиям вращения / поворота, отражения и масштабирования являются эти же преобразования: вращение / поворот, отражение и масштабирование соответственно.

\sphinxAtStartPar
\sphinxstylestrong{Замечание}: Существуют разные алгоритмы нахождения обратной матрицы, которые не будут нами рассматриваться, но с ними можно ознакомиться \sphinxhref{https://ru.wikipedia.org/wiki/\%D0\%9E\%D0\%B1\%D1\%80\%D0\%B0\%D1\%82\%D0\%BD\%D0\%B0\%D1\%8F\_\%D0\%BC\%D0\%B0\%D1\%82\%D1\%80\%D0\%B8\%D1\%86\%D0\%B0}{здесь}.

\sphinxAtStartPar
Будем назвать линейное преобразование \sphinxstylestrong{вырожденным}, если оно задается вырожденной матрицей.

\sphinxAtStartPar
Соответственно, возникает вопрос, чем же так особенны вырожденные линейные преобразования, если для них не существует обратного преобразования?

\sphinxAtStartPar
Невырожденное линейное преобразование устанавливает взаимно\sphinxhyphen{}однозначное соответствие между входными и выходными векторами. Вырожденное преобразование этим свойством не обладает.

\sphinxAtStartPar
Это связано с тем, вырожденные линейные преобразования переводят некоторые ненулевые вектора в нулевые (для невырожденных линейных преобразований только нулевой вектор переходит в нулевой):
\begin{equation*}
\begin{split}
\mathbf{A} \mathbf{x} = 0, \mathbf{x} \not ={\begin{pmatrix} 0 \\ 0 \\ ... \\ 0 \end{pmatrix}}
\end{split}
\end{equation*}
\sphinxAtStartPar
В связи с этим одному выходному вектору (нулевому) соответствует несколько входных векторов, поэтому не существует обратного преобразования.


\section{Определитель}
\label{\detokenize{book/linalg/ru/matrices:id8}}
\sphinxAtStartPar
Введем еще одно из ключевых понятий линейной алгебры – \sphinxstylestrong{определитель}.

\sphinxAtStartPar
Определитель – это скалярный показатель (число) \sphinxstylestrong{квадратной матрицы} \(f: \mathbf{R}^{n \times n} \rightarrow \mathbf{R}\), который позволяет охарактеризовать некоторые свойства этой матрицы и линейного преобразования, заданного этой матрицей.

\sphinxAtStartPar
Определитель матрицы \(\mathbf{x}\) обозначается как: \(\det(\mathbf{A}) = |\mathbf{A}| = \Delta(\mathbf{A})\)

\sphinxAtStartPar
Формально понятие определителя может быть введено несколькими способами:
\begin{itemize}
\item {} 
\sphinxAtStartPar
через перестановки

\item {} 
\sphinxAtStartPar
через свойства определителя

\item {} 
\sphinxAtStartPar
геометрически

\end{itemize}

\sphinxAtStartPar
\sphinxstylestrong{Замечание}: В данной лекции не будет рассказано, как посчитать определитель. Ознакомиться с алгоритмом расчета и формальным выводом определителя можно по \sphinxhref{https://ru.wikipedia.org/wiki/\%D0\%9E\%D0\%BF\%D1\%80\%D0\%B5\%D0\%B4\%D0\%B5\%D0\%BB\%D0\%B8\%D1\%82\%D0\%B5\%D0\%BB\%D1\%8C}{ссылке}.

\sphinxAtStartPar
Определитель обладает следующими важными свойствами – он \sphinxstylestrong{равен нулю} тогда и только тогда, когда \sphinxstylestrong{строки (столбцы) матрицы линейно зависимы}.

\sphinxAtStartPar
Из этого можно сделать следующие выводы:
\begin{itemize}
\item {} 
\sphinxAtStartPar
матрица вырожденная тогда и только тогда, когда ее определитель равен 0

\item {} 
\sphinxAtStartPar
линейное преобразование вырожденное тогда и только тогда, когда определитель матрицы, задающей данное преобразование, равен 0

\item {} 
\sphinxAtStartPar
если определитель матрицы равен 0, то для данной матрицы не существует обратной

\end{itemize}

\sphinxAtStartPar
Существуют эффективные алгоритмы вычисления определителя квадратной матрицы, которые позволяют проверять, является матрица вырожденной.


\section{Собственные числа и векторы}
\label{\detokenize{book/linalg/ru/matrices:id9}}
\sphinxAtStartPar
Для некоторых линейных преобразований существуют такие векторы, которые после данного преобразования либо растягиваются, либо сжимаются (тот же вектор, умноженный на некоторое число). Такие векторы называются \sphinxstylestrong{собственными векторами} линейного преобразования, а числа, на которые данные векторы умножаются – \sphinxstylestrong{собственными значениями}.

\sphinxAtStartPar
Рассмотрим произвольную матрицу линейного преобразования \(\mathbf{A}\). Формально понятия собственных векторов и собственных значений вводятся через следующее равенство: \(
\mathbf{A} \mathbf{x} = \lambda \mathbf{x}\)

\sphinxAtStartPar
Векторы \(\mathbf{x}\), удовлетворяющие данному равенству являются собственными векторами линейного преобразования \(\mathbf{A}\), а соответствующие данным векторам значения \(\lambda\) – собственными числами.

\sphinxAtStartPar
Линейное преобразование может как не иметь собственных векторов (например, поворот в двумерном пространстве), или иметь \(n\) собственных векторов с различными собственными значениями.

\sphinxAtStartPar
Собственные числа и собственные значения играют большую роль в линейной алгебре, так как многие соотношения, связанные с линейными преобразованиями, существенно упрощаются в системе координат, построенной на базисе из собственных векторов линейного преобразованиями.

\sphinxAtStartPar
Множество собственных значений линейного преобразованиями (\sphinxstylestrong{спектр оператора}) характеризует важные свойства оператора без привязки к какой\sphinxhyphen{}либо конкретной системе координат.

\sphinxAtStartPar
Также собственные векторы используются в Методе Главных Компонент, который предназначен для уменьшения размерности данных с потерей наименьшего количества информации.


\section{Что мы узнали?}
\label{\detokenize{book/linalg/ru/matrices:id10}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Определение матрицы

\item {} 
\sphinxAtStartPar
Операции с матрицами

\item {} 
\sphinxAtStartPar
Норма матрицы

\item {} 
\sphinxAtStartPar
Ранг матрицы

\item {} 
\sphinxAtStartPar
Линейные преобразования

\item {} 
\sphinxAtStartPar
Обратная матрица

\item {} 
\sphinxAtStartPar
Определитель матрицы

\item {} 
\sphinxAtStartPar
Собственные числа и векторы матрицы

\end{itemize}

\sphinxstepscope


\chapter{Numpy}
\label{\detokenize{book/linalg/ru/numpy:numpy}}\label{\detokenize{book/linalg/ru/numpy:id1}}\label{\detokenize{book/linalg/ru/numpy::doc}}
\sphinxAtStartPar
Автор(ы):
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/Erlemar}{Лукьяненко Андрей}

\end{itemize}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Numpy}} – это широко используемая библиотека для вычислений с многомерными массивами. API большей частью вдохновлен \sphinxcode{\sphinxupquote{MATLAB}} (великая и ужасная среда, язык и IDE для матричных вычислений), а теперь сам является примером для подражания API различных вычислительных пакетов.
Более последовательный гайд стоит посмотреть на \sphinxhref{https://numpy.org/devdocs/user}{сайте библиотеки}.


\section{Массивы}
\label{\detokenize{book/linalg/ru/numpy:id2}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{n}{a} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} создадим вектор}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{a} \PYG{l+s+si}{= \PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{n}{b} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{b} \PYG{l+s+si}{= \PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{n}{c} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{eye}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{c} \PYG{l+s+si}{= \PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{n}{q} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{random}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{q} \PYG{l+s+si}{= \PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
a = array([1, 2, 3])
b = array([[0., 0.],
       [0., 0.]])
c = array([[1., 0., 0.],
       [0., 1., 0.],
       [0., 0., 1.]])
q = array([[0.61489174, 0.52664549, 0.1778471 , 0.62368887, 0.68195148,
        0.64482789, 0.67942519, 0.45092505, 0.70625959, 0.94145252,
        0.68800156, 0.04564975, 0.02340102, 0.5659795 , 0.79219096,
        0.11187013, 0.29897186, 0.89156398, 0.94970861, 0.95349695]])
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Арифметические операции}
\label{\detokenize{book/linalg/ru/numpy:id3}}
\sphinxAtStartPar
Для удобства использования \sphinxcode{\sphinxupquote{np.ndarray}} арифметические операторы определены так, чтобы соответствовать ожиданиям:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{a} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{b} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{diff} \PYG{o}{=} \PYG{n}{a} \PYG{o}{\PYGZhy{}} \PYG{n}{b}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{diff} \PYG{l+s+si}{= \PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{n}{mult} \PYG{o}{=} \PYG{n}{a} \PYG{o}{*} \PYG{n}{b}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{mult} \PYG{l+s+si}{= \PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{n}{scalar\PYGZus{}mult} \PYG{o}{=} \PYG{n}{a} \PYG{o}{@} \PYG{n}{b}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{scalar\PYGZus{}mult} \PYG{l+s+si}{= \PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
diff = array([ 2, \PYGZhy{}1, \PYGZhy{}1])
mult = array([\PYGZhy{}1,  6, 12])
scalar\PYGZus{}mult = 17
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Indexing, slicing and sugar}
\label{\detokenize{book/linalg/ru/numpy:indexing-slicing-and-sugar}}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Numpy}} поддерживает, кажется, все разумные варианты индексации:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{a} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{l+m+mi}{16}\PYG{p}{)}\PYG{o}{.}\PYG{n}{reshape}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{a} \PYG{l+s+si}{= \PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} просто по индексам}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{a}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]} \PYG{l+s+si}{= \PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{a}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{l+s+si}{= \PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} по слайсам}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{a}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{:}\PYG{l+m+mi}{3}\PYG{p}{]} \PYG{l+s+si}{= \PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{a}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{l+s+si}{= \PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{a}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{p}{:}\PYG{p}{]} \PYG{l+s+si}{= \PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{a}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]} \PYG{l+s+si}{= \PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} по маске}
\PYG{n}{mask} \PYG{o}{=} \PYG{p}{(}\PYG{n}{a} \PYG{o}{\PYGZpc{}} \PYG{l+m+mi}{3} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{mask} \PYG{l+s+si}{= \PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{a}\PYG{p}{[}\PYG{n}{mask}\PYG{p}{]} \PYG{l+s+si}{= \PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{n}{first\PYGZus{}rows} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{k+kc}{True}\PYG{p}{,} \PYG{k+kc}{True}\PYG{p}{,} \PYG{k+kc}{False}\PYG{p}{,} \PYG{k+kc}{False}\PYG{p}{]}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{a}\PYG{p}{[}\PYG{n}{first\PYGZus{}rows}\PYG{p}{]} \PYG{l+s+si}{= \PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
a = array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11],
       [12, 13, 14, 15]])

a[0, 1] = 1
a[0][1] = 1

a[0, 1:3] = array([1, 2])
a[2] = array([ 8,  9, 10, 11])
a[2, :] = array([ 8,  9, 10, 11])
a[2, ...] = array([ 8,  9, 10, 11])

mask = array([[ True, False, False,  True],
       [False, False,  True, False],
       [False,  True, False, False],
       [ True, False, False,  True]])
a[mask] = array([ 0,  3,  6,  9, 12, 15])

a[first\PYGZus{}rows] = array([[0, 1, 2, 3],
       [4, 5, 6, 7]])
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Для работы с размерностями часто используются еще три конструкции: \sphinxcode{\sphinxupquote{None}}, \sphinxcode{\sphinxupquote{...}} (ellipsis, многоточие) и \sphinxcode{\sphinxupquote{:}} (двоеточие).

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{a} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{l+m+mi}{16}\PYG{p}{)}\PYG{o}{.}\PYG{n}{reshape}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{a} \PYG{l+s+si}{= \PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} None добавляет ось размерности 1}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{a}\PYG{p}{[}\PYG{k+kc}{None}\PYG{p}{]}\PYG{o}{.}\PYG{n}{shape} \PYG{l+s+si}{= \PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{a}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{p}{:}\PYG{p}{,} \PYG{k+kc}{None}\PYG{p}{]}\PYG{o}{.}\PYG{n}{shape} \PYG{l+s+si}{= \PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} : превращается в slice (None), берет все элементы вдоль размерности}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{a}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{p}{:}\PYG{p}{]} \PYG{l+s+si}{= \PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{a}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{:}\PYG{k+kc}{None}\PYG{p}{]} \PYG{l+s+si}{= \PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} ... ellipsis, превращается в необходимое число двоеточий :,:,:}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{a}\PYG{p}{[}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]} \PYG{l+s+si}{= \PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} также ... удобен когда мы не знаем настоящий шейп массива или нужно не трогать несколько подряд идущих размерностей}
\PYG{n}{z} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{l+m+mi}{27}\PYG{p}{)}\PYG{o}{.}\PYG{n}{reshape}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{z}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]} \PYG{l+s+si}{= \PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{z}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]} \PYG{l+s+si}{= \PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
a = array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11],
       [12, 13, 14, 15]])

a[None].shape = (1, 4, 4)
a[:, :, None].shape = (4, 4, 1)

a[2, :] = array([ 8,  9, 10, 11])
a[2, 0:None] = array([ 8,  9, 10, 11])

a[...] = array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11],
       [12, 13, 14, 15]])

z[0, ..., 1] = array([1, 4, 7])
z[0, :, 1] = array([1, 4, 7])
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
В целом в \sphinxcode{\sphinxupquote{NumPy}} очень здорово реализованы методы \sphinxcode{\sphinxupquote{\_\_getitem\_\_}}/\sphinxcode{\sphinxupquote{\_\_setitem\_\_}}.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{a} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{element} \PYG{o}{=} \PYG{n}{a}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{element} \PYG{l+s+si}{= \PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{n}{a}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{5}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{a} \PYG{l+s+si}{= \PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
element = 3
a = array([1, 2, 5])
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Кроме того, мы можем делать индексацию по заданному условию с помощью \sphinxcode{\sphinxupquote{np.where}}.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} создадим вектор}
\PYG{n}{a} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{selection} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{where}\PYG{p}{(}\PYG{n}{a} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{selection} \PYG{l+s+si}{= \PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} дополнительно можем передать два значения или вектора, при выполнении условия выбираются элементы из первого значения/вектора, при невыполнении \PYGZhy{}\PYGZhy{} из второго}
\PYG{n}{a2} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{where}\PYG{p}{(}\PYG{n}{a} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{a} \PYG{o}{*} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{a2} \PYG{l+s+si}{= \PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} np.where работает и с многомерными массивами}
\PYG{n}{b} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{8}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{b\PYGZus{}mult} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{where}\PYG{p}{(}\PYG{n}{b} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{b\PYGZus{}mult} \PYG{l+s+si}{= \PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
selection = (array([0, 1]),)
a2 = array([ 2,  2, 12, 16])
b\PYGZus{}mult = array([[1, 1, 2, 1],
       [0, 1, 3, 1]])
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Broadcasting}
\label{\detokenize{book/linalg/ru/numpy:broadcasting}}
\sphinxAtStartPar
Что происходит, если мы хотим производить арифметические операции с массивами разных размеров?

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{a} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{k} \PYG{o}{=} \PYG{l+m+mi}{2}
\PYG{n}{broad} \PYG{o}{=} \PYG{n}{a} \PYG{o}{*} \PYG{n}{k}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{broad} \PYG{l+s+si}{= \PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
broad = array([2, 4, 6])
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
С точки зрения математики, ничего интересного тут не происходит: мы подразумевали умножение всего вектора на скаляр. Однако матричные операции в numpy справляются и с менее очевидными случаями, например, при сложении или вычитании вектора и скаляра:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{a} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{k} \PYG{o}{=} \PYG{l+m+mi}{2}
\PYG{n}{broad} \PYG{o}{=} \PYG{n}{a} \PYG{o}{\PYGZhy{}} \PYG{n}{k}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{broad}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
[\PYGZhy{}1  0  1]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
В numpy приняты следующие правила работы с массивами разного размера:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
размерности сравниваются справа налево;

\item {} 
\sphinxAtStartPar
два массива совместимы в размерности, если она одинаковая, либо у одного из массивов единичная;

\item {} 
\sphinxAtStartPar
вдоль отсутствующих размерностей происходит расширение повторением (\sphinxcode{\sphinxupquote{np.repeat}}).

\end{enumerate}

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{numpy_work_with_arrays}.png}
\end{figure}

\begin{sphinxadmonition}{attention}{Attention:}
\sphinxAtStartPar
Be aware
Автоматический броадкастинг легко приводит к ошибкам, так что лучше делать его самостоятельно в явной форме.
\end{sphinxadmonition}


\section{Операции с плавающей точкой}
\label{\detokenize{book/linalg/ru/numpy:id4}}
\sphinxAtStartPar
Отдельно стоит поговорить про числа с плавающей точкой.
Число с плавающей точкой (или число с плавающей запятой) – экспоненциальная форма представления вещественных (действительных) чисел, в которой число хранится в виде мантиссы и порядка (показателя степени). При этом число с плавающей точкой имеет фиксированную относительную точность и изменяющуюся абсолютную.
В результате одно и то же значение может выглядеть по\sphinxhyphen{}разному, если хранить его с разной точностью.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{f16} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{float16}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0.1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{f32} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{float32}\PYG{p}{(}\PYG{n}{f16}\PYG{p}{)}
\PYG{n}{f64} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{float64}\PYG{p}{(}\PYG{n}{f32}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{f16} \PYG{l+s+si}{= \PYGZcb{}}\PYG{l+s+s2}{, }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{f32} \PYG{l+s+si}{= \PYGZcb{}}\PYG{l+s+s2}{, }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{f64} \PYG{l+s+si}{= \PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{f16} \PYG{o}{==} \PYG{n}{f32} \PYG{o}{==} \PYG{n}{f64} \PYG{l+s+si}{= \PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{n}{f16} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{float16}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0.1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{f32} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{float32}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0.1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{f64} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{float64}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0.1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{f16} \PYG{l+s+si}{= \PYGZcb{}}\PYG{l+s+s2}{, }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{f32} \PYG{l+s+si}{= \PYGZcb{}}\PYG{l+s+s2}{, }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{f64} \PYG{l+s+si}{= \PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{f16} \PYG{o}{==} \PYG{n}{f32} \PYG{o}{==} \PYG{n}{f64} \PYG{l+s+si}{= \PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
f16 = 0.1, f32 = 0.099975586, f64 = 0.0999755859375
f16 == f32 == f64 = True
f16 = 0.1, f32 = 0.1, f64 = 0.1
f16 == f32 == f64 = False
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Из\sphinxhyphen{}за этого для сравнения массивов с типом float используют \sphinxcode{\sphinxupquote{np.allclose}}.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{np}\PYG{o}{.}\PYG{n}{allclose}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{1e10}\PYG{p}{,}\PYG{l+m+mf}{1e\PYGZhy{}7}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{1.00001e10}\PYG{p}{,}\PYG{l+m+mf}{1e\PYGZhy{}8}\PYG{p}{]}\PYG{p}{)} \PYG{l+s+si}{= \PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{np}\PYG{o}{.}\PYG{n}{allclose}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{1e10}\PYG{p}{,}\PYG{l+m+mf}{1e\PYGZhy{}8}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{1.00001e10}\PYG{p}{,}\PYG{l+m+mf}{1e\PYGZhy{}9}\PYG{p}{]}\PYG{p}{)} \PYG{l+s+si}{= \PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
np.allclose([1e10,1e\PYGZhy{}7], [1.00001e10,1e\PYGZhy{}8]) = False
np.allclose([1e10,1e\PYGZhy{}8], [1.00001e10,1e\PYGZhy{}9]) = True
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{NumPy и линейная алгебра}
\label{\detokenize{book/linalg/ru/numpy:id5}}
\sphinxAtStartPar
В \sphinxcode{\sphinxupquote{Numpy}} много удобных функций, которые позволяют упростить код. Приведем несколько примеров:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} матрица с единицами по диагонали и с нулями в остальных ячейках}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{np}\PYG{o}{.}\PYG{n}{eye}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{dtype}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{)} \PYG{l+s+si}{= \PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} есть возможность указать индекс диагонали}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{np}\PYG{o}{.}\PYG{n}{eye}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{k}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{dtype}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{)} \PYG{l+s+si}{= \PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} в Numpy есть свой генератор случайных чисел и векторов}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{beta}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)} \PYG{l+s+si}{= \PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{randint}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)} \PYG{l+s+si}{= \PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Numpy позволяет заменить значений основной диагонали матрицы.}
\PYG{c+c1}{\PYGZsh{} внимание, эта функция работает in\PYGZhy{}place}
\PYG{n}{a} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{randint}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{a} \PYG{l+s+si}{= \PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{np}\PYG{o}{.}\PYG{n}{fill\PYGZus{}diagonal}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{a} \PYG{l+s+si}{= \PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Можно сделать и наоборот \PYGZhy{}\PYGZhy{} получить вектор значений диагонали матрица}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{np}\PYG{o}{.}\PYG{n}{diag}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)} \PYG{l+s+si}{= \PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
np.eye(2, dtype=int) = array([[1, 0],
       [0, 1]])
np.eye(3, k=\PYGZhy{}1, dtype=int) = array([[0, 0, 0],
       [1, 0, 0],
       [0, 1, 0]])
np.random.beta(1, 2) = 0.012431361250291652
np.random.randint(1, 5, (2, 3)) = array([[3, 1, 3],
       [4, 4, 2]])
a = array([[1, 2, 4],
       [1, 1, 2],
       [3, 3, 3]])
a = array([[4, 2, 4],
       [1, 4, 2],
       [3, 3, 4]])
np.diag(a) = array([4, 4, 4])
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Решение систем линейных уравнений}
\label{\detokenize{book/linalg/ru/numpy:id6}}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Numpy}} позволяет решить систему линейных уравнений.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{a} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{9}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{b} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{solution} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linalg}\PYG{o}{.}\PYG{n}{solve}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{solution}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
[ 1.4 \PYGZhy{}1.2]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Обращение матриц}
\label{\detokenize{book/linalg/ru/numpy:id7}}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Numpy}} дает возможность выполнить операцию обращения матриц.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{a} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mf}{1.}\PYG{p}{,} \PYG{l+m+mf}{2.}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{3.}\PYG{p}{,} \PYG{l+m+mf}{4.}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{inv} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linalg}\PYG{o}{.}\PYG{n}{inv}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{inv}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
[[\PYGZhy{}2.   1. ]
 [ 1.5 \PYGZhy{}0.5]]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Собственные вектора и числа}
\label{\detokenize{book/linalg/ru/numpy:id8}}
\sphinxAtStartPar
Вычисление собственных векторов и чисел.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{linalg}\PYG{o}{.}\PYG{n}{eig}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{diag}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
(array([1., 2., 3.]), array([[1., 0., 0.],
       [0., 1., 0.],
       [0., 0., 1.]]))
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Мы вкратце рассмотрели}
\label{\detokenize{book/linalg/ru/numpy:id9}}\begin{itemize}
\item {} 
\sphinxAtStartPar
основы работы с \sphinxcode{\sphinxupquote{NumPy}};

\item {} 
\sphinxAtStartPar
индексацию в массивах;

\item {} 
\sphinxAtStartPar
broadcasting массивов \sphinxcode{\sphinxupquote{NumPy}};

\item {} 
\sphinxAtStartPar
операции с плавающей точкой;

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{NumPy}} и примитивы линейной алгебры.

\end{itemize}

\sphinxstepscope


\part{Основы машинного обучения}

\sphinxstepscope


\chapter{О блоке “Машинное обучение”}
\label{\detokenize{book/ml/ru/ml_intro:ml-intro}}\label{\detokenize{book/ml/ru/ml_intro:id1}}\label{\detokenize{book/ml/ru/ml_intro::doc}}
\sphinxAtStartPar
Этот блок рассказывает о том, что общего у разных задач машинного обучения и как из основных компонентов, подобно паззлу, складываются различные применения моделей машинного обучения. Основная наша  задача – чтоб у читателя даже не знакомого с машинным обучением возникло понимание того, как это все работает и как “сложить паззл” в новой задаче, будь то кластеризация новостей, детекция лиц на фотографиях или различные сложные применения вариационных квантовых схем, о которых пойдет речь далее в курсе.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=600\sphinxpxdimen]{{vqgan_clip_neural_network}.png}
\caption{Нейронные сети “глазами” других нейросетей – VQGAN и CLIP, сгенерировано в \sphinxhref{https://colab.research.google.com/drive/1L8oL-vLJXVcRzCFbPwOoMkPKJ8-aYdPN}{Google Colab}}\label{\detokenize{book/ml/ru/ml_intro:vqgan-clip-neural-network}}\end{figure}

\sphinxstepscope


\chapter{Машинное обучение как пазл}
\label{\detokenize{book/ml/ru/ml_l1:mll1}}\label{\detokenize{book/ml/ru/ml_l1:id1}}\label{\detokenize{book/ml/ru/ml_l1::doc}}
\sphinxAtStartPar
Автор(ы):
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/alexey-pronkin}{Кашницкий Юрий}

\end{itemize}


\section{Введение}
\label{\detokenize{book/ml/ru/ml_l1:id2}}
\sphinxAtStartPar
Мы продолжаем вводную часть нашего курса и переходим к машинному обучению. Если тема для вас хорошо знакома, можете пропустить этот блок, при желании можно пройти  \sphinxhref{https://ods.ai/tracks/qmlcourse/blocks/ee9f2a26-6234-4a72-84a6-a05de035bb1a}{этот тест}, для определения достаточности уровня знаний (там 5 вопросов по Python, 5 – по машинному обучению и столько же – по линейной алгебре). Тест можно проигнорировать, если вы не знакомы с машинным обучением и для вас выглядят магией такие вещи как автоматическая детекция лиц на фото или определение тональности отзыва на товар.

\sphinxAtStartPar
Про машинное обучение, конечно, уже много всего написано, есть и немало неплохих курсов, сочетающих как теорию, так и практику. Но все же теория в этой области еще не догоняет практику, мы пока не понимаем, “почему оно работает”, а гарантии обобщающей способности алгоритмов (т.е. гарантии того, что модель машинного обучения будет работать на новых данных) в теории даются только для очень простых моделей. Таким образом, работа со сложными моделями остается своего рода искусством с примесью математики, инженерии и просто следования хорошим практикам, выработанным, как правило, в корпорациях или академическом сообществе.

\sphinxAtStartPar
В этой лекции мы примем сторону практики и расскажем про задачи машинного обучения как некоторый пазл (или лего, кому что ближе) – меняя разные кусочки, мы будем получать разные прикладные задачи/сценарии/модели применения машинного обучения. Для иллюстрации такое описание мы сопроводим 3\sphinxhyphen{}мя примерами:
\begin{itemize}
\item {} 
\sphinxAtStartPar
задача рекомендации контента и градиентный бустинг

\item {} 
\sphinxAtStartPar
автоматическая оценка читаемости научной статьи и BERT

\item {} 
\sphinxAtStartPar
детекция симптомов COVID\sphinxhyphen{}19 на рентгенограммах и YOLO

\end{itemize}

\sphinxAtStartPar
В этой лекции мы не опишем подробно, что это за модели машинного обучения (градиентный бустинг, BERT, YOLO), но зато покажем, что сценарии их применения в разных задачах (анализ табличных данных, текстов, изображений) похожи.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Здесь мы почти не будем говорить о математике. Изложенный взгляд на машинное обучение как ремесло, вполне вероятно, вызовет критику со стороны специалистов в области статистики, эконометрики и теории машинного/статического обучения. Мы осознаем эти риски и тем не менее рассказываем о машинном обучении именно как о ремесле. Акцент в курсе делается на квантовые вычисления и квантовое машинное обучение, и в этой лекции мы опишем задачи “классического” машинного обучения на том уровне, чтоб просто было понятно, как это переносится на квантово\sphinxhyphen{}классические вариационные схемы и прочие алгоритмы, о которых пойдет речь далее в курсе. При этом строгость изложения материала тоже может немного пострадать.
\end{sphinxadmonition}


\section{Составляющие части задачи машинного обучения}
\label{\detokenize{book/ml/ru/ml_l1:id3}}
\sphinxAtStartPar
Выделим следующие компоненты (“пазлы”), которые просматриваются во многих разных задачах машинного обучения:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Целевой признак

\item {} 
\sphinxAtStartPar
Модель

\item {} 
\sphinxAtStartPar
Данные

\item {} 
\sphinxAtStartPar
Функция потерь

\item {} 
\sphinxAtStartPar
Решатель

\item {} 
\sphinxAtStartPar
Схема валидации и метрика качества

\end{itemize}

\sphinxAtStartPar
По ходу изложения будем обсуждать упомянутые примеры задач машинного обучения.


\subsection{Целевой признак}
\label{\detokenize{book/ml/ru/ml_l1:id4}}
\sphinxAtStartPar
Есть задачи, в которых машинное обучение не нужно, а достаточно экспертных знаний. По закону Ома, известно что напряжение пропорционально силе тока и электрическому сопротивлению, и вряд ли захочется предсказывать напряжение в сети каким\sphinxhyphen{}то другим образом, кроме как применением закона Ома. То же самое можно сказать про многие другие физические явления.

\sphinxAtStartPar
Однако, для очень многих явлений вокруг нет хорошего теоретического объяснения или достаточных экспертных знаний. У нас нет “формулы”, которая описала бы, как поставленный лайк к посту в соцсети, возврат кредита, клик по рекомендации товара или локализация заразы в конкретной части легких зависят от прочих факторов. В таких случаях мы можем приблизить такую неизвестную нам формулу с помощью машинного обучения.

\sphinxAtStartPar
В идеале с помощью машинного обучения мы хотели бы предсказывать какое\sphinxhyphen{}то событие, явление или процесс так, чтоб от этого была польза: прибыль компании/клиентов, если речь о бизнес\sphinxhyphen{}проекте, или новые знания, если это исследовательский проект. При этом напрямую это сделать вряд ли получится, и надо определить целевой признак, который, как мы считаем, будет связан с целевым событием/явлением. Звучит абстрактно, и дать строгое определение таких событий, явлений или процессов вряд ли получится. Поэтому сразу перейдем к примерам.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Перед этим только небольшое замечание, что потребовав наличие целевого признака, мы ограничилиcь рассмотрением задач обучения с учителем (\sphinxhref{https://en.wikipedia.org/wiki/Supervised\_learning}{supervised learning}). Это все еще включает очень большой перечень типов задач машинного обучения, но не все.
\end{sphinxadmonition}

\sphinxAtStartPar
\sphinxstylestrong{Пример 1. Рекомендация новостного контента}

\sphinxAtStartPar
Новостному порталу хочется понять, какой контент нравится пользователям и по каким ссылкам они будут кликать. Здесь \sphinxstyleemphasis{событием} будет то, что пользователю нравится рекомендуемый контент.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=600\sphinxpxdimen]{{see_also}.png}
\caption{Блок “Читайте также” на новостном портале}\label{\detokenize{book/ml/ru/ml_l1:see-also}}\end{figure}

\sphinxAtStartPar
Понятно, что нет возможности установить строгую зависимость такого события от прочих факторов. Поэтому мы определяем целевой признак: факт клика пользователя по показанной рекомендованной ссылке. Мы верим, что клик по ссылке связан с \sphinxstyleemphasis{событием}: если пользователю  нравится рекомендуемый контент, он/она перейдет по ссылке.

\sphinxAtStartPar
\sphinxstylestrong{Пример 2. Автоматическая оценка читаемости научной статьи}

\sphinxAtStartPar
Допустим, научному журналу хочется автоматически оценивать читаемость текста, чтобы знать, какие статьи можно сразу подавать на ревью, а какие лучше предварительно направить в сервис proofreading, где статья будет вычитана и поправлена носителем языка.

\sphinxAtStartPar
В идеале мы бы хотели предсказывать, “хорошо” ли написана статья или “плохо”. Но это очень сложно определить формально, и потому есть много метрик читаемости текста, таких как \sphinxhref{https://en.wikipedia.org/wiki/Automated\_readability\_index}{Automated readability index} или \sphinxhref{https://en.wikipedia.org/wiki/Flesch\%E2\%80\%93Kincaid\_readability\_tests\#Flesch\_reading\_ease}{Flesch reading ease}, которые являются эвристиками и “приближают” то что мы имеем в виду под “хорошо” или “плохо” написанным текстом. Кстати, на момент написания это лекции на платформе Kaggle проходит \sphinxhref{https://www.kaggle.com/c/commonlitreadabilityprize/overview}{соревнование} по этой теме.

\sphinxAtStartPar
Небольшое лирическое отступление: во многом опыт специалиста по машинному обучению сказывается в способности понять, когда это машинное обучение \sphinxstylestrong{не} требуется. Описанную задачу можно решить и без всякого машинного обучения. Можно замерить 5\sphinxhyphen{}10 метрик читаемости текста, разметить 100\sphinxhyphen{}200 статей вручную (желательно, чтоб это делали эксперты уровня редактора журнала, а еще и лучше бы иметь по 3 оценки на статью) и заключить, хорошо ли метрики читаемости коррелируют с оценками экспертов. Другой вариант – попытаться малой ценой использоваться готовые решения, например, Grammarly.

\sphinxAtStartPar
Но если этого окажется недостаточно, придется подумать. Пока остановимся тут и еще раз подчеркнем, что определить читаемость текста напрямую – невозможно, и мы это заменим на другой \sphinxstyleemphasis{Целевой признак}, например, на агрегированную метрику читаемости текста.

\sphinxAtStartPar
\sphinxstylestrong{Пример 3. Детекция симптомов COVID\sphinxhyphen{}19 на рентгенограммах}

\sphinxAtStartPar
Последние пару лет мы видели бурное развитие методов глубокого обучение в приложениях к анализу медицинских данных, а в особенности это стало актуальным в симптомов COVID\sphinxhyphen{}эпоху.

\sphinxAtStartPar
Допустим, стоит задача определения аномалий на рентгенограммах грудной клетки. В идеале мы хотели мы сразу по таким изображениям обнаруживать симптомы симптомов COVID\sphinxhyphen{}19 у пациента. Но заголовок этого примера выдает желаемое за действительное, и, конечно, сразу по снимкам диагностировать не получится.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=1000\sphinxpxdimen]{{covid_detection_ct}.png}
\caption{Пример данных \sphinxhref{https://www.kaggle.com/c/siim-COVID19-detection}{соревнования} по определению аномалий на рентгенограммах грудной клетки. \sphinxhref{https://www.kaggle.com/andradaolteanu/siim-COVID-19-box-detect-dcm-metadata}{Источник}}\label{\detokenize{book/ml/ru/ml_l1:covid-detection-ct}}\end{figure}

\sphinxAtStartPar
Поэтому в такой задаче надо аккуратно определить \sphinxstyleemphasis{Целевой признак}. В данном случае их несколько. Согласно \sphinxhref{https://www.kaggle.com/c/siim-covid19-detection/data}{описанию источника данных} соревнования, комитет врачей\sphinxhyphen{}радиологов проанализировал 6334 рентгенограмм и пометил их метками: ‘Negative for Pneumonia’ (нет пневмонии), ‘Typical Appearance’ (нормально), ‘Indeterminate Appearance’ (неразборчиво) и ‘Atypical Appearance’ (ненормально). Надо четко понимать, что возможности обученной модели будут ограничены имеющейся разметкой и поэтому заголовок “детекция симптомов COVID\sphinxhyphen{}19” слегка “желтоват”, в реальности модель детекции сможет выделять участок изображения (bounding box) и помечать это вектором из 4\sphinxhyphen{}х значений, соответствующих описанным целевым признакам в обучающей выборке.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=1000\sphinxpxdimen]{{covid_detection_prediction}.png}
\caption{Прогноз модели детекции, обученной на данных \sphinxhref{https://www.kaggle.com/c/siim-COVID19-detection}{соревнования} по определению аномалий на рентгенограммах грудной клетки. \sphinxhref{https://www.kaggle.com/yujiariyasu/catch-up-on-positive-samples-plot-submission-csv}{Источник}}\label{\detokenize{book/ml/ru/ml_l1:covid-detection-prediction}}\end{figure}


\subsection{Данные}
\label{\detokenize{book/ml/ru/ml_l1:id5}}
\sphinxAtStartPar
Определение \sphinxstyleemphasis{Целевого признака} неразрывно связано с имеющимися данными. Нет смысла определять целевой признак, который мы не можем измерить или по которому мы не можем собрать данные. Например, если новостной портал не логирует клики пользователей, нет смысла задавать вопрос о том, нравятся ли пользователям показанные рекомендации – для начала надо настроить сервисы для хранения кликов. Другой пример: вряд ли стоит пытаться предсказывать движения денежных активов в микросекундном диапазоне, если нет дорогостоящей инфраструктуры для сбора и обработки таких данных.

\sphinxAtStartPar
Но \sphinxstyleemphasis{Данные} – это, конечно, не только \sphinxstyleemphasis{Целевой признак}. Но и просто \sphinxstyleemphasis{признаки}, также в эконометрике называемые предикторами или независимыми переменными. С помощью \sphinxstyleemphasis{признаков} как раз и получится предсказать \sphinxstyleemphasis{Целевой признак}, а хорошо или плохо – об этом чуть далее.

\sphinxAtStartPar
Продумывание, сбор, и обработка  \sphinxstyleemphasis{признаков} – один из наиболее творческих аспектов работы специалистов по машинному обучению. Эта работа может включать в себя общение с представителями предметной области или бизнеса, клиентами, чтение научных статей, применение и более технических приемов, таких как порождение признаков из других признаков (feature engineering) или использование моделей для получения признаков (например, признаки изображения, полученные предобученной искусственной нейросетью).

\sphinxAtStartPar
\sphinxstylestrong{Пример 1. Рекомендация новостного контента}

\sphinxAtStartPar
В этой задаче, как правило, хорошо работают данные о поведении пользователей, попросту – “клики”. Обычно алгоритмы рекомендации хорошо работают при обучении на больших объемах данных, и поэтому большая часть проекта посвящена настройка хранилища данных и обработке потоковых событий (показ рекомендации, клик по рекомендации).

\sphinxAtStartPar
Если есть возможность собрать какие\sphinxhyphen{}то признаки пользователей (пол, возраст, указанные интересы) или рекомендуемого контента (темы новостей, представление текста новости “эмбеддингами”), эту информацию можно добавить в модель.

\sphinxAtStartPar
При достаточно хорошей подготовке данных задачу можно решить и без машинного обучения. Довольно сильным прототипом (baseline\sphinxhyphen{}решением), опять же, при достаточных объемах данных, моет быть просто сортировка контента по Click\sphinxhyphen{}through\sphinxhyphen{}Rate (CTR). Для каждой новости мы просто собираем статистику, сколько раз она была показана пользователю в качестве рекомендации и сколько раз по ней в итоге кликнули. Отношение кликов к показам и есть Click\sphinxhyphen{}through\sphinxhyphen{}Rate. Есть, конечно, детали – что делать с “холодными” новостями, без накопленной статистики для расчета CTR, что делать с clickbait\sphinxhyphen{}новостями, как фильтровать то, что нельзя показывать в качестве рекомендации. Но после решения этих проблем может оказаться, что просто сортировка по CTR – уже неплохое решение.

\sphinxAtStartPar
\sphinxstylestrong{Пример 2. Автоматическая оценка читаемости научной статьи}

\sphinxAtStartPar
Допустим, научному журналу удалось договориться с сервисом proofreading и получить данные о том, какие статьи хорошо написаны и не требуют множества правок, а какие пришлось переписывать почти что с нуля. Эту информацию можно пытаться использовать для обучения модели, которая для заданного куска текста будет предсказывать, как сильно его нужно поправить.

\sphinxAtStartPar
Тут мы будем иметь дело с задачей из области NLP (Natural Language Processing) – на входе будет просто текст (полный текст статьи или разбитый на параграфы) и по сути мы можем не придумывать \sphinxstyleemphasis{признаки} вручную, а модель сама их извлечет, то есть выучит представление текста. \sphinxstyleemphasis{Целевым признаком} при этом будет, например, какое\sphinxhyphen{}либо расстояние (скажем, Левенштейна) между оригинальным текстом и поправленным редактором. Таким образом, это будет задачей регрессии, в которой для текста предсказывается, как сильно его следует изменить.

\sphinxAtStartPar
Опять стоит отметить, что в такой задаче скорее всего нужно много  обучающих данных, чтобы описанный алгоритм хорошо заработал.

\sphinxAtStartPar
И еще стоит отметить, что задачи NLP зачастую пересекаются с лингвистикой, и это как раз такой пример. Вполне вероятно, что задачу можно решить без тоже машинного обучения и по\sphinxhyphen{}другому – на основе правил\sphinxhyphen{}эвристик, разработанных в сотрудничестве с лингвистами. Эдакая версия Grammarly для работы с научными текстами.

\sphinxAtStartPar
Но дальше в примере будем считать, что лингвистов в команде нет, простые метрики читаемости текста, описанные выше, работают плохо, и мы решаем задачу регрессии, то есть используем машинное обучение.

\sphinxAtStartPar
\sphinxstylestrong{Пример 3. Детекция симптомов COVID\sphinxhyphen{}19 на рентгенограммах}

\sphinxAtStartPar
В этой задаче ключевые данные для обучения модели – это собственно изображение, рентгенограмма области грудной клетки и разметка, которая состоит из координат интересующей области изображения и типа области, в данном случае это одна из 4\sphinxhyphen{}х меток: ‘Negative for Pneumonia’ (нет пневмонии), ‘Typical Appearance’ (нормально), ‘Indeterminate Appearance’ (неразборчиво) и ‘Atypical Appearance’ (ненормально).

\sphinxAtStartPar
Конечно, у снимков есть разные метаданные, да и форматы медицинских данных обычно специфические, но нам для примера подойдет такое упрощение.


\subsection{Модель}
\label{\detokenize{book/ml/ru/ml_l1:id6}}
\sphinxAtStartPar
С моделированием знаком любой исследователь. Чтоб рассчитать минимальную толщину стекла вагона метро для защиты от птиц во время движения по открытым участкам, достаточно представить птицу цилиндром той же массы, и для данной задачи цилиндр будет подходящей моделью птицы.

\sphinxAtStartPar
Подобным же образом, в задачах машинного обучения с учителем \sphinxstyleemphasis{Модель} приближает \sphinxstyleemphasis{Целевой признак} и делает это с помощью \sphinxstyleemphasis{Данных} и \sphinxstyleemphasis{Параметров}. (Параметры – это неотъемлемая часть модели, и поэтому мы их не выносим как отдельный компонент задач машинного обучения).

\sphinxAtStartPar
Надо понимать, что предлагая модель, мы совершаем уже второе упрощение. Сначала, как мы говорили, \sphinxstyleemphasis{Целевой признак} заменяет нам то, что мы реально хотим знать. А теперь, к тому же, мы заменяем целевой признак на его прогноз с помощью модели.

\sphinxAtStartPar
\sphinxstylestrong{Пример 1. Рекомендация новостного контента}

\sphinxAtStartPar
В задачах рекомендации есть классический алгоритм ALS (Alternative Least Squares), но можно задачу решить и как задачу ранжирования. Это может быть предпочтительно, поскольку можно использовать боевую лошадку машинного обучения на табличных данных – градиентный бустинг (доступно, на русском про эту модель написано \sphinxhref{https://habr.com/ru/company/ods/blog/327250/}{тут на Хабре} в рамках курса \sphinxhref{https://mlcourse.ai}{mlcourse.ai}).  Бустинг подходит для задач классификации, регрессии и ранжирования, и его можно использовать также и в описанной задаче.

\sphinxAtStartPar
Также, если бустинг уже используется в компании в других задачах, скорее всего получится безболезненно переиспользовать опыт поддержки модели и соответствующей инфраструктуры в “продакшене” вместо того, чтобы отдельно все это разрабатывать для ALS.

\sphinxAtStartPar
\sphinxstylestrong{Пример 2. Автоматическая оценка читаемости научной статьи}

\sphinxAtStartPar
Описанную задачу, опять же с оговорками про возможность альтернативного подхода без всякого машинного обучения, скорее всего хочется решать с помощью языковых моделей, основанных на трансформерах. В частности, в этой задаче имеет смысл использовать \sphinxhref{https://github.com/allenai/scibert}{SciBERT}, предобученный как раз на научных текстах. Это модель типа BERT (Bidirectional Encoder Representations from Transformers, \sphinxhref{https://arxiv.org/abs/1810.04805}{arXiv}), которая основана на архитектуре трансформеров, ставшей настоящей революцией в NLP (оригинальная статья – \sphinxhref{https://papers.nips.cc/paper/2017/file/3f5ee243547dee91fbd053c1c4a845aa-Paper.pdf}{Attention is all you need}, NIPS 2017). BERT используется для представления текста на основе трансформеров и дообучения параметров под многие стандартные задачи NLP – классификация текстов, пар текстов, вопросно\sphinxhyphen{}ответные системы, распознавание именованных сущностей и т.д. Подробнее про BERT можно почитать в \sphinxhref{https://jalammar.github.io/}{постах Jay Alammar} (англ.) или в их переводах на русский: \sphinxhref{https://habr.com/ru/post/486358/}{“Transformer в картинках”} и \sphinxhref{https://habr.com/ru/post/498144/}{“Ваш первый BERT: иллюстрированное руководство”}.

\sphinxAtStartPar
\sphinxstylestrong{Пример 3. Детекция симптомов COVID\sphinxhyphen{}19 на рентгенограммах}

\sphinxAtStartPar
Подходов к детекции объектов на изображениях немало, но по соотношению скорости и качества работы особенно хорошо себя зарекомендовала модель \sphinxhref{https://github.com/ultralytics/yolov5}{YOLOv5}. Про принцип работы этой модели можно узнать из лекции \sphinxhref{https://www.youtube.com/watch?v=nDPWywWRIRo}{“Detection and segmentation”} курса cs231n, также на Хабре можно найти \sphinxhref{https://habr.com/ru/post/503200/}{статью} про YOLOv4.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=800\sphinxpxdimen]{{detection_yolo}.jpeg}
\caption{Пример обнаружения объектов на изображении. \sphinxhref{https://habr.com/ru/post/503200/}{Источник}}\label{\detokenize{book/ml/ru/ml_l1:detection-yolo}}\end{figure}


\subsection{Функция потерь}
\label{\detokenize{book/ml/ru/ml_l1:id7}}
\sphinxAtStartPar
Выбор функции потерь (loss function) зависит от конкретной задачи, и это вопрос, изучаемый в курсах машинного обучения. Функция потерь определена для объектов обучающей выборки и по сути говорит, насколько прогноз хорошо соответствует значению целевого признака.

\sphinxAtStartPar
Тут тонкий момент: примерно для того же нужны метрики качества, о которых речь пойдет ниже. Но функция потерь на практике чаще всего используется именно для того, чтоб задать цель обучения модели (для чего именно ей менять свои параметры) и также оценить, насколько хорошо модель обучилась, попросту, насколько хорошо она “сошлась”.

\sphinxAtStartPar
В отличие от метрик качества, функции потерь вполне могут быть плохо интерпретируемыми, например как логистическая функция потерь (logloss, на русском про нее можно прочитать в \sphinxhref{https://dyakonov.org/2018/03/12/\%D0\%BB\%D0\%BE\%D0\%B3\%D0\%B8\%D1\%81\%D1\%82\%D0\%B8\%D1\%87\%D0\%B5\%D1\%81\%D0\%BA\%D0\%B0\%D1\%8F-\%D1\%84\%D1\%83\%D0\%BD\%D0\%BA\%D1\%86\%D0\%B8\%D1\%8F-\%D0\%BE\%D1\%88\%D0\%B8\%D0\%B1\%D0\%BA\%D0\%B8/}{посте} А.Г. Дьяконова), и на практике при разработке модели Data Scientist посмотрит на значение функции потерь всего несколько раз:
\begin{itemize}
\item {} 
\sphinxAtStartPar
при отладке модели стоит проверить, может ли она “переобучиться под мини\sphinxhyphen{}батч”, то есть может ли она при обучении всего с парой десятком примеров добиться почти нулевого значения функции потерь. Это важно, чтоб понять, нет ли где\sphinxhyphen{}то ошибки в коде описания модели и хватает ли модели сложности (capacity), чтобы подстроиться под данные

\item {} 
\sphinxAtStartPar
чтобы избежать переобучения, стоит проверять (вручную или автоматически) значение функции потерь на отложенной выборке

\item {} 
\sphinxAtStartPar
еще значения функции потерь можно сравнивать для разных версий модели, чтоб понять, какая из них лучше обучилась

\end{itemize}

\sphinxAtStartPar
Заметим, что дизайн функции потерь под задачу, как и придумывание признаков – порой интересный творческий процесс, а итоговая функции потерь, используемая для обучения модели может быть сложной, состоящей из нескольких более простых функций потерь.

\sphinxAtStartPar
Для примера, в задаче переноса стиля (style transfer), в классическом варианте задаются два изображения – “контентное” и “стилевое” – и генерируется третье изображение, которое похоже в целом на “контентное” изображение, но по стилю – на “стилевое”. При этом функция потерь складывается из двух других:
\begin{itemize}
\item {} 
\sphinxAtStartPar
одна – content loss – передает, насколько отличаются карты признаков (feature maps) генерируемого и “контентного” изображений

\item {} 
\sphinxAtStartPar
вторая – style loss – соответственно передает, насколько похожи стили генерируемого и “стилевого” изображений. Делается это хитро, и за деталями лучше обратиться, например, к \sphinxhref{https://www.youtube.com/watch?v=6wcs6szJWMY}{лекции “Visualizing and Understanding”} стэнфордского курса cs231n.

\end{itemize}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=800\sphinxpxdimen]{{example_styletransfer}.png}
\caption{Пример решения задачи Neural Style Transfer из \sphinxhref{https://cs231n.github.io/assignments2020/assignment3/}{задания 3} стэнфордского курса cs231n.}\label{\detokenize{book/ml/ru/ml_l1:example-styletransfer-png}}\end{figure}

\sphinxAtStartPar
Функция потерь может включать и много составляющих, больше двух, если мы хотим чтоб модель выучила разные аспекты задачи. К примеру, в \sphinxhref{https://habr.com/ru/post/562064/}{этой статье на Хабре} (уровень \sphinxhyphen{} продвинутый NLP) Давид Дале описывает дистилляцию нескольких больших NLP моделей для получения маленькой версии русскоязычной модели BERT. Маленький BERT по сути “учится” у больших моделей RuBERT, LaBSE, USE и T5, а описание того, что маленькая модель должна уметь (предсказывать замаскированные токены по контексту, строить представления токенов подобно тому, как это делают большие модели, предсказывать правильный порядок токенов в предложении) – это и есть составление сложной функции потерь.

\sphinxAtStartPar
\sphinxstylestrong{Пример 1. Рекомендация новостного контента}

\sphinxAtStartPar
Задача свелась к задаче ранжирования на табличных данных, и тут можно использовать функцию потерь, которую можно оптимизировать с помощью градиентного бустинга (т.е. дифференцируемую, это важно), для задачи ранжирования. Например, \sphinxhref{https://www.microsoft.com/en-us/research/publication/from-ranknet-to-lambdarank-to-lambdamart-an-overview/}{LambdaMART}.

\sphinxAtStartPar
\sphinxstylestrong{Пример 2. Автоматическая оценка читаемости научной статьи}

\sphinxAtStartPar
Тут задача свелась к задаче регрессии с текстовым входными данными, и можно использовать простую функцию потерь – среднеквадратичную ошибку (Mean Squared Error). Подробнее о функциях потерь в задаче регрессии можно прочитать в \sphinxhref{https://dyakonov.org/2018/10/23/\%D1\%84\%D1\%83\%D0\%BD\%D0\%BA\%D1\%86\%D0\%B8\%D0\%B8-\%D0\%BE\%D1\%88\%D0\%B8\%D0\%B1\%D0\%BE\%D0\%BA-\%D0\%B2-\%D0\%B7\%D0\%B0\%D0\%B4\%D0\%B0\%D1\%87\%D0\%B0\%D1\%85-\%D1\%80\%D0\%B5\%D0\%B3\%D1\%80\%D0\%B5\%D1\%81\%D1\%81\%D0\%B8\%D0\%B8/}{посте} А.Г. Дьяконова.

\sphinxAtStartPar
\sphinxstylestrong{Пример 3. Детекция симптомов COVID\sphinxhyphen{}19 на рентгенограммах}

\sphinxAtStartPar
В задаче детекции объектов на изображениях, как правило, для каждого объекта модель выдает 4 числа – координаты окна (bounding box) и его длину и ширину, а также вектор с числами – оценки принадлежности данного региона к каждому из классов. Поэтому функция потерь, как правило, складывается из двух других:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Для сравнения предсказанного региона с реальным (согласно разметке в обучающей выборке) используется среднеквадратичная ошибка (Mean Squared Error).

\item {} 
\sphinxAtStartPar
Для сравнения вектора оценок принадлежности региона к каждому из классов с реальным (согласно разметке в обучающей выборке) используется стандартная для задачи классификации функция потерь – логистическая, (также известная под термином “кросс\sphinxhyphen{}энтропия”), которую мы упоминали выше.

\end{itemize}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=800\sphinxpxdimen]{{object_detection_loss}.png}
\caption{Слайд стэнфордского курса cs231n про функцию потерь в задаче детекции объектов. \sphinxhref{http://cs231n.stanford.edu/slides/2020/lecture\_12.pdf}{Источник}.}\label{\detokenize{book/ml/ru/ml_l1:object-detection-loss}}\end{figure}


\subsection{Решатель}
\label{\detokenize{book/ml/ru/ml_l1:id8}}
\sphinxAtStartPar
Когда мы определились с целевым признаком, обучающими данными, моделью и функцией потерь, мы наконец можем собственно обучать модель – то есть менять ее параметры так, чтобы все лучше и лучше предсказывать целевой признак, что меряется с помощью функции потерь.

\sphinxAtStartPar
Наиболее часто используемых вариантов два:
\begin{itemize}
\item {} 
\sphinxAtStartPar
явное решение (closed\sphinxhyphen{}form solution), в котором просто применится формула для получения оптимальных параметров модели. Тут \sphinxstyleemphasis{Решателем} будет фреймворк, вычисляющий эту явно выписанную формулу, т.е. скорее всего производящий матричные умножения –  например, \sphinxcode{\sphinxupquote{NumPy}}.

\item {} 
\sphinxAtStartPar
оптимизация параметров модели градиентными методами оптимизации. Тут \sphinxstyleemphasis{Решателем} будет алгоритм оптимизации и его конкретная реализация, например, в \sphinxcode{\sphinxupquote{PyTorch}}

\end{itemize}

\sphinxAtStartPar
Самый известный пример первого варианта – это явное решение задачи наименьших квадратов. Существует прямо конкретная формула, включающая в себя перемножение матриц и векторов и взятие обратной матрицы, и дающая оптимальный (по минимизации среднеквадратичной ошибки) вектор весов линейной модели при наличии, конечно, обучающей выборки.

\sphinxAtStartPar
Получилось, что эта лекция вводная, без математических выкладок, поэтому не будем здесь приводить формулы без контекста, детали можно найти в любом классическом учебнике по статистике или машинному обучению или вкратце \sphinxhref{https://habr.com/ru/company/ods/blog/322076/}{в этой статье} на Хабре в разделе “Линейная регрессия”.

\sphinxAtStartPar
Во всех трех примерах задач, которые мы попутно рассматриваем и которые сводятся к обучению градиентного бустинга, SciBERT и YOLO соответственно, нет явного решения, которое простой формулой выдало бы оптимальные параметры модели, поэтому параметры подбираются с помощью методов оптимизации. В примере с градиентным бустингом “под капотом” – алгоритм обучения деревьев решений, с ним можно познакомиться в \sphinxhref{https://habr.com/ru/company/ods/blog/322534/}{этой статье}. А в двух других примерах обучаются искусственные нейронные сети, и сегодня это делается как правило с помощью оптимизаторов, реализованных во фреймворках (PyTorch/TensorFlow/etc), причем аппаратная реализация, в которой работает \sphinxstyleemphasis{Решатель}, – это скорее видеокарта или TPU.

\sphinxAtStartPar
Ко второму из рассмотренных вариантов \sphinxstyleemphasis{Решателя} можно также отнести и автоматическое дифференцирование. Чтобы оптимизировать параметры модели градиентными методами, нужно знать собственно градиенты функции потерь – вектора частных производных функции потерь по параметрам. Попросту говоря, это ответ на вопрос, какие параметры модели стоит изменять и как это скажется на функции потерь, которую мы хотим минимизировать.

\sphinxAtStartPar
Иногда такие градиенты функции потерь можно найти аналитически, например, в случае линейной или логистической регрессии. Но как правило, в случае более сложных моделей с большим числом параметров аналитическое выражение для градиента функции потерь выглядит слишком громоздко, лучше вычислять его численно. Это задача методов автоматического дифференцирования. В частности, возможно, величайший алгоритм машинного обучения всех времен \sphinxhyphen{} алгоритм обратного распространения ошибки (backpropagation) – не что иное как численный метод нахождения производных функции потерь по параметрам модели.


\subsection{Схема валидации и метрика качества}
\label{\detokenize{book/ml/ru/ml_l1:id9}}
\sphinxAtStartPar
Наконец, когда мы определились с целевым признаком, обучающими данными, моделью, функцией потерь, а также научились подбирать параметры модели так, чтоб функция потерь уменьшалась, остался последний шаг – решить, как мы действительно поймем, что решаем задачу хорошо.

\sphinxAtStartPar
Выбор метрики качества напрямую связан с тем, чего мы хотим от модели машинного обучения в более широком контексте. Например, в бизнес\sphinxhyphen{}процессе могут быть ключевые показатели, которые мы \sphinxstyleemphasis{опосредованно} можем улучшать с помощью машинного обучения. Ключевыми показателями могут быть такие вещи как дневная аудитория приложения, Life\sphinxhyphen{}Time Value, показатели, связанные с удержанием (retention) клиентов/сотрудников, удовлетворенность клиентов и т.д. Многие из этих показателей нельзя замерять напрямую и оптимизировать, и тогда искусство Data Scientist\sphinxhyphen{}а заключается в том, чтобы выбрать простую метрику качества, которая бы задавалась понятной формулой (например, доля верных ответов или полнота) и при этом неплохо “коррелировала” с тем показателем бизнес\sphinxhyphen{}процесса, который хочется оптимизировать и таким образом приносить деньги компании или уменьшать операционные расходы.

\sphinxAtStartPar
Определение схемы валидации нужно, чтобы ответить на следующие вопросы:
\begin{itemize}
\item {} 
\sphinxAtStartPar
как понять, что модель сработает неплохо на новых, ранее не виденных данных

\item {} 
\sphinxAtStartPar
как понять, что мы улучшили решение, поменяв модель, ее гиперпараметры или добавив новые признаки

\item {} 
\sphinxAtStartPar
как понять, что одна модель лучше другой модели, один набор признаков лучше другого при фиксированной модели и т.д.

\end{itemize}

\sphinxAtStartPar
Во многом это связано с переобучением. Недостаточно просто замерить метрику качества на обучающей выборке. Надо хотя бы разбить выборку на 2 части: на одной обучать модель, на второй – проверить метрику качества. И чаще всего при больших объемах данных и больших моделях ровно так и делают. Но в мире “малых данных” и легковесных моделей более предпочтительна кросс\sphinxhyphen{}валидация. В этой схеме выборка делится на несколько частей, а модель обучается столько же раз. При этом каждая из подвыборок один раз является тестовой частью, на которой измеряется качество прогнозов, а все остальные разы она участвует в обучении модели. Таким образом, кросс\sphinxhyphen{}валидация дает более надежную оценку того, как модель сработает на новых данных, в сравнении с простым разбиением обучающей выборки на две части.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=600\sphinxpxdimen]{{k_fold_cross_validation}.png}
\caption{Схема K\sphinxhyphen{}fold кросс\sphinxhyphen{}валидации.}\label{\detokenize{book/ml/ru/ml_l1:k-fold-cross-validation-png}}\end{figure}

\sphinxAtStartPar
Вы вряд ли ошибетесь, если на практике будете применять 5\sphinxhyphen{}кратную стратифицированную (такую что распределение целевого признака примерно одинаковое в каждой подвыборке) кросс\sphinxhyphen{}валидацию, но надо понимать, что кросс\sphinxhyphen{}валидация – не панацея. И схема валидации, которую мы тут описываем, – это больше, чем просто кросс\sphinxhyphen{}валидация.

\sphinxAtStartPar
Часто выделяют “офлайн” и “онлайн” режимы валидации. И метрики, полученные на кросс\sphinxhyphen{}валидации относятся к первому режиму, “офлайн”. То есть мы один раз собрали обучающие данные, они больше не меняются, и вот с таким статическим срезом данных мы работаем, создаем признаки, обучаем модели, измеряем значения метрик на кросс\sphinxhyphen{}валидации. Но это не отвечает на вопрос, что получится, когда мы “выкатим модель в прод”, какие значения метрик ожидать на новых данных. И тут, как правило, устраиваются A/B\sphinxhyphen{}тесты, которые позволяют понять, а действительно ли мы видим эффект от модели, лучше ли вообще с моделью, чем без нее, а если лучше с моделью, то какую модель выбрать. A/B\sphinxhyphen{}тестирование – это очень обширная тема, выходящая за рамки данной статьи, и развивать ее тут мы не будем. Только отметим, что определение схемы валидации – зачастую нетривиальный процесс и в зависимости от проекта может быть методологически сложным, в том числе и приводить к ошибкам.

\sphinxAtStartPar
Также заметим, что AutoML, о котором столь многие мечтают, решает некоторые вопросы, но далеко не все. В частности, алгоритмы AutoML не подберут вам правильную схему валидации. Они работают с уже имеющейся схемой валидации, и если валидация неверна, приводит к ошибкам, то тут и AutoML не поможет. Так что Data\sphinxhyphen{}Scientist\sphinxhyphen{}ов AutoML пока не вытеснит.

\sphinxAtStartPar
\sphinxstylestrong{Пример 1. Рекомендация новостного контента}

\sphinxAtStartPar
В этой задаче для выбора модели и ее гиперпараметров можно использовать обычную кросс\sphinxhyphen{}валидацию, но вот чтоб убедиться, что “в бою” модель также работает, лучше настроить A/B\sphinxhyphen{}тест (а точнее, для задач ранжирования намного лучше использовать \sphinxhref{https://sease.io/2020/05/online-testing-for-learning-to-rank-interleaving.html}{интерливинг}).  Пришло время сказать, что этот пример взят из практики автора этой лекции, Юрия Кашницкого, и в \sphinxhref{https://www.youtube.com/watch?v=uK4hPD12YmI}{выступлении на DataFest 2018} описывались сложности валидации модели в задаче рекомендации новостей. Вывод такой, что в задачах рекомендации (да и во многих других) надо устроить онлайн\sphinxhyphen{}проверку модели (A/B\sphinxhyphen{}тест, интерливинг) помимо офлайн\sphinxhyphen{}проверки (кросс\sphinxhyphen{}валидации), только таким образом можно удостовериться, что модель действительно полезна, например, что использовать модель – лучше, чем просто показывать самый популярный контент.

\sphinxAtStartPar
\sphinxstylestrong{Пример 2. Автоматическая оценка читаемости научной статьи}

\sphinxAtStartPar
Здесь тоже может использоваться обычная кросс\sphinxhyphen{}валидация, хотя на практике из\sphinxhyphen{}за объемов данных и размера модели кросс\sphinxhyphen{}валидацию проводить будет дороговато и придется удовлетвориться разбиением обучающей выборки на две части и проверкой модели на отложенной части.

\sphinxAtStartPar
Есть, конечно, детали. BERT не очень хорошо работает с длинными текстами, так что скорее всего мы разобьем полный текст статьи на параграфы и будем их подавать в модель по очереди. В таком случае лучше проводить \sphinxhref{https://scikit-learn.org/stable/modules/generated/sklearn.model\_selection.GroupKFold.html}{GroupKFold кросс\sphinxhyphen{}валидацию} так, чтобы на каждом этапе кросс\sphinxhyphen{}валидации в обучающей и проверочной выборке были параграфы из разных статей. Мы вряд ли хотим обучаться на одной половине статьи и проверять модель на второй ее половине – так бы мы получили слишком оптимистичную оценку качества модели.

\sphinxAtStartPar
Но даже при оговоренных тонкостях кросс\sphinxhyphen{}валидации самая большая сложность данной задачи – убедиться, что метрика качества соответствует тому, что мы реально хотим получить в задаче. Это связано со сложностью определения “хорошо” и “плохо” написанного научного текста, о которой мы говорили выше. Поэтому в данной задаче, как и во многих других практических задачах машинного обучения, не обойтись без проверки результатов модели вручную. Такая проверка модели будет делаться уже после кросс\sphinxhyphen{}валидации, и в этом смысле она похожа на онлайн\sphinxhyphen{}оценку модели.

\sphinxAtStartPar
\sphinxstylestrong{Пример 3. Детекция симптомов COVID\sphinxhyphen{}19 на рентгенограммах}

\sphinxAtStartPar
Здесь схема проверки модели очень похожа на предыдущую. Сначала кросс\sphinxhyphen{}валидация или проверка модели на отложенной части, а потом – проверка предсказаний модели экспертами. Конечно, никто не будет по одной только кросс\sphinxhyphen{}валидации или результатам участников в соревновании Kaggle заключать, что модель прекрасно работает и ее можно нести врачам. В данном случае надо проверить модель на данных, приближенных к тем, которые будут использоваться врачами на практике. Чтобы не было \sphinxhref{https://www.technologyreview.com/2020/04/27/1000658/google-medical-ai-accurate-lab-real-life-clinic-covid-diabetes-retina-disease/}{таких историй}, как у Google Health, когда Deep Learning модель достигала 90\% верных ответов при определении диабетической ретинопатии по фото зрачка, но при обучении на качественных снимках высокого разрешения. А при работе с менее качественными снимками система просто слишком часто отказывалась выносить вердикт из\sphinxhyphen{}за того, что была недостаточно уверена в прогнозе.


\subsection{Заключение}
\label{\detokenize{book/ml/ru/ml_l1:id10}}
\sphinxAtStartPar
В этой лекции мы описали, из чего складывается постановка задачи машинного обучения и рассмотрели, как общие компоненты проглядываются в разных по своей природе задачах. При этом мы поговорили о моделях\sphinxhyphen{}рабочих лошадках в трех разных областях: градиентном бустинге для табличных данных, BERT для текстов и YOLO для детекции изображений.

\sphinxAtStartPar
Немного пожертвовав, возможно, строгостью определения таких понятий как целевой признак или решатель, мы, надеюсь, описали все “пазлы” достаточно абстрактно, чтоб сложилось общее представление о том, как машинное обучение применяется в разных задачах, а также какие подводные камни стоит ожидать при боевом применении машинного обучения. Надеемся, это позволит лучше осознать взаимосвязь разных компонентов в квантово\sphinxhyphen{}классических схемах обучения, о которых речь пойдет далее в курсе.

\sphinxstepscope


\part{Квантовые вычисления}

\sphinxstepscope


\chapter{О блоке “Квантовые вычисления”}
\label{\detokenize{book/qc/ru/qc_intro:qc-intro}}\label{\detokenize{book/qc/ru/qc_intro:id1}}\label{\detokenize{book/qc/ru/qc_intro::doc}}
\sphinxAtStartPar
Этот блок включает в себя:
\begin{itemize}
\item {} 
\sphinxAtStartPar
общий рассказ о том, что такое квантовый бит;

\item {} 
\sphinxAtStartPar
введение в основные квантовые гейты.

\end{itemize}

\sphinxAtStartPar
Продвинутые темы блока дополнительно рассказывают:
\begin{itemize}
\item {} 
\sphinxAtStartPar
о квантовой физике, на которой базируется концепция кубита;

\item {} 
\sphinxAtStartPar
о смешанных состояниях, операторе плотности и энтропии фон Неймана.

\end{itemize}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=600\sphinxpxdimen]{{vqgan_clip_quantum_mind}.png}
\caption{Квантовый разум “глазами” VQGAN и CLIP, сгенерировано в \sphinxhref{https://colab.research.google.com/drive/1L8oL-vLJXVcRzCFbPwOoMkPKJ8-aYdPN}{Google Colab}}\label{\detokenize{book/qc/ru/qc_intro:vqgan-clip-quantum-mind}}\end{figure}

\sphinxstepscope


\chapter{Квантовый бит}
\label{\detokenize{book/qc/ru/qubit:qubit}}\label{\detokenize{book/qc/ru/qubit:id1}}\label{\detokenize{book/qc/ru/qubit::doc}}
\sphinxAtStartPar
Автор(ы):
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/SemyonSinchenko}{Синченко Семен}

\end{itemize}


\section{Описание лекции}
\label{\detokenize{book/qc/ru/qubit:id2}}
\sphinxAtStartPar
Эта лекция расскажет:
\begin{itemize}
\item {} 
\sphinxAtStartPar
что такое кубит;

\item {} 
\sphinxAtStartPar
в чем разница между значением и состоянием;

\item {} 
\sphinxAtStartPar
что такое сфера Блоха;

\item {} 
\sphinxAtStartPar
какие можно делать операции над кубитами;

\item {} 
\sphinxAtStartPar
что такое измерение.

\end{itemize}


\section{Введение}
\label{\detokenize{book/qc/ru/qubit:id3}}
\sphinxAtStartPar
Это первая лекция основного блока нашего курса. Прежде чем мы начнем детально разбирать понятие кубита, давайте взглянем на общий пайплайн квантовых схем.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{diagram1}.png}
\caption{Схема любого квантового алгоритма}\label{\detokenize{book/qc/ru/qubit:qscheme}}\end{figure}

\sphinxAtStartPar
Любая квантовая схема включает в себя:
\begin{itemize}
\item {} 
\sphinxAtStartPar
кубиты, инициализируемые в начальное состояние, обычно \(\ket{0}\);

\item {} 
\sphinxAtStartPar
унитарные и обратимые операции над кубитами;

\item {} 
\sphinxAtStartPar
измерение кубитов.

\end{itemize}

\sphinxAtStartPar
Эта лекция посвящена разбору операций для одного кубита. Начнем с понятия кубита и его отличий от бита классических компьютеров.


\section{Что такое кубит}
\label{\detokenize{book/qc/ru/qubit:id4}}
\sphinxAtStartPar
Классический компьютер оперирует двоичными числами – нулем и единицей. Минимальный объем информации для классического компьютера называется бит. Квантовый компьютер оперирует квантовыми битами или кубитами, которые тоже имеют два возможных значения – 0 и 1. Так в чем же разница? В чем особенности квантовых компьютеров, которые дают им преимущества над классическими компьютерами?

\sphinxAtStartPar
Разница в том, что для квантовомеханических систем (и кубитов в частности) их \sphinxstyleemphasis{состояния} и \sphinxstyleemphasis{значения} – это не одно и то же.


\section{Состояние vs значение}
\label{\detokenize{book/qc/ru/qubit:vs}}

\subsection{Состояние классического бита}
\label{\detokenize{book/qc/ru/qubit:id5}}
\sphinxAtStartPar
Обычно мы не отличаем состояние классического бита от его значения и считаем, что если бит имеет значение \sphinxstylestrong{1}, то и состояние его описывается числом \sphinxstylestrong{1}.


\subsection{Кот Шредингера}
\label{\detokenize{book/qc/ru/qubit:id6}}
\sphinxAtStartPar
Давайте вспомним мысленный эксперимента Шредингера. Кот, который одновременно и жив, и мертв. Понятно, что \sphinxstyleemphasis{значение} кота точно одно: он либо жив, либо мертв. Но \sphinxstyleemphasis{состояние} его более сложное. Он находится в \sphinxstyleemphasis{суперпозиции} состояний “жив” и “мертв” одновременно.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=600\sphinxpxdimen]{{Schrodingers_cat}.png}
\caption{Кот Шредингера}\label{\detokenize{book/qc/ru/qubit:schrodingers-cat}}\end{figure}


\subsection{Состояние кубита}
\label{\detokenize{book/qc/ru/qubit:id7}}
\sphinxAtStartPar
Состояние кубита, если можно так сказать, аналогично состоянию кота Шредингера. Оно отличается от \sphinxstyleemphasis{значения} кубита и описывается вектором из двух комплексных чисел. Мы будем обозначать состояния (или вектора) символом \(\ket{\Psi}\) (кет – вектор\sphinxhyphen{}столбец) – это широко принятая в квантовой механике и квантовых вычислениях нотация Дирака:
\begin{equation*}
\begin{split}
\ket{\Psi} = \begin{bmatrix}
c_0 \\
c_1
\end{bmatrix}
\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Может возникнуть вопрос, а почему комплексные числа? Короткий ответ на этот вопрос дать сложно. Если в двух словах, то использование комплексных чисел связано с удобством представления матричных групп, используемых в квантовой механике.

\sphinxAtStartPar
Все еще звучит сложно? Тогда нужно вспомнить, что изначально квантовая механика возникла в том числе из\sphinxhyphen{}за того, что физики экпериментально обнаружили у фундаментальных частиц свойство \sphinxcode{\sphinxupquote{корпускулярно\sphinxhyphen{}волнового дуализма}}. Иными словами, электроны, фотоны и другие частицы проявляли как типичные свойства волнового движения (например, интерференцию и дифракцию), и свойства частиц – например, всегда есть минимальная порция (\sphinxcode{\sphinxupquote{квант}}!) света или электрического поля. Кстати, часто вместо вектора состояния используется понятие \sphinxcode{\sphinxupquote{волновой функции}}, которая описывает плотность вероятности обнаружить частицу в той или иной точке пространства (обычного или специального). Ко времени создания квантовой механики для описания волнового движения ученые уже привыкли использовать комплескные числа, которые позволяют упростить описание многих эффектов за счет разделения амплитуды и фазы процесса. Такое удобство справедливо и для многих задач квантовой физики.

\sphinxAtStartPar
Для более детального ответа авторы курса рекомендуют читать книги по истории квантовой физики (и по самой квантовой физике).
\end{sphinxadmonition}

\sphinxAtStartPar
Значение чисел \(c_0\) и \(c_1\) мы обсудим чуть позже, а пока запишем наш кубит \(\ket{\Psi}\) в коде Python. Для начала \(c_0 = c_1 = \frac{1}{\sqrt{2}}\).

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{n}{qubit} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1} \PYG{o}{/} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{0}\PYG{n}{j}\PYG{p}{,} \PYG{l+m+mi}{1} \PYG{o}{/} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{0}\PYG{n}{j}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{reshape}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Здесь мы создаем именно вектор\sphinxhyphen{}столбец размерности \(2 \times 1\).
\begin{equation*}
\begin{split}
\ket{\Psi} = \begin{bmatrix}
\frac{1}{\sqrt{2}} \\
\frac{1}{\sqrt{2}}
\end{bmatrix}
\end{split}
\end{equation*}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{qubit}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
(2, 1)
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Связь состояния и значения кубита}
\label{\detokenize{book/qc/ru/qubit:id8}}
\sphinxAtStartPar
Разберем подробнее вектор \(\ket{\Psi}\) и значение цифр \(c_0, c_1\). Посмотрим на состояния кубита, значение которого мы знаем точно. То есть “посмотрим на кота Шредингера”, но который точно жив или точно мертв.


\subsubsection{Базисные состояния}
\label{\detokenize{book/qc/ru/qubit:id9}}
\sphinxAtStartPar
Посмотрим, как выглядят состояния кубитов с точно определенными значениями:
\begin{equation*}
\begin{split}
\ket{0} = \begin{bmatrix}
1 \\ 0
\end{bmatrix} \text{\qquad}
\ket{1} = \begin{bmatrix}
0 \\ 1
\end{bmatrix}
\end{split}
\end{equation*}
\sphinxAtStartPar
Что мы можем сказать об этих состояниях? Как минимум следующее:
\begin{itemize}
\item {} 
\sphinxAtStartPar
они ортогональны (\(\ket{0} \perp \ket{1}\));

\item {} 
\sphinxAtStartPar
они имеют единичную норму;

\item {} 
\sphinxAtStartPar
они образуют базис.

\end{itemize}

\sphinxAtStartPar
Что это значит для нас? А то, что любое состояние \(\ket{\Psi}\) можно записать как линейную комбинацию векторов \(\ket{0}\) и \(\ket{1}\), причем коэффициентами в этой комбинации будут как раз \(c_0, c_1\):

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{basis\PYGZus{}0} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1} \PYG{o}{+} \PYG{l+m+mi}{0}\PYG{n}{j}\PYG{p}{,} \PYG{l+m+mi}{0} \PYG{o}{+} \PYG{l+m+mi}{0}\PYG{n}{j}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{reshape}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{basis\PYGZus{}1} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0} \PYG{o}{+} \PYG{l+m+mi}{0}\PYG{n}{j}\PYG{p}{,} \PYG{l+m+mi}{1} \PYG{o}{+} \PYG{l+m+mi}{0}\PYG{n}{j}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{reshape}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{c0} \PYG{o}{=} \PYG{n}{c1} \PYG{o}{=} \PYG{l+m+mi}{1} \PYG{o}{/} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{allclose}\PYG{p}{(}\PYG{n}{qubit}\PYG{p}{,} \PYG{n}{c0} \PYG{o}{*} \PYG{n}{basis\PYGZus{}0} \PYG{o}{+} \PYG{n}{c1} \PYG{o}{*} \PYG{n}{basis\PYGZus{}1}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
True
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}\begin{equation*}
\begin{split}
\ket{\Psi} = \frac{1}{\sqrt{2}}
\begin{bmatrix}
1 \\
0
\end{bmatrix}
+
\frac{1}{\sqrt{2}}
\begin{bmatrix}
0 \\
1
\end{bmatrix}
=
\begin{bmatrix}
\frac{1}{\sqrt{2}} \\
\frac{1}{\sqrt{2}}
\end{bmatrix}
\end{split}
\end{equation*}

\subsubsection{Амплитуды вероятностей}
\label{\detokenize{book/qc/ru/qubit:id10}}
\sphinxAtStartPar
Квантовая механика устроена таким интересным образом, что если мы будем измерять \sphinxstylestrong{значение} кубита, то вероятность каждого из вариантов будет пропорциональна соответствующему коэффициенту в разложении \sphinxstylestrong{состояния}. Но так как амплитуды – это в общем случае комплексные числа, а вероятности должны быть строго действительные, нужно домножить амплитуды на комплексно сопряженные значения. В случае наших значений \(c_0 = c_1 = \frac{1}{\sqrt{2}}\) получаем:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{p0} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{conj}\PYG{p}{(}\PYG{n}{c0}\PYG{p}{)} \PYG{o}{*} \PYG{n}{c0}
\PYG{n}{p1} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{conj}\PYG{p}{(}\PYG{n}{c1}\PYG{p}{)} \PYG{o}{*} \PYG{n}{c1}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{allclose}\PYG{p}{(}\PYG{n}{p0}\PYG{p}{,} \PYG{n}{p1}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{allclose}\PYG{p}{(}\PYG{n}{p0} \PYG{o}{+} \PYG{n}{p1}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
True
True
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Видим еще одну важную вещь: сумма вероятностей всех состояний должна быть равна 100\%. Это сразу приводит нас к тому, что состояния – это не любые комплексные вектора, а комплексные вектора с единичной нормой:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{allclose}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{conj}\PYG{p}{(}\PYG{n}{qubit}\PYG{p}{)}\PYG{o}{.}\PYG{n}{T} \PYG{o}{@} \PYG{n}{qubit}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
True
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}\begin{equation*}
\begin{split}
\begin{bmatrix}
\frac{1}{\sqrt{2}} & \frac{1}{\sqrt{2}}
\end{bmatrix}
\begin{bmatrix}
\frac{1}{\sqrt{2}} \\
\frac{1}{\sqrt{2}}
\end{bmatrix}
= 1.0
\end{split}
\end{equation*}
\sphinxAtStartPar
Мы будем очень часто пользоваться транспонированием и взятием комплексно сопряженного от векторов. В квантовой механике это имеет специальное обозначение \(\bra{\Psi} = {\Psi^T}^* = \Psi^\dagger\) (бра – вектор\sphinxhyphen{}строка). Тогда наше правило нормировки из \sphinxcode{\sphinxupquote{NumPy}} кода может быть записано в нотации Дирака так:
\begin{equation*}
\begin{split}
\braket{\Psi | \Psi} = 1
\end{split}
\end{equation*}

\section{Сфера Блоха}
\label{\detokenize{book/qc/ru/qubit:id11}}
\sphinxAtStartPar
Описанный выше базис \(\ket{0}, \ket{1}\) не является единственно возможным. Вектора \(\ket{0}, \ket{1}\) – это лишь самый часто применимый базис, который называют \(\mathbf{Z}\) базисом. Но есть и другие варианты.


\subsection{Возможные базисы}
\label{\detokenize{book/qc/ru/qubit:id12}}

\subsubsection{Z\sphinxhyphen{}базис}
\label{\detokenize{book/qc/ru/qubit:z}}
\sphinxAtStartPar
Уже описанные нами \(\ket{0}\) и \(\ket{1}\).


\subsubsection{X\sphinxhyphen{}базис}
\label{\detokenize{book/qc/ru/qubit:x}}
\sphinxAtStartPar
Базисные состояния \(\ket{+} = \frac{\ket{0} + \ket{1}}{\sqrt{2}}\) и \(\ket{-} = \frac{\ket{0} - \ket{1}}{\sqrt{2}}\):

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{plus} \PYG{o}{=} \PYG{p}{(}\PYG{n}{basis\PYGZus{}0} \PYG{o}{+} \PYG{n}{basis\PYGZus{}1}\PYG{p}{)} \PYG{o}{/} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{minus} \PYG{o}{=} \PYG{p}{(}\PYG{n}{basis\PYGZus{}0} \PYG{o}{\PYGZhy{}} \PYG{n}{basis\PYGZus{}1}\PYG{p}{)} \PYG{o}{/} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\subsubsection{Y\sphinxhyphen{}базис}
\label{\detokenize{book/qc/ru/qubit:y}}
\sphinxAtStartPar
Базисные состояния \(\ket{R} = \frac{\ket{0} + i\ket{1}}{\sqrt{2}}\) и \(\ket{L} = \frac{\ket{0} - i\ket{1}}{\sqrt{2}}\):

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{R} \PYG{o}{=} \PYG{p}{(}\PYG{n}{basis\PYGZus{}0} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{n}{j} \PYG{o}{*} \PYG{n}{basis\PYGZus{}1}\PYG{p}{)} \PYG{o}{/} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{L} \PYG{o}{=} \PYG{p}{(}\PYG{n}{basis\PYGZus{}0} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{n}{j} \PYG{o}{*} \PYG{n}{basis\PYGZus{}1}\PYG{p}{)} \PYG{o}{/} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Легко убедиться, что все вектора каждого из этих базисов ортогональны:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{allclose}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{conj}\PYG{p}{(}\PYG{n}{basis\PYGZus{}0}\PYG{p}{)}\PYG{o}{.}\PYG{n}{T} \PYG{o}{@} \PYG{n}{basis\PYGZus{}1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
True
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}\begin{equation*}
\begin{split}
\begin{bmatrix}
1 & 0
\end{bmatrix}
\begin{bmatrix}
0 \\
1
\end{bmatrix}
= 0
\end{split}
\end{equation*}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{allclose}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{conj}\PYG{p}{(}\PYG{n}{plus}\PYG{p}{)}\PYG{o}{.}\PYG{n}{T} \PYG{o}{@} \PYG{n}{minus}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
True
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}\begin{equation*}
\begin{split}
\begin{bmatrix}
\frac{1}{\sqrt{2}} & \frac{1}{\sqrt{2}}
\end{bmatrix}
\begin{bmatrix}
\frac{1}{\sqrt{2}} \\
-\frac{1}{\sqrt{2}}
\end{bmatrix}
= 0
\end{split}
\end{equation*}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{allclose}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{conj}\PYG{p}{(}\PYG{n}{R}\PYG{p}{)}\PYG{o}{.}\PYG{n}{T} \PYG{o}{@} \PYG{n}{L}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
True
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}\begin{equation*}
\begin{split}
\begin{bmatrix}
\frac{1}{\sqrt{2}} & -i\frac{1}{\sqrt{2}}
\end{bmatrix}
\begin{bmatrix}
\frac{1}{\sqrt{2}} \\
-i\frac{1}{\sqrt{2}}
\end{bmatrix}
= 0
\end{split}
\end{equation*}
\sphinxAtStartPar
Заметьте, что в наших векторных пространствах скалярное произведение – это (в случае действительных векторов) \(\vec{a}\vec{b} = \left\langle a\middle| b\right\rangle\) (\sphinxhref{https://en.wikipedia.org/wiki/Bra\%E2\%80\%93ket\_notation}{бра\sphinxhyphen{}кет}). Именно поэтому нужно делать транспонирование и комплексное сопряжение первого вектора в паре.


\subsection{Сфера Блоха}
\label{\detokenize{book/qc/ru/qubit:id13}}
\sphinxAtStartPar
Обозначения \(\ket{0}, \ket{1}, \ket{+}, \ket{-}, \ket{R}, \ket{L}\) выбраны неслучайно: они имеют геометрический смысл.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{Blochsphere}.png}
\caption{Сфера Блоха}\label{\detokenize{book/qc/ru/qubit:blochcphere}}\end{figure}

\sphinxAtStartPar
Принято считать, что ось \(\mathbf{Z}\) – это основная ось, так как физически квантовые компьютеры измеряют именно по ней. Ось \(\mathbf{X}\) “смотрит на нас” и поэтому обозначается \(\ket{+}\) и \(\ket{-}\). А ось \(\mathbf{Y}\) направлена как бы вдоль, поэтому базис обозначают как “право” (\(\ket{R}\)) и “лево” (\(\ket{L}\)).

\sphinxAtStartPar
Вектор состояния кубита еще называют волновой функцией, и этот вектор может идти в любую точку сферы Блоха. Сама сфера имеет единичный радиус, и это гарантирует нам, что для всех состояний сумма квадратов амплитуд будет равна единице.


\subsubsection{Состояние в полярных координатах}
\label{\detokenize{book/qc/ru/qubit:id14}}
\sphinxAtStartPar
Состояние кубита можно выразить через полярные координаты на сфере Блоха:
\begin{equation*}
\begin{split}
\ket{\Psi} = c_0 \ket{0} + c_1 \ket{1} = \cos\theta\ket{0} + e^{i\phi}\sin\theta \ket{1},
\end{split}
\end{equation*}
\sphinxAtStartPar
где \(\theta,\phi\) – это угловые координаты на сфере Блоха. В этом смысле сфера Блоха очень удобна для представления состояний одного кубита.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Тут мы воспользовались формулой Эйлера, а также вынесли за скобки локальные фазы множителей \(c_0\) и \(c_1\). Если у вас возникают трудности с подобными операциями над комплексными числами, то рекомендуем еще раз пересмотреть базовый {\hyperref[\detokenize{book/linalg/ru/linalg_intro::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{блок}}}} нашего курса по линейной алгебре и комплексным числам, там эти моменты освещаются более подробно.
\end{sphinxadmonition}


\section{Что можно делать с таким кубитом?}
\label{\detokenize{book/qc/ru/qubit:id15}}

\subsection{Линейные операторы}
\label{\detokenize{book/qc/ru/qubit:id16}}
\sphinxAtStartPar
Любое действие, которое мы совершаем с кубитом в состоянии \(\ket{\Psi}\), должно переводить его в другое состояние \(\ket{\Phi}\). Что переводит один вектор в другой вектор в том же пространстве? Правильно, матрица. Другими словами, линейный оператор. Мы будем обозначать операторы как \(\hat{U}\).


\subsection{Унитарность}
\label{\detokenize{book/qc/ru/qubit:id17}}
\sphinxAtStartPar
Как мы уже говорили, квадраты амплитуд – это вероятности. Следовательно, волновая функция должна быть нормирована на единицу. А значит, любой оператор, который переводит одно состояние в другое \(\hat{U}\ket{\Psi} = \ket{\Phi}\), должен сохранять эту нормировку, то есть должен быть \sphinxhref{https://ru.wikipedia.org/wiki/\%D0\%A3\%D0\%BD\%D0\%B8\%D1\%82\%D0\%B0\%D1\%80\%D0\%BD\%D1\%8B\%D0\%B9\_\%D0\%BE\%D0\%BF\%D0\%B5\%D1\%80\%D0\%B0\%D1\%82\%D0\%BE\%D1\%80}{\sphinxstyleemphasis{унитарным}}. Более того, свойство унитарности приводит к тому, что любой квантовый оператор еще и сохраняет скалярное произведение:
\begin{equation*}
\begin{split}
\bra{\Psi}\hat{U}^\dagger\hat{U}\ket{\Psi} = \bra{\Psi}\ket{\Psi}
\end{split}
\end{equation*}
\sphinxAtStartPar
Другими словами, унитарный оператор удовлетворяет условию \(\hat{U}^\dagger \hat{U} = \hat{I}\).


\subsection{Обратимость}
\label{\detokenize{book/qc/ru/qubit:id18}}
\sphinxAtStartPar
Одно из важных следствий унитарности операций над кубитами – это их обратимость. Если вы сделали какую\sphinxhyphen{}то последовательность унитарных операций над кубитами \(\hat{U}\), то их можно вернуть в начальное состояние, ведь у унитарного оператора всегда есть обратный оператор \(\hat{U}^{-1} = \hat{U}^\dagger\).

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Квантовый компьютер должен уметь делать несколько не унитарных операций, например, инициализацию кубита в определенное состояние (например, \(\ket{0}\)) и считывание состояния кубитов. Такие неунитарные операции приводят к потере информации и являются необратимыми.
\end{sphinxadmonition}


\subsection{Пример оператора}
\label{\detokenize{book/qc/ru/qubit:id19}}
\sphinxAtStartPar
В дальнейших лекциях мы разберем много операторов, так как именно операторы (или квантовые \sphinxstylestrong{гейты}) являются основой квантовых вычислений. А пока рассмотрим простой пример: оператор Адамара (\sphinxstylestrong{Hadamard gate}), который переводит \(\ket{0} \to \ket{+}\).


\subsubsection{Гейт Адамара}
\label{\detokenize{book/qc/ru/qubit:id20}}
\sphinxAtStartPar
Начнем с того, что пока у нас лишь один кубит. Состояние одного кубита – это вектор размерности два. Значит, оператор, который переводит его в другой вектор размерности два – это матрица \(2\times 2\). Запишем оператор Адамара в матричном виде, а потом убедимся, что он унитарный и действительно переводит состояние \(\ket{0} \to \ket{+}\).
\begin{equation*}
\begin{split}
\hat{H} = \frac{1}{\sqrt{2}}\begin{bmatrix}
1 & 1 \\
1 & -1 \\
\end{bmatrix}
\end{split}
\end{equation*}

\paragraph{Реализация в Python}
\label{\detokenize{book/qc/ru/qubit:python}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{h} \PYG{o}{=} \PYG{l+m+mi}{1} \PYG{o}{/} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}
    \PYG{p}{[}\PYG{l+m+mi}{1} \PYG{o}{+} \PYG{l+m+mi}{0}\PYG{n}{j}\PYG{p}{,} \PYG{l+m+mi}{1} \PYG{o}{+} \PYG{l+m+mi}{0}\PYG{n}{j}\PYG{p}{]}\PYG{p}{,}
    \PYG{p}{[}\PYG{l+m+mi}{1} \PYG{o}{+} \PYG{l+m+mi}{0}\PYG{n}{j}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{n}{j} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\paragraph{Унитарность}
\label{\detokenize{book/qc/ru/qubit:id21}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{allclose}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{conj}\PYG{p}{(}\PYG{n}{h}\PYG{p}{)}\PYG{o}{.}\PYG{n}{T} \PYG{o}{@} \PYG{n}{h}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{eye}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
True
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}\begin{equation*}
\begin{split}
\frac{1}{\sqrt{2}}\begin{bmatrix}
1 & 1 \\
1 & -1 \\
\end{bmatrix}
\frac{1}{\sqrt{2}}\begin{bmatrix}
1 & 1 \\
1 & -1 \\
\end{bmatrix}
= \begin{bmatrix}
1 & 0 \\
0 & 1 \\
\end{bmatrix}
\end{split}
\end{equation*}

\paragraph{Проверка}
\label{\detokenize{book/qc/ru/qubit:id22}}
\sphinxAtStartPar
Проверим, что гейт Адамара действительно переводит кубит из состояния \(\ket{0}\) в состояние \(\ket{+}\).

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{allclose}\PYG{p}{(}\PYG{n}{h} \PYG{o}{@} \PYG{n}{basis\PYGZus{}0}\PYG{p}{,} \PYG{n}{plus}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
True
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}\begin{equation*}
\begin{split}
\frac{1}{\sqrt{2}}\begin{bmatrix}
1 & 1 \\
1 & -1 \\
\end{bmatrix}
\begin{bmatrix}
1 \\
0
\end{bmatrix}
=
\begin{bmatrix}
\frac{1}{\sqrt{2}} \\
\frac{1}{\sqrt{2}}
\end{bmatrix}
\end{split}
\end{equation*}

\section{Измерение}
\label{\detokenize{book/qc/ru/qubit:id23}}
\sphinxAtStartPar
\sphinxstylestrong{Измерение} в квантовых вычислениях выделяется отдельно именно потому, что оно “открывает” коробку с котом Шредингера: мы точно узнаем, жив он или мертв, и уже никогда не сможем это “забыть” обратно. Вся \sphinxstyleemphasis{суперпозиция} его состояния исчезает. То есть \sphinxstyleemphasis{измерение} – это как раз пример одной из не унитарных операций, которые должен уметь делать квантовый компьютер.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Это интересный факт: исчезновение суперпозиции многим кажется парадоксом, именно поэтому и появляются разные интерпретации квантовой механики, например, многомировая интерпретация Эверетта. Действительно, это кажется немного странным, что полностью обратимая квантовая механика и непрерывная динамика волновых функций вдруг “ломаются” и мы получаем такой коллапс, который еще называют редукцией фон Неймана. Доктору Эверетт тоже это не нравилось и он предложил другую интерпретацию этого процесса. Согласно его теории, когда мы производим измерения, мы как бы “расщепляем” нашу вселенную на две ниточки: в одной кот остается жив, а в другой остается мертв.

\sphinxAtStartPar
Такие теории остаются на уровне спекуляций, так как почти невозможно придумать эксперимент, который бы подтверждал или опровергал такую гипотезу. Скорее это вопрос личного понимания и интерпретации процесса, так как математически подобные теории в итоге дают один и тот же наблюдаемый и измеримый результат.


\end{sphinxadmonition}

\sphinxAtStartPar
Как мы уже говорили, состояние кубита может быть записано в разных базисах: \(\ket{0}, \ket{1}\), \(\ket{+}, \ket{-}\), \(\ket{R}, \ket{L}\). \sphinxstyleemphasis{Значение} кубита в каждом из этих базисов может быть измерено. Но что такое измерение с точки зрения математики?


\subsection{Операторы Паули}
\label{\detokenize{book/qc/ru/qubit:id24}}
\sphinxAtStartPar
На самом деле, любая наблюдаемая величина соответствует какому\sphinxhyphen{}то оператору. Например, измерения в разных базисах \(\mathbf{X}\), \(\mathbf{Y}\), \(\mathbf{Z}\) соответствуют операторам Паули:
\begin{equation*}
\begin{split}
\hat{\sigma}^x = \begin{bmatrix}
0 & 1\\
1 & 0
\end{bmatrix}
\qquad
\hat{\sigma}^y = \begin{bmatrix}
0 & -i\\
i & 0
\end{bmatrix}
\qquad
\hat{\sigma}^z = \begin{bmatrix}
1 & 0\\
0 & -1
\end{bmatrix}
\end{split}
\end{equation*}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pauli\PYGZus{}x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0} \PYG{o}{+} \PYG{l+m+mi}{0}\PYG{n}{j}\PYG{p}{,} \PYG{l+m+mi}{1} \PYG{o}{+} \PYG{l+m+mi}{0}\PYG{n}{j}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1} \PYG{o}{+} \PYG{l+m+mi}{0}\PYG{n}{j}\PYG{p}{,} \PYG{l+m+mi}{0} \PYG{o}{+} \PYG{l+m+mi}{0}\PYG{n}{j}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{pauli\PYGZus{}y} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0} \PYG{o}{+} \PYG{l+m+mi}{0}\PYG{n}{j}\PYG{p}{,} \PYG{l+m+mi}{0} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{n}{j}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{n}{j}\PYG{p}{,} \PYG{l+m+mi}{0} \PYG{o}{+} \PYG{l+m+mi}{0}\PYG{n}{j}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{pauli\PYGZus{}z} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1} \PYG{o}{+} \PYG{l+m+mi}{0}\PYG{n}{j}\PYG{p}{,} \PYG{l+m+mi}{0} \PYG{o}{+} \PYG{l+m+mi}{0}\PYG{n}{j}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0} \PYG{o}{+} \PYG{l+m+mi}{0}\PYG{n}{j}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{n}{j} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Эти операторы очень важны, рекомендуется знать их наизусть, так как они встречаются в каждой второй статье по квантовым вычислениям, а также постоянно фигурируют в документации всех основных библиотек для квантового машинного обучения.


\subsection{Собственные значения}
\label{\detokenize{book/qc/ru/qubit:id25}}
\sphinxAtStartPar
Мы поняли, что есть связь между нашими измерениями и операторами. Но какая именно? Что значит, например, что измерения по оси \(\mathbf{Z}\) соответствуют оператору \(\hat{\sigma}^z\)?

\sphinxAtStartPar
Здесь мы приходим к собственным значениям операторов. Оказывается (так устроен наш мир), что \sphinxstyleemphasis{измеряя} какую\sphinxhyphen{}то величину в квантовой механике, мы всегда будем получать одно из собственных значений соответствующего оператора, а состояние будет коллапсировать в соответствующий собственный вектор этого оператора. Другими словами, \sphinxstyleemphasis{измеряя} кота Шредингера, мы будем получать значения “жив” или “мертв”, а состояние кота будет переходить в состояние, соответствующее одному из этих значений. А еще \sphinxstyleemphasis{измерение} не является обратимой операцией: однажды открыв коробку с котом и поняв, жив он или мертв, мы уже не сможем закрыть ее обратно и вернуть кота в суперпозицию.

\sphinxAtStartPar
Описанное выше – не абстрактные рассуждения из квантовой физики. Оно пригодится, когда мы будем говорить о решении практических комбинаторных задач, таких как задача о выделении сообществ в графе.


\subsection{Собственные вектора \protect\(\hat{\sigma}^z\protect\)}
\label{\detokenize{book/qc/ru/qubit:hat-sigma-z}}
\sphinxAtStartPar
Вернемся к нашему оператору \(\hat{\sigma}^z\). Легко убедиться, что его собственные значения равны 1 и \sphinxhyphen{}1, а соответствующие им собственные вектора – это \(\begin{bmatrix}1 \\ 0\end{bmatrix}\) и \(\begin{bmatrix}0 \\ 1\end{bmatrix}\):

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{linalg}\PYG{o}{.}\PYG{n}{eig}\PYG{p}{(}\PYG{n}{pauli\PYGZus{}z}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
(array([ 1.+0.j, \PYGZhy{}1.+0.j]), array([[1.+0.j, 0.+0.j],
       [0.+0.j, 1.+0.j]]))
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Таким образом, измерение по оси \(\mathbf{Z}\) всегда будет давать нам одно из этих двух значений и переводить состояние кубита в соответствующий собственный вектор.

\begin{sphinxadmonition}{caution}{Caution:}
\sphinxAtStartPar
Зачастую кубиты измеряют именно в в \(\mathbf{Z}\)\sphinxhyphen{}базисе; является неким “стандартом” для квантовых вычислений, так как это измерение “ближе к железу”. Также \(\mathbf{Z}\)\sphinxhyphen{}базис удобен для нас из\sphinxhyphen{}за диагональности {\hyperref[\detokenize{book/glossary:term-23}]{\sphinxtermref{\DUrole{xref,std,std-term}{оператора Паули}}}} \(\sigma^z\).
\end{sphinxadmonition}


\subsection{Формальная запись}
\label{\detokenize{book/qc/ru/qubit:id26}}
\sphinxAtStartPar
Формально мы можем записать для любого \sphinxhref{https://en.wikipedia.org/wiki/Hermitian\_adjoint\#Hermitian\_operators}{эрмитова} оператора \(\hat{U}\), что собственные состояния этого оператора являются его собственными векторами, а собственные значения в этом случае являются наблюдаемыми значениями:
\begin{equation*}
\begin{split}
\hat{U}\ket{\Psi} = u\ket{\Psi}
\end{split}
\end{equation*}

\subsection{Другие операторы Паули}
\label{\detokenize{book/qc/ru/qubit:id27}}
\sphinxAtStartPar
Убедимся, что у остальных операторов собственные значения такие же:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{linalg}\PYG{o}{.}\PYG{n}{eig}\PYG{p}{(}\PYG{n}{pauli\PYGZus{}x}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{linalg}\PYG{o}{.}\PYG{n}{eig}\PYG{p}{(}\PYG{n}{pauli\PYGZus{}y}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
(array([ 1.+0.j, \PYGZhy{}1.+0.j]), array([[ 0.70710678\PYGZhy{}0.j,  0.70710678+0.j],
       [ 0.70710678+0.j, \PYGZhy{}0.70710678\PYGZhy{}0.j]]))
(array([ 1.+0.j, \PYGZhy{}1.+0.j]), array([[\PYGZhy{}0.        \PYGZhy{}0.70710678j,  0.70710678+0.j        ],
       [ 0.70710678+0.j        ,  0.        \PYGZhy{}0.70710678j]]))
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Заметим, что собственные вектора могут отличаться на какой\sphinxhyphen{}то множитель. В частности, один из собственных векторов оператора \(\hat{\sigma}^y\), возвращенный \sphinxcode{\sphinxupquote{np.linalg.eig}} равен \(\frac{1}{\sqrt{2}}  \begin{bmatrix} -i  \\ 1 \end{bmatrix}\), что отличается от \(\ket{R} = \frac{\ket{0} + i\ket{1}}{\sqrt{2}} = \frac{1}{\sqrt{2}}  \begin{bmatrix} 1  \\ i \end{bmatrix}\) только домножением на \(i\).

\sphinxAtStartPar
Во\sphinxhyphen{}первых, по курсу линейной алгебры мы знаем, что собственные вектора можно домножать на любую константу и они все равно останутся собственными, поскольку если вектор \(x^*\)– решение уравнения \(Ax^* = \lambda x^*\), то и любой вектор \(kx^*, k \in \mathbb{С}, k \neq 0\) также будет решением этого уравнения.

\sphinxAtStartPar
Во\sphinxhyphen{}вторых, состояния, отличающиеся только множителем, по сути соответствуют одному и тому же состоянию. Любой множитель \(c \in \mathbb{С}\), стоящий перед вектором состояния \(\ket{\Psi}\) можно представить в виде \(c = e^{i\phi}\), что соответствует повороту на некоторый угол \(\phi\). При вычислении амплитуды \({|\ket{\Psi}|} ^ 2\) этот множитель даст единицу, то есть, другими словами, поворот кубита никак не повлияет на результат измерения кубита. Это известно как \sphinxstyleemphasis{глобальная фаза}, и в научной литературе часто можно встретить фразу “up to a global phase factor”, что означает одинаковые состояния с точностью до поворота (примерно как произвольная константа, добавляемая к интегралу).
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Также можно заметить, что у всех операторов Паули нет ни одного общего собственного вектора. Таким образом, мы приходим к ситуации, когда не можем одновременно точно провести измерения двумя разными операторами, так как наше измерение должно переводить состояние в соответствующий собственный вектор. В квантовой механике это называется \sphinxstylestrong{принципом неопределенности}.
\end{sphinxadmonition}


\subsection{Ожидаемое значение при измерении}
\label{\detokenize{book/qc/ru/qubit:id28}}
\sphinxAtStartPar
Мы не будем писать с нуля полный симулятор кубитов, который включает измерения – это требует введения сложного случайного процесса. Но мы можем легко ответить на другой вопрос. А именно: можно ли сказать, какое будет \sphinxstyleemphasis{ожидаемое} значение оператора \(\hat{U}\) для состояния \(\Psi\)? Другими словами, какое будет математическое ожидание большого числа измерений? Это можно записать следующим образом:
\begin{equation*}
\begin{split}
\mathbf{E}(\hat{U}) = \bra{\Psi}\hat{U}\ket{\Psi}
\end{split}
\end{equation*}
\sphinxAtStartPar
Например, оператор \(\hat{\sigma}^z\) полностью не определен в состоянии \(\ket{+}\), то есть мы будем равновероятно получать значения \sphinxhyphen{}1 и 1, а математическое ожидание, соответственно, будет равно нулю:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{plus}\PYG{o}{.}\PYG{n}{conj}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{T} \PYG{o}{@} \PYG{n}{pauli\PYGZus{}z} \PYG{o}{@} \PYG{n}{plus}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
[[\PYGZhy{}2.23711432e\PYGZhy{}17+0.j]]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}\begin{equation*}
\begin{split}
\begin{bmatrix}
\frac{1}{\sqrt{2}} & \frac{1}{\sqrt{2}}
\end{bmatrix}
\begin{bmatrix}
1 & 0 \\
0 & -1 \\
\end{bmatrix}
\begin{bmatrix}
\frac{1}{\sqrt{2}} \\
\frac{1}{\sqrt{2}}
\end{bmatrix}
= 0
\end{split}
\end{equation*}
\sphinxAtStartPar
С другой стороны, измеряя состояние \(\ket{+}\) в \sphinxstyleemphasis{X}\sphinxhyphen{}базисе мы всегда будем получать 1:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{plus}\PYG{o}{.}\PYG{n}{conj}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{T} \PYG{o}{@} \PYG{n}{pauli\PYGZus{}x} \PYG{o}{@} \PYG{n}{plus}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
[[1.+0.j]]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}\begin{equation*}
\begin{split}
\begin{bmatrix}
\frac{1}{\sqrt{2}} & \frac{1}{\sqrt{2}}
\end{bmatrix}
\begin{bmatrix}
0 & 1 \\
1 & 0 \\
\end{bmatrix}
\begin{bmatrix}
\frac{1}{\sqrt{2}} \\
\frac{1}{\sqrt{2}}
\end{bmatrix}
= 1
\end{split}
\end{equation*}

\subsection{Вероятности битовых строк}
\label{\detokenize{book/qc/ru/qubit:id29}}
\sphinxAtStartPar
Последнее, чего мы коснемся в части измерений – это битовые строки и метод Шредингера. Мы много говорили о вероятностной интерпретации волновой функции и аналогиях с классическим битом, но пока этого никак не касались на практике. Как же получить вероятность определенной битовой строки для произвольного состояния? Если взять все битовые строки размерности вектора состояния и отсортировать их в лексикографическом порядке (например, \(0 < 1\), \(00 < 01 < 10 < 11\), и т.д.), то вероятность каждой битовой строки получается следующим выражением:
\begin{equation*}
\begin{split}
\mathbf{P} = | \bra{\Psi}\ket{\vec{s}} |^2,
\end{split}
\end{equation*}
\sphinxAtStartPar
где \(\vec{s}\) – это вектор, каждая компонента которого соответствует порядковой битовой строке или вектор битовых строк. Другими словами, вероятность получить \sphinxstyleemphasis{i}\sphinxhyphen{}ю битовую строку равна квадрату \sphinxstyleemphasis{i}\sphinxhyphen{}го элемента амплитуды волновой функции. Кажется немного запутанным, но на самом деле \(|\ket{\Psi}|^2\) – это идейно и есть плотность вероятности.


\subsection{Еще пара слов об измерениях}
\label{\detokenize{book/qc/ru/qubit:id30}}

\subsubsection{Измерение как проекция на пространство собственных векторов}
\label{\detokenize{book/qc/ru/qubit:id31}}
\sphinxAtStartPar
Мы уже говорили, что при измерении мы как бы “выбираем” один из собственных векторов наблюдаемой. Более строго такой процесс называется проецированием на пространство собственных векторов. Для собственного вектора \(\ket{\Phi}\) проекция будет линейным оператором:
\begin{equation*}
\begin{split}
\hat{P}_{\ket{\Phi}} = \ket{\Phi}\bra{\Phi}
\end{split}
\end{equation*}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{super\PYGZus{}position} \PYG{o}{=} \PYG{n}{h} \PYG{o}{@} \PYG{n}{basis\PYGZus{}0}
\PYG{n}{eigenvectors} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linalg}\PYG{o}{.}\PYG{n}{eig}\PYG{p}{(}\PYG{n}{pauli\PYGZus{}z}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}

\PYG{n}{proj\PYGZus{}0} \PYG{o}{=} \PYG{n}{eigenvectors}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{reshape}\PYG{p}{(}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)} \PYG{o}{@} \PYG{n}{eigenvectors}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{reshape}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{proj\PYGZus{}1} \PYG{o}{=} \PYG{n}{eigenvectors}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{reshape}\PYG{p}{(}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)} \PYG{o}{@} \PYG{n}{eigenvectors}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{reshape}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}\begin{equation*}
\begin{split}
\hat{P}_{\ket{\Phi_0}}
=
\begin{bmatrix}
1 \\
0
\end{bmatrix}
\otimes
\begin{bmatrix}
1 & 0
\end{bmatrix}
=
\begin{bmatrix}
1 & 0 \\
0 & 0 \\
\end{bmatrix}
\end{split}
\end{equation*}\begin{equation*}
\begin{split}
\hat{P}_{\ket{\Phi_1}}
=
\begin{bmatrix}
0 \\
1
\end{bmatrix}
\otimes
\begin{bmatrix}
0 & 1
\end{bmatrix}
=
\begin{bmatrix}
0 & 0 \\
0 & 1 \\
\end{bmatrix}
\end{split}
\end{equation*}

\subsubsection{Правило Борна}
\label{\detokenize{book/qc/ru/qubit:id32}}
\sphinxAtStartPar
Как мы уже говорили, любому эрмитову оператору соответствует какая\sphinxhyphen{}либо наблюдаемая величина. А какая наблюдаемая величина соответствует оператору проекции на собственный вектор \(\ket{\Phi}\), про который мы говорили выше? Ответ – вероятность наблюдения собственного значения, которое соответствует этому собственному вектору. Значит, чтобы получить вероятность измерения значения \(\lambda_i\) эрмитова оператора \(\hat{A}\) (которое соответствует собственному вектору \(\ket{\Phi_i}\) этого оператора) в состоянии \(\ket{\Psi}\), мы должны измерить величину \(\bra{\Psi} \hat{P}_{\ket{\Phi_i}} \ket{\Psi}\). Это называется правилом Борна.
\begin{equation*}
\begin{split}
\mathbf{P}(\lambda_i) = \bra{\Psi} \hat{P}_{\ket{\Phi_i}} \ket{\Psi}
\end{split}
\end{equation*}
\sphinxAtStartPar
Считать ожидаемое значение оператора мы уже умеем. Давайте убедимся, что для состояния \(\ket{\Psi} = \frac{1}{\sqrt{2}}\begin{bmatrix} 1 \\ 1\end{bmatrix}\) результаты измерений операторов проекций дадут 0.5 и совпадут с результатом упражнения, которое мы проделали ранее:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{p\PYGZus{}0} \PYG{o}{=} \PYG{n}{super\PYGZus{}position}\PYG{o}{.}\PYG{n}{conj}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{T} \PYG{o}{@} \PYG{n}{proj\PYGZus{}0} \PYG{o}{@} \PYG{n}{super\PYGZus{}position}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{allclose}\PYG{p}{(}\PYG{n}{p\PYGZus{}0}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
True
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}\begin{equation*}
\begin{split}
\mathbf{P}(\lambda_0) =
\Bigg(
\begin{bmatrix}
\frac{1}{\sqrt{2}} & \frac{1}{\sqrt{2}}
\end{bmatrix}
\begin{bmatrix}
1 & 0 \\
0 & 0 \\
\end{bmatrix}
\Bigg)
\begin{bmatrix}
\frac{1}{\sqrt{2}} \\
\frac{1}{\sqrt{2}}
\end{bmatrix}
=
\begin{bmatrix}
\frac{1}{\sqrt{2}} & \frac{1}{\sqrt{2}}
\end{bmatrix}
\Bigg(
\begin{bmatrix}
1 & 0 \\
0 & 0 \\
\end{bmatrix}
\begin{bmatrix}
\frac{1}{\sqrt{2}} \\
\frac{1}{\sqrt{2}}
\end{bmatrix}
\Bigg)
= \frac{1}{2}
\end{split}
\end{equation*}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{p\PYGZus{}1} \PYG{o}{=} \PYG{n}{super\PYGZus{}position}\PYG{o}{.}\PYG{n}{conj}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{T} \PYG{o}{@} \PYG{n}{proj\PYGZus{}1} \PYG{o}{@} \PYG{n}{super\PYGZus{}position}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{allclose}\PYG{p}{(}\PYG{n}{p\PYGZus{}1}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{allclose}\PYG{p}{(}\PYG{n}{p\PYGZus{}0} \PYG{o}{+} \PYG{n}{p\PYGZus{}1}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
True
True
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}\begin{equation*}
\begin{split}
\mathbf{P}(\lambda_1) =
\Bigg(
\begin{bmatrix}
\frac{1}{\sqrt{2}} & \frac{1}{\sqrt{2}}
\end{bmatrix}
\begin{bmatrix}
0 & 0 \\
0 & 1 \\
\end{bmatrix}
\Bigg)
\begin{bmatrix}
\frac{1}{\sqrt{2}} \\
\frac{1}{\sqrt{2}}
\end{bmatrix}
=
\begin{bmatrix}
\frac{1}{\sqrt{2}} & \frac{1}{\sqrt{2}}
\end{bmatrix}
\Bigg(
\begin{bmatrix}
0 & 0 \\
0 & 1 \\
\end{bmatrix}
\begin{bmatrix}
\frac{1}{\sqrt{2}} \\
\frac{1}{\sqrt{2}}
\end{bmatrix}
\Bigg)
= \frac{1}{2}
\end{split}
\end{equation*}

\section{Что мы узнали?}
\label{\detokenize{book/qc/ru/qubit:id33}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Состояние и значение для кубита – это не одно и то же.

\item {} 
\sphinxAtStartPar
Состояния представляют собой комплекснозначные вектора.

\item {} 
\sphinxAtStartPar
Квантовые операторы – унитарные и самосопряженные.

\item {} 
\sphinxAtStartPar
Измеряемые значения – собственные значения операторов.

\item {} 
\sphinxAtStartPar
Измерение “ломает” суперпозицию.

\end{itemize}

\sphinxstepscope


\chapter{Квантовые гейты}
\label{\detokenize{book/qc/ru/gates:gates}}\label{\detokenize{book/qc/ru/gates:id1}}\label{\detokenize{book/qc/ru/gates::doc}}
\sphinxAtStartPar
Автор(ы):
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/SemyonSinchenko}{Синченко Семен}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/ooovector}{Беседин Илья}

\end{itemize}


\section{Описание лекции}
\label{\detokenize{book/qc/ru/gates:id2}}
\sphinxAtStartPar
Из этой лекции мы узнаем:
\begin{itemize}
\item {} 
\sphinxAtStartPar
какие есть основные однокубитные и многокубитные гейты;

\item {} 
\sphinxAtStartPar
как записывать многокубитные состояния;

\item {} 
\sphinxAtStartPar
как конструировать многокубитные операторы;

\item {} 
\sphinxAtStartPar
как работать с библиотекой \sphinxcode{\sphinxupquote{PennyLane}}.

\end{itemize}


\section{Введение}
\label{\detokenize{book/qc/ru/gates:id3}}
\sphinxAtStartPar
Квантовые гейты являются основными \sphinxstyleemphasis{строительными} блоками для любых квантовых схем, в том числе и тех, что применяются для машинного обучения. Можно сказать, что это своеобразный алфавит квантовых вычислений. Он необходим, чтобы сходу понимать, например, что изображено на подобных схемах:

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=600\sphinxpxdimen]{{Layer-VQE}.png}
\caption{\sphinxhref{https://arxiv.org/abs/2102.05566}{Схема Layered\sphinxhyphen{}VQE}}\label{\detokenize{book/qc/ru/gates:lvqe}}\end{figure}


\section{Основные однокубитные гейты}
\label{\detokenize{book/qc/ru/gates:id4}}
\sphinxAtStartPar
В прошлый раз мы познакомились с \sphinxhref{../../qc/ru/qubit.html\#id24}{операторами Паули}, а также \sphinxhref{../../qc/ru/qubit.html\#id20}{гейтом Адамара}. Как для обычных квантовых алгоритмов, так и
для QML\sphinxhyphen{}алгоритмов нужны и другие гейты, потому что одни только эти гейты не позволяют перейти во все возможные квантовые состояния.
Теперь давайте посмотрим, какие еще однокубитные гейты часто применяются в квантовых вычислениях и квантовом машинном обучении.


\subsection{T\sphinxhyphen{}гейт}
\label{\detokenize{book/qc/ru/gates:t}}
\sphinxAtStartPar
T\sphinxhyphen{}гейт очень популярен в универсальных квантовых вычислениях. Его матрица имеет вид:
\begin{equation*}
\begin{split}
\hat{T} = \begin{bmatrix}
1 & 0 \\
0 & \frac{1+i}{\sqrt{2}}
\end{bmatrix}
\end{split}
\end{equation*}
\sphinxAtStartPar
Любой однокубитный гейт можно аппроксимировать последовательностью гейтов Адамара и T\sphinxhyphen{}гейтов. Чем точнее требуется аппроксимация, тем длиннее будет аппроксимирующая последовательность.

\sphinxAtStartPar
Помимо важной роли в математике квантовых вычислений, гейт Адамара и T\sphinxhyphen{}гейт интересны тем, что именно на них построено большинство предложений по реализации квантовых вычислений с топологической защитой или с коррекцией ошибок. На сегодняшний день эти схемы реально пока не очень работают: никаких топологически защищенных кубитов продемонстрировано не было, а коррекция ошибок не выходит за пределы двух логических кубитов.


\subsection{Гейты поворота вокруг оси}
\label{\detokenize{book/qc/ru/gates:id5}}
\sphinxAtStartPar
Поворотные гейты играют центральную роль в квантовом машинном обучении. Вспомним на секунду, как выглядят наши однокубитные состояния на сфере Блоха:

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{Blochsphere}.png}
\caption{Сфера Блоха}\label{\detokenize{book/qc/ru/gates:blochsphere}}\end{figure}

\sphinxAtStartPar
Любой однокубитный гейт можно представить как вращение вектора состояния \(\ket{\Psi}\) на некоторый угол вокруг некоторой оси, проходящей через центр сферы Блоха.

\sphinxAtStartPar
Гейты \(\hat{RX}(\phi), \hat{RY}(\phi), \hat{RZ}(\phi)\) осуществляют поворот на определенный угол \(\phi\) вокруг соответствующей оси на сфере Блоха.

\sphinxAtStartPar
Давайте внимательно рассмотрим это на примере гейта \(\hat{RY}\).


\subsubsection{Гейт \protect\(\hat{RY}\protect\)}
\label{\detokenize{book/qc/ru/gates:hat-ry}}
\sphinxAtStartPar
Сам гейт определяется следующим образом:
\begin{equation*}
\begin{split}
\hat{RY}(\phi) = \begin{bmatrix}
\cos(\frac{\phi}{2}) & -\sin(\frac{\phi}{2}) \\
\sin(\frac{\phi}{2}) & \cos(\frac{\phi}{2})
\end{bmatrix}
\end{split}
\end{equation*}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{k}{def} \PYG{n+nf}{ry}\PYG{p}{(}\PYG{n}{state}\PYG{p}{,} \PYG{n}{phi}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}
        \PYG{p}{[}\PYG{n}{np}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{n}{phi} \PYG{o}{/} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{np}\PYG{o}{.}\PYG{n}{sin}\PYG{p}{(}\PYG{n}{phi} \PYG{o}{/} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{[}\PYG{n}{np}\PYG{o}{.}\PYG{n}{sin}\PYG{p}{(}\PYG{n}{phi} \PYG{o}{/} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,}  \PYG{n}{np}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{n}{phi} \PYG{o}{/} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{]}
    \PYG{p}{]}\PYG{p}{)} \PYG{o}{@} \PYG{n}{state}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Запишем наше состояние \(\ket{0}\):

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{basis} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1} \PYG{o}{+} \PYG{l+m+mi}{0}\PYG{n}{j}\PYG{p}{,} \PYG{l+m+mi}{0} \PYG{o}{+} \PYG{l+m+mi}{0}\PYG{n}{j}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{reshape}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Внимательно посмотрим на сферу Блоха. Можно заметить, что если повернуть состояние из \(\ket{0}\) на \(\frac{\pi}{2}\) и измерить значение \(\hat{\sigma^x}\), то получится 1. А если повернуть на \(-\frac{\pi}{2}\), то получится \sphinxhyphen{}1:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{expval}\PYG{p}{(}\PYG{n}{state}\PYG{p}{,} \PYG{n}{op}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n}{state}\PYG{o}{.}\PYG{n}{conj}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{T} \PYG{o}{@} \PYG{n}{op} \PYG{o}{@} \PYG{n}{state}

\PYG{n}{pauli\PYGZus{}x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0} \PYG{o}{+} \PYG{l+m+mi}{0}\PYG{n}{j}\PYG{p}{,} \PYG{l+m+mi}{1} \PYG{o}{+} \PYG{l+m+mi}{0}\PYG{n}{j}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1} \PYG{o}{+} \PYG{l+m+mi}{0}\PYG{n}{j}\PYG{p}{,} \PYG{l+m+mi}{0} \PYG{o}{+} \PYG{l+m+mi}{0}\PYG{n}{j}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{allclose}\PYG{p}{(}\PYG{n}{expval}\PYG{p}{(}\PYG{n}{ry}\PYG{p}{(}\PYG{n}{basis}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi} \PYG{o}{/} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{n}{pauli\PYGZus{}x}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{allclose}\PYG{p}{(}\PYG{n}{expval}\PYG{p}{(}\PYG{n}{ry}\PYG{p}{(}\PYG{n}{basis}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi} \PYG{o}{/} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{n}{pauli\PYGZus{}x}\PYG{p}{)}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.0}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
True
True
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Убедимся также, что вращение на угол, пропорциональный \(2\pi\), не меняет результат измерения. Возьмем случайное состояние:
\begin{equation*}
\begin{split}
\ket{\Psi} = \begin{bmatrix}
0.42 \\
\sqrt{1 - 0.42^2}
\end{bmatrix}
\end{split}
\end{equation*}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{random\PYGZus{}state} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.42} \PYG{o}{+} \PYG{l+m+mi}{0}\PYG{n}{j}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.42}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{0}\PYG{n}{j}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{reshape}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Измерим его по осям \(\mathbf{X}\) и \(\mathbf{Z}\), затем повернем на угол \(2\pi\) и измерим снова:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pauli\PYGZus{}z} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1} \PYG{o}{+} \PYG{l+m+mi}{0}\PYG{n}{j}\PYG{p}{,} \PYG{l+m+mi}{0} \PYG{o}{+} \PYG{l+m+mi}{0}\PYG{n}{j}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0} \PYG{o}{+} \PYG{l+m+mi}{0}\PYG{n}{j}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{n}{j} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Z:}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{expval}\PYG{p}{(}\PYG{n}{random\PYGZus{}state}\PYG{p}{,} \PYG{n}{pauli\PYGZus{}z}\PYG{p}{)}\PYG{p}{)} \PYG{o}{+} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X:}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{expval}\PYG{p}{(}\PYG{n}{random\PYGZus{}state}\PYG{p}{,} \PYG{n}{pauli\PYGZus{}x}\PYG{p}{)}\PYG{p}{)} \PYG{o}{+} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Z after RY:}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{expval}\PYG{p}{(}\PYG{n}{ry}\PYG{p}{(}\PYG{n}{random\PYGZus{}state}\PYG{p}{,} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{p}{)}\PYG{p}{,} \PYG{n}{pauli\PYGZus{}z}\PYG{p}{)}\PYG{p}{)} \PYG{o}{+} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X after RY:}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{expval}\PYG{p}{(}\PYG{n}{ry}\PYG{p}{(}\PYG{n}{random\PYGZus{}state}\PYG{p}{,} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{p}{)}\PYG{p}{,} \PYG{n}{pauli\PYGZus{}x}\PYG{p}{)}\PYG{p}{)} \PYG{o}{+} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Z:
	[[\PYGZhy{}0.6472+0.j]]

X:
	[[0.76232025+0.j]]

Z after RY:
	[[\PYGZhy{}0.6472+0.j]]

X after RY:
	[[0.76232025+0.j]]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsubsection{Другие гейты вращений}
\label{\detokenize{book/qc/ru/gates:id6}}
\sphinxAtStartPar
Аналогичным образом определяются гейты \(\hat{RX}\) и \(\hat{RZ}\):
\begin{equation*}
\begin{split}
\hat{RX}(\phi) = \begin{bmatrix}
\cos(\frac{\phi}{2}) & -i\sin(\frac{\phi}{2}) \\
-i\sin(\frac{\phi}{2}) & \cos(\frac{\phi}{2})
\end{bmatrix} \qquad \hat{RZ}(\phi) = \begin{bmatrix}
e^{-\frac{i\phi}{2}} & 0 \\
0 & e^{\frac{i\phi}{2}}
\end{bmatrix}
\end{split}
\end{equation*}

\subsubsection{Общая форма записи однокубитных гейтов}
\label{\detokenize{book/qc/ru/gates:id7}}
\sphinxAtStartPar
В общем случае однокубитные гейты могут быть также записаны следующим образом:
\begin{equation*}
\begin{split}
\large \hat{R}^\vec{n}(\alpha) = e^{-\frac{i\alpha\hat{\vec{\sigma}}\vec{n}}{2}},
\end{split}
\end{equation*}
\sphinxAtStartPar
где \(\alpha\) – это угол поворота, \(\vec{n}\) – единичный вектор в направлении оси поворота, а \(\hat{\vec{\sigma}} = \{\hat{\sigma}^x, \hat{\sigma}^y, \hat{\sigma}^z\}\) – это вектор, составленный из операторов Паули. Если использовать покоординатную запись и \(\vec{n} = \{n_x, n_y, n_z\}\) задает ось вращения, то
\begin{equation*}
\begin{split}
\large \hat{R}^\vec{n}(\alpha) = e^{-i\frac{\alpha}{2}\left(\hat{\sigma}^xn_x+\hat{\sigma}^yn_y+\hat{\sigma}^zn_z\right)}.
\end{split}
\end{equation*}
\sphinxAtStartPar
Забегая вперед, можно сказать, что именно гейты вращений – это основа {\hyperref[\detokenize{book/vqc/ru/vqc_intro::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{квантовых вариационных схем}}}}, главного инструмента этого курса.


\subsection{Phase\sphinxhyphen{}shift гейт}
\label{\detokenize{book/qc/ru/gates:phase-shift}}
\sphinxAtStartPar
Другой важный гейт – это так называемый phase\sphinxhyphen{}shift гейт, или \(\hat{U}_1\) гейт. Его матричная форма имеет следующий вид:
\begin{equation*}
\begin{split}
\hat{U}_1(\phi) = \begin{bmatrix}
1 & 0 \\
0 & e^{i\phi}
\end{bmatrix}
\end{split}
\end{equation*}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{u1}\PYG{p}{(}\PYG{n}{state}\PYG{p}{,} \PYG{n}{phi}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{n}{j} \PYG{o}{*} \PYG{n}{phi}\PYG{p}{)}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)} \PYG{o}{@} \PYG{n}{state}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Легко видеть, что с точностью до глобального фазового множителя, который ни на что не влияет, Phase\sphinxhyphen{}shift\sphinxhyphen{}гейт – это тот же \(\hat{RZ}(\phi)\).
Он играет важную роль в квантовых ядерных методах.


\subsection{Гейты \protect\(\hat{U}_2\protect\) и \protect\(\hat{U}_3\protect\)}
\label{\detokenize{book/qc/ru/gates:hat-u-2-hat-u-3}}
\sphinxAtStartPar
Более редкие в QML гейты, которые однако все равно встречаются в статьях.
\begin{equation*}
\begin{split}
\hat{U}_2(\phi, \lambda) = \frac{1}{\sqrt{2}}\begin{bmatrix}
1 & -e^{i\lambda} \\
e^{i\phi} & e^{i(\phi + \lambda)}
\end{bmatrix} = \hat{U}_1(\phi + \lambda)\hat{RZ}(-\lambda)\hat{RY}(\frac{\pi}{2})\hat{RZ}(\lambda)
\end{split}
\end{equation*}
\sphinxAtStartPar
Давайте убедимся в справедливости этого выражения:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{rz}\PYG{p}{(}\PYG{n}{state}\PYG{p}{,} \PYG{n}{phi}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{n}{j} \PYG{o}{*} \PYG{n}{phi} \PYG{o}{/} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{n}{j} \PYG{o}{*} \PYG{n}{phi} \PYG{o}{/} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)} \PYG{o}{@} \PYG{n}{state}


\PYG{k}{def} \PYG{n+nf}{u2\PYGZus{}direct}\PYG{p}{(}\PYG{n}{phi}\PYG{p}{,} \PYG{n}{l}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{p}{(}
        \PYG{l+m+mi}{1}
        \PYG{o}{/} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}
        \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{n}{j} \PYG{o}{*} \PYG{n}{l}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{n}{j} \PYG{o}{*} \PYG{n}{phi}\PYG{p}{)}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{n}{j} \PYG{o}{*} \PYG{p}{(}\PYG{n}{phi} \PYG{o}{+} \PYG{n}{l}\PYG{p}{)}\PYG{p}{)}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
    \PYG{p}{)}


\PYG{k}{def} \PYG{n+nf}{u2\PYGZus{}inferenced}\PYG{p}{(}\PYG{n}{phi}\PYG{p}{,} \PYG{n}{l}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{p}{(}
        \PYG{n}{u1}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{eye}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{n}{phi} \PYG{o}{+} \PYG{n}{l}\PYG{p}{)}
        \PYG{o}{@} \PYG{n}{rz}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{eye}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{l}\PYG{p}{)}
        \PYG{o}{@} \PYG{n}{ry}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{eye}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi} \PYG{o}{/} \PYG{l+m+mi}{2}\PYG{p}{)}
        \PYG{o}{@} \PYG{n}{rz}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{eye}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{n}{l}\PYG{p}{)}
    \PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{allclose}\PYG{p}{(}\PYG{n}{u2\PYGZus{}direct}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi} \PYG{o}{/} \PYG{l+m+mi}{6}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi} \PYG{o}{/} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,} \PYG{n}{u2\PYGZus{}inferenced}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi} \PYG{o}{/} \PYG{l+m+mi}{6}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi} \PYG{o}{/} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
True
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Схожим образом определяется \(\hat{U}_3(\theta, \phi, \lambda)\):
\begin{equation*}
\begin{split}
\hat{U}_3(\theta, \phi, \lambda) = \begin{bmatrix}
\cos(\frac{\theta}{2}) & -e^{1j\lambda}\sin(\frac{\theta}{2}) \\
e^{1j\phi}\sin(\frac{\theta}{2}) & e^{1j(\phi + \lambda)}\cos(\frac{\theta}{2})
\end{bmatrix} = \hat{U}_1(\phi + \lambda)\hat{RZ}(-\lambda)\hat{RY}(\theta)\hat{RZ}(\lambda)
\end{split}
\end{equation*}
\sphinxAtStartPar
Читатель может сам легко убедиться, что эти формы записи эквивалентны. Для этого надо написать примерно такой же код, что мы писали раньше для \(\hat{U}_2\).


\subsection{Еще пара слов об однокубитных гейтах}
\label{\detokenize{book/qc/ru/gates:id8}}
\sphinxAtStartPar
На этом мы завершаем обзор основных однокубитных гейтов. Маленькое замечание: гейты, связанные со сдвигом фазы, никак не меняют состояние кубита, если оно сейчас \(\ket{0}\). Так как мы всегда предполагаем, что начальное состояние кубитов – это именно \(\ket{0}\), то перед применением, например, \(\hat{U}_1\), рекомендуется применить гейт Адамара:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{allclose}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{(}\PYG{n}{basis}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi} \PYG{o}{/} \PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{,} \PYG{n}{basis}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{h} \PYG{o}{=} \PYG{l+m+mi}{1} \PYG{o}{/} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1} \PYG{o}{+} \PYG{l+m+mi}{0}\PYG{n}{j}\PYG{p}{,} \PYG{l+m+mi}{1} \PYG{o}{+} \PYG{l+m+mi}{0}\PYG{n}{j}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1} \PYG{o}{+} \PYG{l+m+mi}{0}\PYG{n}{j}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{n}{j} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{allclose}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{(}\PYG{n}{h} \PYG{o}{@} \PYG{n}{basis}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi} \PYG{o}{/} \PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{,} \PYG{n}{h} \PYG{o}{@} \PYG{n}{basis}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
True
False
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsubsection{Единичный гейт}
\label{\detokenize{book/qc/ru/gates:id9}}
\sphinxAtStartPar
Самое последнее об однокубитных гейтах – это единичный гейт \(\hat{I}\):
\begin{equation*}
\begin{split}
\hat{I} = \begin{bmatrix}
1 & 0 \\
0 & 1
\end{bmatrix}
\end{split}
\end{equation*}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{identity\PYGZus{}gate} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{eye}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{dtype}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{complex128}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{identity\PYGZus{}gate}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
[[1.+0.j 0.+0.j]
 [0.+0.j 1.+0.j]]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Он не делает с кубитом ровным счетом ничего. Но единичный гейт понадобится нам позже, когда мы будем конструировать многокубитные операторы.


\section{Многокубитные состояния и гейты}
\label{\detokenize{book/qc/ru/gates:id10}}
\sphinxAtStartPar
Очевидно, что с одним кубитом ничего интересного, кроме разве что генератора истинно\sphinxhyphen{}случайных чисел, мы не сделаем. Для начала разберемся, как выглядят состояния для многокубитных систем.


\subsection{Многокубитные состояния}
\label{\detokenize{book/qc/ru/gates:id11}}
\sphinxAtStartPar
В классическом компьютере один бит имеет два значения – 0 и 1. Два бита имеют четыре значения – 00, 01, 10, 11. Три бита имеют восемь значений и так далее. Аналогично состояние двух кубитов – это вектор в пространстве \(\mathbf{C}^4\), состояние трех кубитов – вектор в пространстве \(\mathbf{C}^8\), то есть состояние \(N\) кубитов описывается вектором размерности \(2^N\) в комплексном пространстве. Вероятности каждой из возможных битовых строк (\(0000...00\), \(0000...01\), \(0000...10\), и так далее) получаются по методу Шредингера, который мы обсуждали \sphinxhref{../../qc/ru/qubit.html\#id29}{в конце прошлой лекции}:
\begin{equation*}
\begin{split}
\mathbf{P}(\vec{s}) = | \bra{\Psi}\ket{\vec{s}} |^2
\end{split}
\end{equation*}
\sphinxAtStartPar
Нужно отсортировать наши битовые строки в лексикографическом порядке – и вероятность \sphinxstyleemphasis{i}\sphinxhyphen{}й битовой строки будет равна квадрату \sphinxstyleemphasis{i}\sphinxhyphen{}го элемента вектора \(\ket{\Psi}\).

\sphinxAtStartPar
Формально, многокубитные состояния описываются с помощью математического концепта так называемого \sphinxhref{https://ru.wikipedia.org/wiki/\%D0\%A2\%D0\%B5\%D0\%BD\%D0\%B7\%D0\%BE\%D1\%80\%D0\%BD\%D0\%BE\%D0\%B5\_\%D0\%BF\%D1\%80\%D0\%BE\%D0\%B8\%D0\%B7\%D0\%B2\%D0\%B5\%D0\%B4\%D0\%B5\%D0\%BD\%D0\%B8\%D0\%B5}{\sphinxstyleemphasis{тензорного произведения}}, которое в случае линейных операторов идентично \sphinxstyleemphasis{произведению Кронекера}, обозначаемого значком \(\otimes\). Так, если \(\ket{\Psi}_A \in \mathrm{H}_A\) и \(\ket{\Psi}_B \in \mathrm{H}_B\), то \(\ket{\Psi}_{AB} = \ket{\Psi}_A \otimes \ket{\Psi}_B \in \mathrm{H}_{AB} = \mathrm{H}_{A} \otimes \mathrm{H}_{B}\). О том, как элементы вектора \(\ket{\Psi}_{AB}\) выражаются через элементы векторов \(\ket{\Psi}_{A}\) и \(\ket{\Psi}_{B}\), можно прочитать на Википедии в статье \sphinxhref{https://ru.wikipedia.org/wiki/\%D0\%9F\%D1\%80\%D0\%BE\%D0\%B8\%D0\%B7\%D0\%B2\%D0\%B5\%D0\%B4\%D0\%B5\%D0\%BD\%D0\%B8\%D0\%B5\_\%D0\%9A\%D1\%80\%D0\%BE\%D0\%BD\%D0\%B5\%D0\%BA\%D0\%B5\%D1\%80\%D0\%B0}{“Произведение Кронекера”}.


\subsection{Многокубитные операторы}
\label{\detokenize{book/qc/ru/gates:id12}}
\sphinxAtStartPar
Как мы уже обсуждали ранее, квантовые операторы должны переводить текущее состояние в новое в том же пространстве и сохранять нормировку, а еще должны быть обратимыми. Значит, оператор для состояния из \(N\) кубитов – это унитарная комплексная матрица размерности \(2^N \times 2^N\).


\subsection{Конструирование многокубитных операторов}
\label{\detokenize{book/qc/ru/gates:id13}}
\sphinxAtStartPar
Прежде чем мы начнем обсуждать двухкубитные операторы, рассмотрим ситуацию. Представим, что у нас есть состояние из двух кубитов и мы хотим подействовать на первый кубит оператором Адамара. Как же тогда нам написать такой двухкубитный оператор? Мы знаем, что действуем на первый кубит оператором, а что происходит со вторым кубитом? Ничего не происходит – и это эквивалентно тому, что мы действуем на второй кубит единичным оператором. А финальный оператор \(2^2 \times 2^2\) записывается через произведение Кронекера:
\begin{equation*}
\begin{split}
\hat{H} \otimes \hat{I} = \frac{1}{\sqrt{2}}\begin{bmatrix}
1 & 1 \\
1 & -1
\end{bmatrix} \otimes \begin{bmatrix}
1 & 0 \\
0 & 1
\end{bmatrix} = \frac{1}{\sqrt{2}} \begin{bmatrix}
\hat{I} & \hat{I} \\
\hat{I} & -\hat{I}
\end{bmatrix} = \frac{1}{\sqrt{2}} \begin{bmatrix}
1 & 0 & 1 & 0 \\
0 & 1 & 0 & 1 \\
1 & 0 & -1 & 0 \\
0 & 1 & 0 & -1
\end{bmatrix}
\end{split}
\end{equation*}
\sphinxAtStartPar
Учитывая, что многокубитные состояния конструируются аналогичным образом через произведение Кронекера, мы можем убедиться в верности нашего вывода:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{allclose}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{kron}\PYG{p}{(}\PYG{n}{h} \PYG{o}{@} \PYG{n}{basis}\PYG{p}{,} \PYG{n}{basis}\PYG{p}{)}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{kron}\PYG{p}{(}\PYG{n}{h}\PYG{p}{,} \PYG{n}{identity\PYGZus{}gate}\PYG{p}{)} \PYG{o}{@} \PYG{n}{np}\PYG{o}{.}\PYG{n}{kron}\PYG{p}{(}\PYG{n}{basis}\PYG{p}{,} \PYG{n}{basis}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
True
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Наблюдаемые для многокубитных гейтов}
\label{\detokenize{book/qc/ru/gates:id14}}
\sphinxAtStartPar
Аналогичным образом можно сконструировать и наблюдаемые. Например, если мы хотим измерять одновременно два спина по оси \(\mathbf{Z}\), то наблюдаемая будет выглядеть так:
\begin{equation*}
\begin{split}
\mathbf{ZZ} = \hat{\sigma^z} \otimes \hat{\sigma^z} = \begin{bmatrix}
1 & 0 & 0 & 0 \\
0 & -1 & 0 & 0 \\
0 & 0 & -1 & 0 \\
0 & 0 & 0 & 1
\end{bmatrix}
\end{split}
\end{equation*}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{kron}\PYG{p}{(}\PYG{n}{basis}\PYG{p}{,} \PYG{n}{basis}\PYG{p}{)}\PYG{o}{.}\PYG{n}{conj}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{T} \PYG{o}{@} \PYG{n}{np}\PYG{o}{.}\PYG{n}{kron}\PYG{p}{(}\PYG{n}{pauli\PYGZus{}z}\PYG{p}{,} \PYG{n}{pauli\PYGZus{}z}\PYG{p}{)} \PYG{o}{@} \PYG{n}{np}\PYG{o}{.}\PYG{n}{kron}\PYG{p}{(}\PYG{n}{basis}\PYG{p}{,} \PYG{n}{basis}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
[[1.+0.j]]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Основные двухкубитные гейты}
\label{\detokenize{book/qc/ru/gates:id15}}
\sphinxAtStartPar
Основные многокубитные гейты, которые предоставляют современные квантовые компьютеры, – это двухкубитные гейты.


\subsection{CNOT (CX)}
\label{\detokenize{book/qc/ru/gates:cnot-cx}}
\sphinxAtStartPar
Квантовый гейт контролируемого инвертирования – это гейт, который действует на два кубита: \sphinxstyleemphasis{рабочий} и \sphinxstyleemphasis{контрольный}. В зависимости от того, имеет ли контрольный кубит значение 1 или 0, этот гейт инвертирует или не инвертирует рабочий кубит.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=200\sphinxpxdimen]{{CNOT_gate}.png}
\caption{Гейт CNOT}\label{\detokenize{book/qc/ru/gates:cnot}}\end{figure}

\sphinxAtStartPar
Иногда этот гейт также называют гейтом CX. В матричном виде этот оператор можно записать так:
\begin{equation*}
\begin{split}
\hat{CNOT} = \begin{bmatrix}
1 & 0 & 0 & 0\\
0 & 1 & 0 & 0\\
0 & 0 & 0 & 1\\
0 & 0 & 1 & 0
\end{bmatrix}
\end{split}
\end{equation*}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cnot} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{+} \PYG{l+m+mi}{0}\PYG{n}{j}\PYG{p}{)} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}
    \PYG{p}{[}
        \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
    \PYG{p}{]}
\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{allclose}\PYG{p}{(}\PYG{n}{cnot} \PYG{o}{@} \PYG{n}{np}\PYG{o}{.}\PYG{n}{kron}\PYG{p}{(}\PYG{n}{basis}\PYG{p}{,} \PYG{n}{basis}\PYG{p}{)}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{kron}\PYG{p}{(}\PYG{n}{basis}\PYG{p}{,} \PYG{n}{basis}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{allclose}\PYG{p}{(}
    \PYG{n}{cnot} \PYG{o}{@} \PYG{n}{np}\PYG{o}{.}\PYG{n}{kron}\PYG{p}{(}\PYG{n}{pauli\PYGZus{}x} \PYG{o}{@} \PYG{n}{basis}\PYG{p}{,} \PYG{n}{basis}\PYG{p}{)}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{kron}\PYG{p}{(}\PYG{n}{pauli\PYGZus{}x} \PYG{o}{@} \PYG{n}{basis}\PYG{p}{,} \PYG{n}{pauli\PYGZus{}x} \PYG{o}{@} \PYG{n}{basis}\PYG{p}{)}
\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
True
True
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Заметьте, тут мы воспользовались тем, что \(\hat{\sigma^x}\) работает так же, как инвертор кубитов: он превращает \(\ket{0}\) в \(\ket{1}\) и наоборот.


\subsection{Гейты CY и CZ}
\label{\detokenize{book/qc/ru/gates:cy-cz}}
\sphinxAtStartPar
Схожие по принципу гейты – это гейты \(\hat{CY}\) и \(\hat{CZ}\). В зависимости от значения управляющего кубита к рабочему кубиту применяют соответствующий оператор Паули:
\begin{equation*}
\begin{split}
\hat{CY} = \begin{bmatrix}
1 & 0 & 0 & 0\\
0 & 1 & 0 & 0\\
0 & 0 & 0 & -i\\
0 & 0 & i & 0
\end{bmatrix} \qquad \hat{CZ} = \begin{bmatrix}
1 & 0 & 0 & 0\\
0 & 1 & 0 & 0\\
0 & 0 & 1 & 0\\
0 & 0 & 0 & -1
\end{bmatrix}
\end{split}
\end{equation*}

\subsection{Гейт iSWAP}
\label{\detokenize{book/qc/ru/gates:iswap}}
\sphinxAtStartPar
Гейты \(\hat{CX}\), \(\hat{CY}\) и \(\hat{CZ}\) эквивалентны с точностью до однокубитных гейтов. Это означает, что любой из них можно получить, добавив необходимые однокубитные гейты до и после другого гейта. Например:
\begin{equation*}
\begin{split}
\hat{CZ} = \left(\hat{I}\times\hat{H}\right)\hat{CX}\left(\hat{I}\times\hat{H}\right).
\end{split}
\end{equation*}
\sphinxAtStartPar
Этим свойством обладают отнюдь не все двухкубитные гейты. Например, таковым является гейт iSWAP:
\begin{equation*}
\begin{split}
\mathrm{iSWAP} = \begin{bmatrix}
1 & 0 & 0 & 0\\
0 & 0 & i & 0\\
0 & i & 0 & 0\\
0 & 0 & 0 & 1
\end{bmatrix}
\end{split}
\end{equation*}

\subsection{Гейт fSim}
\label{\detokenize{book/qc/ru/gates:fsim}}
\sphinxAtStartPar
Для разных архитектур квантовых процессоров “естественный” гейт может выглядеть по\sphinxhyphen{}разному. Например, в квантовом процессоре Google Sycamore естественным является так называемый fermionic simulation gate или fSim. Это двухпараметрическое семейство гейтов вида:
\begin{equation*}
\begin{split}
\mathrm{fSim}(\theta, \phi) = \begin{bmatrix}
1 & 0 & 0 & 0\\
0 & \cos\theta & -i\sin\theta & 0\\
0 & -i\sin\theta & \cos\theta & 0\\
0 & 0 & 0 & e^{-i\phi}
\end{bmatrix}.
\end{split}
\end{equation*}
\sphinxAtStartPar
Впрочем, и fSim\sphinxhyphen{}гейт не является эквивалентным всему множеству двухкубитных гейтов. В общем случае, чем больше кубитов,
тем сложнее будет выглядеть декомпозиция произвольного гейта на физически реализуемые в “железе”.


\section{Первое знакомство с PennyLane}
\label{\detokenize{book/qc/ru/gates:pennylane}}
\sphinxAtStartPar
На сегодняшний день существует достаточно много фреймворков для программирования квантовых компьютеров. Для целей этого курса мы будем использовать \sphinxhref{https://pennylane.ai/}{PennyLane}. Эта библиотека предоставляет высокоуровневый \sphinxcode{\sphinxupquote{Python API}} и создана специально для решения задач квантового машинного обучения.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{pennylane} \PYG{k}{as} \PYG{n+nn}{qml}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\subsection{Device}
\label{\detokenize{book/qc/ru/gates:device}}
\sphinxAtStartPar
Для объявления квантового устройства используется класс \sphinxcode{\sphinxupquote{Device}}. \sphinxcode{\sphinxupquote{PennyLane}} поддерживает работу с большинством существующих квантовых компьютеров, но для целей курса мы будем запускать все наши программы лишь на самом простом симуляторе идеального квантового компьютера:

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Разработка и отладка квантовых алгоритмов, как правило, происходит на симуляторах. Но надо понимать, что это работает только пока алгоритмы – “игрушечные” и задействуют пару\sphinxhyphen{}тройку или пару десятков кубитов. Надо понимать, что при добавлении каждого следующего кубита требуется вдвое больше ресурсов, чтобы просимулировать квантовый компьютер. Поэтому симуляторы –принципиально плохо масштабируемые аналоги реальных квантовых компьютеров.
\end{sphinxadmonition}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{device} \PYG{o}{=} \PYG{n}{qml}\PYG{o}{.}\PYG{n}{device}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{default.qubit}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Первый аргумент тут – указание устройства, а второй – число кубитов.


\subsection{QNode}
\label{\detokenize{book/qc/ru/gates:qnode}}
\sphinxAtStartPar
Основной \sphinxstyleemphasis{строительный блок} в \sphinxcode{\sphinxupquote{PennyLane}} – это \sphinxcode{\sphinxupquote{qnode}}. Это функция, которая отмечена специальным декоратором и включает в себя несколько операций с кубитами. Результатом такой функции всегда является измерение. Напишем функцию, которая поворачивает первый кубит на \(45^o\), после чего измеряет оба кубита по оси \(\mathbf{Z}\).


\subsubsection{Сначала на NumPy}
\label{\detokenize{book/qc/ru/gates:numpy}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{state} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{kron}\PYG{p}{(}\PYG{n}{basis}\PYG{p}{,} \PYG{n}{basis}\PYG{p}{)}
\PYG{n}{op} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{kron}\PYG{p}{(}\PYG{n}{ry}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{eye}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{deg2rad}\PYG{p}{(}\PYG{l+m+mi}{45}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{eye}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{dtype}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{complex128}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{measure} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{kron}\PYG{p}{(}\PYG{n}{pauli\PYGZus{}z}\PYG{p}{,} \PYG{n}{pauli\PYGZus{}z}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{p}{(}\PYG{n}{op} \PYG{o}{@} \PYG{n}{state}\PYG{p}{)}\PYG{o}{.}\PYG{n}{conj}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{T} \PYG{o}{@} \PYG{n}{measure} \PYG{o}{@} \PYG{p}{(}\PYG{n}{op} \PYG{o}{@} \PYG{n}{state}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
[[0.70710678+0.j]]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsubsection{Теперь через QNode}
\label{\detokenize{book/qc/ru/gates:id16}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nd}{@qml}\PYG{o}{.}\PYG{n}{qnode}\PYG{p}{(}\PYG{n}{device}\PYG{p}{)}
\PYG{k}{def} \PYG{n+nf}{test}\PYG{p}{(}\PYG{n}{angle}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{qml}\PYG{o}{.}\PYG{n}{RY}\PYG{p}{(}\PYG{n}{angle}\PYG{p}{,} \PYG{n}{wires}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{qml}\PYG{o}{.}\PYG{n}{expval}\PYG{p}{(}\PYG{n}{qml}\PYG{o}{.}\PYG{n}{PauliZ}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{@} \PYG{n}{qml}\PYG{o}{.}\PYG{n}{PauliZ}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}


\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{test}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{deg2rad}\PYG{p}{(}\PYG{l+m+mi}{45}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
0.7071067811865472
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Заключение}
\label{\detokenize{book/qc/ru/gates:id17}}
\sphinxAtStartPar
Это последняя вводная лекция, где мы сами писали операторы и операции на чистом \sphinxcode{\sphinxupquote{NumPy}}: это должно помочь лучше понять ту математику, которая лежит “под капотом” у квантовых вычислений. Дальше мы будем пользоваться только \sphinxcode{\sphinxupquote{PennyLane}} и в отдельной лекции расскажем, как работать с этим фреймворком.

\sphinxAtStartPar
Итого:
\begin{itemize}
\item {} 
\sphinxAtStartPar
мы знаем, что такое кубит;

\item {} 
\sphinxAtStartPar
понимаем линейную алгебру, которая описывает квантовые вычисления;

\item {} 
\sphinxAtStartPar
понимаем, как можно сконструировать нужный нам оператор и как его применить;

\item {} 
\sphinxAtStartPar
знаем, что такое измерение и наблюдаемые.

\end{itemize}

\sphinxAtStartPar
Теперь мы готовы к тому, чтобы знакомиться с квантовыми вариационными схемами и переходить непосредственно к построению моделей квантового машинного обучения.


\section{Задачи}
\label{\detokenize{book/qc/ru/gates:id18}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Как связаны ось и угол вращения на сфере Блоха с собственными значениями и собственными векторами матрицы однокубитного гейта? Для этого найдите собственные векторы и собственные значения гейта \(R^\vec{n}\left(\alpha\right)\).

\item {} 
\sphinxAtStartPar
Вокруг какой оси и на какой угол вращает состояние гейт Адамара?

\item {} 
\sphinxAtStartPar
Гейт SWAP меняет кубиты местами. Его унитарная матрица имеет вид:

\end{itemize}
\begin{equation*}
\begin{split}
\mathrm{SWAP} =
\begin{bmatrix}
1 & 0 & 0 & 0 \\
0 & 0 & 1 & 0 \\
0 & 1 & 0 & 0 \\
0 & 0 & 0 & 1
\end{bmatrix}.
\end{split}
\end{equation*}
\sphinxAtStartPar
Попробуйте составить последовательность гейтов, реализующую \(\mathrm{SWAP}\), из гейтов \(\mathrm{iSWAP}\), \(\hat{CZ}\) и \(\hat{RZ}(\phi)\).

\sphinxstepscope


\chapter{Смешанные состояния и матрицы плотности}
\label{\detokenize{book/qc/ru/mixedstates:mixedstates}}\label{\detokenize{book/qc/ru/mixedstates:id1}}\label{\detokenize{book/qc/ru/mixedstates::doc}}
\sphinxAtStartPar
Автор(ы):
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/karelin}{Карелин Николай}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/SemyonSinchenko}{Синченко Семен}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/ooovector}{Беседин Илья}

\end{itemize}


\section{Описание лекции}
\label{\detokenize{book/qc/ru/mixedstates:id2}}
\sphinxAtStartPar
Из этой лекции мы узнаем:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Что такое матрица плотности

\item {} 
\sphinxAtStartPar
Как ввести в описание квантовых состояний новый уровень случайности

\item {} 
\sphinxAtStartPar
Как связаны смешанные (mixed) и запутанные (entangled) состояния

\item {} 
\sphinxAtStartPar
Как можно описать насколько “сильно” квантовое состояние является смешанным

\end{itemize}


\section{Смешанные состояния}
\label{\detokenize{book/qc/ru/mixedstates:id3}}
\sphinxAtStartPar
Эта глава кратко рассматривает довольно сложный, но крайне важный аспект квантового описания мира: как описать квантовую систему, в которой случайным является не только результат измерения, но и само состояние квантовой системы, иными словами, когда мы не можем описать квантовую систему определенным вектором состояния.

\sphinxAtStartPar
Как могут появиться такие ситуации?

\sphinxAtStartPar
Прежде всего, в любой реалистичной ситуации квантовая система будет испытывать влияние окружающей среды. Это воздействие окружающей среды на квантовый компьютер, как правило, может быть охарактеризовано некоторой температурой этой самой среды и скоростью термализации системы с ней. В отличие от классических компьютеров, где шумы редко приводят к ошибкам в вычислениях, квантовые компьютеры очень плохо защищены от шумов. Любое масштабное квантовое вычисление является гонкой с процессами декогеренции и релаксации: за время выполнения алгоритма шумы не должны испортить результат вычислений настолько, чтобы его нельзя было использовать.

\sphinxAtStartPar
Вторая, более важная причина использования смешанных состояний состоит в их тесной связи с запутанными состояниями, как показано ниже.


\section{Почему нельзя обойтись волновой функцией}
\label{\detokenize{book/qc/ru/mixedstates:id4}}
\sphinxAtStartPar
Рассмотрим реальный физический кубит в состоянии равновесия, например, спин ядра атома в магнитном поле.
Статистическая физика говорит нам, что вероятность обнаружить этот спин ориентированным вдоль внешнего поля выше, чем в
противоположном полю направлении. Для расчета отношений этих вероятностей можно использовать распределение Больцмана:
\(p_\uparrow/p_\downarrow = e^{\frac{2\mu \Delta H}{k_\mathrm{B}T}}\), где \(2\mu \Delta H\) – разность энергий состояний со спином вдоль
поля и в противоположном полю направлений, \(k_B\) – постоянная Больцмана, а \(T\) – температура. Так как состояний у этой
системы всего два, сумма их вероятностей должна давать единицу: \(p_\uparrow + p_\downarrow = 1\). Таким образом,
вероятности состояний однозначно определены.

\sphinxAtStartPar
Волновую функцию, отвечающую такому тепловому состоянию, можно записать в виде
\begin{equation*}
\begin{split}
\ket{\psi} =
\begin{pmatrix}
\sqrt{p_\uparrow} \\
\sqrt{p_\downarrow}e^{i\phi}
\end{pmatrix},
\end{split}
\end{equation*}
\sphinxAtStartPar
где значение фазы \(\phi\) не определено. Однако \(\phi\) определяет поведение системы не в меньшей мере, чем вероятности
\(p_\uparrow\) и \(p_\downarrow\). \(\phi\) может равновероятно принимать любые значения. Таким образом, уже даже состояние
теплового равновесия нельзя описать одной волновой функцией – это будет распределением вероятности по волновым
функциям с разным \(\phi\).


\section{Матрица плотности}
\label{\detokenize{book/qc/ru/mixedstates:id5}}
\sphinxAtStartPar
Оказывается, что вместо распределения вероятностей по волновым функциям можно использовать более простую
конструкцию – матрицу плотности. Если система находится в состояниях \(\Phi_n\) с вероятностями \(p_n\), то матрицу
плотности можно определить как
\begin{equation}\label{equation:book/qc/ru/mixedstates:eqn:rho_mixed}
\begin{split}
\rho = \sum\limits_{n}p_n \ket{\Phi_n}\bra{\Phi_n}.
\end{split}
\end{equation}
\sphinxAtStartPar
Выражение \(\ket{\Phi_n}\bra{\Phi_n}\) обозначает произведение вектора\sphinxhyphen{}столбца на вектор\sphinxhyphen{}строку – результатом будет
матрица. Важно, что значение любой ожидаемой величины (отвечающей оператору \(\hat{A}\)) можно записать через \(\rho\):
\begin{equation*}
\begin{split}
\mathbb{E}[A] = \sum\limits_{n}p_n \bra{\Phi_n}\hat{A}\ket{\Phi_n} =
\sum\limits_{n}p_n \operatorname{Tr}\left[\ket{\Phi_n}\bra{\Phi_n}\hat{A}\right] = \operatorname{Tr}\left[\rho \hat{A}\right]
\end{split}
\end{equation*}
\sphinxAtStartPar
Математическое обоснование этой циклической перестановки можно получить, расписав матричные произведения покомпонентно:
\begin{equation*}
\begin{split}
\bra{\Phi_n}\hat{A}\ket{\Phi_n} = \sum \limits_{i,j} \Phi_n^{i*} A_{ij} \Phi_n^{j} =
\operatorname{Tr}\left[\ket{\Phi_n}\bra{\Phi_n}\hat{A}\right].
\end{split}
\end{equation*}
\sphinxAtStartPar
Любую наблюдаемую физическую величину можно выразить в виде ожидаемой величины некоторого эрмитова оператора –
а значит, описание с помощью матрицы плотности является универсальным для любых случайных квантовых систем.

\sphinxAtStartPar
Стоит заметить, что матрица плотности для подсистем была впервые введена в научный оборот знаменитым советским физиком, лауреатом Нобелевской премии Львом Ландау. {[}\hyperlink{cite.book/bibliography:id39}{15a}{]}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{Landau}.jpg}
\caption{Лев Ландау, 1908\sphinxhyphen{}1968}\label{\detokenize{book/qc/ru/mixedstates:landau}}\end{figure}


\section{Чистые и смешанные состояния}
\label{\detokenize{book/qc/ru/mixedstates:id7}}
\sphinxAtStartPar
Состояния, которые описываются одной единственной волновой функцией \(\Psi\), называются \sphinxstyleemphasis{чистыми} (англ. \sphinxstyleemphasis{pure states}).
Для таких состояний выражение для матрицы плотности получается тривиальным:
\begin{equation}\label{equation:book/qc/ru/mixedstates:eqn:rho_pure}
\begin{split}
\rho = \ket{\Psi}\bra{\Psi}
\end{split}
\end{equation}
\sphinxAtStartPar
Матрица плотности чистого состояния является \sphinxstyleemphasis{оператором\sphinxhyphen{}проектором}: действие оператора на волновую функцию произвольного состояния \(\Phi\)
дает проекцию \(\Phi\) на \(\Psi\).
Состояния, которые нельзя описать одним вектором состояния, а можно лишь матрицей плотности, называются \sphinxstyleemphasis{смешанными}
(англ. \sphinxstyleemphasis{mixed states}).


\subsection{Чистота состояния}
\label{\detokenize{book/qc/ru/mixedstates:id8}}
\sphinxAtStartPar
Можно легко показать, для оператора\sphinxhyphen{}проектора \eqref{equation:book/qc/ru/mixedstates:eqn:rho_pure} выполняется тождество
\begin{equation*}
\begin{split}
\rho^2 = \ket{\Psi} \bra{\Psi} \ket{\Psi} \bra{\Psi} = \ket{\Psi} \bra{\Psi} = \rho
\end{split}
\end{equation*}
\sphinxAtStartPar
и следовательно, для чистого состояния
\begin{equation*}
\begin{split}
\operatorname{Tr} (\rho^2) = 1
\end{split}
\end{equation*}
\sphinxAtStartPar
(напомним, что мы всегда считаем вектора состояния нормированными на единицу).

\sphinxAtStartPar
Аналогичным образом, но после более длинных выкладок можно показать, что в общем случае
\begin{equation*}
\begin{split}
\operatorname{Tr} (\rho^2) \leq 1,
\end{split}
\end{equation*}
\sphinxAtStartPar
причем знак равенства в последней формуле возможен, только если в формуле \eqref{equation:book/qc/ru/mixedstates:eqn:rho_mixed} сумма имеет лишь одно
слагаемое (т.е. состояние является чистым). Последнее свойство матрицы плотности позволяет ввести ряд величин,
характеризующих смешанные и запутанные состояния, о чем будет рассказано в заключительном разделе этой лекции.
Величина
\begin{equation}\label{equation:book/qc/ru/mixedstates:eqn:purity}
\begin{split}
\gamma = \operatorname{Tr} (\rho^2)
\end{split}
\end{equation}
\sphinxAtStartPar
называется \sphinxstyleemphasis{чистотой состояния} (\sphinxstyleemphasis{quantum state purity}).


\subsection{Энтропия}
\label{\detokenize{book/qc/ru/mixedstates:id9}}
\sphinxAtStartPar
Энтропия фон Неймана – это другая численная характеристика того, насколько сильно наша система смешанная. Ее
выражение очень похоже на выражение для классической \sphinxhref{https://ru.wikipedia.org/wiki/\%D0\%98\%D0\%BD\%D1\%84\%D0\%BE\%D1\%80\%D0\%BC\%D0\%B0\%D1\%86\%D0\%B8\%D0\%BE\%D0\%BD\%D0\%BD\%D0\%B0\%D1\%8F\_\%D1\%8D\%D0\%BD\%D1\%82\%D1\%80\%D0\%BE\%D0\%BF\%D0\%B8\%D1\%8F}{энтропии Шеннона}.
Только в отличие от классики, в квантовой механике мы имеем \sphinxstyleemphasis{матрицу} плотности, поэтому в выражении у нас
фигурирует \sphinxhref{https://en.wikipedia.org/wiki/Logarithm\_of\_a\_matrix}{матричный логарифм}:
\begin{equation}\label{equation:book/qc/ru/mixedstates:eqn:entropy}
\begin{split}
S = -Tr(\rho\cdot \ln(\rho))
\end{split}
\end{equation}

\subsection{Спектральная декомпозиция матрицы плотности}
\label{\detokenize{book/qc/ru/mixedstates:id10}}
\sphinxAtStartPar
Определение матрицы плотности \eqref{equation:book/qc/ru/mixedstates:eqn:rho_mixed} представляет собой сумму матриц плотностей чистых состояний, взятых с
некоторыми вероятностями. Интересно, что совершенно разным комбинациям чистых состояний могут соответствовать одинаковые
матрицы плотности. Например, состояние кубита, который с вероятностью 50\% находится в состоянии \(\ket{0}\) и с
вероятностью 50\% в состоянии \(\ket{1}\) совершенно неотличимо от такой же равновероятной смеси состояний \(\ket{+}\) и
\(\ket{-}\):
\begin{equation*}
\begin{split}
\frac{1}{2}\left(\ket{0}\bra{0} + \ket{1}\bra{1}\right) =
\begin{pmatrix}\frac{1}{2} & 0 \\ 0 & \frac{1}{2}\end{pmatrix} =
\frac{1}{2}\left(\ket{+}\bra{+} + \ket{-}\bra{-}\right)
\end{split}
\end{equation*}
\sphinxAtStartPar
Соотношение \eqref{equation:book/qc/ru/mixedstates:eqn:rho_mixed} также можно рассматривать как спектральную декомпозицию матрицы плотности. В этом случае
состояния \(\Psi_n\) образуют ортонормированный базис, а вероятности \(p_n\) – это собственные значения \(\rho\).
Как чистота \eqref{equation:book/qc/ru/mixedstates:eqn:purity}, так и энтропия \eqref{equation:book/qc/ru/mixedstates:eqn:entropy} зависят лишь от этих собственных значений.


\section{Смешанные состояния и запутанность}
\label{\detokenize{book/qc/ru/mixedstates:id11}}
\sphinxAtStartPar
Рассмотрим ситуацию, когда описываемую квантовую систему \(\Phi\) можно разделить на две подсистемы,
\(\phi\) и \(\psi\), и состояние этой системы \(\ket{\Phi}\) является суперпозицией состояний двух подсистем:
\begin{equation*}
\begin{split}
\ket{\Phi} = \sum_{i,j} c_{i,j} \ket{\phi_i} \ket{\psi_j}.
\end{split}
\end{equation*}
\sphinxAtStartPar
Здесь два ортонормированных набора векторов состояния \(\ket{\phi_i}\) и \(\ket{\psi_j}\) описывают две части всей системы.
Для такого состояния не всегда можно сказать, в каком именно состоянии находится каждая подсистема.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Вспомним обсуждение кота Шредингера в {\hyperref[\detokenize{book/qc/ru/qubit::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{лекции про кубит}}}} – упрощая до предела, можно считать,
что радиоактивный атом является одной системой, а несчастный кот – второй.

\sphinxAtStartPar
До измерения ни атом, ни кот не имеют определенного состояния, а находятся в суперпозиции возможных состояний.
\end{sphinxadmonition}

\sphinxAtStartPar
Что же мы можем сделать, если у нас есть доступ лишь к одной из двух подсистем, а измерить состояние второй мы уже не
можем? В таком случае, все наши наблюдаемые величины будут отвечать операторами \(A_\psi\), которые
действует \sphinxstyleemphasis{только} на вторую подсистему. В примере кота Шредингера можно допустить, что экспериментально
пронаблюдать мы можем лишь состояние кота, а состояние радиоактивного атома недоступно нам для измерения. В таком случае
состояние второй подсистемы можно полностью описать используя \sphinxstyleemphasis{редуцированную}
матрицу плотности. Редуцированная матрица плотности получается из матрицы плотности чистого состояния всей системы
суммированием по вероятностям различных состояний первой подсистемы:
\begin{equation}\label{equation:book/qc/ru/mixedstates:eqn:partial-dm}
\begin{split}
\rho_\psi = \operatorname{Tr}_\phi (\ket{\Phi} \bra{\Phi}) = \sum_{i, j} d_{i, j} \ket{\psi_j} \bra{\psi_i},
\end{split}
\end{equation}
\sphinxAtStartPar
где
\begin{equation*}
\begin{split}
d_{i, j} = \sum_k c_{j, k} c^{*}_{i, k},
\end{split}
\end{equation*}
\sphinxAtStartPar
а \(\operatorname{Tr}_\phi\) означает частичный след по второй подсистеме, звездочка – комплексное сопряжение. В таких обозначениях значение для среднего от оператора \(A\) вычисляется по формуле
\begin{equation*}
\begin{split}
\braket{A_\psi} = \operatorname{Tr}_\psi (A \rho_\psi)
\end{split}
\end{equation*}
\sphinxAtStartPar
Здесь след матрицы уже вычисляется по первой подсистеме.

\sphinxAtStartPar
Чаще всего при обсуждении смешанных состояний рассматривают только одну “подсистему”, считая, что вторая – это некоторый
макроскопический объект (“резервуар”, например лаборатория или даже вся Вселенная).
В этом случае определение матрицы плотности \eqref{equation:book/qc/ru/mixedstates:eqn:rho_mixed} можно рассматривать как редуцированную матрицу плотности
\eqref{equation:book/qc/ru/mixedstates:eqn:partial-dm}, из которой убрали нерелевантные и неконтролируемые степени свободы.


\subsection{Запутанные и сепарабельные состояния}
\label{\detokenize{book/qc/ru/mixedstates:id12}}
\sphinxAtStartPar
Давайте вернемся к представлению состояния составной системы и зададимся вопросом: что можно сказать о связи между частями системы с точки зрения квантового описания? Для системы из двух кубитов такая составная система в общем случае может быть записана в явном виде (в этом разделе мы в основном следуем изложению из книги {[}\hyperlink{cite.book/bibliography:id71}{01}{]}):
\begin{equation}\label{equation:book/qc/ru/mixedstates:eqn:two_qubit}
\begin{split}
\ket{\Phi} = a \ket{0_A 0_B} + b \ket{0_A 1_B} + c \ket{1_A 0_B} + d \ket{1_A 1_B},
\end{split}
\end{equation}
\sphinxAtStartPar
где индексы \(A\) и \(B\) здесь обозначают первый и второй кубиты, соответственно, а условие нормировки дает
\begin{equation*}
\begin{split}
\left\langle \Phi \middle| \Phi \right\rangle = |a|^2 + |b|^2 + |c|^2 + |d|^2 = 1.
\end{split}
\end{equation*}
\sphinxAtStartPar
Теперь, как можно показать, состояние типа \eqref{equation:book/qc/ru/mixedstates:eqn:two_qubit} может быть представлено в виде произведения состояний двух отдельных кубитов, если \(ad = dc\):
\begin{equation*}
\begin{split}
\ket{\Phi_s} = \left(a_A \ket{0_A} + b_A \ket{1_A} \right) \otimes \left(a_B \ket{0_B} + b_B \ket{1_B} \right),
\end{split}
\end{equation*}
\sphinxAtStartPar
где для выражения \eqref{equation:book/qc/ru/mixedstates:eqn:two_qubit}
\begin{equation*}
\begin{split}
\begin{array}{cc} a = a_A a_B & b = a_A b_B \\ c = b_A a_B & d = b_A b_B \end{array}
\end{split}
\end{equation*}
\sphinxAtStartPar
В других случаях, когда \(ad \neq dc\), состояние составной системы не представимо в виде произведения состояний подсистем, такие состояния называют несепарабельными (nonseparable). Другими словами, результат измерения состояния подсистемы \(A\) будет зависеть от состояния подсистемы \(B\). Это означает, что для квантовых систем возможна нелокальная корреляция. Такое свойство квантовых систем называется \sphinxstyleemphasis{запутыванием} (\sphinxstyleemphasis{entanglement}), а сами состояния \sphinxstyleemphasis{запутанными} (\sphinxstyleemphasis{entangled}).

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
В отличие от анлийского языка, в русском языке не сложилось единой терминологии в отношении запутанных состояний. На момент написания этой лекции (осень 2021 года) в статье \sphinxhref{https://ru.wikipedia.org/wiki/\%D0\%9A\%D0\%B2\%D0\%B0\%D0\%BD\%D1\%82\%D0\%BE\%D0\%B2\%D0\%B0\%D1\%8F\_\%D0\%B7\%D0\%B0\%D0\%BF\%D1\%83\%D1\%82\%D0\%B0\%D0\%BD\%D0\%BD\%D0\%BE\%D1\%81\%D1\%82\%D1\%8C}{Квантовая запутанность} русскоязычной Википедии указывается восемь (!) отличающихся терминов для этого явления, например, “запутанность”, “перепутанность” или “сцепленность”. Сделать с этим что\sphinxhyphen{}то сложно, остается только иметь в виду имеющиеся обстоятельства. Мы будем стараться употреблять термин \sphinxstyleemphasis{запутанность} и, соответственно, \sphinxstyleemphasis{запутанные} состояния.
\end{sphinxadmonition}

\sphinxAtStartPar
Приведем пару примеров запутанных состояний:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\(b = c = 0, a = d = \pm 1/\sqrt{2}\) – состояние “\sphinxstyleemphasis{шредингеровского кота}”, см. {[}\hyperlink{cite.book/bibliography:id71}{01}{]} и {[}\hyperlink{cite.book/bibliography:id53}{07}{]}, такая формула для вектора состояния возникает для суперпозиции двух макроскопически различимых состояний одной из подсистем, например, живой или мертвый кот.

\item {} 
\sphinxAtStartPar
\(a = d = 0, b = -c = \pm 1/\sqrt{2}\) – такое состояние называется ЭПР\sphinxhyphen{}парой (EPR, от Einstein\sphinxhyphen{}Podolsky\sphinxhyphen{}Rosen) и это очень важный пример из истории изучения запутанности в квантовой физике.

\end{enumerate}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
в 1930\sphinxhyphen{}е происходили многочисленные споры об “интерпретации” (сути) квантовой механики. Именно тогда Эйнштейн, Шредингер и их коллеги обратили внимание на несепарабельные состояния и затем Эйнштейном, Подольским и Розеном был сформулирован “парадокс” – что квантовая механика либо нелокальна (т.е. несовместима с теорией относительности), либо неполна (мы учитываем не все параметры при описании состяния квантовых систем). Именно с дискуссией о сути запутанности связана знаменитая цитата Эйнштейна “Бог не играет в кости” и менее известный ответ Нильса Бора, “Альберт, не указывай Богу, что ему делать.”
\end{sphinxadmonition}

\sphinxAtStartPar
Довольно долго изучение запутанности и связанных с ней трудностей считались сложным, но не основными вопросами квантовой физики. Но с развитием квантовой информатики стало понятно, что без запутанности нельзя разрабатывать квантовые компьютеры и системы квантовой связи. В настоящее время существуют устоявшиеся методы создания запутанных состояний в эксперименте. А для целей нашего курса, в симуляциях, достаточно использовать \sphinxhref{../../qc/ru/gates.html\#id15}{двухкубитные гейты}, которые обсуждались в предыдущей лекции, например \sphinxcode{\sphinxupquote{CNOT}} или \sphinxcode{\sphinxupquote{CZ}}, который используется в лекции про {\hyperref[\detokenize{book/grads/ru/gradients::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{Градиенты квантовых схем}}}}.

\sphinxAtStartPar
В качестве примера давайте посмотрим, как можно создать запутанное состояние в \sphinxcode{\sphinxupquote{PennyLane}}. Начнем с импортов и создания двухкубитной схемы:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{pennylane} \PYG{k}{as} \PYG{n+nn}{qml}
\PYG{k+kn}{from} \PYG{n+nn}{pennylane} \PYG{k+kn}{import} \PYG{n}{numpy} \PYG{k}{as} \PYG{n}{np}

\PYG{n}{dev} \PYG{o}{=} \PYG{n}{qml}\PYG{o}{.}\PYG{n}{device}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{default.qubit}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{wires}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Далее применим к первому кубиту операцию поворота \(\hat{RX}\), запутаем кубиты с помощью \(\hat{CNOT}\) и далее оценим запутанность с помощью измерения оператора Паули \(\hat{\sigma^z}\):

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nd}{@qml}\PYG{o}{.}\PYG{n}{qnode}\PYG{p}{(}\PYG{n}{dev}\PYG{p}{)}
\PYG{k}{def} \PYG{n+nf}{circuit}\PYG{p}{(}\PYG{n}{param}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{qml}\PYG{o}{.}\PYG{n}{RX}\PYG{p}{(}\PYG{n}{param}\PYG{p}{,} \PYG{n}{wires}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{n}{qml}\PYG{o}{.}\PYG{n}{CNOT}\PYG{p}{(}\PYG{n}{wires}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{qml}\PYG{o}{.}\PYG{n}{expval}\PYG{p}{(}\PYG{n}{qml}\PYG{o}{.}\PYG{n}{PauliZ}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{n}{qml}\PYG{o}{.}\PYG{n}{expval}\PYG{p}{(}\PYG{n}{qml}\PYG{o}{.}\PYG{n}{PauliZ}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
В этом примере значение переменной \sphinxcode{\sphinxupquote{param}} определяет степень запутанности, и для \(\pi/2\) запутанности будет максимальна. В результате оба кубита будут максимально смешанными и средний результат измерения будет нулевым:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{circuit}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi} \PYG{o}{/} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
[1.11022302e\PYGZhy{}16 1.11022302e\PYGZhy{}16]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
(код взят из официальной \sphinxhref{https://pennylane.ai/qml/demos/tutorial\_advanced\_usage.html}{демонстрации} для библиотеки \sphinxcode{\sphinxupquote{PennyLane}})


\subsection{Разложение Шмидта}
\label{\detokenize{book/qc/ru/mixedstates:id16}}
\sphinxAtStartPar
В этом разделе мы познакомимся с важной процедурой – разложением Шмидта, которое тесно связано со спектром редуцированных матриц плотности состояния составной квантовой системы и благодаря которому легко увидеть, является ли состояние системы \sphinxstyleemphasis{запутанным} или нет.

\sphinxAtStartPar
Снова запишем чистое двухчастичное состояние \(\ket{\Phi}\) квантовой системы, в пространстве \(H_{\phi} \otimes H_{\psi}\) двух подсистем \(\phi\) и \(\psi\). Покажем тогда, что \sphinxstyleemphasis{существуют} ортонормированные состояния \(\ket{i_{\phi}}\) системы \(\phi\) и ортонормированные состояния \(\ket{i_{\psi}}\) системы \(\psi\), которые дадут нам разложение:
\begin{equation}\label{equation:book/qc/ru/mixedstates:eqn:schm}
\begin{split}
\ket{\Phi} = \sum_{i} \lambda_{i} \ket{i_{\phi}} \ket{i_{\psi}},
\end{split}
\end{equation}
\sphinxAtStartPar
где \(\lambda_i\) – неотрицательные числа (коэффициенты Шмидта), удовлетворяющие условию \(\sum_{i} \lambda_{i}^{2} = 1\).

\sphinxAtStartPar
Для доказательства рассмотрим случай, когда обе подсистемы имеют пространство одинаковой размерности. Пусть тогда \(\ket{n}\) и \(\ket{k}\) состояния образуют произвольный ортонормированный базис для подсистем  \(\phi\) и \(\psi\). Соответственно, тогда состояние системы  \(\ket{\Phi}\) может быть представлено в виде разложения:
\begin{equation}\label{equation:book/qc/ru/mixedstates:eqn:dec}
\begin{split}
\ket{\Phi} = \sum_{n,k} a_{nk} \ket{n} \ket{k},\ \text{где}\ a_{nk} = \bra{nk} \ket{\Phi}
\end{split}
\end{equation}
\sphinxAtStartPar
Константы разложения \(a_{nk}\) образуют эрмитово\sphinxhyphen{}сопряженную комплексную матрицу \(A\), которую можно привести к диагональному виду. Для этого применим к этой матрице сингулярное разложение (или SVD\sphinxhyphen{}разложение) вида: \(A=U \cdot S \cdot V^{*}\), где \(U\) и \(V\) – унитарные матрицы, а \(S\) – диагональная матрица с неотрицательными действительными числами на диагонали (эти числа называют сингулярными числами матрицы \(A\), и их набор однозначно определяется матрицей). Тогда разложение \eqref{equation:book/qc/ru/mixedstates:eqn:dec} можно привести к виду:
\begin{equation}\label{equation:book/qc/ru/mixedstates:eqn:dec1}
\begin{split}
\ket{\Phi} = \sum_{i,n,k} u_{in}s_{ii}v_{ik} \ket{n} \ket{k}.
\end{split}
\end{equation}
\sphinxAtStartPar
Теперь переопределим базис состояний в подсистемах  \(\phi\) и \(\psi\):
\begin{equation}\label{equation:book/qc/ru/mixedstates:eqn:basis}
\begin{split}
\ket{i_{\phi}}=\sum_{n} u_{ni} \ket{n} \mbox{  ,  } \ket{i_{\psi}}=\sum_{k} v_{ik} \ket{k}
\end{split}
\end{equation}
\sphinxAtStartPar
и обозначим \(s_{ii} \equiv \lambda_{i}\). В результате разложение \eqref{equation:book/qc/ru/mixedstates:eqn:dec1} преобразуется к виду:
\begin{equation*}
\begin{split}
\ket{\Phi} = \sum_{i} \lambda_{i} \ket{i_{\phi}} \ket{i_{\psi}}
\end{split}
\end{equation*}
\sphinxAtStartPar
В силу унитарности \(U\) и \(V\) наборы базисных состояний \(\ket{i_{\phi}}\) и \(\ket{i_{\psi}}\) в \eqref{equation:book/qc/ru/mixedstates:eqn:basis} образуют полную ортонормированную систему, или базис Шмидта, а само представление \eqref{equation:book/qc/ru/mixedstates:eqn:schm} называют \sphinxstylestrong{разложением Шмидта}. Число ненулевых значений коэффициентов Шмидта \(\lambda_i\) называется числом (или рангом \(rank(A)=dim{s_{ii} : s_{ii} > 0}\)) Шмидта для состояния \(\ket{\Phi}\). В теории мер квантовой запутанности это число характеризует степень (или меру) запутанности состояний сложной системы. Чистое двухчастичное состояние запутанно тогда и только тогда, когда его число Шмидта \(> 1\), и чем больше число Шмидта, тем сильнее запутано состояние.

\sphinxAtStartPar
Следствием приведенных выше свойств является важная связь между коэффициентами Шмидта чистого запутанного состояния со спектром его редуцированных матриц плотности
\(\rho_{\phi} = \mbox{Tr}_{\psi} \left( \ket{\Phi}\bra{\Phi}\right)\)  и \(\rho_{\psi} = \mbox{Tr}_{\phi} \left( \ket{\Phi}\bra{\Phi}\right)\). Несложно убедиться, что собственные значения редуцированных матриц \(\rho_{\phi}\) и \(\rho_{\psi}\) совпадают и представляют собой квадраты коэффициентов Шмидта, а их собственные вектора представляют собой состояния \(\ket{i_{\phi}}\) и \(\ket{i_{\psi}}\) соответственно. Эти свойства дают нам удобный алгоритм вычисления разложения Шмидта двухчастичного состояния \(\ket{\Phi}\) через редуцированные матрицы его подсистем: (1) на первом этапе следует вычислить редуцированные матрицы плотности \(\rho_{\phi}\) и \(\rho_{\psi}\); (2) на втором этапе найти общие собственные значения \(a_i\) и соответствующие им собственные векторы   \(\ket{i_{\phi}}\) и \(\ket{i_{\psi}}\) для матриц \(\rho_{\phi}\) и \(\rho_{\psi}\); (3) записать разложение Шмидта в виде:
\begin{equation*}
\begin{split}
\ket{\Phi} = \sum_{i} \sqrt{a_{i}} \ket{i_{\phi}} \ket{i_{\psi}}.
\end{split}
\end{equation*}

\section{Описания эволюции смешанного состояния}
\label{\detokenize{book/qc/ru/mixedstates:id17}}

\subsection{Квантовая динамика}
\label{\detokenize{book/qc/ru/mixedstates:id18}}
\sphinxAtStartPar
Напомним, что квантовая динамика в терминах волновых функций \(\ket{\Psi}\) описывается при помощи уравнения Шредингера:
\begin{equation*}
\begin{split}
i\hbar \frac{\partial \Psi(x, t)}{\partial t} = \hat{H} \Psi(x, t).
\end{split}
\end{equation*}
\sphinxAtStartPar
Аналогичное уравнение можно получить и для матриц плотности. Оно называется уравнением фон Неймана и записывается через коммутатор \([]\), который определен как \([\hat{A}, \hat{B}] = \hat{A}\hat{B} - \hat{B}\hat{A}\):
\begin{equation*}
\begin{split}
i\hbar \frac{\partial \rho}{\partial t} = [\hat{H}, \rho].
\end{split}
\end{equation*}
\sphinxAtStartPar
Аналогично, если действие каких\sphinxhyphen{}то унитарных операций изменяет вектор состояния \(\ket{\Psi}\) на \(\hat{U} \ket{\Psi}\), то матрицу плотности оно должно изменять как
\begin{equation*}
\begin{split}
\sum\limits_{n} p_n \hat{U} \ket{\Psi_n} \bra{\Psi_n} \hat{U}^\dagger = \hat{U}\rho\hat{U}^\dagger.
\end{split}
\end{equation*}
\sphinxAtStartPar
Важное свойство унитарных матриц – их собственные значения по модулю равны единице. Действие унитарного оператора не изменяет собственных значений матрицы плотности, но вращает собственный ее базис. Исходя из этого можно сделать вывод о том, что ни чистота, ни энтропия не могут изменяться в результате унитарных операций.


\subsection{Измерения и томография}
\label{\detokenize{book/qc/ru/mixedstates:id19}}
\sphinxAtStartPar
Квантовая механика работает так, что любое \sphinxhref{../../qc/ru/qubit.html\#id23}{измерение} приводит к коллапсу волновой функции и является необратимым. А еще измерения, например, состояния \(\ket{+}\) и \(\ket{-}\) не различимы при измерениях по оси \(\mathbf{Z}\) – для обоих состояний мы будем получать \(\ket{1}\) и \(\ket{0}\) с вероятностью \(0.5\), то есть нам нужно измерять по \sphinxstyleemphasis{всем} базисам. В общем, получается, что восстановить амплитуду и фазу волновой функции \(\Psi\) это большая проблема, если добавить сюда вероятностный характер измерения.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Строго говоря это не просто “большая” проблема, а настоящая NP\sphinxhyphen{}полная задача оптимизации!
\end{sphinxadmonition}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=250\sphinxpxdimen]{{MarginalDistribution}.png}
\caption{Иллюстрация фазовой проблемы.}\label{\detokenize{book/qc/ru/mixedstates:id21}}\end{figure}

\sphinxAtStartPar
Эта задача обычно решается при помощи квантовой томографии, и восстанавливают как раз не волновую функцию \(\Psi\), а матрицу плотности \(\rho\)  (потому что в реальных экспериментах и задачах почти не бывает чистых состояний).
Представим, что наша квантовая система описывается базисом \(y_i\) – набором из \(2^N\) векторов, причем каждому из этих базисных векторов соответствует свое собственное значение – результат измерения (подробнее об этом было в \sphinxhref{../../qc/ru/qubit.html\#id31}{лекции про кубит}). Тогда если у нас будет достаточно много результатов измерений, то мы сможем восстановить нашу матрицу плотности \(\rho\) методом максимизации правдоподобия. Выражение для правдоподобия в этом случае можно записать как:
\begin{equation*}
\begin{split}
L(\rho) = \prod_i \bra{y_i} \rho \ket{y_i} ^{q_i},
\end{split}
\end{equation*}
\sphinxAtStartPar
где \(q_i\) – это частота получения собственного значения, соответствующего волновой функции \(\ket{y_i}\) (потому что измерение переводит наше состояние в базисный вектор, соответствующий результату измерения). В итоге увеличивая число измерений мы приближаем частоты \(q_i\) к вероятностям \(\bra{\Psi}(\ket{y_i}\bra{y_i})\ket{\Psi}\), а нашу матрицу \(\rho\) к ее истинному виду.

\sphinxAtStartPar
Методы квантовой томографии являются критической частью, в том числе, квантовой связи, так как системы там обычно небольшие, но восстанавливать надо всю матрицу плотности.


\section{Что мы узнали?}
\label{\detokenize{book/qc/ru/mixedstates:id20}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Формализм матрицы плотности позволяет описывать составные системы (например, один кубит в многокубитной системе)

\item {} 
\sphinxAtStartPar
Чаще всего в реальных экспериментах у нас ситуация “мы приготовили состояние, но точно не знаем какое” и волновая функция нам не подходит

\item {} 
\sphinxAtStartPar
Что такое квантовая запутанность и как ее можно описать

\item {} 
\sphinxAtStartPar
Состояние части запутанного состояния – смешанное

\item {} 
\sphinxAtStartPar
Отличие смешанного состояния от чистого можно охарактеризовать параметром типа энтропии

\end{itemize}

\sphinxstepscope


\part{Фреймворки}

\sphinxstepscope


\chapter{О блоке “Фреймворки”}
\label{\detokenize{book/prog/ru/prog_intro:prog-intro-md}}\label{\detokenize{book/prog/ru/prog_intro:id1}}\label{\detokenize{book/prog/ru/prog_intro::doc}}
\sphinxAtStartPar
Этот блок включает в себя обзор фреймворков и библиотек для квантовых вычислений. Основная часть курса будет строиться вокруг библиотеки \sphinxcode{\sphinxupquote{PennyLane}}. Этот фреймворк кажется наиболее простым в освоении, а также является платформо\sphinxhyphen{}независимым, так как представляет собой высокоуровневый API. Дополнительные лекции этого блока расскажут также про:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Qiskit}} от компании IBM;

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{cirq}} и \sphinxcode{\sphinxupquote{Tensorflow Quantum}} от компании Google.

\end{itemize}

\sphinxstepscope


\chapter{Обзор фреймворков для квантовых вычислений}
\label{\detokenize{book/prog/ru/progreview:progreview}}\label{\detokenize{book/prog/ru/progreview:id1}}\label{\detokenize{book/prog/ru/progreview::doc}}
\sphinxAtStartPar
Автор(ы):
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/SemyonSinchenko}{Синченко Семен}

\end{itemize}

\sphinxAtStartPar
В этом обзоре мы кратко пробежимся по существующим сегодня фреймворкам для программирования квантовых компьютеров, а также по тем компьютерам, с которыми они совместимы.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Цель этой лекции – исключительно показать как визуально выглядит тот, или иной фреймворк для программирования квантовых компьютеров. Поэтому не стоит пытаться вникнуть и понять, что именно делает тот, или иной пример приведенного тут кода! Также хочется сразу сказать, что разделение на низкоуровневые и высокоуровневые языки квантового относительно субъективно и эта лекция выражает именно точку зрения ее автора.
\end{sphinxadmonition}


\section{Квантовые ассемблеры}
\label{\detokenize{book/prog/ru/progreview:id2}}

\subsection{OpenQASM}
\label{\detokenize{book/prog/ru/progreview:openqasm}}
\sphinxAtStartPar
В нашем курсе мы в основном будем пользоваться относительно высокоуровневые фреймворки. Однако это не значит, что квантовый программист не имеет возможности программировать на низком уровне. Например, компания \sphinxcode{\sphinxupquote{IBM}} дает доступ к своему квантовому ассемблеру \sphinxhref{https://github.com/QISKit/openqasm}{OpenQASM} {[}\hyperlink{cite.book/bibliography:id57}{CBSG17}{]}, код на котором выглядит примерно так:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/* Measuring the relaxation time of a qubit}
\PYG{c+cm}{ * This example demonstrates the repeated use of fixed delays.}
\PYG{c+cm}{*/}
\PYG{n}{OPENQASM}\PYG{+w}{ }\PYG{l+m+mf}{3.0}\PYG{p}{;}
\PYG{n}{include}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{stdgates.inc}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}

\PYG{n}{duration}\PYG{+w}{ }\PYG{n}{stride}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{1u}\PYG{n}{s}\PYG{p}{;}\PYG{+w}{            }\PYG{c+c1}{// time resolution of points taken}
\PYG{k}{const}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{p}{[}\PYG{l+m+mi}{32}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{points}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{50}\PYG{p}{;}\PYG{+w}{              }\PYG{c+c1}{// number of points taken}
\PYG{k}{const}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{p}{[}\PYG{l+m+mi}{32}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{shots}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{1000}\PYG{p}{;}\PYG{+w}{             }\PYG{c+c1}{// how many shots per point}

\PYG{k+kt}{int}\PYG{p}{[}\PYG{l+m+mi}{32}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{counts0}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{l+m+mi}{32}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{counts1}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{+w}{   }\PYG{c+c1}{// surviving |1\PYGZgt{} populations of qubits}

\PYG{k}{extern}\PYG{+w}{ }\PYG{n}{tabulate}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{[}\PYG{l+m+mi}{32}\PYG{p}{]}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{p}{[}\PYG{l+m+mi}{32}\PYG{p}{]}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{p}{[}\PYG{l+m+mi}{32}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{bit}\PYG{+w}{ }\PYG{n}{c0}\PYG{p}{;}
\PYG{n}{bit}\PYG{+w}{ }\PYG{n}{c1}\PYG{p}{;}

\PYG{n}{defcalgrammar}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{openpulse}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}

\PYG{c+c1}{// define a gate calibration for an X gate on any qubit}
\PYG{n}{defcal}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{n}{\PYGZdl{}q}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{n}{play}\PYG{+w}{ }\PYG{n+nf}{drive}\PYG{p}{(}\PYG{n}{\PYGZdl{}q}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{gaussian}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{30}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k}{for}\PYG{+w}{ }\PYG{n}{p}\PYG{+w}{ }\PYG{n}{in}\PYG{+w}{ }\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{points}\PYG{l+m+mi}{\PYGZhy{}1}\PYG{p}{]}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{n}{in}\PYG{+w}{ }\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{shots}\PYG{p}{]}\PYG{+w}{ }\PYG{p}{\PYGZob{}}

\PYG{+w}{        }\PYG{c+c1}{// start of a basic block}
\PYG{+w}{        }\PYG{n}{reset}\PYG{+w}{ }\PYG{n}{\PYGZdl{}0}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{reset}\PYG{+w}{ }\PYG{n}{\PYGZdl{}1}\PYG{p}{;}

\PYG{+w}{        }\PYG{c+c1}{// excite qubits}
\PYG{+w}{        }\PYG{n}{x}\PYG{+w}{ }\PYG{n}{\PYGZdl{}0}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{x}\PYG{+w}{ }\PYG{n}{\PYGZdl{}1}\PYG{p}{;}

\PYG{+w}{        }\PYG{c+c1}{// wait for a fixed time indicated by loop counter}
\PYG{+w}{        }\PYG{n}{delay}\PYG{p}{[}\PYG{n}{p}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{n}{stride}\PYG{p}{]}\PYG{+w}{ }\PYG{n}{\PYGZdl{}0}\PYG{p}{;}

\PYG{+w}{        }\PYG{c+c1}{// wait for a fixed time indicated by loop counters}
\PYG{+w}{        }\PYG{n}{delay}\PYG{p}{[}\PYG{n}{p}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{n}{durationof}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{n}{x}\PYG{+w}{ }\PYG{n}{\PYGZdl{}1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{]}\PYG{p}{;}

\PYG{+w}{        }\PYG{c+c1}{// read out qubit states}
\PYG{+w}{        }\PYG{n}{c0}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{measure}\PYG{+w}{ }\PYG{n}{\PYGZdl{}0}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{c1}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{measure}\PYG{+w}{ }\PYG{n}{\PYGZdl{}1}\PYG{p}{;}

\PYG{+w}{        }\PYG{c+c1}{// increment counts memories, if a 1 is seen}
\PYG{+w}{        }\PYG{n}{counts0}\PYG{+w}{ }\PYG{o}{+}\PYG{o}{=}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{(}\PYG{n}{c0}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{counts1}\PYG{+w}{ }\PYG{o}{+}\PYG{o}{=}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{(}\PYG{n}{c1}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}

\PYG{+w}{    }\PYG{c+c1}{// log survival probability curve}
\PYG{+w}{    }\PYG{n}{tabulate}\PYG{p}{(}\PYG{n}{counts0}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{shots}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{p}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{tabulate}\PYG{p}{(}\PYG{n}{counts1}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{shots}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{p}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Пример этого кода \sphinxhref{https://github.com/Qiskit/openqasm/blob/master/examples/t1.qasm}{взят} из официального репозитория.


\subsection{PyQuil}
\label{\detokenize{book/prog/ru/progreview:pyquil}}
\sphinxAtStartPar
Другим примером относительно низкоуровневого языка квантового программирования является фреймворк \sphinxhref{https://github.com/rigetti/pyquil}{PyQuil} {[}\hyperlink{cite.book/bibliography:id56}{SCZ17}{]}. Он разработан компанией \sphinxcode{\sphinxupquote{Rigetti Computing}}, производителем одноименных квантовых компьютеров и включает в себя компилятор и виртуальную машину \sphinxcode{\sphinxupquote{QVM}}. Вот так выглядит код на этом фреймворке:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{pyquil} \PYG{k+kn}{import} \PYG{n}{get\PYGZus{}qc}\PYG{p}{,} \PYG{n}{Program}
\PYG{k+kn}{from} \PYG{n+nn}{pyquil}\PYG{n+nn}{.}\PYG{n+nn}{gates} \PYG{k+kn}{import} \PYG{n}{CNOT}\PYG{p}{,} \PYG{n}{H}\PYG{p}{,} \PYG{n}{MEASURE}

\PYG{n}{qvm} \PYG{o}{=} \PYG{n}{get\PYGZus{}qc}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{2q\PYGZhy{}qvm}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{n}{p} \PYG{o}{=} \PYG{n}{Program}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{p} \PYG{o}{+}\PYG{o}{=} \PYG{n}{H}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{p} \PYG{o}{+}\PYG{o}{=} \PYG{n}{CNOT}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{ro} \PYG{o}{=} \PYG{n}{p}\PYG{o}{.}\PYG{n}{declare}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ro}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{BIT}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{p} \PYG{o}{+}\PYG{o}{=} \PYG{n}{MEASURE}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{ro}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{p} \PYG{o}{+}\PYG{o}{=} \PYG{n}{MEASURE}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{ro}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{p}\PYG{o}{.}\PYG{n}{wrap\PYGZus{}in\PYGZus{}numshots\PYGZus{}loop}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}

\PYG{n}{qvm}\PYG{o}{.}\PYG{n}{run}\PYG{p}{(}\PYG{n}{p}\PYG{p}{)}\PYG{o}{.}\PYG{n}{readout\PYGZus{}data}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ro}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{tolist}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Пример взят из официального репозитория.


\section{Высокоуровневое программирование}
\label{\detokenize{book/prog/ru/progreview:id5}}
\sphinxAtStartPar
В таких фреймворках программист имеет возможность уже не только напрямую манипулировать кубитами на низком уровне, но также вызывать высокоуровневые функции, например, \sphinxhref{https://quantumai.google/reference/python/cirq/ops/QuantumFourierTransformGate}{квантовое преобразование Фурье}.


\subsection{Cirq}
\label{\detokenize{book/prog/ru/progreview:cirq}}
\sphinxAtStartPar
Одним из таких фреймворков является \sphinxcode{\sphinxupquote{Cirq}} от компании \sphinxcode{\sphinxupquote{Google}}. Код, написанный на нем можно запускать на симуляторах локально или в облаке, а также используя специально разработанные компанией \sphinxcode{\sphinxupquote{Google}} симуляторы на базе \sphinxstylestrong{T}ensor \sphinxstylestrong{P}rocessing \sphinxstylestrong{U}nits или \sphinxstylestrong{TPU} используя \sphinxcode{\sphinxupquote{Floq API}}. Для целей квантового машинного обучения в связке с \sphinxcode{\sphinxupquote{Cirq}} можно использовать \sphinxcode{\sphinxupquote{Tensorflow Quantum}} – расширение библиотеки для обычного \sphinxstyleemphasis{Deep Leanring}, которое позволяет комбинировать классические и квантовые нейронные сети вместе. Еще в экосистему \sphinxcode{\sphinxupquote{Cirq}} входит также библиотека для квантовой химии \sphinxhref{https://github.com/quantumlib/OpenFermion}{\sphinxcode{\sphinxupquote{OpenFermion}}}.

\sphinxAtStartPar
Вот так выглядит код, написанный на \sphinxcode{\sphinxupquote{Cirq}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{cirq}
\PYG{n}{qubit} \PYG{o}{=} \PYG{n}{cirq}\PYG{o}{.}\PYG{n}{GridQubit}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}

\PYG{n}{circuit} \PYG{o}{=} \PYG{n}{cirq}\PYG{o}{.}\PYG{n}{Circuit}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{circuit}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{cirq}\PYG{o}{.}\PYG{n}{H}\PYG{p}{(}\PYG{n}{qubit}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{circuit}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{cirq}\PYG{o}{.}\PYG{n}{measure}\PYG{p}{(}\PYG{n}{qubit}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{circuit}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Еще больше примеров и более детальный обзор этого фреймворка читайте в {\hyperref[\detokenize{book/prog/ru/cirq_tfq::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{нашей статье про \sphinxcode{\sphinxupquote{Tensorflow Quantum}}}}}}. Также очень рекомендуем ознакомиться с \sphinxhref{https://quantumai.google/}{блогом} “квантового” подразделения компании \sphinxcode{\sphinxupquote{Google}} – \sphinxstyleemphasis{Google Quantum AI}.


\subsection{Q\#}
\label{\detokenize{book/prog/ru/progreview:q}}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Q\#}} это полноценный язык квантового программирования от компании \sphinxcode{\sphinxupquote{Microsoft}}. Этот техногигант также, как и другие, разрабатывает сейчас свои квантовые компьютеры и облачные симуляторы, а также предоставляет облачный доступ к квантовому железу других производителей. Так что программы, написанные на \sphinxcode{\sphinxupquote{Q\#}} можно запускать в облаке \sphinxhref{https://azure.microsoft.com/en-us/services/quantum/}{Azure Quantum}.

\sphinxAtStartPar
В отличии от большинства фреймворков, которые обычно написаны как библиотека для языка \sphinxcode{\sphinxupquote{Python}}, \sphinxcode{\sphinxupquote{Q\#}} использует \sphinxcode{\sphinxupquote{C\#}} для запуска и в целом имеет синтаксис, больше похожий на \sphinxcode{\sphinxupquote{C\#}} или \sphinxcode{\sphinxupquote{Java}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{QuantumRNG}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{open}\PYG{+w}{ }\PYG{n}{Microsoft}\PYG{p}{.}\PYG{n}{Quantum}\PYG{p}{.}\PYG{n}{Intrinsic}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{open}\PYG{+w}{ }\PYG{n}{Microsoft}\PYG{p}{.}\PYG{n}{Quantum}\PYG{p}{.}\PYG{n}{Measurement}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{open}\PYG{+w}{ }\PYG{n}{Microsoft}\PYG{p}{.}\PYG{n}{Quantum}\PYG{p}{.}\PYG{n}{Canon}\PYG{p}{;}

\PYG{+w}{    }\PYG{n}{@EntryPoint}\PYG{p}{(}\PYG{p}{)}
\PYG{+w}{    }\PYG{n}{operation}\PYG{+w}{ }\PYG{n+nf}{GenerateRandomBits}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{:}\PYG{+w}{ }\PYG{n}{Result}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{use}\PYG{+w}{ }\PYG{n}{qubits}\PYG{+w}{ }\PYG{p}{=}\PYG{+w}{ }\PYG{n}{Qubit}\PYG{p}{[}\PYG{l+m}{4}\PYG{p}{]}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{ApplyToEach}\PYG{p}{(}\PYG{n}{H}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{qubits}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{k}{return}\PYG{+w}{ }\PYG{n+nf}{MultiM}\PYG{p}{(}\PYG{n}{qubits}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Этот пример взят из \sphinxhref{https://docs.microsoft.com/en-us/azure/quantum/quickstart-microsoft-qc?view=qsharp-preview\&pivots=platform-ionq}{официальной документации}.

\sphinxAtStartPar
На самом деле \sphinxcode{\sphinxupquote{Q\#}} это не просто язык для программирования квантовых компьютеров, а целая экосистема, в которую кроме самого языка и его стандартной библиотеки также входят:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Библиотека \sphinxhref{https://docs.microsoft.com/en-us/azure/quantum/user-guide/libraries/chemistry/?view=qsharp-preview}{Microsoft.Quantum.Chemistry} для квантовой химии

\item {} 
\sphinxAtStartPar
Библиотека \sphinxhref{https://docs.microsoft.com/en-us/azure/quantum/user-guide/libraries/machine-learning/intro?view=qsharp-preview}{Microsoft.Quantum.MachineLearning} для квантового машинного обучения

\end{itemize}

\sphinxAtStartPar
В качестве отличного источника информации про квантовые вычисления с примерами на \sphinxcode{\sphinxupquote{Q\#}}\sphinxhyphen{}стеке можно использовать потрясающий репозиторий на \sphinxcode{\sphinxupquote{GitHub}}, который называется \sphinxhref{https://github.com/microsoft/QuantumKatas}{QuantumKatas}.


\subsection{Strawberry\sphinxhyphen{}Fields}
\label{\detokenize{book/prog/ru/progreview:strawberry-fields}}
\sphinxAtStartPar
\sphinxhref{https://github.com/XanaduAI/strawberryfields}{\sphinxcode{\sphinxupquote{Strawberry\sphinxhyphen{}Fields}}} это библиотека для работы с фотонными квантовыми компьютерами компании \sphinxcode{\sphinxupquote{Xanadu}}. Эти устройства являются \sphinxstyleemphasis{continuous\sphinxhyphen{}variable quantum computers} и в их основе лежат не бинарные состояния – кубиты, а состояния с непрерывными значениями. Учитывая сложность этого концепта, а также специфичность решаемых на таких устройствах задач мы мало будем о них говорить, но любопытный читатель может ознакомиться, например, с \sphinxhref{https://en.wikipedia.org/wiki/Continuous-variable\_quantum\_information}{этой статьей}.

\sphinxAtStartPar
Вот так выглядит код, написанный с использованием этого фреймворка (пример из \sphinxhref{https://strawberryfields.readthedocs.io/en/stable/introduction/circuits.html}{официальной документации}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{strawberryfields} \PYG{k}{as} \PYG{n+nn}{sf}
\PYG{k+kn}{from} \PYG{n+nn}{strawberryfields} \PYG{k+kn}{import} \PYG{n}{ops}

\PYG{c+c1}{\PYGZsh{} create a 3\PYGZhy{}mode quantum program}
\PYG{n}{prog} \PYG{o}{=} \PYG{n}{sf}\PYG{o}{.}\PYG{n}{Program}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}

\PYG{k}{with} \PYG{n}{prog}\PYG{o}{.}\PYG{n}{context} \PYG{k}{as} \PYG{n}{q}\PYG{p}{:}
    \PYG{n}{ops}\PYG{o}{.}\PYG{n}{Sgate}\PYG{p}{(}\PYG{l+m+mf}{0.54}\PYG{p}{)} \PYG{o}{|} \PYG{n}{q}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
    \PYG{n}{ops}\PYG{o}{.}\PYG{n}{Sgate}\PYG{p}{(}\PYG{l+m+mf}{0.54}\PYG{p}{)} \PYG{o}{|} \PYG{n}{q}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
    \PYG{n}{ops}\PYG{o}{.}\PYG{n}{Sgate}\PYG{p}{(}\PYG{l+m+mf}{0.54}\PYG{p}{)} \PYG{o}{|} \PYG{n}{q}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}
    \PYG{n}{ops}\PYG{o}{.}\PYG{n}{BSgate}\PYG{p}{(}\PYG{l+m+mf}{0.43}\PYG{p}{,} \PYG{l+m+mf}{0.1}\PYG{p}{)} \PYG{o}{|} \PYG{p}{(}\PYG{n}{q}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{ops}\PYG{o}{.}\PYG{n}{BSgate}\PYG{p}{(}\PYG{l+m+mf}{0.43}\PYG{p}{,} \PYG{l+m+mf}{0.1}\PYG{p}{)} \PYG{o}{|} \PYG{p}{(}\PYG{n}{q}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{ops}\PYG{o}{.}\PYG{n}{MeasureFock}\PYG{p}{(}\PYG{p}{)} \PYG{o}{|} \PYG{n}{q}
\end{sphinxVerbatim}

\sphinxAtStartPar
Также к \sphinxcode{\sphinxupquote{Strawberry\sphinxhyphen{}Fields}} идет большое число высокоуровневых API для конкретных приложений к задачам реального мира. Например:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://strawberryfields.readthedocs.io/en/stable/code/api/strawberryfields.apps.similarity.html}{Вычисление схожести графов}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://strawberryfields.readthedocs.io/en/stable/code/api/strawberryfields.apps.train.html}{Gaussian Boson Sampling}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://strawberryfields.readthedocs.io/en/stable/code/api/strawberryfields.apps.clique.html}{Поиск Clique в графах}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://strawberryfields.readthedocs.io/en/stable/code/api/strawberryfields.apps.subgraph.html}{Поиск плотных подграфов}

\end{itemize}

\sphinxAtStartPar
И многие другие, с которыми можно ознакомиться на \sphinxhref{https://strawberryfields.ai/photonics/applications.html}{странице} официальной документации.


\subsection{Qiskit}
\label{\detokenize{book/prog/ru/progreview:qiskit}}
\sphinxAtStartPar
\sphinxhref{https://qiskit.org/overview}{Qiskit} – это один из самых популярных в мире фреймворков для квантовых вычислений от компании \sphinxcode{\sphinxupquote{IBM}}. На самом деле представляет собой даже не фреймворк, а целую экосистему, в которую входят, например:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Уже \sphinxhref{../../prog/ru/progreview.html\#openqasm}{упомянутый нами} квантовый ассемблер \sphinxcode{\sphinxupquote{OpenQASM}}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/Qiskit/qiskit}{Фреймворк} для программирования кубитов, написанный на \sphinxcode{\sphinxupquote{OpenQASM}}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/Qiskit/qiskit-finance}{API для применения квантовых вычислений в финансах}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/Qiskit/qiskit-machine-learning}{API для применения квантовых вычислений в ML}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/Qiskit/qiskit-optimization}{API для применения квантовых вычислений в оптимизации}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/Qiskit/qiskit-nature}{API для применения квантовых вычислений в квантовой химии}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/Qiskit/qiskit-metal}{Открытый CAD для проектирования квантовых компьютеров (!)}

\end{itemize}

\sphinxAtStartPar
И \sphinxhref{https://github.com/Qiskit}{многое другое}.

\sphinxAtStartPar
Код, написанный на \sphinxcode{\sphinxupquote{Qiskit}} выглядит так (пример из \sphinxhref{https://qiskit.org/documentation/intro\_tutorial1.html}{официальной документации}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{from} \PYG{n+nn}{qiskit} \PYG{k+kn}{import} \PYG{n}{QuantumCircuit}\PYG{p}{,} \PYG{n}{transpile}
\PYG{k+kn}{from} \PYG{n+nn}{qiskit}\PYG{n+nn}{.}\PYG{n+nn}{providers}\PYG{n+nn}{.}\PYG{n+nn}{aer} \PYG{k+kn}{import} \PYG{n}{QasmSimulator}
\PYG{k+kn}{from} \PYG{n+nn}{qiskit}\PYG{n+nn}{.}\PYG{n+nn}{visualization} \PYG{k+kn}{import} \PYG{n}{plot\PYGZus{}histogram}

\PYG{c+c1}{\PYGZsh{} Use Aer\PYGZsq{}s qasm\PYGZus{}simulator}
\PYG{n}{simulator} \PYG{o}{=} \PYG{n}{QasmSimulator}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Create a Quantum Circuit acting on the q register}
\PYG{n}{circuit} \PYG{o}{=} \PYG{n}{QuantumCircuit}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Add a H gate on qubit 0}
\PYG{n}{circuit}\PYG{o}{.}\PYG{n}{h}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Add a CX (CNOT) gate on control qubit 0 and target qubit 1}
\PYG{n}{circuit}\PYG{o}{.}\PYG{n}{cx}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Map the quantum measurement to the classical bits}
\PYG{n}{circuit}\PYG{o}{.}\PYG{n}{measure}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} compile the circuit down to low\PYGZhy{}level QASM instructions}
\PYG{c+c1}{\PYGZsh{} supported by the backend (not needed for simple circuits)}
\PYG{n}{compiled\PYGZus{}circuit} \PYG{o}{=} \PYG{n}{transpile}\PYG{p}{(}\PYG{n}{circuit}\PYG{p}{,} \PYG{n}{simulator}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Execute the circuit on the qasm simulator}
\PYG{n}{job} \PYG{o}{=} \PYG{n}{simulator}\PYG{o}{.}\PYG{n}{run}\PYG{p}{(}\PYG{n}{compiled\PYGZus{}circuit}\PYG{p}{,} \PYG{n}{shots}\PYG{o}{=}\PYG{l+m+mi}{1000}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Grab results from the job}
\PYG{n}{result} \PYG{o}{=} \PYG{n}{job}\PYG{o}{.}\PYG{n}{result}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Returns counts}
\PYG{n}{counts} \PYG{o}{=} \PYG{n}{result}\PYG{o}{.}\PYG{n}{get\PYGZus{}counts}\PYG{p}{(}\PYG{n}{compiled\PYGZus{}circuit}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{Total count for 00 and 11 are: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{counts}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Draw the circuit}
\PYG{n}{circuit}\PYG{o}{.}\PYG{n}{draw}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Код, написанный на \sphinxcode{\sphinxupquote{Qiskit}} может быть запущен на квантовых компьютерах от компании \sphinxcode{\sphinxupquote{IBM.}} Для изучения квантовых вычислений с экосистемой \sphinxcode{\sphinxupquote{Qsikit}} можно рекомендовать \sphinxhref{https://qiskit.org/textbook/what-is-quantum.html}{прекрасную онлайн книгу}. Более подробный обзор библиотеки также {\hyperref[\detokenize{book/prog/ru/qiskit::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{в отдельной лекции нашего курса}}}}.


\subsection{Pennylane}
\label{\detokenize{book/prog/ru/progreview:pennylane}}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Pennylane}} это относительно высокоуровневая библиотека для квантовых вычислений и квантового машинного обучения от компании \sphinxcode{\sphinxupquote{Xanadu}}. Вот так выглядит написанный на ней код:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{pennylane} \PYG{k}{as} \PYG{n+nn}{qml}
\PYG{k+kn}{from} \PYG{n+nn}{pennylane} \PYG{k+kn}{import} \PYG{n}{numpy} \PYG{k}{as} \PYG{n}{np}

\PYG{n}{dev} \PYG{o}{=} \PYG{n}{qml}\PYG{o}{.}\PYG{n}{device}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{default.qubit}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{shots}\PYG{o}{=}\PYG{l+m+mi}{1000}\PYG{p}{,} \PYG{n}{wires}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}

\PYG{k}{def} \PYG{n+nf}{make\PYGZus{}entanglement}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{qml}\PYG{o}{.}\PYG{n}{Hadamard}\PYG{p}{(}\PYG{n}{wires}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{n}{qml}\PYG{o}{.}\PYG{n}{CNOT}\PYG{p}{(}\PYG{n}{wires}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{qml}\PYG{o}{.}\PYG{n}{probs}\PYG{p}{(}\PYG{n}{wires}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{circuit} \PYG{o}{=} \PYG{n}{qml}\PYG{o}{.}\PYG{n}{QNode}\PYG{p}{(}\PYG{n}{make\PYGZus{}entanglement}\PYG{p}{,} \PYG{n}{dev}\PYG{p}{)}
\PYG{n}{circuit}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Draw the circuit}
\PYG{n}{qml}\PYG{o}{.}\PYG{n}{drawer}\PYG{o}{.}\PYG{n}{use\PYGZus{}style}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{default}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{qml}\PYG{o}{.}\PYG{n}{draw\PYGZus{}mpl}\PYG{p}{(}\PYG{n}{circuit}\PYG{p}{)}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{fig}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Эта библиотека может использовать в качестве backend любое из:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Cirq}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Qiskit}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Q\#}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Strawberry\sphinxhyphen{}Fields}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{PyQuil}} (через расширение \sphinxhref{https://github.com/PennyLaneAI/pennylane-forest}{Pennylane\sphinxhyphen{}Forest})

\end{itemize}

\sphinxAtStartPar
Но для нас самое главное преимущество этой библиотеки – это огромное количество готовых API для машинного обучения, которые позволяют автоматически считать градиенты и дифференцировать квантовые схемы, или обновлять параметры таких схем градиентным спуском.

\sphinxAtStartPar
В нашем курсе библиотеке \sphinxcode{\sphinxupquote{Pennylane}} посвящена {\hyperref[\detokenize{book/prog/ru/pennylane::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{целая отдельная лекций}}}}.


\section{Заключение}
\label{\detokenize{book/prog/ru/progreview:id6}}

\subsection{Что мы будем использовать в курсе?}
\label{\detokenize{book/prog/ru/progreview:id7}}
\sphinxAtStartPar
В рамках нашего курса мы в основном будем пользоваться библиотекой \sphinxcode{\sphinxupquote{Pennylane}}. Некоторые отдельные лекции будут использовать \sphinxcode{\sphinxupquote{Qiskit}}, но это скорее в порядке исключения.


\subsection{Почему Pennylane?}
\label{\detokenize{book/prog/ru/progreview:id8}}
\sphinxAtStartPar
Но почему \sphinxcode{\sphinxupquote{Pennylane}}, если самым популярным фреймворком является именно \sphinxcode{\sphinxupquote{Qiskit}}? Приведем два основных аргумента.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Сегодня трудно сказать, какое квантовое железо в итоге победит, а большим преимуществом \sphinxcode{\sphinxupquote{Pennylane}} является то, что эта библиотека является верхнеуровневой и может использовать различные backend для запуска на квантовых компьютерах разных производителей. Включая \sphinxcode{\sphinxupquote{Qsikit}} и \sphinxcode{\sphinxupquote{IBM}}.

\item {} 
\sphinxAtStartPar
Наш курс больше про квантовое машинное обучение и именно для этих целей \sphinxcode{\sphinxupquote{Pennylane}} подходит лучше всего. Там есть рутины и API разных уровней, позволяющих где\sphinxhyphen{}то самому писать градиенты квантовых схем и обновлять их параметры, а где\sphinxhyphen{}то просто вызывать готовый метод из \sphinxcode{\sphinxupquote{API}}, чтобы не повторять 10 раз то, что мы уже разбирали в более ранних лекциях.

\end{enumerate}

\sphinxstepscope


\chapter{PennyLane}
\label{\detokenize{book/prog/ru/pennylane:pennylane}}\label{\detokenize{book/prog/ru/pennylane:id1}}\label{\detokenize{book/prog/ru/pennylane::doc}}
\sphinxAtStartPar
Автор(ы):
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/SergeiShirkin}{Ширкин Сергей}

\end{itemize}

\sphinxAtStartPar
\sphinxhref{https://pennylane.ai/}{PennyLane} – библиотека Python для квантового машинного обучения, которую можно использовать для обычных квантовых вычислений. Программы, написанные на PennyLane, можно запускать, используя в качестве бэкенда настоящие квантовые компьютеры от IBM Q, Xanadu, Rigetti и другие, либо квантовые симуляторы.

\sphinxAtStartPar
Кубиты в PennyLane называются по\sphinxhyphen{}особому – \sphinxcode{\sphinxupquote{wires}} (от англ. wires – провода). Такое название, скорее всего, связано с тем, что на квантовых схемах кубиты изображаются в виде продольных линий.

\sphinxAtStartPar
Последовательность квантовых операций называется \sphinxstyleemphasis{квантовой функцией}. Такая функция может принимать в качестве аргументов только хэшируемые объекты. В качестве возвращаемого значения выступают величины, связанные с результатами измерения: ожидаемое значение, вероятности состояний или результаты сэмплирования.

\sphinxAtStartPar
Квантовая функция существует не сама по себе, она запускается на определенном устройстве – симуляторе либо настоящем квантовом компьютере. Такое устройство в PennyLane называется \sphinxcode{\sphinxupquote{device}}.


\section{QNode}
\label{\detokenize{book/prog/ru/pennylane:qnode}}
\sphinxAtStartPar
Квантовые вычисления при использовании PennyLane раскладываются на отдельные узлы, которые называются \sphinxcode{\sphinxupquote{QNode}}. Для их создания используются квантовые функции совместно с \sphinxcode{\sphinxupquote{device}}.

\sphinxAtStartPar
Создавать объекты квантовых узлов можно двумя способами: явно либо с помощью декоратора \sphinxcode{\sphinxupquote{QNode}}.

\sphinxAtStartPar
Рассмотрим первый способ – явное создание узла.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{pennylane} \PYG{k}{as} \PYG{n+nn}{qml}
\PYG{k+kn}{from} \PYG{n+nn}{pennylane} \PYG{k+kn}{import} \PYG{n}{numpy} \PYG{k}{as} \PYG{n}{np}
\PYG{n}{qml}\PYG{o}{.}\PYG{n}{drawer}\PYG{o}{.}\PYG{n}{use\PYGZus{}style}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{default}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{n}{dev} \PYG{o}{=} \PYG{n}{qml}\PYG{o}{.}\PYG{n}{device}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{default.qubit}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{shots}\PYG{o}{=}\PYG{l+m+mi}{1000}\PYG{p}{,} \PYG{n}{wires}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{k}{def} \PYG{n+nf}{make\PYGZus{}entanglement}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{qml}\PYG{o}{.}\PYG{n}{Hadamard}\PYG{p}{(}\PYG{n}{wires}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{n}{qml}\PYG{o}{.}\PYG{n}{CNOT}\PYG{p}{(}\PYG{n}{wires}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{qml}\PYG{o}{.}\PYG{n}{probs}\PYG{p}{(}\PYG{n}{wires}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{circuit} \PYG{o}{=} \PYG{n}{qml}\PYG{o}{.}\PYG{n}{QNode}\PYG{p}{(}\PYG{n}{make\PYGZus{}entanglement}\PYG{p}{,} \PYG{n}{dev}\PYG{p}{)}
\PYG{n}{circuit}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
tensor([0.45, 0.  , 0.  , 0.55], requires\PYGZus{}grad=True)
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{qml}\PYG{o}{.}\PYG{n}{draw\PYGZus{}mpl}\PYG{p}{(}\PYG{n}{circuit}\PYG{p}{)}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{fig}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{pennylane_2_0}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Работая с библиотекой PennyLane для математических операций, можно использовать интерфейс \sphinxcode{\sphinxupquote{NumPy}}, но при этом также пользоваться преимуществами автоматического дифференцирования, которое обеспечивает autograd.
Именно поэтому мы не импортировали \sphinxcode{\sphinxupquote{NumPy}} обычным способом: \sphinxcode{\sphinxupquote{import numpy as np}}, а сделали это так: \sphinxcode{\sphinxupquote{from pennylane import numpy as np}}.

\sphinxAtStartPar
Второй способ создания квантовых узлов – с помощью декоратора \sphinxcode{\sphinxupquote{QNode}}. Пропускаем импорт библиотек и создание устройства, так как в начале код тот же самый:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nd}{@qml}\PYG{o}{.}\PYG{n}{qnode}\PYG{p}{(}\PYG{n}{dev}\PYG{p}{)}
\PYG{k}{def} \PYG{n+nf}{circuit}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{qml}\PYG{o}{.}\PYG{n}{Hadamard}\PYG{p}{(}\PYG{n}{wires}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{n}{qml}\PYG{o}{.}\PYG{n}{CNOT}\PYG{p}{(}\PYG{n}{wires}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{qml}\PYG{o}{.}\PYG{n}{probs}\PYG{p}{(}\PYG{n}{wires}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{circuit}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
[0.499 0.    0.    0.501]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
В данном примере мы взяли двухкубитную систему и создали запутанное состояние, а затем с помощью метода \sphinxcode{\sphinxupquote{probs}} вычислили вероятности получения состояний \(|00\rangle\), \(|01\rangle\), \(|10\rangle\), \(|11\rangle\).


\section{Операторы}
\label{\detokenize{book/prog/ru/pennylane:id2}}
\sphinxAtStartPar
В квантовой функции можно применять операторы X, Y, Z, S, T (\sphinxcode{\sphinxupquote{qml.PauliX}}, \sphinxcode{\sphinxupquote{qml.PauliY}}, \sphinxcode{\sphinxupquote{qml.PauliZ}}, \sphinxcode{\sphinxupquote{qml.S}}, \sphinxcode{\sphinxupquote{qml.T}} соответственно), а также операторы, в которых можно задавать угол вращения вокруг одной из осей в радианах: \sphinxcode{\sphinxupquote{qml.RX}}, \sphinxcode{\sphinxupquote{qml.RY}}, \sphinxcode{\sphinxupquote{qml.RZ}}. Здесь и далее будем использовать \sphinxcode{\sphinxupquote{qml}} как псевдоним библиотеки \sphinxcode{\sphinxupquote{PennyLane}}.

\sphinxAtStartPar
В этой функции мы вращаем кубит под индексом 0 вокруг оси X на 90 градусов из начального состояния \(|0\rangle\) и возвращаем \sphinxstylestrong{ожидаемое значение} \sphinxcode{\sphinxupquote{qml.PauliZ}} для этого кубита с помощью \sphinxcode{\sphinxupquote{qml.expval}}. Вероятности получения состояний \(|0\rangle\) и \(|1\rangle\) равны, так что мы получаем ожидаемое значение, близкое к нулю, что легко проверить:
\begin{equation*}
\begin{split}0.5 \cdot 1 + 0.5 \cdot (-1) = 0\end{split}
\end{equation*}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nd}{@qml}\PYG{o}{.}\PYG{n}{qnode}\PYG{p}{(}\PYG{n}{dev}\PYG{p}{)}
\PYG{k}{def} \PYG{n+nf}{circuit}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{qml}\PYG{o}{.}\PYG{n}{RX}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{wires}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{qml}\PYG{o}{.}\PYG{n}{expval}\PYG{p}{(}\PYG{n}{qml}\PYG{o}{.}\PYG{n}{PauliZ}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{circuit}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
tensor(0.002, requires\PYGZus{}grad=True)
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
В следующем примере мы вращаем кубит на тот же угол 90 градусов, но уже вокруг оси Y. Ожидаемое значение в этот раз ищем для \sphinxcode{\sphinxupquote{qml.PauliX}} и получаем 1, что соответствует вычислениям:
\begin{equation*}
\begin{split}1 \cdot 1 + 0 \cdot (-1) = 1\end{split}
\end{equation*}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nd}{@qml}\PYG{o}{.}\PYG{n}{qnode}\PYG{p}{(}\PYG{n}{dev}\PYG{p}{)}
\PYG{k}{def} \PYG{n+nf}{circuit}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{qml}\PYG{o}{.}\PYG{n}{RY}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{wires}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{qml}\PYG{o}{.}\PYG{n}{expval}\PYG{p}{(}\PYG{n}{qml}\PYG{o}{.}\PYG{n}{PauliX}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{circuit}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
tensor(1., requires\PYGZus{}grad=True)
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
В начале этого урока мы создали устройство, которое создает и запускает одну и ту же схему 1000 раз, каждый раз производя измерения. Поменяем этот параметр:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{dev}\PYG{o}{.}\PYG{n}{shots} \PYG{o}{=} \PYG{l+m+mi}{5}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Посмотрим на результат каждого из этих пяти запусков и измерений для \sphinxcode{\sphinxupquote{qml.PauliZ}}. Квантовая схема будет простой: применим к кубиту с индексом 1 оператор Адамара:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nd}{@qml}\PYG{o}{.}\PYG{n}{qnode}\PYG{p}{(}\PYG{n}{dev}\PYG{p}{)}
\PYG{k}{def} \PYG{n+nf}{circuit}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{qml}\PYG{o}{.}\PYG{n}{Hadamard}\PYG{p}{(}\PYG{n}{wires}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{qml}\PYG{o}{.}\PYG{n}{sample}\PYG{p}{(}\PYG{n}{qml}\PYG{o}{.}\PYG{n}{PauliZ}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{circuit}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
tensor([ 1,  1,  1, \PYGZhy{}1,  1], requires\PYGZus{}grad=True)
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Мы получаем разные результаты: то 1, что соответствует состоянию \(|0\rangle\), то \sphinxhyphen{}1, что соответствует состоянию \(|1\rangle\).

\sphinxAtStartPar
Если вместо \sphinxcode{\sphinxupquote{qml.PauliZ}} брать сэмплы для \sphinxcode{\sphinxupquote{qml.PauliX}}, то результат все время будет один и тот же: 1, что соответствует состоянию \(|+\rangle\) (вектор базиса Адамара).

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nd}{@qml}\PYG{o}{.}\PYG{n}{qnode}\PYG{p}{(}\PYG{n}{dev}\PYG{p}{)}
\PYG{k}{def} \PYG{n+nf}{circuit}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{qml}\PYG{o}{.}\PYG{n}{Hadamard}\PYG{p}{(}\PYG{n}{wires}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{qml}\PYG{o}{.}\PYG{n}{sample}\PYG{p}{(}\PYG{n}{qml}\PYG{o}{.}\PYG{n}{PauliX}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{circuit}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
tensor([1, 1, 1, 1, 1], requires\PYGZus{}grad=True)
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{QubitUnitary}
\label{\detokenize{book/prog/ru/pennylane:qubitunitary}}
\sphinxAtStartPar
В PennyLane можно использовать готовые операторы, либо задавать операторы явно с помощью матриц.

\sphinxAtStartPar
Для этого можно использовать класс \sphinxcode{\sphinxupquote{qml.QubitUnitary}}, который принимает два параметра: U – квадратную унитарную матрицу и \sphinxcode{\sphinxupquote{wires}} – кубиты, на которые действует оператор U.

\sphinxAtStartPar
В качестве примера создадим оператор, осуществляющий обмен состояний между кубитами (SWAP). Такой оператор уже есть в библиотеке PennyLane (\sphinxcode{\sphinxupquote{qml.SWAP}}), но мы создадим его с помощью \sphinxcode{\sphinxupquote{qml.QubitUnitary}}. Сначала мы зададим саму матрицу в виде двумерного массива, используя интерфейс \sphinxcode{\sphinxupquote{NumPy}}:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{U} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
              \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
              \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
              \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Создадим заново устройство, при этом зададим число запусков схемы как \sphinxcode{\sphinxupquote{shots=1}}: чтобы убедиться, что все работает правильно, нам будет достаточно одного запуска.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{dev} \PYG{o}{=} \PYG{n}{qml}\PYG{o}{.}\PYG{n}{device}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{default.qubit}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{shots}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{wires}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Создадим и запустим схему, в которой перед применением операции SWAP, реализованной с помощью \sphinxcode{\sphinxupquote{qml.QubitUnitary}}, один кубит будет находиться в состоянии 1, а другой – в состоянии 0.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nd}{@qml}\PYG{o}{.}\PYG{n}{qnode}\PYG{p}{(}\PYG{n}{dev}\PYG{p}{)}
\PYG{k}{def} \PYG{n+nf}{circuit}\PYG{p}{(}\PYG{n}{do\PYGZus{}swap}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{qml}\PYG{o}{.}\PYG{n}{PauliX}\PYG{p}{(}\PYG{n}{wires}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{k}{if} \PYG{n}{do\PYGZus{}swap}\PYG{p}{:}
        \PYG{n}{qml}\PYG{o}{.}\PYG{n}{QubitUnitary}\PYG{p}{(}\PYG{n}{U}\PYG{p}{,} \PYG{n}{wires}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{qml}\PYG{o}{.}\PYG{n}{sample}\PYG{p}{(}\PYG{n}{qml}\PYG{o}{.}\PYG{n}{PauliZ}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{n}{qml}\PYG{o}{.}\PYG{n}{sample}\PYG{p}{(}\PYG{n}{qml}\PYG{o}{.}\PYG{n}{PauliZ}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Запустим схему сначала без применения операции SWAP:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{circuit}\PYG{p}{(}\PYG{n}{do\PYGZus{}swap}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
tensor([[\PYGZhy{}1],
        [ 1]], requires\PYGZus{}grad=True)
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
А затем – с применением:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{circuit}\PYG{p}{(}\PYG{n}{do\PYGZus{}swap}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
tensor([[ 1],
        [\PYGZhy{}1]], requires\PYGZus{}grad=True)
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Видим, что во втором случае операция SWAP сработала: состояния кубитов поменялись местами. Можно посмотреть, как выглядит такая схема:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{qml}\PYG{o}{.}\PYG{n}{draw\PYGZus{}mpl}\PYG{p}{(}\PYG{n}{circuit}\PYG{p}{)}\PYG{p}{(}\PYG{k+kc}{True}\PYG{p}{)}
\PYG{n}{fig}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{pennylane_26_0}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxstepscope


\chapter{Cirq \& TFQ}
\label{\detokenize{book/prog/ru/cirq_tfq:cirq-tfq}}\label{\detokenize{book/prog/ru/cirq_tfq:id1}}\label{\detokenize{book/prog/ru/cirq_tfq::doc}}
\sphinxAtStartPar
Автор(ы):
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/SemyonSinchenko}{Синченко Семен}

\end{itemize}


\section{Введение}
\label{\detokenize{book/prog/ru/cirq_tfq:id2}}
\sphinxAtStartPar
\sphinxhref{https://quantumai.google/cirq}{Cirq} – это библиотека для работы с квантовыми компьютерами и симуляторами компании \sphinxstyleemphasis{Google}. В рамках темы квантового машинного обучения нам также интересен фреймворк \sphinxhref{https://www.tensorflow.org/quantum/overview}{Tensorflow Quantum} или сокращенно \sphinxcode{\sphinxupquote{TFQ}}. Это высокоуровневая библиотека, которая содержит готовые функции для квантового и гибридного машинного обучения. В качестве системы автоматического дифференцирования, а также для построения гибридных квантово\sphinxhyphen{}классических нейронных сетей там используется библиотека \sphinxhref{https://www.tensorflow.org/overview/}{Tensorflow}.

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
Во всех дальнейших лекциях мы будем использовать в основном библиотеку \sphinxcode{\sphinxupquote{PennyLane}}, так что данная лекция исключительно обзорная и факультативная. В ней мы посмотрим несколько примеров \sphinxstyleemphasis{end2end} обучения квантовых схем на \sphinxcode{\sphinxupquote{TFQ}} без детального объяснения теории и вообще того, что происходит. Основная цель данной лекции – исключительно обзор еще одного инструмента, а не изучение QML! Заинтересованный читатель может вернуться к этому обзору после изучения глав про {\hyperref[\detokenize{book/vqc/ru/vqc::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{VQC}}}}, {\hyperref[\detokenize{book/grads/ru/gradients::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{Градиенты}}}} и \sphinxstylestrong{Квантовые нейросети}.
\end{sphinxadmonition}


\section{Работа с кубитами}
\label{\detokenize{book/prog/ru/cirq_tfq:id3}}

\subsection{Импорты и схема}
\label{\detokenize{book/prog/ru/cirq_tfq:id4}}
\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Tensorflow Quantum}} нельзя установить на \sphinxcode{\sphinxupquote{Windows}}. Если система \sphinxcode{\sphinxupquote{POSIX}}\sphinxhyphen{}совместимая и хотите попробовать запустить примеры кода из этой лекции, то просто в корне данного репозитория наберите команду (если уже установили \sphinxcode{\sphinxupquote{tensorflow}}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
poetry run pip install tensorflow\PYGZhy{}quantum==0.5.1
\end{sphinxVerbatim}

\sphinxAtStartPar
Обладателям компьютеров на системе \sphinxcode{\sphinxupquote{Windows}} можем лишь предложить использовать \sphinxhref{https://docs.microsoft.com/en-us/windows/wsl/about}{\sphinxcode{\sphinxupquote{WSL2}}} или \sphinxcode{\sphinxupquote{Docker}}. В целом эта лекция факультативная и нигде далее \sphinxcode{\sphinxupquote{TFQ}} не используется.

\sphinxAtStartPar
А так, больше информации по установке можно найти в \sphinxhref{https://www.tensorflow.org/quantum/install}{разделе про установку} в официальной документации или у них же на \sphinxhref{https://github.com/tensorflow/quantum/blob/master/docs/install.md}{GitHub}.
\end{sphinxadmonition}

\sphinxAtStartPar
Для начала импортируем \sphinxcode{\sphinxupquote{cirq}}.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{cirq}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Cirq}} рассчитан на работу с квантовым компьютером от компании \sphinxstyleemphasis{Google}, который представляет собой решетку кубитов. Например, вот так выглядит решетка кубитов квантового компьютера \sphinxcode{\sphinxupquote{Sycamore}}:

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{sycamore}.png}
\caption{Изображение из {[}\hyperlink{cite.book/bibliography:id68}{AAB+19}{]}}\label{\detokenize{book/prog/ru/cirq_tfq:sycamore-lattice}}\end{figure}

\sphinxAtStartPar
Поэтому в нем все строится вокруг работы с решеткой кубитов – объектом \sphinxcode{\sphinxupquote{cirq.GridQubit}}. Давайте создадим кубит на решетке, который имеет координаты \((0, 0)\):

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{qubit} \PYG{o}{=} \PYG{n}{cirq}\PYG{o}{.}\PYG{n}{GridQubit}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Следующей важной концепцией в \sphinxcode{\sphinxupquote{Cirq}} является непосредственно квантовая схема. Давайте создадим схему, которая переводит кубит в суперпозицию состояний \(\ket{0}\) и \(\ket{1}\) и измеряет его:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{circuit} \PYG{o}{=} \PYG{n}{cirq}\PYG{o}{.}\PYG{n}{Circuit}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{circuit}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{cirq}\PYG{o}{.}\PYG{n}{H}\PYG{p}{(}\PYG{n}{qubit}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{circuit}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{cirq}\PYG{o}{.}\PYG{n}{measure}\PYG{p}{(}\PYG{n}{qubit}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{circuit}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
(0, 0): ───H───M───
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Запуск и симуляция}
\label{\detokenize{book/prog/ru/cirq_tfq:id6}}
\sphinxAtStartPar
Теперь создадим квантовый симулятор, который посчитает нам результат этой простой схемы на классическом компьютере:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sim} \PYG{o}{=} \PYG{n}{cirq}\PYG{o}{.}\PYG{n}{Simulator}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Как мы знаем, результат измерения такой схемы равен 50\% для состояния \(\ket{0}\), то есть если мы будем сэмплировать, то должны получать \(\sim 0.5\). Проверим это с разным числом сэмплов:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{5 сэмплов: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{sim}\PYG{o}{.}\PYG{n}{sample}\PYG{p}{(}\PYG{n}{circuit}\PYG{p}{,} \PYG{n}{repetitions}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{100 сэмплов: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{sim}\PYG{o}{.}\PYG{n}{sample}\PYG{p}{(}\PYG{n}{circuit}\PYG{p}{,} \PYG{n}{repetitions}\PYG{o}{=}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{1000 сэмплов: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{sim}\PYG{o}{.}\PYG{n}{sample}\PYG{p}{(}\PYG{n}{circuit}\PYG{p}{,} \PYG{n}{repetitions}\PYG{o}{=}\PYG{l+m+mi}{1000}\PYG{p}{)}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
5 сэмплов: (0, 0)    0.8
dtype: float64

100 сэмплов: (0, 0)    0.51
dtype: float64

1000 сэмплов: (0, 0)    0.484
dtype: float64
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Метод \sphinxcode{\sphinxupquote{sim.sample}} возвращает хорошо знакомый всем специалистам в области Data Science объект \sphinxcode{\sphinxupquote{pandas.DataFrame}}.
\end{sphinxadmonition}

\sphinxAtStartPar
Также у нас есть опция запустить схему через метод \sphinxcode{\sphinxupquote{run}}. Может показаться, что это то же самое, но на самом деле в отличие от \sphinxcode{\sphinxupquote{sample}}, метод \sphinxcode{\sphinxupquote{run}} возвращает результат в несколько ином виде; а еще он позволяет запускать программу на реальном квантовом компьютере \sphinxcode{\sphinxupquote{Goolge}} или их новых квантовых симуляторах на TPU:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{sim}\PYG{o}{.}\PYG{n}{run}\PYG{p}{(}\PYG{n}{circuit}\PYG{p}{,} \PYG{n}{repetitions}\PYG{o}{=}\PYG{l+m+mi}{25}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
(0, 0)=1110011001110010000000000
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Тут мы просто видим последовательность наших измерений.


\section{Квантовое машинное обучение}
\label{\detokenize{book/prog/ru/cirq_tfq:id7}}

\subsection{Импорты}
\label{\detokenize{book/prog/ru/cirq_tfq:id8}}
\sphinxAtStartPar
Мы будем использовать \sphinxcode{\sphinxupquote{Tensorflow}} и \sphinxcode{\sphinxupquote{Tensorflow Quantum}}.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{os}
\PYG{n}{os}\PYG{o}{.}\PYG{n}{environ}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{TF\PYGZus{}CPP\PYGZus{}MIN\PYGZus{}LOG\PYGZus{}LEVEL}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{3}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{k+kn}{import} \PYG{n+nn}{tensorflow} \PYG{k}{as} \PYG{n+nn}{tf}
\PYG{k+kn}{import} \PYG{n+nn}{tensorflow\PYGZus{}quantum} \PYG{k}{as} \PYG{n+nn}{tfq}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\subsection{Задача}
\label{\detokenize{book/prog/ru/cirq_tfq:id9}}
\sphinxAtStartPar
Давайте попробуем решить игрушечную задачку классификации простой гибридной квантово\sphinxhyphen{}классической нейронной сетью. У нас будет один квантовый слой и один классический слой. В качестве задачи сгенерируем простенький набор данных, используя рутины \sphinxcode{\sphinxupquote{scikit\sphinxhyphen{}learn}}. Сразу переведем входящие признаки в диапазон от нуля до \(\pi\).

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{sklearn}\PYG{n+nn}{.}\PYG{n+nn}{datasets} \PYG{k+kn}{import} \PYG{n}{make\PYGZus{}classification}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{n}{x}\PYG{p}{,} \PYG{n}{y} \PYG{o}{=} \PYG{n}{make\PYGZus{}classification}\PYG{p}{(}\PYG{n}{n\PYGZus{}samples}\PYG{o}{=}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{n}{n\PYGZus{}features}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{n\PYGZus{}informative}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{random\PYGZus{}state}\PYG{o}{=}\PYG{l+m+mi}{42}\PYG{p}{,} \PYG{n}{n\PYGZus{}redundant}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}

\PYG{k}{def} \PYG{n+nf}{normalize}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{x\PYGZus{}min} \PYG{o}{=} \PYG{n}{x}\PYG{o}{.}\PYG{n}{min}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{x\PYGZus{}max} \PYG{o}{=} \PYG{n}{x}\PYG{o}{.}\PYG{n}{max}\PYG{p}{(}\PYG{p}{)}

    \PYG{k}{return} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi} \PYG{o}{*} \PYG{p}{(}\PYG{n}{x} \PYG{o}{\PYGZhy{}} \PYG{n}{x\PYGZus{}min}\PYG{p}{)} \PYG{o}{/} \PYG{p}{(}\PYG{n}{x\PYGZus{}max} \PYG{o}{\PYGZhy{}} \PYG{n}{x\PYGZus{}min}\PYG{p}{)}

\PYG{n}{x}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{n}{normalize}\PYG{p}{(}\PYG{n}{x}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{x}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n}{normalize}\PYG{p}{(}\PYG{n}{x}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Посмотрим на эти данные:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{cb} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{scatter}\PYG{p}{(}\PYG{n}{x}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{x}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{c}\PYG{o}{=}\PYG{n}{y}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{n}{cb}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{cirq_tfq_17_0}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Кубиты}
\label{\detokenize{book/prog/ru/cirq_tfq:id10}}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Tensorflow Quantum}} позволяет “превращать” параметризированные схемы \sphinxcode{\sphinxupquote{Cirq}} в слои нейронных сетей \sphinxcode{\sphinxupquote{Tensorflow}}. Но для начала нам все равно потребуется схема. Давайте объявим пару кубитов.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{qubits} \PYG{o}{=} \PYG{p}{[}\PYG{n}{cirq}\PYG{o}{.}\PYG{n}{GridQubit}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{n}{cirq}\PYG{o}{.}\PYG{n}{GridQubit}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{]}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{qubits}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
[cirq.GridQubit(0, 0), cirq.GridQubit(0, 1)]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Входной слой нейронной сети}
\label{\detokenize{book/prog/ru/cirq_tfq:id11}}
\sphinxAtStartPar
Определим входной слой, который будет кодировать наши классические данные в квантовые. Сразу закодируем данные. Так как \sphinxcode{\sphinxupquote{Tensorflow}} работает с тензорами, то нам необходимо будет преобразовать схемы в тензор. Для этого есть специальная функция \sphinxcode{\sphinxupquote{convert\_to\_tensor}}.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{data2circuit}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{input\PYGZus{}circuit} \PYG{o}{=} \PYG{n}{cirq}\PYG{o}{.}\PYG{n}{Circuit}\PYG{p}{(}\PYG{p}{)}

    \PYG{n}{input\PYGZus{}circuit}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{cirq}\PYG{o}{.}\PYG{n}{Ry}\PYG{p}{(}\PYG{n}{rads}\PYG{o}{=}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{on}\PYG{p}{(}\PYG{n}{qubits}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{input\PYGZus{}circuit}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{cirq}\PYG{o}{.}\PYG{n}{Ry}\PYG{p}{(}\PYG{n}{rads}\PYG{o}{=}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{on}\PYG{p}{(}\PYG{n}{qubits}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}

    \PYG{k}{return} \PYG{n}{input\PYGZus{}circuit}

\PYG{n}{x\PYGZus{}input} \PYG{o}{=} \PYG{n}{tfq}\PYG{o}{.}\PYG{n}{convert\PYGZus{}to\PYGZus{}tensor}\PYG{p}{(}\PYG{p}{[}\PYG{n}{data2circuit}\PYG{p}{(}\PYG{n}{xi}\PYG{p}{)} \PYG{k}{for} \PYG{n}{xi} \PYG{o+ow}{in} \PYG{n}{x}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\subsection{Слой из параметризованной схемы}
\label{\detokenize{book/prog/ru/cirq_tfq:id12}}
\sphinxAtStartPar
Для создания параметризованных схем в \sphinxcode{\sphinxupquote{Tensorflow Quantum}} используются символы из библиотеки символьных вычислений \sphinxhref{https://www.sympy.org/en/index.html}{\sphinxcode{\sphinxupquote{sympy}}}. Давайте объявим несколько параметров и создадим схему:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{sympy} \PYG{k+kn}{import} \PYG{n}{symbols}

\PYG{n}{params} \PYG{o}{=} \PYG{n}{symbols}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{w1, w2, w3, w4}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{n}{trainable\PYGZus{}circuit} \PYG{o}{=} \PYG{n}{cirq}\PYG{o}{.}\PYG{n}{Circuit}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{trainable\PYGZus{}circuit}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{cirq}\PYG{o}{.}\PYG{n}{H}\PYG{o}{.}\PYG{n}{on}\PYG{p}{(}\PYG{n}{qubits}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{trainable\PYGZus{}circuit}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{cirq}\PYG{o}{.}\PYG{n}{H}\PYG{o}{.}\PYG{n}{on}\PYG{p}{(}\PYG{n}{qubits}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{trainable\PYGZus{}circuit}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{cirq}\PYG{o}{.}\PYG{n}{Ry}\PYG{p}{(}\PYG{n}{rads}\PYG{o}{=}\PYG{n}{params}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{on}\PYG{p}{(}\PYG{n}{qubits}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{trainable\PYGZus{}circuit}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{cirq}\PYG{o}{.}\PYG{n}{Ry}\PYG{p}{(}\PYG{n}{rads}\PYG{o}{=}\PYG{n}{params}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{on}\PYG{p}{(}\PYG{n}{qubits}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{trainable\PYGZus{}circuit}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{cirq}\PYG{o}{.}\PYG{n}{CNOT}\PYG{o}{.}\PYG{n}{on}\PYG{p}{(}\PYG{n}{qubits}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{qubits}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{trainable\PYGZus{}circuit}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{cirq}\PYG{o}{.}\PYG{n}{H}\PYG{o}{.}\PYG{n}{on}\PYG{p}{(}\PYG{n}{qubits}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{trainable\PYGZus{}circuit}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{cirq}\PYG{o}{.}\PYG{n}{H}\PYG{o}{.}\PYG{n}{on}\PYG{p}{(}\PYG{n}{qubits}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{trainable\PYGZus{}circuit}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{cirq}\PYG{o}{.}\PYG{n}{Rx}\PYG{p}{(}\PYG{n}{rads}\PYG{o}{=}\PYG{n}{params}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{on}\PYG{p}{(}\PYG{n}{qubits}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{trainable\PYGZus{}circuit}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{cirq}\PYG{o}{.}\PYG{n}{Rx}\PYG{p}{(}\PYG{n}{rads}\PYG{o}{=}\PYG{n}{params}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{on}\PYG{p}{(}\PYG{n}{qubits}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{trainable\PYGZus{}circuit}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{cirq}\PYG{o}{.}\PYG{n}{CNOT}\PYG{o}{.}\PYG{n}{on}\PYG{p}{(}\PYG{n}{qubits}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{qubits}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{trainable\PYGZus{}circuit}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
(0, 0): ───H───Ry(w1)───@───H───Rx(w3)───@───
                        │                │
(0, 1): ───H───Ry(w2)───X───H───Rx(w4)───X───
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Наблюдаемые}
\label{\detokenize{book/prog/ru/cirq_tfq:id13}}
\sphinxAtStartPar
В качестве операторов, которые мы будем измерять, воспользуемся парой \(\hat{XY}\) и \(\hat{YX}\) для наших кубитов:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ops} \PYG{o}{=} \PYG{p}{[}\PYG{n}{cirq}\PYG{o}{.}\PYG{n}{X}\PYG{o}{.}\PYG{n}{on}\PYG{p}{(}\PYG{n}{qubits}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)} \PYG{o}{*} \PYG{n}{cirq}\PYG{o}{.}\PYG{n}{Y}\PYG{o}{.}\PYG{n}{on}\PYG{p}{(}\PYG{n}{qubits}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,} \PYG{n}{cirq}\PYG{o}{.}\PYG{n}{Y}\PYG{o}{.}\PYG{n}{on}\PYG{p}{(}\PYG{n}{qubits}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)} \PYG{o}{*} \PYG{n}{cirq}\PYG{o}{.}\PYG{n}{X}\PYG{o}{.}\PYG{n}{on}\PYG{p}{(}\PYG{n}{qubits}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\subsection{Гибридная нейронная сеть}
\label{\detokenize{book/prog/ru/cirq_tfq:id14}}
\sphinxAtStartPar
Теперь воспользуемся классическим \sphinxcode{\sphinxupquote{Tensorflow}}, чтобы объявить и скомпилировать нашу нейронную сеть, предварительно добавив в нее один классический слой.
\begin{itemize}
\item {} 
\sphinxAtStartPar
зафиксируем случайный генератор

\end{itemize}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{tf}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{set\PYGZus{}seed}\PYG{p}{(}\PYG{l+m+mi}{42}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}\begin{itemize}
\item {} 
\sphinxAtStartPar
входной тензор – это в нашем случае тензор типа \sphinxcode{\sphinxupquote{string}}, так как это квантовые схемы

\end{itemize}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cirq\PYGZus{}inputs} \PYG{o}{=} \PYG{n}{tf}\PYG{o}{.}\PYG{n}{keras}\PYG{o}{.}\PYG{n}{Input}\PYG{p}{(}\PYG{n}{shape}\PYG{o}{=}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{dtype}\PYG{o}{=}\PYG{n}{tf}\PYG{o}{.}\PYG{n}{dtypes}\PYG{o}{.}\PYG{n}{string}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}\begin{itemize}
\item {} 
\sphinxAtStartPar
квантовый слой

\end{itemize}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{quantum\PYGZus{}layer} \PYG{o}{=} \PYG{n}{tfq}\PYG{o}{.}\PYG{n}{layers}\PYG{o}{.}\PYG{n}{PQC}\PYG{p}{(}\PYG{n}{trainable\PYGZus{}circuit}\PYG{p}{,} \PYG{n}{ops}\PYG{p}{)}\PYG{p}{(}\PYG{n}{cirq\PYGZus{}inputs}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}\begin{itemize}
\item {} 
\sphinxAtStartPar
классический слой и выходной слой

\end{itemize}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{dense\PYGZus{}layer} \PYG{o}{=} \PYG{n}{tf}\PYG{o}{.}\PYG{n}{keras}\PYG{o}{.}\PYG{n}{layers}\PYG{o}{.}\PYG{n}{Dense}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{activation}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{relu}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{(}\PYG{n}{quantum\PYGZus{}layer}\PYG{p}{)}
\PYG{n}{output\PYGZus{}layer} \PYG{o}{=} \PYG{n}{tf}\PYG{o}{.}\PYG{n}{keras}\PYG{o}{.}\PYG{n}{layers}\PYG{o}{.}\PYG{n}{Dense}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{activation}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{sigmoid}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{(}\PYG{n}{dense\PYGZus{}layer}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}\begin{itemize}
\item {} 
\sphinxAtStartPar
компилируем модель и смотрим, что получилось. И сразу указываем метрики, которые хотим отслеживать

\end{itemize}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{model} \PYG{o}{=} \PYG{n}{tf}\PYG{o}{.}\PYG{n}{keras}\PYG{o}{.}\PYG{n}{Model}\PYG{p}{(}\PYG{n}{inputs}\PYG{o}{=}\PYG{n}{cirq\PYGZus{}inputs}\PYG{p}{,} \PYG{n}{outputs}\PYG{o}{=}\PYG{n}{output\PYGZus{}layer}\PYG{p}{)}
\PYG{n}{model}\PYG{o}{.}\PYG{n}{compile}\PYG{p}{(}
    \PYG{n}{optimizer}\PYG{o}{=}\PYG{n}{tf}\PYG{o}{.}\PYG{n}{keras}\PYG{o}{.}\PYG{n}{optimizers}\PYG{o}{.}\PYG{n}{SGD}\PYG{p}{(}\PYG{n}{learning\PYGZus{}rate}\PYG{o}{=}\PYG{l+m+mf}{0.1}\PYG{p}{)}\PYG{p}{,}
    \PYG{n}{loss}\PYG{o}{=}\PYG{n}{tf}\PYG{o}{.}\PYG{n}{keras}\PYG{o}{.}\PYG{n}{losses}\PYG{o}{.}\PYG{n}{BinaryCrossentropy}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
    \PYG{n}{metrics}\PYG{o}{=}\PYG{p}{[}
        \PYG{n}{tf}\PYG{o}{.}\PYG{n}{keras}\PYG{o}{.}\PYG{n}{metrics}\PYG{o}{.}\PYG{n}{BinaryAccuracy}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
        \PYG{n}{tf}\PYG{o}{.}\PYG{n}{keras}\PYG{o}{.}\PYG{n}{metrics}\PYG{o}{.}\PYG{n}{BinaryCrossentropy}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
    \PYG{p}{]}
\PYG{p}{)}
\PYG{n}{model}\PYG{o}{.}\PYG{n}{summary}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Model: \PYGZdq{}model\PYGZdq{}
\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}
 Layer (type)                Output Shape              Param \PYGZsh{}   
=================================================================
 input\PYGZus{}1 (InputLayer)        [(None,)]                 0         
                                                                 
 pqc (PQC)                   (None, 2)                 4         
                                                                 
 dense (Dense)               (None, 2)                 6         
                                                                 
 dense\PYGZus{}1 (Dense)             (None, 1)                 3         
                                                                 
=================================================================
Total params: 13
Trainable params: 13
Non\PYGZhy{}trainable params: 0
\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Предсказания со случайной инициализацией}
\label{\detokenize{book/prog/ru/cirq_tfq:id15}}
\sphinxAtStartPar
Наша нейросеть имеет случайные начальные параметры. Давайте посмотрим, что она предсказывает до обучения:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{preds} \PYG{o}{=} \PYG{n}{model}\PYG{p}{(}\PYG{n}{x\PYGZus{}input}\PYG{p}{)}\PYG{o}{.}\PYG{n}{numpy}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{cb} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{scatter}\PYG{p}{(}\PYG{n}{x}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{x}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{c}\PYG{o}{=}\PYG{n}{preds}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{n}{cb}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{cirq_tfq_37_0}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Обучение сети}
\label{\detokenize{book/prog/ru/cirq_tfq:id16}}\begin{itemize}
\item {} 
\sphinxAtStartPar
запустим обучение

\end{itemize}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}\PYGZpc{}time}
\PYG{n}{model}\PYG{o}{.}\PYG{n}{fit}\PYG{p}{(}\PYG{n}{x}\PYG{o}{=}\PYG{n}{x\PYGZus{}input}\PYG{p}{,} \PYG{n}{y}\PYG{o}{=}\PYG{n}{y}\PYG{p}{,} \PYG{n}{epochs}\PYG{o}{=}\PYG{l+m+mi}{200}\PYG{p}{,} \PYG{n}{verbose}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
CPU times: user 4.34 s, sys: 76.4 ms, total: 4.42 s
Wall time: 4.01 s
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}keras.callbacks.History at 0x7fc0c885ae20\PYGZgt{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}\begin{itemize}
\item {} 
\sphinxAtStartPar
визуализируем логи обучения

\end{itemize}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{f}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{ax}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{model}\PYG{o}{.}\PYG{n}{history}\PYG{o}{.}\PYG{n}{history}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{binary\PYGZus{}accuracy}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{ax}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{model}\PYG{o}{.}\PYG{n}{history}\PYG{o}{.}\PYG{n}{history}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{binary\PYGZus{}crossentropy}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{cirq_tfq_41_0}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}\begin{itemize}
\item {} 
\sphinxAtStartPar
визуализируем предсказания

\end{itemize}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{preds\PYGZus{}after\PYGZus{}training} \PYG{o}{=} \PYG{n}{model}\PYG{p}{(}\PYG{n}{x\PYGZus{}input}\PYG{p}{)}\PYG{o}{.}\PYG{n}{numpy}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{cb} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{scatter}\PYG{p}{(}\PYG{n}{x}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{x}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{c}\PYG{o}{=}\PYG{n}{preds\PYGZus{}after\PYGZus{}training}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{n}{cb}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{cirq_tfq_43_0}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Заключение}
\label{\detokenize{book/prog/ru/cirq_tfq:id17}}
\sphinxAtStartPar
В данной лекции мы познакомились с фреймворком \sphinxcode{\sphinxupquote{Tensorflow Quantum}}. Это достаточно мощный инструмент, особенно в связке с \sphinxcode{\sphinxupquote{Tensorflow}}, так как позволяет использовать большое число готовых методов \sphinxcode{\sphinxupquote{Tensorflow}} и различных расширений. Тем не менее, для целей обучения \sphinxcode{\sphinxupquote{Tensorflow Quantum}} кажется не лучшим выбором, так как имеет много неочевидного синтаксиса и предполагает, как минимум, среднего знания \sphinxcode{\sphinxupquote{Tensorflow}}. Во всех дальнейших лекциях мы будем использовать в основном библиотеку \sphinxcode{\sphinxupquote{PennyLane}}.

\sphinxstepscope


\chapter{Qiskit}
\label{\detokenize{book/prog/ru/qiskit:qiskit}}\label{\detokenize{book/prog/ru/qiskit:id1}}\label{\detokenize{book/prog/ru/qiskit::doc}}
\sphinxAtStartPar
Автор(ы):
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/SemyonSinchenko}{Синченко Семен}

\end{itemize}

\sphinxAtStartPar
В этой лекции мы посмотрим, как при помощи библиотеки \sphinxcode{\sphinxupquote{Qiskit}} можно работать с кубитами и квантовыми схемами.

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
Во всех дальнейших лекциях мы будем, за редким исключением, использовать в основном библиотеку \sphinxcode{\sphinxupquote{PennyLane}}, так что данная лекция исключительно обзорная и факультативная. В ней мы поверхностно познакомимся с концептами \sphinxcode{\sphinxupquote{Qiskit}} и напишем пару примеров по работе с кубитами. Обзор экосистемы \sphinxcode{\sphinxupquote{Qiskit}}, включая \sphinxcode{\sphinxupquote{qiskit\sphinxhyphen{}machine\sphinxhyphen{}learning}} выходит за рамки этой лекции, но в конце мы дадим несколько ссылок для самостоятельного изучения.
\end{sphinxadmonition}


\section{Кубиты}
\label{\detokenize{book/prog/ru/qiskit:id2}}

\subsection{Импорты}
\label{\detokenize{book/prog/ru/qiskit:id3}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{qiskit} \PYG{k+kn}{import} \PYG{n}{QuantumCircuit}
\PYG{k+kn}{from} \PYG{n+nn}{qiskit}\PYG{n+nn}{.}\PYG{n+nn}{providers}\PYG{n+nn}{.}\PYG{n+nn}{aer} \PYG{k+kn}{import} \PYG{n}{QasmSimulator}

\PYG{k+kn}{from} \PYG{n+nn}{qiskit} \PYG{k+kn}{import} \PYG{n}{version}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Qiskit version: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{version}\PYG{o}{.}\PYG{n}{get\PYGZus{}version\PYGZus{}info}\PYG{p}{(}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Qiskit version: 0.18.3
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Симулятор}
\label{\detokenize{book/prog/ru/qiskit:id4}}
\sphinxAtStartPar
Для запуска мы будем использовать симулятор квантового компьютера \sphinxcode{\sphinxupquote{QasmSimulator}}:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{simulator} \PYG{o}{=} \PYG{n}{QasmSimulator}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
В \sphinxcode{\sphinxupquote{Qiskit}} поддерживается несколько симуляторов, например:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://qiskit.org/documentation/stubs/qiskit.providers.aer.UnitarySimulator.html\#qiskit.providers.aer.UnitarySimulator}{UnitarySimulator} – симулятор унитарной динамики идеальной схемы;

\item {} 
\sphinxAtStartPar
\sphinxhref{https://qiskit.org/documentation/stubs/qiskit.providers.aer.StatevectorSimulator.html\#qiskit.providers.aer.StatevectorSimulator}{StatevectorSimulator} – симулятор волновой функции идеальной схемы;

\item {} 
\sphinxAtStartPar
\sphinxhref{https://qiskit.org/documentation/stubs/qiskit.providers.aer.QasmSimulator.html\#qiskit.providers.aer.QasmSimulator}{QasmSimulator} – симулятор, который моделирует шумы;

\end{itemize}

\sphinxAtStartPar
Мы использовали лишь один из них. В целом, модуль \sphinxcode{\sphinxupquote{qiskit.providers}} предоставляет базовые абстракции, которые позволяют запускать наш код на разных backend, включая реальные квантовые компьютеры, просто поменяв одну строчку в коде.


\subsection{Квантовая схема}
\label{\detokenize{book/prog/ru/qiskit:id5}}
\sphinxAtStartPar
Ключевым элементом в \sphinxcode{\sphinxupquote{Qiskit}} является квантовая схема – экземпляр класса \sphinxcode{\sphinxupquote{QuantumCircuit}}. Создадим такую схему:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{circuit} \PYG{o}{=} \PYG{n}{QuantumCircuit}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
В \sphinxcode{\sphinxupquote{Qiskit}} необходимо явно указывать не только количество кубитов, которые нам необходимы, но также и количество классических битов, которые необходимы будут нам для измерений. В данном случае мы создали квантовую схему с двумя кубитами и двумя битами.


\section{Квантовые гейты}
\label{\detokenize{book/prog/ru/qiskit:id6}}
\sphinxAtStartPar
Давайте попробуем воспроизвести функцию \sphinxcode{\sphinxupquote{make\_entanglement}} из \sphinxhref{../../prog/ru/pennylane.html\#qnode}{лекции про \sphinxcode{\sphinxupquote{Pennylane}}}. Применим \sphinxhref{../../qc/ru/qubit.html\#id20}{гейт Адамара} к первому кубиту, а потом применим \sphinxhref{../../qc/ru/gates.html\#cnot-cx}{гейт CNOT (CX)}:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{circuit}\PYG{o}{.}\PYG{n}{h}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{circuit}\PYG{o}{.}\PYG{n}{cx}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}qiskit.circuit.instructionset.InstructionSet at 0x7f087838dd30\PYGZgt{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
И добавим шаг измерений:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{circuit}\PYG{o}{.}\PYG{n}{measure}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}qiskit.circuit.instructionset.InstructionSet at 0x7f087838de80\PYGZgt{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Компиляция и запуск схемы}
\label{\detokenize{book/prog/ru/qiskit:id7}}
\sphinxAtStartPar
Квантовые схемы \sphinxcode{\sphinxupquote{Qiskit}} должны быть скомпилированы в инструкции \sphinxhref{../../prog/ru/progreview.html\#openqasm}{квантового ассемблера}. Для этого используется функция \sphinxcode{\sphinxupquote{transpile}}:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{qiskit} \PYG{k+kn}{import} \PYG{n}{transpile}

\PYG{n}{compiled\PYGZus{}circuit} \PYG{o}{=} \PYG{n}{transpile}\PYG{p}{(}\PYG{n}{circuit}\PYG{p}{,} \PYG{n}{simulator}\PYG{p}{)}
\PYG{n}{job} \PYG{o}{=} \PYG{n}{simulator}\PYG{o}{.}\PYG{n}{run}\PYG{p}{(}\PYG{n}{compiled\PYGZus{}circuit}\PYG{p}{,} \PYG{n}{shots}\PYG{o}{=}\PYG{l+m+mi}{1000}\PYG{p}{)}
\PYG{n}{result} \PYG{o}{=} \PYG{n}{job}\PYG{o}{.}\PYG{n}{result}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{counts} \PYG{o}{=} \PYG{n}{result}\PYG{o}{.}\PYG{n}{get\PYGZus{}counts}\PYG{p}{(}\PYG{n}{compiled\PYGZus{}circuit}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Number of }\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{00}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{counts}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{00}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Number of }\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{11}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{counts}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{11}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Number of \PYGZsq{}00\PYGZsq{}: 506
Number of \PYGZsq{}11\PYGZsq{}: 494
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Мы получили результат, аналогичный \sphinxhref{../../prog/ru/pennylane.html\#qnode}{полученному в лекции про \sphinxcode{\sphinxupquote{Pennylane}}}: вероятности получения результата \(\ket{00}\) и \(\ket{11}\) равны \(\sim 0.5\), а другие результаты мы получить не можем.


\section{Визуализация}
\label{\detokenize{book/prog/ru/qiskit:id8}}
\sphinxAtStartPar
В \sphinxcode{\sphinxupquote{Qiskit}} есть очень мощные средства визуализации как результатов измерений, так и самих квантовых схем. Например, мы можем посмотреть результаты измерения \sphinxcode{\sphinxupquote{counts}} в виде графика:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{qiskit}\PYG{n+nn}{.}\PYG{n+nn}{visualization} \PYG{k+kn}{import} \PYG{n}{plot\PYGZus{}histogram}

\PYG{n}{plot\PYGZus{}histogram}\PYG{p}{(}\PYG{n}{counts}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
/home/runner/work/qmlcourse/qmlcourse/.venv/lib/python3.8/site\PYGZhy{}packages/qiskit/visualization/counts\PYGZus{}visualization.py:226: MatplotlibDeprecationWarning: The label function was deprecated in Matplotlib 3.1 and will be removed in 3.8. Use Tick.label1 instead.
  tick.label.set\PYGZus{}fontsize(14)
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{qiskit_13_1}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
А также визуализировать саму квантовую схему:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{circuit}\PYG{o}{.}\PYG{n}{draw}\PYG{p}{(}\PYG{n}{output}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{mpl}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{qiskit_15_0}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
В данном случае мы использовали \sphinxcode{\sphinxupquote{MatplotlibDrawe}}, который позволяет делать очень красивые и легко читаемые визуализации квантовых схем – это одна из причин почему \sphinxcode{\sphinxupquote{Qiskit}} часто используют в курсах по основам квантовых вычислений.


\section{Экосистема Qiskit}
\label{\detokenize{book/prog/ru/qiskit:id9}}
\sphinxAtStartPar
Для более подробного изучения всей экосистемы \sphinxcode{\sphinxupquote{Qiskit}} мы рекомендуем \sphinxhref{https://qiskit.org/textbook/what-is-quantum.html}{онлайн книгу}, которая также является прекрасным источником для изучения базовых и продвинутых квантовых алгоритмов. Для знакомства со средствами для квантового машинного обучения можно также изучить \sphinxhref{https://qiskit.org/documentation/machine-learning/getting\_started.html\#installation}{документацию библиотеки \sphinxcode{\sphinxupquote{qiskit\sphinxhyphen{}machine\sphinxhyphen{}learning}}}, в которой представлены высокоуровневые API для таких вещей, как, например, \sphinxhref{https://qiskit.org/documentation/machine-learning/stubs/qiskit\_machine\_learning.algorithms.QSVC.html\#qiskit\_machine\_learning.algorithms.QSVC}{квантовый  SVM}, или \sphinxhref{https://qiskit.org/documentation/machine-learning/stubs/qiskit\_machine\_learning.algorithms.QGAN.html\#qiskit\_machine\_learning.algorithms.QGAN}{квантовая Generative Adversarial Network}.

\sphinxstepscope


\part{Базовые квантовые алгоритмы}

\sphinxstepscope


\chapter{О блоке “Базовые квантовые алгоритмы”}
\label{\detokenize{book/qcalgo/ru/qcalgo_intro:qcalgo-intro}}\label{\detokenize{book/qcalgo/ru/qcalgo_intro:id1}}\label{\detokenize{book/qcalgo/ru/qcalgo_intro::doc}}
\sphinxAtStartPar
Этот блок включает в себя:
\begin{itemize}
\item {} 
\sphinxAtStartPar
общий обзор наиболее известных квантовых алгоритмов;

\item {} 
\sphinxAtStartPar
реализации алгоритмов Дойча и квантовой телепортации.

\end{itemize}

\sphinxAtStartPar
Продвинутые темы блока дополнительно рассказывают об алгоритмах:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Саймона;

\item {} 
\sphinxAtStartPar
Гровера.

\end{itemize}

\sphinxstepscope


\chapter{Обзор квантовых алгоритмов}
\label{\detokenize{book/qcalgo/ru/quantum_algorithms_overview:quantum-algorithms-overview}}\label{\detokenize{book/qcalgo/ru/quantum_algorithms_overview:id1}}\label{\detokenize{book/qcalgo/ru/quantum_algorithms_overview::doc}}
\sphinxAtStartPar
Автор(ы):
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/SergeiShirkin}{Ширкин Сергей}

\end{itemize}

\sphinxAtStartPar
Квантовые вычисления открывают новые возможности решения задач, для которых ранее были известны только классические алгоритмы решения. С появлением идеи квантового компьютера стало понятно, что нахождение ответа для многих задач можно значительно ускорить. При этом некоторым сложным задачам, решить которые классическим способом в разумные сроки невозможно, квантовый компьютер дает реальный шанс быть решенными.


\section{Классификация задач по временной сложности}
\label{\detokenize{book/qcalgo/ru/quantum_algorithms_overview:id2}}
\sphinxAtStartPar
Вообще, в соответствии с теорией алгоритмов, задачи можно разбить на классы по временной сложности их решения. Также часто используется классификация задач по объему необходимой памяти (пространственная сложность), но нас в первую очередь волнует, насколько быстро мы сможем найти правильный ответ, так что поговорим о временной сложности. Класс задач \(P\) – это те задачи, которые возможно решить на классическом компьютере за полиномиальное время, их сложность можно представить как \(O(n^k)\). Соответственно, решение задач этого класса не является драматически затратным по времени (за исключением случаев, когда степень полинома высока, хотя такие алгоритмы и не являются типичными).

\sphinxAtStartPar
Другой класс задач – \(NP\) (расшифровывается как “недетерминировано полиномиальные”). Это класс задач, для которых неизвестно полиномиальное классическое решение. При этом проверка решения возможна за полиномиальное время. К примеру, нахождение простых множителей большого числа с помощью известных классических алгоритмов – субэкспоненциально сложная задача (работает за время, большее, чем полиномиальное, но меньшее, чем экспоненциальное). Проверить же найденное решение предельно просто: достаточно перемножить найденные простые числа.

\sphinxAtStartPar
Среди \(NP\)\sphinxhyphen{}задач есть наиболее сложные задачи, которые выделяют в специальную группу под названием \(NP\)\sphinxhyphen{}полные задачи (или \(NP\)\sphinxhyphen{}complete). Если найти для них быстрое решение, то этот способ решения также можно применить и к “обычным” \(NP\)\sphinxhyphen{}задачам.

\sphinxAtStartPar
Вообще, есть также задачи, которые, хотя и не относятся к классу \(NP\), но несмотря на это, к ним все же можно свести задачи из \(NP\)\sphinxhyphen{}класса. В совокупности с \(NP\)\sphinxhyphen{}полными задачами они образуют класс \(NP\)\sphinxhyphen{}трудных задач (\(NP\)\sphinxhyphen{}hard).

\sphinxAtStartPar
К примеру, к \(NP\)\sphinxhyphen{}hard задачам относится задача коммивояжера, в которой требуется установить кратчайший путь. Как решение, так и его проверка в данном случае займет суперполиномиальное время, так что эта задача не входит в класс \(NP\)\sphinxhyphen{}complete. Если же ее немного упростить, так что решением будет являться путь не дольше заданного, то такая разновидность задачи является примером класса \(NP\)\sphinxhyphen{}complete, так проверка ее решения не требует времени, большего, чем полиномиальное.

\sphinxAtStartPar
Если дать возможность классическому компьютеру решать задачи с привнесением случайности, так что компьютер получает правильный ответ с высокой вероятностью (стандартно берут порог не менее \(\frac{2}{3}\), хотя достаточно, чтобы вероятность была константой больше 0.5), то можно говорить о классе задач \(BPP\) (сокращение от англ. bounded\sphinxhyphen{}error, probabilistic, polynomial). Такие задачи получается решить за полиномиальное время, причем точность решения можно сколько угодно увеличивать, повторно запуская алгоритм. Квантовый аналог таких задач – класс \(BQP\) (от англ. bounded error quantum polynomial time). Это задачи, которые получается решить на квантовом компьютере за полиномиальное время, обеспечивая точность решения повторным запуском алгоритма. Наиболее известный пример такой задачи – факторизация чисел, решаемая на квантовом компьютере с помощью алгоритма Шора.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{problem_classes}.png}
\caption{Классы задач по временной сложности}\label{\detokenize{book/qcalgo/ru/quantum_algorithms_overview:problem-classes}}\end{figure}

\sphinxAtStartPar
На данный момент можно говорить о том, что класс \(BQP\) включает в себя в том числе и задачи, для которых неизвестно полиномиальное классическое решение, что позволяет относиться к квантовым вычислениям с оптимизмом.


\section{Наиболее известные квантовые алгоритмы}
\label{\detokenize{book/qcalgo/ru/quantum_algorithms_overview:id3}}
\sphinxAtStartPar
Квантовые вычисления, несмотря на новые возможности, которые они предоставляют, все же не являются панацеей: не для всех классических “медленных” (то есть, не решаемых за полиномиальное время) алгоритмов пока удалось найти ускоренный квантовый аналог. Более того, многие даже более простые задачи в настоящий момент выгоднее решать на классических компьютерах. Тем не менее, уже найдены квантовые алгоритмы, работающие быстрее классических. Кратко расскажем о наиболее важных из них.

\sphinxAtStartPar
\sphinxstylestrong{Алгоритм Шора} – алгоритм, наделавший больше всего шума и привлекший внимание научно\sphinxhyphen{}популярных СМИ к квантовым вычислениям. Действительно, этот алгоритм дает повод для беспокойства, так как он позволяет узнавать содержание сообщений, зашифрованных с помощью алгоритма шифрования RSA. Для расшифровки требуется разложить большое число на два простых множителя. Для классического компьютера решение этой задачи может занять несколько тысяч лет, а для алгоритма Шора это дело считанных часов или даже минут. Такая скорость вычислений обусловлена тем, что на квантовом компьютере удается ускорить преобразование Фурье (как прямое так и обратное). Благодаря алгоритму Шора начала развиваться квантовая криптография – шифрование, неуязвимое для атак.

\sphinxAtStartPar
Еще один алгоритм, способный преобразить мир ИТ – \sphinxstylestrong{алгоритм Гровера}. Благодаря ему возможно ускорить поиск по базе данных. Если на классическом компьютере решить задачу поиска элемента в базе данных возможно только перебором всех элементов, то на квантовом компьютере можно получить квадратичное уменьшение сложности, так как за счет использования эффектов суперпозиции и квантовой запутанности алгоритм Гровера “просматривает” одновременно все элементы, хотя и делает это много раз, постепенно выявляя правильное решение.

\sphinxAtStartPar
Некоторые квантовые алгоритмы пока не выглядят полезными с практической точки зрения, но даже и в таком случае они уже демонстрируют возможности, которых нет в классических вычислениях. К примеру, \sphinxstylestrong{алгоритм Дойча} и \sphinxstylestrong{алгоритм Саймона} не несут особой практической пользы в силу своей простоты, но даже такие простые примеры квантовых вычислений демонстрируют значительное ускорение (в данном случае экспоненциальное). Эти алгоритмы позволяют быстро установить свойства функций. Если алгоритм Дойча определяет, является ли функция сбалансированной, то с помощью алгоритма Саймона можно вычислить период некоторой функции.


\subsection{Перспективы квантовых алгоритмов}
\label{\detokenize{book/qcalgo/ru/quantum_algorithms_overview:id4}}
\sphinxAtStartPar
С увеличением числа кубитов и уменьшением количества ошибок в квантовых компьютерах известные квантовые алгоритмы смогут показать себя в полной мере, но также станет возможным находить новые, более сложные и практически полезные квантовые алгоритмы. Заниматься их поиском в ближайшее время будут не только физики и математики, но и программисты, освоившие квантовые вычисления.


\section{Алгоритмы в нашем курсе}
\label{\detokenize{book/qcalgo/ru/quantum_algorithms_overview:id5}}
\sphinxAtStartPar
Для более глубокого погружения в детали этих квантовых алгоритмов у нас в курсе есть отдельные лекции по:
\begin{itemize}
\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{book/qcalgo/ru/deutschs_algorithm::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{Алгоритм Дойча (начальный уровень)}}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{book/qcalgo/ru/quantum_teleportation::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{Квантовая телепортация (начальный уровень) на Qiskit}}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{book/qcalgo/ru/grovers_algorithm::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{Алгоритм Гровера (продвинутый уровень)}}}}

\end{itemize}

\sphinxstepscope


\chapter{Алгоритм Дойча}
\label{\detokenize{book/qcalgo/ru/deutschs_algorithm:deutschs-algorithm}}\label{\detokenize{book/qcalgo/ru/deutschs_algorithm:id1}}\label{\detokenize{book/qcalgo/ru/deutschs_algorithm::doc}}
\sphinxAtStartPar
Автор(ы):
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/SergeiShirkin}{Ширкин Сергей}

\end{itemize}

\sphinxAtStartPar
\sphinxstylestrong{Алгоритм Дойча} (в английском варианте – \sphinxstylestrong{Deutsch’s algorithm}) – это один из первых алгоритмов, показавших, что квантовый компьютер может решать задачи особым способом, отличающимся как от алгоритмов классического компьютера, так и от интуиции и здравого смысла человека. При этом такое решение может занимать меньшее количество шагов.

\sphinxAtStartPar
Нужно прежде всего сказать, что алгоритм Дойча не имеет практического применения в силу своей предельной простоты, зато является простейшим примером, с помощью которого можно понять, в чем состоит отличие квантовых алгоритмов от классических. Данный алгоритм был предложен в 1985 году, когда квантовых компьютеров еще не было, а практически он был реализован в 1998 году на 2\sphinxhyphen{}кубитном квантовом компьютере, работавшем на принципах ядерно\sphinxhyphen{}магнитного резонанса.

\begin{sphinxadmonition}{note}{Дэвид Дойч}

\sphinxAtStartPar
Помимо занятий теоретической физикой в Оксфордском университете, Дэвид Дойч – автор книг “Структура реальности” и “Начало бесконечности”, в которых он популярно излагает идеи квантовых вычислений с точки зрения многомировой интерпретеции (сторонником которой является) и философствует о будущем науки и человечества. Так что можно сказать, что работа алгоритма, согласно замыслу создателя, производится в параллельных вселенных. Так это или нет, пока проверить невозможно, но вычисления работают, и это главное.
\end{sphinxadmonition}

\sphinxAtStartPar
Итак, в чем состоит задача, которую решает алгоритм? Представьте, что у вас есть функция, которая представляет собой “черный ящик”, принимающий на вход число из множества \(\{0, 1\}\). Функция неким образом обрабатывает входное значение и возвращает число из этого же множества, то есть либо \(0\), либо \(1\). Нам известно, что эта функция принадлежит либо к классу сбалансированных функций, либо к классу константных функций (которые мы также можем называть несбалансированными). Задача алгоритма – установить, к какому классу принадлежит функция.

\sphinxAtStartPar
Рассмотрим все варианты этих двух классов. Всего их четыре, то есть по две функции в каждом классе. Начнем с несбалансированных:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\(f_1(x) = 0\)

\end{itemize}

\sphinxAtStartPar
Это функция, всегда возвращающая \(0\), независимо от входного значения. Для нее справедливы выражения:
\begin{equation*}
\begin{split}
f_1(0) = 0
\end{split}
\end{equation*}\begin{equation*}
\begin{split}
f_1(1) = 0
\end{split}
\end{equation*}\begin{itemize}
\item {} 
\sphinxAtStartPar
\(f_2(x) = 1\)

\end{itemize}

\sphinxAtStartPar
Такая функция всегда возвращает \(1\), то есть верно следующее:
\begin{equation*}
\begin{split}
f_2(0) = 1
\end{split}
\end{equation*}\begin{equation*}
\begin{split}
f_2(1) = 1
\end{split}
\end{equation*}
\sphinxAtStartPar
Ну а теперь посмотрим на сбалансированные функции. Для них характерно то, что они могут возвращать как \(0\), так и \(1\). В этом и заключается “баланс”.
\begin{itemize}
\item {} 
\sphinxAtStartPar
\(f_3(x) = x\)

\end{itemize}

\sphinxAtStartPar
Это тождественная функция, которая ничего не делает с входным значением. Для нее справедливо следующее:
\begin{equation*}
\begin{split}
f_3(0) = 0
\end{split}
\end{equation*}\begin{equation*}
\begin{split}
f_3(1) = 1
\end{split}
\end{equation*}\begin{itemize}
\item {} 
\sphinxAtStartPar
\(f_4(x) = \overline{x}\)

\end{itemize}

\sphinxAtStartPar
А вот эта функция инвертирует входное значение, то есть возвращает не то число, которое было подано на вход, а другое:
\begin{equation*}
\begin{split}
f_4(0) = 1
\end{split}
\end{equation*}\begin{equation*}
\begin{split}
f_4(1) = 0
\end{split}
\end{equation*}
\sphinxAtStartPar
Классический компьютер справляется с задачей за два шага. Например, нам дана некоторая функция\sphinxhyphen{}“черный ящик”, и мы должны установить, сбалансирована ли она. На первом шаге мы отправляем в функцию входное значение \(0\). Допустим, мы получили на выходе также \(0\). Мы можем сказать, что данная функция – либо \(f_1\) (константная функция, всегда возвращающая \(0\)), либо \(f_3\) (сбалансированная функция, не меняющая входное значение). Для окончательного решения мы должны сделать еще один шаг – отправить в функцию значение \(1\). Если при этом мы получим опять \(0\), то это функция \(f_1\), а если получили на выходе \(1\), то искомая функция – \(f_3\).

\sphinxAtStartPar
Способа, с помощью которого на классическом компьютере можно за одно действие установить, сбалансирована функция или нет, не существует. И здесь свое преимущество показывает квантовый компьютер: он может установить класс функции за одно действие.

\sphinxAtStartPar
Для начала рассмотрим простейшую схему, с помощью которой можно отправлять число на вход и получать ответ от черного ящика:

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{scheme_1}.png}
\caption{Схема 1}\label{\detokenize{book/qcalgo/ru/deutschs_algorithm:scheme-1}}\end{figure}

\sphinxAtStartPar
\(U_f\) на данной схеме – это неизвестная функция (ее также часто называют “оракул”), являющаяся унитарным оператором. Обратите внимание, что в квантовой схеме используются два кубита. Это нужно для того, чтобы информация, с которой работает квантовый компьютер, не стиралась. В квантовом компьютере важно, чтобы все действия с кубитами (кроме операции измерения) были обратимыми, а для этого информация должна сохраняться. В верхнем кубите будет записано входное значение, а в нижнем – выходное значение функции. Таким образом, входное значение не будет перезаписано значением, которое вернет функция.

\sphinxAtStartPar
Но нам важно будет не только сохранить значение \(|x\rangle\), но также и не разрушить \(|y\rangle\). Так как кубит \(y\) очевидно имеет некоторое изначальное значение, мы не можем его просто перезаписать тем числом, которое выдаст функция \(f(x)\). Здесь на помощь приходит операция исключающее ИЛИ \sphinxhyphen{} \(XOR\) (также ее можно называть сложением по модулю 2), обозначенная на схеме как \(\oplus\). В процессе работы черный ящик \(U_f\) не только находит значение \(f(x)\), но и применяет исключающее ИЛИ к значениям \(y\) и \(f(x)\).

\sphinxAtStartPar
Операции \(XOR\) соответствует такая таблица истинности:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
a
&\sphinxstyletheadfamily 
\sphinxAtStartPar
b
&\sphinxstyletheadfamily 
\sphinxAtStartPar
a XOR b
\\
\hline
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
\\
\hline
\sphinxAtStartPar
0
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
1
\\
\hline
\sphinxAtStartPar
1
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
1
\\
\hline
\sphinxAtStartPar
1
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
0
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
Операция \(XOR\) хороша для нас тем, что она не разрушает значение \(|y\rangle\), так как является обратимой. Убедиться в этом можно, проверив тождество:
\begin{equation*}
\begin{split}
(a \oplus b) \oplus b = a
\end{split}
\end{equation*}
\sphinxAtStartPar
\sphinxstyleemphasis{Схема 1} пока что не дает преимущества по сравнению с классическим компьютером, но мы можем ее немного усовершенствовать:

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=500\sphinxpxdimen]{{scheme_2}.png}
\caption{Схема 2}\label{\detokenize{book/qcalgo/ru/deutschs_algorithm:scheme-2}}\end{figure}

\sphinxAtStartPar
В новой схеме оба кубита вначале будут находиться в состоянии \(|0\rangle\). Затем мы применим к верхнему кубиту оператор Адамара, а к нижнему – гейт \(X\), а затем так же, как и к верхнему, оператор Адамара. Тем самым мы приведем оба кубита в состояние суперпозиции перед тем, как они попадут на вход функции \(U_f\).
Верхний кубит будет находиться в такой суперпозиции:
\begin{equation*}
\begin{split}
|x\rangle = \frac{1}{\sqrt{2}}|0\rangle + \frac{1}{\sqrt{2}}|1\rangle,
\end{split}
\end{equation*}
\sphinxAtStartPar
а нижний \sphinxhyphen{} в такой:
\begin{equation*}
\begin{split}
|y\rangle = \frac{1}{\sqrt{2}}|0\rangle - \frac{1}{\sqrt{2}}|1\rangle.
\end{split}
\end{equation*}
\sphinxAtStartPar
Если рассмотреть это как систему \(|\psi\rangle\), состоящую из двух кубитов, то она будет выглядеть так:
\begin{equation*}
\begin{split}
|\psi\rangle = \frac{1}{2}(|0\rangle + |1\rangle)(|0\rangle - |1\rangle)
\end{split}
\end{equation*}
\sphinxAtStartPar
Сразу после \(U_f\) система будет находиться в состоянии:
\begin{equation*}
\begin{split}|\psi\rangle = \frac{1}{2}(|0\rangle + |1\rangle)(|0 \oplus f(x)\rangle - |1 \oplus f(x)\rangle)
\end{split}
\end{equation*}
\sphinxAtStartPar
После того, как \(U_f\) отрабатывает, нижний кубит, как это ни странно, уже нас не интересует, так что к нему операции больше не применяются, и его измерение также не производится.

\sphinxAtStartPar
Дело в том, что ответ на вопрос о том, сбалансирована функция \(f(x)\) или нет, будет нами получен из верхнего кубита после того, как на него подействует оператор Адамара и будет произведено измерение. В том случае, если функция сбалансирована, результат измерения верхнего кубита будет равен \(1\), а если несбалансированна – \(0\).

\sphinxAtStartPar
Разберемся подробнее, почему это происходит. Рассмотрим все возможные \(f(x)\), которые могут находиться в черном ящике:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\(f(x) = f_1\)

\end{itemize}

\sphinxAtStartPar
В этом случае \(f(x)\) всегда принимает значение \(0\), и система кубитов будет выглядеть так:
\begin{equation*}
\begin{split}
|\psi\rangle = \frac{1}{2}(|0\rangle + |1\rangle)(|0\rangle - |1\rangle) = \frac{1}{2}(|00\rangle - |01\rangle + |10\rangle - |11\rangle)
\end{split}
\end{equation*}\begin{itemize}
\item {} 
\sphinxAtStartPar
\(f(x) = f_2\)

\end{itemize}

\sphinxAtStartPar
\(f(x)\) будет равно \(1\) независимо от аргумента. Используя таблицу истинности XOR, легко убедиться, что во второй скобке \(|0\rangle\) и \(|1\rangle\) поменяются местами, но если вынести минус за скобку, то мы можем его не учитывать, так общий фазовый множитель (\sphinxhyphen{}1 в данном случае) для системы не имеет значения:
\begin{equation*}
\begin{split}
|\psi\rangle = \frac{1}{2}(|0\rangle + |1\rangle)(|1\rangle - |0\rangle) = -\frac{1}{2}(|0\rangle + |1\rangle)(|0\rangle - |1\rangle) = -\frac{1}{2}(|00\rangle - |01\rangle + |10\rangle - |11\rangle)
\end{split}
\end{equation*}
\sphinxAtStartPar
Видно, что при применении функций \(f_1\) и \(f_2\), являющихся несбалансированными, мы получаем фактически одно и тоже состояние. Если после этого применить к первому кубиту оператор Адамара, то после измерения мы получим значение \(0\).

\sphinxAtStartPar
Рассмотрим теперь сбалансированные функции \(f_3\) и \(f_4\).
\begin{itemize}
\item {} 
\sphinxAtStartPar
\(f(x) = f_3\)

\end{itemize}

\sphinxAtStartPar
Здесь ситуация сложнее, так как \(f(x)\) будет зависеть от состояния первого кубита. Поэтому мы раскроем скобки, а значения функции подставим позже:

\sphinxAtStartPar
\(
|\psi\rangle = \frac{1}{2}(|0\rangle + |1\rangle)(|0 \oplus f(x)\rangle - |1 \oplus f(x)\rangle) =
\frac{1}{2}(|0\rangle |0 \oplus f(x)\rangle - |0\rangle |1 \oplus f(x)\rangle + |1\rangle |0 \oplus f(x)\rangle - |1\rangle |1 \oplus f(x)\rangle)=\)

\sphinxAtStartPar
\(
=\frac{1}{2}(|0\rangle |0 \oplus 0\rangle - |0\rangle |1 \oplus 0\rangle + |1\rangle |0 \oplus 1\rangle - |1\rangle |1 \oplus 1\rangle) =
\frac{1}{2}(|00\rangle - |01\rangle + |11\rangle - |10\rangle) =\)

\sphinxAtStartPar
\(
=\frac{1}{2}(|00\rangle - |01\rangle - |10\rangle + |11\rangle) = \frac{1}{2}(|0\rangle - |1\rangle)(|0\rangle - |1\rangle)\)

\sphinxAtStartPar
Видно, что первый кубит поменял свое состояние \sphinxhyphen{} теперь он в суперпозиции \(\frac{1}{\sqrt{2}}(|0\rangle - |1\rangle)\), так что далее к нему можно применить оператор Адамара, после которого он перейдет в состояние \(|1\rangle\).
\begin{itemize}
\item {} 
\sphinxAtStartPar
\(f(x) = f_4\)

\end{itemize}

\sphinxAtStartPar
Здесь будет похожая ситуация:

\sphinxAtStartPar
\(
|\psi\rangle = \frac{1}{2}(|0\rangle + |1\rangle)(|0 \oplus f(x)\rangle - |1 \oplus f(x)\rangle) =
\frac{1}{2}(|0\rangle |0 \oplus f(x)\rangle - |0\rangle |1 \oplus f(x)\rangle + |1\rangle |0 \oplus f(x)\rangle - |1\rangle |1 \oplus f(x)\rangle)=\)

\sphinxAtStartPar
\(
=\frac{1}{2}(|0\rangle |0 \oplus 1\rangle - |0\rangle |1 \oplus 1\rangle + |1\rangle |0 \oplus 0\rangle - |1\rangle |1 \oplus 0\rangle) =
\frac{1}{2}(|01\rangle - |00\rangle + |10\rangle - |11\rangle) =\)

\sphinxAtStartPar
\(
=-\frac{1}{2}(|00\rangle - |01\rangle + |11\rangle - |10\rangle) =-\frac{1}{2}(|0\rangle - |1\rangle)(|0\rangle - |1\rangle)\)

\sphinxAtStartPar
Получили то же состояние \(|\psi\rangle\), что и для \(f_3\), с точностью до фазового множителя. Соответственно, здесь первый кубит после применения оператора Адамара также будет измерен с результатом \(1\).

\sphinxAtStartPar
Теперь можно получить более компактную формулу, которая подходит для всех четырех функций:
\begin{equation*}
\begin{split}
|\psi\rangle = \frac{1}{2}((-1)^{f(0)}|0\rangle + (-1)^{f(1)}|1\rangle)(|0\rangle - |1\rangle)
\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Задание}

\sphinxAtStartPar
С помощью квантовых операторов попробуйте создать \(U_f\) для всех четырех \(f(x)\).

\sphinxAtStartPar
Задание рекомендуется сделать до прочтения программистской части по алгоритму Дойча, так как там содержится ответ.
\end{sphinxadmonition}


\section{Алгоритм Дойча в коде}
\label{\detokenize{book/qcalgo/ru/deutschs_algorithm:id2}}
\sphinxAtStartPar
Запрограммируем алгоритм с помощью библиотеки PennyLane. Предполагается, что функция, находящаяся в черном ящике, изначально присутствует, но для учебного примера создадим также и ее, точнее, все ее четыре варианта. Для того, чтобы нам не сразу было известно, какая из этих функций анализируется алгоритмом (иначе будет неинтересно), будем использовать случайный выбор функции.

\sphinxAtStartPar
Импортируем все необходимые библиотеки и модули, а также создадим квантовое устройство\sphinxhyphen{}симулятор, рассчитанное на схему из двух кубитов:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{pennylane} \PYG{k}{as} \PYG{n+nn}{qml}
\PYG{k+kn}{from} \PYG{n+nn}{pennylane} \PYG{k+kn}{import} \PYG{n}{numpy} \PYG{k}{as} \PYG{n}{np}

\PYG{n}{dev} \PYG{o}{=} \PYG{n}{qml}\PYG{o}{.}\PYG{n}{device}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{default.qubit}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{shots}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{wires}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Теперь создадим функции для черного ящика. Обратите внимание, что здесь уже учтено сложение по модулю \(2\) результата функции с состоянием второго кубита:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{f1}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{pass}

\PYG{k}{def} \PYG{n+nf}{f2}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{qml}\PYG{o}{.}\PYG{n}{PauliX}\PYG{p}{(}\PYG{n}{wires}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}

\PYG{k}{def} \PYG{n+nf}{f3}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{qml}\PYG{o}{.}\PYG{n}{CNOT}\PYG{p}{(}\PYG{n}{wires}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}

\PYG{k}{def} \PYG{n+nf}{f4}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{qml}\PYG{o}{.}\PYG{n}{PauliX}\PYG{p}{(}\PYG{n}{wires}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{n}{qml}\PYG{o}{.}\PYG{n}{CNOT}\PYG{p}{(}\PYG{n}{wires}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{qml}\PYG{o}{.}\PYG{n}{PauliX}\PYG{p}{(}\PYG{n}{wires}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Создадим словарь с функциями и их названиями:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{black\PYGZus{}boxes\PYGZus{}dict} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{f1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{n}{f1}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{f2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{n}{f2}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{f3}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{n}{f3}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{f4}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{n}{f4}\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
А вот таким образом мы будем случайно выбирать название функции для черного ящика:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{random\PYGZus{}black\PYGZus{}box}\PYG{p}{(}\PYG{n}{black\PYGZus{}boxes\PYGZus{}dict}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{black\PYGZus{}boxes\PYGZus{}dict\PYGZus{}list\PYGZus{}keys} \PYG{o}{=} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{black\PYGZus{}boxes\PYGZus{}dict}\PYG{o}{.}\PYG{n}{keys}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{n} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{randint}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{black\PYGZus{}boxes\PYGZus{}dict\PYGZus{}list\PYGZus{}keys}\PYG{p}{)}\PYG{p}{)}

    \PYG{k}{return} \PYG{n}{black\PYGZus{}boxes\PYGZus{}dict\PYGZus{}list\PYGZus{}keys}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
А теперь самое важное – сам алгоритм Дойча:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nd}{@qml}\PYG{o}{.}\PYG{n}{qnode}\PYG{p}{(}\PYG{n}{dev}\PYG{p}{,} \PYG{n}{interface}\PYG{o}{=}\PYG{k+kc}{None}\PYG{p}{)}
\PYG{k}{def} \PYG{n+nf}{circuit}\PYG{p}{(}\PYG{n}{black\PYGZus{}box\PYGZus{}name}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{qml}\PYG{o}{.}\PYG{n}{Hadamard}\PYG{p}{(}\PYG{n}{wires}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{n}{qml}\PYG{o}{.}\PYG{n}{PauliX}\PYG{p}{(}\PYG{n}{wires}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{n}{qml}\PYG{o}{.}\PYG{n}{Hadamard}\PYG{p}{(}\PYG{n}{wires}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}

    \PYG{n}{black\PYGZus{}boxes\PYGZus{}dict}\PYG{p}{[}\PYG{n}{black\PYGZus{}box\PYGZus{}name}\PYG{p}{]}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{qml}\PYG{o}{.}\PYG{n}{Hadamard}\PYG{p}{(}\PYG{n}{wires}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}

    \PYG{k}{return} \PYG{n}{qml}\PYG{o}{.}\PYG{n}{sample}\PYG{p}{(}\PYG{n}{qml}\PYG{o}{.}\PYG{n}{PauliZ}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Итак, подготовительные действия завершены, можно приступать к демонстрации работы алгоритма.

\sphinxAtStartPar
Выберем случайным образом функцию:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{black\PYGZus{}box\PYGZus{}name} \PYG{o}{=} \PYG{n}{random\PYGZus{}black\PYGZus{}box}\PYG{p}{(}\PYG{n}{black\PYGZus{}boxes\PYGZus{}dict}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
А затем запустим алгоритм Дойча и выведем результат его работы. Собственное значение \(1\) оператора \(Z\) будет соответствовать состоянию \(|0\rangle\) (функция несбалансированная), а собственное значение \(-1\) – состоянию \(|1\rangle\) (функция сбалансирована):

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{result} \PYG{o}{=} \PYG{n}{circuit}\PYG{p}{(}\PYG{n}{black\PYGZus{}box\PYGZus{}name}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{result}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
1
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Проверим, насколько правильно сработал алгоритм. Для этого посмотрим на функцию из черного ящика:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{black\PYGZus{}box\PYGZus{}name}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
f1
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Также посмотрим, как выглядит квантовая схема:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{qml}\PYG{o}{.}\PYG{n}{drawer}\PYG{o}{.}\PYG{n}{use\PYGZus{}style}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{default}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{qml}\PYG{o}{.}\PYG{n}{draw\PYGZus{}mpl}\PYG{p}{(}\PYG{n}{circuit}\PYG{p}{)}\PYG{p}{(}\PYG{n}{black\PYGZus{}box\PYGZus{}name}\PYG{p}{)}
\PYG{n}{fig}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{deutschs_algorithm_17_0}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
На примере алгоритма Дойча мы видим, что уже двухкубитная схема дает прирост скорости в два раза. Если же увеличивать количество входных параметров (как в аналогичном алгоритме \sphinxhref{https://ru.wikipedia.org/wiki/\%D0\%90\%D0\%BB\%D0\%B3\%D0\%BE\%D1\%80\%D0\%B8\%D1\%82\%D0\%BC\_\%D0\%94\%D0\%BE\%D0\%B9\%D1\%87\%D0\%B0\_\%E2\%80\%94\_\%D0\%99\%D0\%BE\%D0\%B6\%D0\%B8}{Дойча\sphinxhyphen{}Йожи}), то ускорение будет экспоненциальным.

\sphinxAtStartPar
Для специалистов, занимающихся искусственным интеллектом, алгоритм может быть интересен тем, что не просто решает задачу нахождения некоторого значения, действуя как калькулятор, а дает возможность определить скрытую функцию. Это похоже на задачи машинного обучения, когда дата сайентист, производя математические манипуляции с данными, в итоге получает модель (фактически – функцию), описывающую связь признаков с целевой переменной. Таким образом, интерес специалистов ИИ к квантовым вычислениям, вполне понятен, как и перспективы квантовых вычислений в этой области.

\sphinxstepscope


\chapter{Квантовая телепортация}
\label{\detokenize{book/qcalgo/ru/quantum_teleportation:quantum-teleportation}}\label{\detokenize{book/qcalgo/ru/quantum_teleportation:id1}}\label{\detokenize{book/qcalgo/ru/quantum_teleportation::doc}}
\sphinxAtStartPar
Автор(ы):
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/Carinetta}{Решетова Карина}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/polyzer}{Токарев Игорь}

\end{itemize}

\sphinxAtStartPar
Пожалуй, пришло время познакомиться с квантовой телепортацией.

\sphinxAtStartPar
Часто вижу в новостях “телепортировали кубит”, “телепортировали электрон”. Но это лишь игра слов… Рассмотрим два запутанных электрона – первый находится у вас, а второй у вашего друга. И под телепортацией подразумевается вот что: вы, используя допустимую операцию, изменяете состояние своего электрона, и второй (запутанный с ним), также изменит свое состояние (в соответствии с примененной операцией). Вам остается лишь выбрать допустимую операцию.

\sphinxAtStartPar
Давайте сейчас посмотрим на \sphinxhref{https://ru.wikipedia.org/wiki/\%D0\%A1\%D0\%BE\%D1\%81\%D1\%82\%D0\%BE\%D1\%8F\%D0\%BD\%D0\%B8\%D0\%B5\_\%D0\%91\%D0\%B5\%D0\%BB\%D0\%BB\%D0\%B0}{состояния Белла} (Bell states). Прошу:
\begin{equation}\label{equation:book/qcalgo/ru/quantum_teleportation:eqn:bell_beta_00}
\begin{split} |\beta_{00}\rangle = \frac{1}{\sqrt{2}} (|00\rangle + |11\rangle)\end{split}
\end{equation}\begin{equation*}
\begin{split} |\beta_{01}\rangle = \frac{1}{\sqrt{2}} (|01\rangle + |10\rangle)\end{split}
\end{equation*}\begin{equation*}
\begin{split} |\beta_{10}\rangle = \frac{1}{\sqrt{2}} (|00\rangle - |11\rangle)\end{split}
\end{equation*}\begin{equation*}
\begin{split} |\beta_{11}\rangle = \frac{1}{\sqrt{2}} (|01\rangle - |10\rangle)\end{split}
\end{equation*}
\sphinxAtStartPar
Это четыре всадника квантовой запутанности. И у них есть много преимуществ: используют всего два кубита, их легко получить… А что нам еще нужно? Дальше в примере мы воспользуемся одним из этих состояний.

\sphinxAtStartPar
Теперь работаем в терминах квантовой теории информации – это сильно поможет с пониманием остальных тем нашего с вами курса.

\sphinxAtStartPar
Итак, квантовая телепортация будет проводиться двумя персонами – Алисой и Бобом, из которых первые два кубита контролируются Алисой, а третий – Бобом. Алиса хочет передать Бобу закодированное сообщение (отождествляемое с квантовым состоянием): \( |\psi\rangle = \alpha|0\rangle + \beta|1\rangle \)

\sphinxAtStartPar
Изначально, вся система из трех кубитов будет иметь следующее состояние: \( |\psi_{0}\rangle = |\psi\rangle|0\rangle|0\rangle \). Т.е. первый кубит находится в состоянии \( |\psi\rangle \), которое затем будет передаваться с помощью второго кубита на третий.

\begin{sphinxadmonition}{note}{Алиса и Боб}

\sphinxAtStartPar
Первые два шага являются подготовительными. Поэтому Боб находится рядом и ждет, пока Алиса проведет необходимые операции.
\end{sphinxadmonition}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Алиса применяет гейт Адамара ко второму кубиту:
\begin{equation*}
\begin{split} |\psi_{1}\rangle = (I \otimes H \otimes I)|\psi_{0}\rangle = (I \otimes H \otimes I) |\psi\rangle|0\rangle|0\rangle  = \frac{1}{\sqrt{2}}|\psi\rangle(|0\rangle + |1\rangle)|0\rangle \end{split}
\end{equation*}
\item {} 
\sphinxAtStartPar
Далее Алиса использует гейт CNOT для того, чтобы запутать второй кубит с третьим:
\begin{equation*}
\begin{split}  |\psi_{2}\rangle = (I \otimes CNOT(2,3))|\psi_{1}\rangle =\end{split}
\end{equation*}\begin{equation*}
\begin{split}(I \otimes CNOT(2,3))\frac{1}{\sqrt{2}}|\psi\rangle(|0\rangle + |1\rangle)|0\rangle = \frac{1}{\sqrt{2}}|\psi\rangle(|0\rangle|0\rangle + |1\rangle|1\rangle)\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Алиса и Боб}

\sphinxAtStartPar
Теперь состояния готовы. Сейчас Боб, забрав третий кубит с собой, отправляется по своим делам. И Алиса, в случае необходимости, сможет передать ему послание.
\end{sphinxadmonition}

\item {} 
\sphinxAtStartPar
Алиса применяет CNOT между первым и вторым кубитами. Вспоминая, что \( |\psi\rangle = \alpha|0\rangle + \beta|1\rangle \):
\begin{equation*}
\begin{split}|\psi_{3}\rangle = (CNOT(1, 2) \otimes I)|\psi_{2}\rangle =\end{split}
\end{equation*}\begin{equation*}
\begin{split}(CNOT(1, 2) \otimes I)\frac{1}{\sqrt{2}}(\alpha|0\rangle + \beta|1\rangle)(|00\rangle + |11\rangle) =\end{split}
\end{equation*}\begin{equation*}
\begin{split} = \frac{1}{\sqrt{2}}[\alpha(|000\rangle + |011\rangle) + \beta(|110\rangle + |101\rangle)] \end{split}
\end{equation*}
\item {} 
\sphinxAtStartPar
Алиса применяет гейт Адамара на своем первом кубите:
\begin{equation*}
\begin{split} |\psi_4\rangle = (H \otimes I \otimes I)|\psi_{3}\rangle = \end{split}
\end{equation*}\begin{equation*}
\begin{split}\frac{1}{2} [|00\rangle(\alpha|0\rangle + \beta|1\rangle) +\end{split}
\end{equation*}\begin{equation*}
\begin{split} |01\rangle(\alpha|1\rangle + \beta|0\rangle)+ \end{split}
\end{equation*}\begin{equation*}
\begin{split} |10\rangle(\alpha|0\rangle - \beta|1\rangle)+ \end{split}
\end{equation*}\begin{equation*}
\begin{split} |11\rangle(\alpha|1\rangle - \beta|0\rangle)] \end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Внимание}

\sphinxAtStartPar
Видно, что в каждой строчке у нас получаются разные состояния, по первым двум кубитам мы можем определить, в каком будет третий. Обратите внимание на общий множитель \(\frac{1}{2}\) в первой строчке, не пропустите.
\end{sphinxadmonition}

\item {} 
\sphinxAtStartPar
Алисе нужно теперь измерить первые 2 кубита и станет ясно, в какое из четырех состояний перейдет кубит Боба:
\begin{equation*}
\begin{split}
   \begin{array} {|r|r|}
   \hline 00 & \alpha|0\rangle + \beta|1\rangle \\
   \hline 01 & \alpha|1\rangle + \beta|0\rangle \\
   \hline 10 & \alpha|0\rangle - \beta|1\rangle \\
   \hline 11 & \alpha|1\rangle - \beta|0\rangle \\
   \hline
   \end{array}
   \end{split}
\end{equation*}
\item {} 
\sphinxAtStartPar
В зависимости от полученных по классическому каналу данных, Боб должен применить одну из операций для того, чтобы восстановить исходное состояние:

\end{enumerate}
\begin{equation*}
\begin{split}
\begin{array} {|r|r|}
\hline 00 & I \\
\hline 01 & X \\
\hline 10 & Z \\
\hline 11 & ZX \\
\hline
\end{array}
\end{split}
\end{equation*}
\sphinxAtStartPar
Одним из ограничений квантовой телепортации является необходимость передать результаты измерений первых двух кубитов от Алисы к Бобу по классическому каналу (5 шаг). Поэтому весь протокол выполняется не быстрее скорости света.

\sphinxAtStartPar
Приведем данную схему:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{qiskit} \PYG{k+kn}{import} \PYG{n}{QuantumCircuit}\PYG{p}{,} \PYG{n}{ClassicalRegister}\PYG{p}{,} \PYG{n}{QuantumRegister}

\PYG{c+c1}{\PYGZsh{} создаем необходимые регистры}
\PYG{n}{qr} \PYG{o}{=} \PYG{n}{QuantumRegister}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{q}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{crz} \PYG{o}{=} \PYG{n}{ClassicalRegister}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{crz}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{crx} \PYG{o}{=} \PYG{n}{ClassicalRegister}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{crx}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} создаем схему}
\PYG{n}{qc} \PYG{o}{=} \PYG{n}{QuantumCircuit}\PYG{p}{(}\PYG{n}{qr}\PYG{p}{,} \PYG{n}{crz}\PYG{p}{,} \PYG{n}{crx}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Шаг 1}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{h}\PYG{p}{(}\PYG{n}{qr}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Шаг 2}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{cx}\PYG{p}{(}\PYG{n}{qr}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{qr}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Шаг 3}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{cx}\PYG{p}{(}\PYG{n}{qr}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{qr}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Шаг 4}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{h}\PYG{p}{(}\PYG{n}{qr}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Шаг 5 \PYGZhy{} измеряются 2 кубита Алисы, чтобы передать результат Бобу}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{measure}\PYG{p}{(}\PYG{n}{qr}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{crz}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{measure}\PYG{p}{(}\PYG{n}{qr}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{crx}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Шаг 6 \PYGZhy{} применяются гейт X и гейт Z в завиимости от того, какое из измерений дает результат 1.}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{x}\PYG{p}{(}\PYG{n}{qr}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{c\PYGZus{}if}\PYG{p}{(}\PYG{n}{crx}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{z}\PYG{p}{(}\PYG{n}{qr}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{c\PYGZus{}if}\PYG{p}{(}\PYG{n}{crz}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}

\PYG{n}{qc}\PYG{o}{.}\PYG{n}{draw}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
                      ┌───┐┌─┐              
  q\PYGZus{}0: ────────────■──┤ H ├┤M├──────────────
       ┌───┐     ┌─┴─┐└┬─┬┘└╥┘              
  q\PYGZus{}1: ┤ H ├──■──┤ X ├─┤M├──╫───────────────
       └───┘┌─┴─┐└───┘ └╥┘  ║  ┌───┐  ┌───┐ 
  q\PYGZus{}2: ─────┤ X ├───────╫───╫──┤ X ├──┤ Z ├─
            └───┘       ║   ║  └─╥─┘  └─╥─┘ 
                        ║   ║    ║   ┌──╨──┐
crz: 1/═════════════════╬═══╩════╬═══╡ = 1 ╞
                        ║   0 ┌──╨──┐└─────┘
crx: 1/═════════════════╩═════╡ = 1 ╞═══════
                        0     └─────┘       
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
\sphinxhref{https://qiskit.org/textbook/ch-algorithms/teleportation.html}{Лекция и реализация квантовой телепортации в Qiskit}

\sphinxstepscope


\chapter{Квантовое сверхплотное кодирование}
\label{\detokenize{book/qcalgo/ru/superdense_coding:superdense-coding}}\label{\detokenize{book/qcalgo/ru/superdense_coding:id1}}\label{\detokenize{book/qcalgo/ru/superdense_coding::doc}}
\sphinxAtStartPar
Автор(ы):
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/dmburd}{Бурдейный Дмитрий}

\end{itemize}

\sphinxAtStartPar
\sphinxhref{https://ru.wikipedia.org/wiki/\%D0\%9A\%D0\%B2\%D0\%B0\%D0\%BD\%D1\%82\%D0\%BE\%D0\%B2\%D0\%BE\%D0\%B5\_\%D1\%81\%D0\%B2\%D0\%B5\%D1\%80\%D1\%85\%D0\%BF\%D0\%BB\%D0\%BE\%D1\%82\%D0\%BD\%D0\%BE\%D0\%B5\_\%D0\%BA\%D0\%BE\%D0\%B4\%D0\%B8\%D1\%80\%D0\%BE\%D0\%B2\%D0\%B0\%D0\%BD\%D0\%B8\%D0\%B5}{Сверхплотное кодирование} (Superdense coding) – простое, но при этом довольно неожиданное приложение квантовой механики. Оно комбинирует определенным нетривиальным образом большинство основных идей этой физической теории, и потому является отличным примером решения задач обработки информации с помощью квантовой механики.

\sphinxAtStartPar
В задаче о сверхплотном кодировании рассматриваются два действующих лица – Алиса и Боб. Они могут находиться, вообще говоря, далеко друг от друга. Цель – передать некоторое количество классической информации от Алисы к Бобу. Пусть у Алисы есть два классических бита информации, которые она хочет передать Бобу, но Алисе разрешено переслать Бобу только один кубит. Достижима ли эта цель?

\sphinxAtStartPar
Задача о сверхплотном кодировании в некотором смысле противоположна задаче о {\hyperref[\detokenize{book/qcalgo/ru/quantum_teleportation::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{квантовой телепортации}}}}:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
квантовая телепортация
&\sphinxstyletheadfamily 
\sphinxAtStartPar
сверхплотное кодирование
\\
\hline
\sphinxAtStartPar
передача одного кубита с помощью двух классических бит
&
\sphinxAtStartPar
передача двух классических бит с помощью одного кубита
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
Ответ на вопрос выше – утвердительный. Пусть изначально у Алисы и Боба есть пара кубитов в запутанном состоянии
\begin{equation*}
\begin{split}
\ket{\psi} = \ket{\beta_{00}} = \frac{\ket{00} + \ket{11}}{\sqrt{2}}
\end{split}
\end{equation*}
\sphinxAtStartPar
(это первое состояние Белла \eqref{equation:book/qcalgo/ru/quantum_teleportation:eqn:bell_beta_00} из четырёх, перечисленных в предыдущей лекции о квантовой телепортации). Вначале первый кубит находится у Алисы, второй – у Боба. Обратите внимание, что для приготовления состояния \( \ket{\psi} \) Алисе не требовалось присылать Бобу никаких кубитов. Некое третье действующее лицо могло приготовить запутанное состояние \( \ket{\psi} \) заранее и переслать первый кубит Алисе, второй – Бобу.

\sphinxAtStartPar
Оказывается, Алиса может передать два бита классической информации Бобу, отправив ему свой кубит. Для этого Алиса выполняет следующую процедуру:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Если Алиса хочет передать Бобу битовую строку “00”, она ничего не делает со своим кубитом.

\item {} 
\sphinxAtStartPar
Если Алиса хочет передать битовую строку “01”, она применяет оператор \(X\) (гейт \(NOT\)) к своему кубиту.

\item {} 
\sphinxAtStartPar
Если Алиса хочет передать битовую строку “10”, она применяет оператор \(Z\) к своему кубиту.

\item {} 
\sphinxAtStartPar
Если Алиса хочет передать битовую строку “11”, она применяет оператор \(ZX = iY\) к своему кубиту.

\end{enumerate}

\sphinxAtStartPar
В результате получаются состояния двухкубитной системы справа от стрелок в следующих формулах (проверьте это!):
\begin{equation*}
\begin{split}
00: \ket{\psi} \rightarrow \frac{\ket{00} + \ket{11}}{\sqrt{2}} = \ket{\beta_{00}} , \\
01: \ket{\psi} \rightarrow \frac{\ket{10} + \ket{01}}{\sqrt{2}} = \ket{\beta_{01}} , \\
10: \ket{\psi} \rightarrow \frac{\ket{00} - \ket{11}}{\sqrt{2}} = \ket{\beta_{10}} , \\
11: \ket{\psi} \rightarrow \frac{\ket{01} - \ket{10}}{\sqrt{2}} = \ket{\beta_{11}} ,
\end{split}
\end{equation*}
\sphinxAtStartPar
т.е. как раз четыре состояния Белла. Они образуют ортонормированный базис в пространстве состояний двухкубитной системы (убедитесь в этом самостоятельно). Следовательно, эти четыре состояния можно различить подходящим измерением для двухкубитной системы. Если Алиса отправит свой кубит Бобу, то Боб после измерения двухкубитной системы в базисе Белла сможет определить, которую из четырех возможных битовых строк Алиса хотела отправить.

\sphinxAtStartPar
Бобу для декодирования удобно было бы применить некий двухкубитный унитарный оператор, отображающий базис Белла в вычислительный базис (чтобы в итоге выполнить измерение в вычислительном базисе). Для этого можно применить оператор \(CNOT\) (первый кубит – контрольный) и затем оператор Адамара \(H\) для первого кубита, как показано в пунктирном блоке в нижнем правом углу на общей схеме:

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=542\sphinxpxdimen]{{Superdense_coding_wikimedia}.png}
\caption{Общая схема для решения задачи о сверхплотном кодировании}\label{\detokenize{book/qcalgo/ru/superdense_coding:superdense-coding-wikimedia}}\end{figure}

\sphinxAtStartPar
В качестве упражнения проверьте самостоятельно, что произведение операторов \((H \otimes I) CNOT\) действительно переводит базис \(\left\{ \ket{\beta_{00}}, \ket{\beta_{01}}, \ket{\beta_{10}}, \ket{\beta_{11}} \right\}\) в базис \( \left\{ \ket{00 }, \ket{01}, \ket{10}, \ket{11} \right\} \).

\sphinxAtStartPar
Приведем код на qiskit.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{qiskit} \PYG{k+kn}{import} \PYG{n}{QuantumCircuit}

\PYG{n}{qc} \PYG{o}{=} \PYG{n}{QuantumCircuit}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} готовим состояние beta\PYGZus{}\PYGZob{}00\PYGZcb{} из стартового состояния |00\PYGZgt{}:}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{h}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{cx}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} визуальный разделитель при отрисовке схемы:}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{barrier}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} выбираем какое\PYGZhy{}либо сообщение из набора в assert\PYGZhy{}выражении ниже:}
\PYG{n}{message} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{10}\PYG{l+s+s1}{\PYGZsq{}}

\PYG{k}{assert} \PYG{n}{message} \PYG{o+ow}{in} \PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{00}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{01}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{10}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{11}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Алиса выполняет кодирование сообщения:}
\PYG{k}{if} \PYG{n}{message}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{==} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}
    \PYG{n}{qc}\PYG{o}{.}\PYG{n}{x}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{k}{if} \PYG{n}{message}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{==} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}
    \PYG{n}{qc}\PYG{o}{.}\PYG{n}{z}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}

\PYG{n}{qc}\PYG{o}{.}\PYG{n}{barrier}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Боб декодирует сообщение:}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{cx}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{h}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Боб измеряет двухкубитную систему целиком (в вычислительном базисе):}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{measure\PYGZus{}all}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{qc}\PYG{o}{.}\PYG{n}{draw}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
        ┌───┐      ░ ┌───┐ ░      ┌───┐ ░ ┌─┐   
   q\PYGZus{}0: ┤ H ├──■───░─┤ Z ├─░───■──┤ H ├─░─┤M├───
        └───┘┌─┴─┐ ░ └───┘ ░ ┌─┴─┐└───┘ ░ └╥┘┌─┐
   q\PYGZus{}1: ─────┤ X ├─░───────░─┤ X ├──────░──╫─┤M├
             └───┘ ░       ░ └───┘      ░  ║ └╥┘
meas: 2/═══════════════════════════════════╩══╩═
                                           0  1 
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Запускаем схему на симуляторе:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{qiskit} \PYG{k+kn}{import} \PYG{n}{Aer}

\PYG{n}{aer\PYGZus{}sim} \PYG{o}{=} \PYG{n}{Aer}\PYG{o}{.}\PYG{n}{get\PYGZus{}backend}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{aer\PYGZus{}simulator}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{result} \PYG{o}{=} \PYG{n}{aer\PYGZus{}sim}\PYG{o}{.}\PYG{n}{run}\PYG{p}{(}\PYG{n}{qc}\PYG{p}{)}\PYG{o}{.}\PYG{n}{result}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{counts} \PYG{o}{=} \PYG{n}{result}\PYG{o}{.}\PYG{n}{get\PYGZus{}counts}\PYG{p}{(}\PYG{n}{qc}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}
    \PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{message was }\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{message}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{ \PYGZhy{}\PYGZgt{} the measurement result is }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{counts}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}
    \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ (\PYGZlt{}\PYGZhy{} NOTE: the keys are little\PYGZhy{}endian!)}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
message was \PYGZsq{}10\PYGZsq{} \PYGZhy{}\PYGZgt{} the measurement result is \PYGZob{}\PYGZsq{}01\PYGZsq{}: 1024\PYGZcb{} (\PYGZlt{}\PYGZhy{} NOTE: the keys are little\PYGZhy{}endian!)
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxadmonition}{note}{RTFM!}

\sphinxAtStartPar
Обратите внимание на \sphinxhref{https://qiskit.org/documentation/stubs/qiskit.result.Result.get\_counts.html?highlight=get\_counts\#qiskit-result-result-get-counts}{документацию} к \sphinxcode{\sphinxupquote{qiskit.result.Result.get\_counts}}! Ключи возвращаемого словаря – это битовые строки в \sphinxstylestrong{little\sphinxhyphen{}endian} формате, т.е. кубит с индексом \sphinxcode{\sphinxupquote{{[}0{]}}} находится справа в битовой строке.
\end{sphinxadmonition}

\sphinxAtStartPar
Инициализируем переменную \sphinxcode{\sphinxupquote{message}} каждым из четырех значений и получаем следующие результаты:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{message} \PYG{n}{was} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{00}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{the} \PYG{n}{measurement} \PYG{n}{result} \PYG{o+ow}{is} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{00}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{1024}\PYG{p}{\PYGZcb{}}
\PYG{n}{message} \PYG{n}{was} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{01}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{the} \PYG{n}{measurement} \PYG{n}{result} \PYG{o+ow}{is} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{10}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{1024}\PYG{p}{\PYGZcb{}}
\PYG{n}{message} \PYG{n}{was} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{10}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{the} \PYG{n}{measurement} \PYG{n}{result} \PYG{o+ow}{is} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{01}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{1024}\PYG{p}{\PYGZcb{}}
\PYG{n}{message} \PYG{n}{was} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{11}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{the} \PYG{n}{measurement} \PYG{n}{result} \PYG{o+ow}{is} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{11}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{1024}\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Резюмируем. Алиса, взаимодействуя только с одним кубитом, смогла передать два классических бита информации Бобу. Конечно, в процедуре участвовало два кубита, но Алисе не требовалось взаимодействовать со вторым кубитом. Если бы Алиса пересылала Бобу один классический бит вместо одного кубита, то передать таким способом два классических бита было бы невозможно, разумеется.

\sphinxAtStartPar
Существуют более впечатляющие, чем сверхплотное кодирование, примеры применения квантовой механики к задачам обработки информации. Но на примере сверхплотного кодирования виден важнейший принцип – \sphinxstylestrong{информация физична}. Нетривиальные физические теории вроде квантовой механики могут привести к неожиданным новым возможностям в обработке информации.

\sphinxAtStartPar
Напоследок рассмотрим вопрос безопасности коммуникации. Допустим, некий третий субъект (пусть с именем Ева) хочет “подслушать” сообщение, передаваемое Бобу. Ева перехватывает кубит, отправленный Алисой, и может попытаться извлечь какую\sphinxhyphen{}либо полезную информацию, выполнив какое\sphinxhyphen{}либо измерение над кубитом Алисы. Пусть Ева использует положительно\sphinxhyphen{}определенный оператор \(E\) для первого кубита и вычисляет величину \(\braket{\xi | E \otimes I | \xi}\), где \(\ket{\xi}\) – одно из состояний \(\left\{ \ket{\beta_{00}}, \ket{\beta_{01}}, \ket{\beta_{10}}, \ket{\beta_{11}} \right\}\). Кубит Боба (второй кубит) Еве недоступен, поэтому мы поставили единичный оператор на второе место в составном операторе. Любое возможное состояние \(\ket{\xi}\) можно записать в виде
\begin{equation*}
\begin{split}
\ket{\xi} = \frac{\ket{\phi_1} + \ket{\phi_2}}{\sqrt{2}},
\end{split}
\end{equation*}
\sphinxAtStartPar
где \(\ket{\phi_1}, \ket{\phi_2}\) – двухкубитные состояния, соответствующие вычислительному базису (см. формулы для \(\ket{\beta_{ij}}\) выше). Например, \(\ket{\phi_1} = \ket{01}, \ket{\phi_2} = -\ket{10}\) для случая \(\ket{\xi} = \ket{\beta_{11}}\) и т.д.
\begin{equation*}
\begin{split}
2 \braket{\xi | E \otimes I | \xi} =
    \braket{\phi_1 | E \otimes I | \phi_1} +
    \braket{\phi_2 | E \otimes I | \phi_2} +
    \braket{\phi_1 | E \otimes I | \phi_2} +
    \braket{\phi_2 | E \otimes I | \phi_1}.
\end{split}
\end{equation*}
\sphinxAtStartPar
В каждом из четырех возможных случаев \(\braket{\phi_1 | E \otimes I | \phi_2} = \braket{\phi_2 | E \otimes I | \phi_1} = 0\), потому что второй кубит имеет противоположные значения в \(\ket{\phi_1}\) и \(\ket{\phi_2}\). Вычислив \(\braket{\phi_i | E \otimes I | \phi_i}\) для \(i = 1, 2\) (первые два слагаемых в правой части), легко убедиться, что
\begin{equation*}
\begin{split}
2 \braket{\xi | E \otimes I | \xi} =
    \braket{0 | E | 0} +
    \braket{1 | E | 1}
\end{split}
\end{equation*}
\sphinxAtStartPar
во всех случаях. Таким образом, Ева всегда будет получать один и тот же результат своего измерения, не зависящий от сообщения, которое Алиса пыталась передать Бобу. Ева не сможет получить никакой полезной информации о сообщении от Алисы, перехватив её кубит.

\sphinxAtStartPar
\sphinxhref{https://qiskit.org/textbook/ch-algorithms/superdense-coding.html}{Лекция и реализация процедуры сверхплотного кодирования в Qiskit}

\sphinxstepscope


\chapter{Алгоритм Гровера}
\label{\detokenize{book/qcalgo/ru/grovers_algorithm:grovers-algorithm}}\label{\detokenize{book/qcalgo/ru/grovers_algorithm:id1}}\label{\detokenize{book/qcalgo/ru/grovers_algorithm::doc}}
\sphinxAtStartPar
Автор(ы):
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/SergeiShirkin}{Ширкин Сергей}

\end{itemize}

\sphinxAtStartPar
Одно из самых востребованных действий в работе с данными – поиск по базе данных. При использовании классического компьютера такой поиск в худшем случае требует \(N\) операций, где \(N\) – количество строк в таблице. В среднем найти нужный элемент можно за \(N/2\) операций.

\sphinxAtStartPar
Фактически, это означает, что если мы не знаем, где расположен нужный элемент в таблице, то придется перебирать все элементы, пока не найдем то, что нужно. Для классических вычислений это нормально, но что, если у нас есть квантовый компьютер?

\sphinxAtStartPar
Если наша база данных работает на основе квантовых вычислений, то мы можем применить алгоритм Гровера, и тогда такой поиск потребует всего порядка \(\sqrt{N}\) действий. Конечно же, такое ускорение не будет экспоненциальным, как при использовании некоторых других квантовых алгоритмов, но оно будет квадратичным, что также довольно неплохо.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{Grover_photo}.jpg}
\caption{Лов Гровер}\label{\detokenize{book/qcalgo/ru/grovers_algorithm:grover-photo}}\end{figure}

\begin{sphinxadmonition}{note}{Лов Гровер}

\sphinxAtStartPar
Индо\sphinxhyphen{}американский ученый в сфере Computer Science Лов Кумар Гровер предложил квантовый алгоритм поиска по базе данных в 1996 году. Этот алгоритм считается вторым по значимости для квантовых вычислений после алгоритма Шора. Впервые он был реализован на простейшем квантовом компьютере в 1998 году, а в 2017 году алгоритм Гровера был впервые запущен для трехкубитной базы данных.
\end{sphinxadmonition}

\sphinxAtStartPar
Итак, наша задача состоит в том, что мы должны найти идентификационный номер (\(Id\)) записи, которая удовлетворяет определенным условиям. Функция\sphinxhyphen{}оракул находит такую запись (для простоты будем сначала считать, что такая запись одна) и помечает соответствующий ей \(Id\). Отметка делается достаточно оригинальным способом: \(Id\) умножается на \(-1\).

\sphinxAtStartPar
Для полной ясности соотнесем количество \(Id\) с числом кубитов в квантовой схеме. Здесь все очень просто: имея \(n\) кубитов, можно закодировать \(N = 2^n\) идентификаторов. К примеру, если в таблице базы данных \(1024\) записей, то закодировать все \(Id\) можно с помощью десяти кубитов.

\sphinxAtStartPar
Для того, чтобы не запутаться в квантовых операциях, рассмотрим пример поменьше: с помощью двух кубитов закодируем четыре идентификационных номера, один из которых будет помечен функцией\sphinxhyphen{}оракулом как искомый – он будет домножен на \(-1\). Все эти четыре числа могут существовать в квантовой схеме одновременно, если кубиты приведены в состояние суперпозиции.

\sphinxAtStartPar
Пусть искомый \(Id\) равен \(11\) (будем пользоваться двоичной системой и вести счет с нуля), тогда после работы функции\sphinxhyphen{}оракула мы будем иметь \(4\) состояния: \(|00\rangle\), \(|01\rangle\), \(|10\rangle\), \(-|11\rangle\). Проблема в том, что если измерить эту схему, то с равной вероятностью будет обнаружено одно из этих четырех значений, но узнать, какое из них функция\sphinxhyphen{}оракул пометила минусом, будет невозможно.

\sphinxAtStartPar
Получается, что одной функции\sphinxhyphen{}оракула недостаточно, нужно что\sphinxhyphen{}то дополнительное. На помощь приходит алгоритм Гровера. Правда, у него есть такая особенность – он является итерационным, то есть определенные операции (в том числе и применение функции\sphinxhyphen{}оракула) нужно повторить несколько раз (порядка \(\sqrt{N}\)). Причем, с количеством итераций нельзя ошибиться, иначе алгоритм даст неправильный ответ.

\sphinxAtStartPar
В идеале после всех итераций квантовую схему можно будет измерить и получить значение \(Id\) искомой записи в таблице базы данных.

\sphinxAtStartPar
Разберем операции, которые включает в себя каждая итерация, но перед этим добавим в схему еще один кубит, который мы будем называть вспомогательным. Он нужен для хранения метки искомого индекса. Звучит не совсем понятно, но ничего сложного в этом нет, все станет ясным после разбора работы функции\sphinxhyphen{}оракула. Итак, наша база данных двухкубитная, но сама схема состоит из трех кубитов.

\sphinxAtStartPar
Квантовая схема выглядит так:

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=666\sphinxpxdimen]{{grover_2_qubits}.png}
\caption{Алгоритм Гровера для n=2 (искомый индекс 11).}\label{\detokenize{book/qcalgo/ru/grovers_algorithm:grover-2-qubits}}\end{figure}

\sphinxAtStartPar
В самом начале, еще до всех итераций, все кубиты (включая вспомогательный) должны быть приведены в состояние суперпозиции с помощью оператора Адамара. Причем начальное состояние всех кубитов должно быть равно \(0\), кроме вспомогательного кубита – до действия оператора Адамара он должен быть приведен в состояние \(1\).

\sphinxAtStartPar
Таким образом, вспомогательный кубит после применения оператора Адамара будет находиться в состоянии \(\frac{1}{\sqrt{2}}(|0\rangle - |1\rangle)\), тогда как остальные кубиты примут состояние \(\frac{1}{\sqrt{2}}(|0\rangle + |1\rangle)\).

\sphinxAtStartPar
Далее начинаем итерации. Каждая итерация состоит из двух частей. Первая часть – это действие функции\sphinxhyphen{}оракула. Это некоторая функция, умеющая эффективно определять, какой индекс соответствует искомому объекту. Эта функция не может сообщить нам этот индекс напрямую, зато она может пометить его минусом.

\sphinxAtStartPar
Для разбора внутренней работы алгоритма нам потребуется задать функцию\sphinxhyphen{}оракул вручную и сделать ее достаточно простой, поэтому нужно знать, что в рабочих условиях она будет действовать похоже, но будет устроена, скорее всего, по\sphinxhyphen{}другому, так как предназначена для конкретной задачи выбора искомых данных. Мы не будем касаться вопроса конкретной реализации функции\sphinxhyphen{}оракула для выбора определенных данных, так как это уже другой вопрос, не влияющий на принцип алгоритма Гровера.

\sphinxAtStartPar
Для того чтобы понять алгоритм Гровера, мы должны будем понять, какие изменения происходят с состояниями кубитов до того момента, когда производится измерение, выдающее искомый индекс.

\sphinxAtStartPar
Мы договорились, что в нашей учебной задаче искомый \(Id\) равен \(11\), так что в результате измерения мы должны получить именно это значение. Смоделируем оракул, который будет помечать этот индекс. В качестве такого оракула подойдет гейт Тоффоли (\(CCNOT\)). При подаче на оба его управляющих входа значений \(1\), он будет применять к управляемому кубиту (это как раз будет вспомогательный кубит) гейт \(X\).

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=200\sphinxpxdimen]{{Toffoli_gate}.png}
\caption{Гейт Тоффоли.}\label{\detokenize{book/qcalgo/ru/grovers_algorithm:toffoli-gate}}\end{figure}

\sphinxAtStartPar
На состояния верхних кубитов, кодирующих индексы \(00\), \(01\) и \(10\) гейт Тоффоли не будет реагировать, и вспомогательный кубит будет находиться в состоянии \(\frac{1}{\sqrt{2}}(|0\rangle - |1\rangle)\).

\sphinxAtStartPar
Но при срабатывании гейта на индексе \(11\) к вспомогательному кубиту применится оператор \(X\), так что вспомогательный кубит примет состояние \(\frac{1}{\sqrt{2}}(|1\rangle - |0\rangle)\), или, если это состояние записать по\sphinxhyphen{}другому, за скобками появится минус: \(-\frac{1}{\sqrt{2}}(|0\rangle - |1\rangle)\).

\sphinxAtStartPar
Этот минус относится не только к вспомогательному кубиту, но и ко всему состоянию, соответствующему индексу \(11\), так что можно считать, что вспомогательный кубит остался неизменным, и отнести минус к состоянию \(11\) верхних кубитов. Таким образом, индекс \(11\) помечен минусом как искомый. Другими словами, функция\sphinxhyphen{}оракул перевела состояние \(|11\rangle |q_{helper}\rangle\) в состояние \(-|11\rangle |q_{helper}\rangle\), где \(|q_{helper}\rangle\) – вспомогательный кубит.

\sphinxAtStartPar
Запишем состояние квантовой схемы после применения оракула (состояние вспомогательного кубита – скобка справа):
\begin{equation*}
\begin{split}
|\psi\rangle = \frac{1}{2\sqrt{2}}(|00\rangle + |01\rangle + |10\rangle - |11\rangle)(|0\rangle - |1\rangle)
\end{split}
\end{equation*}
\sphinxAtStartPar
Итак, первая часть первой итерации завершена. Искомый индекс помечен, но если измерить кубиты прямо сейчас, то это ничего не даст – минус не проявит себя при измерении. Да и сам индекс \(11\) будет получен только с вероятностью \(0.25\) – такой же, как и у других индексов.

\sphinxAtStartPar
Для того, чтобы лучше понять дальнейшие действия, представим первую половину работы алгоритма в виде рисунка, показывающего вектор текущего состояния. В качестве единичного вектора горизонтальной оси мы будем использовать все состояния из суперпозиции кроме того, который соответствует искомому индексу, а вертикальным единичным вектором будет искомый вектор.

\sphinxAtStartPar
Вектор \(c\) – состояние системы перед первой итерацией – является линейной комбинацией векторов, соответствующим горизонтальной и вертикальной осям.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{grover_1a}.png}
\caption{Состояние системы перед первой итерацией.}\label{\detokenize{book/qcalgo/ru/grovers_algorithm:grover-1a}}\end{figure}

\sphinxAtStartPar
Можно выразить вектор \(c\) для нашего случая (системы из двух кубитов с искомым индексом \(11\)), обозначив его координаты за \(x\) и \(y\):
\begin{equation*}
\begin{split}
\frac{1}{2}(|00\rangle + |01\rangle + |10\rangle + |11\rangle) = x \frac{1}{\sqrt{3}}(|00\rangle + |01\rangle + |10\rangle) + y |11\rangle
\end{split}
\end{equation*}
\sphinxAtStartPar
Из данного уравнения находим \(x = \frac{\sqrt{3}}{2}\) и \(y = \frac{1}{2}\).

\sphinxAtStartPar
По этим координатам можно понять, что угол между вектором \(с\) и горизонтальной осью (обозначим его как \(\theta\)) равен \(\frac{\pi}{6}\). Если забежать немного вперед, то можно сказать, что наша цель – добиться, чтобы текущее состояние дошло до \(\frac{\pi}{2}\) (или хотя бы приблизительно), то есть почти или полностью равнялось искомому состоянию, так что после измерения можно было его и получить с высокой вероятностью.

\sphinxAtStartPar
Координаты текущего вектора состояния можно записать через угол \(\theta\):
\begin{equation*}
\begin{split}
x = \cos{\theta}
\end{split}
\end{equation*}\begin{equation*}
\begin{split}
y = \sin{\theta}
\end{split}
\end{equation*}
\sphinxAtStartPar
На всякий случай нужно уточнить, что вспомогательный кубит не отражается на рисунке с окружностью, так как он не предназначен для обозначения индекса, а только хранит в себе его метку.

\sphinxAtStartPar
После применения функции\sphinxhyphen{}оракула текущий вектор отразится относительно горизонтальной оси. Объясняется это очень легко – его вертикальная компонента (вектор \(|11\rangle\)) становится отрицательной.

\sphinxAtStartPar
Вектор \(c_{1b}\) – это отражение вектора \(c\) на угол \(\theta\) вниз относительно горизонтальной оси:

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{grover_1b}.png}
\caption{Состояние системы после первой части первой итерации.}\label{\detokenize{book/qcalgo/ru/grovers_algorithm:grover-1b}}\end{figure}

\sphinxAtStartPar
Такое отражение в нашем примере производится с помощью операции \(CCNOT\), но в общем случае операция выглядит так:
\begin{equation*}
\begin{split}
U_{1b} = I - 2|b\rangle \langle b|
\end{split}
\end{equation*}
\sphinxAtStartPar
Функцию\sphinxhyphen{}оракул мы здесь обозначили как \(U_{1b}\). Она меняет знак только для вертикальной составляющей вектора состояния, поэтому и происходит отражение.

\sphinxAtStartPar
Проверим формулу в действии, применив ее для нашего примера:

\sphinxAtStartPar
\(U_{1b} |c\rangle = (I - 2|11\rangle \langle 11|) \frac{1}{2}(|00\rangle + |01\rangle + |10\rangle + |11\rangle) = \frac{1}{2} (|00\rangle + |01\rangle + |10\rangle + |11\rangle - 2|11\rangle) =\)
\(= \frac{1}{2} (|00\rangle + |01\rangle + |10\rangle - |11\rangle)\)

\sphinxAtStartPar
И наконец приступаем к разбору второй части первой итерации. В ней будет происходить еще одно отражение вектора, но уже не относительно горизонтальной оси, а относительно вектора \(c\). Нетрудно заметить, что при этом текущий вектор состояния станет равен \(\cos{3 \theta}|a\rangle + \sin{3 \theta}|b\rangle\).

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{grover_1c}.png}
\caption{Состояние системы после второй части первой итерации.}\label{\detokenize{book/qcalgo/ru/grovers_algorithm:grover-1c}}\end{figure}

\sphinxAtStartPar
Операция для получения вектора \(c_{1c}\) будет выглядеть так:
\begin{equation*}
\begin{split}
U_{1c} = 2|c\rangle \langle c| - I
\end{split}
\end{equation*}
\sphinxAtStartPar
Посчитаем, чему равен вектор \(c_{1c}\) для нашего примера:
\begin{equation*}
\begin{split}U_{1c} |c_{1b}\rangle = (2|c\rangle \langle c| - I) \frac{1}{2}(|00\rangle + |01\rangle + |10\rangle - |11\rangle) = |11\rangle
\end{split}
\end{equation*}
\sphinxAtStartPar
Произошло отражение текущего вектора состояния \(|c_{1b}\rangle\) относительно вектора \(|c\rangle\). Если представить \(|c_{1b}\rangle\) как \(k_1 |c\rangle + k_2 |c_{\bot}\rangle\), где \(|c_{\bot}\rangle\) – вектор, перпендикулярный \(|c\rangle\), а \(k_1\) и \(k_2\) – действительные коэффициенты, то тогда отраженный вектор будет равен \(k_1 |c\rangle - k_2 |c_{\bot}\rangle\).

\sphinxAtStartPar
В нашей квантовой схеме эта часть итерации реализована таким образом:

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=450\sphinxpxdimen]{{iteration_part2}.png}
\caption{Вторая часть итерации.}\label{\detokenize{book/qcalgo/ru/grovers_algorithm:iteration-part2}}\end{figure}

\sphinxAtStartPar
Вначале применяется оператор Адамара для первого и второго кубитов. Это упрощает нашу задачу, так как теперь отразить вектор состояния нужно не относительно состояния суперпозиции \(\frac{1}{2}(|00\rangle + |01\rangle + |10\rangle + |11\rangle)\), а относительно состояния \(|00\rangle\).

\sphinxAtStartPar
Далее требуется отразить вектор, то есть всем состояниям кроме нулевого присвоить минус, но мы сделаем проще: присвоим минус нулевому состоянию \(|00\rangle\), а остальные состояния, составляющие суперпозицию, оставим как есть. Сделаем это, последовательно применив гейты \(X\) и \(CCNOT\). После этого вернемся в исходную “систему координат”, применив операции в обратном порядке: сначала \(X\), а потом \(H\).

\sphinxAtStartPar
Из\sphinxhyphen{}за применения такого лайфхака (присвоения минуса нулевому состоянию) мы в нашем двухкубитном примере получим результат с точностью до общей фазы: не \(|11\rangle\), а \(-|11\rangle\). Но это не страшно, так как после измерения мы все равно увидим искомое значение индекса.

\sphinxAtStartPar
По рисунку, изображающему на окружности состояние системы после второй части первой итерации, видно, что в общем случае каждая последующая итерация будет приближать текущий вектор к вертикальному. Но в нашем случае угол между вектором состояния и горизонтальной осью после окончания первой итерации равен \(3 \theta\), то есть это уже и есть желаемый угол \(\frac{\pi}{2}\).

\sphinxAtStartPar
В общем случае этот угол равен \((2t + 1) \theta \approx \frac{\pi}{2}\), где \(t\) – номер произведенной итерации. Отсюда можно вывести число итераций, необходимое для работы алгоритма. При большом требуемом количестве итераций \(t\) и фиксированном \(K = 1\) (для \(K > 1\) вывод формулы аналогичный) угол \(\theta\) будет близок к \(0\), так что его можно заменить на \(\sin{\theta}\), который, в свою очередь, равен \(\frac{1}{\sqrt{N}}\):
\begin{equation*}
\begin{split}
(2t + 1) \theta \rightarrow (2t + 1) \frac{1}{\sqrt{N}} \approx \frac{\pi}{2}
\end{split}
\end{equation*}
\sphinxAtStartPar
Если пренебречь единицей в скобках на основании того, что \(t\) – большое число, можно найти, что \(t\) приблизительно равно \(\frac{\pi \sqrt{N}}{4}\).

\sphinxAtStartPar
Мы уже разобрались, что каждая итерация состоит из двух частей. Первая часть – отражение вниз относительно горизонтальной оси. Вторая часть – отражение вверх относительно изначального состояния, то есть вектора \(c\). Вектор состояния всегда будет отражаться вверх на больший угол, чем в первой части итерации. Этим и будет обеспечиваться его постепенное приближение в вертикальной оси.

\sphinxAtStartPar
Мы разобрали случай, когда требуется найти один объект в таблице. Если же потребуется найти несколько объектов, то тогда, обозначив их количество за \(K\), мы должны будем проделать около \(\frac {\pi}{4} \sqrt {\frac{N}{K}}\) итераций. Таким образом, для успешной работы алгоритма Гровера необходимо знать число \(K\), чтобы можно было найти через него угол \(\theta\), а затем число итераций.


\section{Реализация алгоритма Гровера}
\label{\detokenize{book/qcalgo/ru/grovers_algorithm:id2}}
\sphinxAtStartPar
Итак, мы разобрали общие принципы алгоритма Гровера, а также рассмотрели конкретный пример. Настало время написать для этого примера программу.

\sphinxAtStartPar
Для начала импортируем все необходимые библиотеки и создадим схему из трех кубитов:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{pennylane} \PYG{k}{as} \PYG{n+nn}{qml}
\PYG{k+kn}{from} \PYG{n+nn}{pennylane} \PYG{k+kn}{import} \PYG{n}{numpy} \PYG{k}{as} \PYG{n}{np}

\PYG{n}{dev} \PYG{o}{=} \PYG{n}{qml}\PYG{o}{.}\PYG{n}{device}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{default.qubit}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{shots}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{wires}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Начальная функция, создающая суперпозицию для каждого кубита:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{U\PYGZus{}start}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{qml}\PYG{o}{.}\PYG{n}{PauliX}\PYG{p}{(}\PYG{n}{wires}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{qml}\PYG{o}{.}\PYG{n}{Hadamard}\PYG{p}{(}\PYG{n}{wires}\PYG{o}{=}\PYG{n}{i}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Создадим функцию, действующую аналогично оракулу (первая часть итерации). Эта функция помечает значение индекса \(11\):

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
 \PYG{k}{def} \PYG{n+nf}{U\PYGZus{}b}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{qml}\PYG{o}{.}\PYG{n}{Toffoli}\PYG{p}{(}\PYG{n}{wires}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Вторая часть итерации:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
 \PYG{k}{def} \PYG{n+nf}{U\PYGZus{}c}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{qml}\PYG{o}{.}\PYG{n}{Hadamard}\PYG{p}{(}\PYG{n}{wires}\PYG{o}{=}\PYG{n}{i}\PYG{p}{)}
        \PYG{n}{qml}\PYG{o}{.}\PYG{n}{PauliX}\PYG{p}{(}\PYG{n}{wires}\PYG{o}{=}\PYG{n}{i}\PYG{p}{)}

    \PYG{n}{qml}\PYG{o}{.}\PYG{n}{Toffoli}\PYG{p}{(}\PYG{n}{wires}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{qml}\PYG{o}{.}\PYG{n}{PauliX}\PYG{p}{(}\PYG{n}{wires}\PYG{o}{=}\PYG{n}{i}\PYG{p}{)}
        \PYG{n}{qml}\PYG{o}{.}\PYG{n}{Hadamard}\PYG{p}{(}\PYG{n}{wires}\PYG{o}{=}\PYG{n}{i}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Объединим первую и вторую часть итерации в одну функцию:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{U\PYGZus{}iteration}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{U\PYGZus{}b}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{U\PYGZus{}c}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Переходим к итоговой функции, содержащей все шаги, а также производящей измерение кубитов в конце. В аргументе \(N\) мы должны будем указать количество итераций:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nd}{@qml}\PYG{o}{.}\PYG{n}{qnode}\PYG{p}{(}\PYG{n}{dev}\PYG{p}{)}
\PYG{k}{def} \PYG{n+nf}{circuit}\PYG{p}{(}\PYG{n}{N}\PYG{p}{:} \PYG{n+nb}{int}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{U\PYGZus{}start}\PYG{p}{(}\PYG{p}{)}
    \PYG{k}{for} \PYG{n}{t} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{U\PYGZus{}iteration}\PYG{p}{(}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{qml}\PYG{o}{.}\PYG{n}{probs}\PYG{p}{(}\PYG{n}{wires}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Запускаем функцию и выведем ее результат:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{circuit}\PYG{p}{(}\PYG{n}{N}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
[0. 0. 0. 1.]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Так как в качестве искомого индекса выступало значение \(11\), то в результате запуска функции мы должны получить массив, состоящий из вероятностей каждого индекса, в котором искомый индекс (в нашем примере он будет последним в массиве) должен иметь наибольшую вероятность. Параметр устройства \sphinxcode{\sphinxupquote{shots}} при необходимости можно увеличивать, не забывая о том, что его увеличение будет кратно замедлять алгоритм. Таким образом, мы нашли с помощью алгоритма Гровера искомый индекс.

\sphinxAtStartPar
Алгоритм Гровера может применяться не только для задач простого поиска в базе данных, но и как дополнительное средство ускорения для поиска экстремума целочисленной функции, а также для поиска совпадающих строк в базе данных, так что этот алгоритм, как и его модификации, сможет быть полезным в разнообразных задачах Data Science.


\section{Задание}
\label{\detokenize{book/qcalgo/ru/grovers_algorithm:id3}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Распишите операторы \(U_{1b}\) и \(U_{1c}\) из примера в виде матриц \(4\)x\(4\) и проведите расчеты для получения \(c_{1b}\) и \(c_{1c}\) в виде векторов\sphinxhyphen{}столбцов.

\item {} 
\sphinxAtStartPar
Модифицируйте приведенный выше код алгоритма Гровера для двухкубитной базы данных так, чтобы искомый индекс соответствовал состоянию \(|00\rangle\).

\end{enumerate}

\sphinxstepscope


\chapter{Алгоритм Саймона}
\label{\detokenize{book/qcalgo/ru/simon_algorithm:simon-algorithm}}\label{\detokenize{book/qcalgo/ru/simon_algorithm:id1}}\label{\detokenize{book/qcalgo/ru/simon_algorithm::doc}}
\sphinxAtStartPar
Автор(ы):
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/Carinetta}{Решетова Карина}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/polyzer}{Токарев Игорь}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/flatslm}{Сендерович Леонид}

\end{itemize}


\section{Задача Саймона}
\label{\detokenize{book/qcalgo/ru/simon_algorithm:id2}}
\sphinxAtStartPar
Давайте начнём с того, что алгоритм Саймона решает задачу Саймона. Да, вот такой замечательный учёный \sphinxhyphen{} нашёл проблему, решил проблему.

\sphinxAtStartPar
По своей природе задача Саймона является разновидностью задачи о скрытой абелевой подгруппе {[}\hyperlink{cite.book/bibliography:id51}{Lom04}{]}.

\sphinxAtStartPar
Пусть задана функция \(f: \{0, 1\}^n \rightarrow \{0, 1\}^n\) и \sphinxstylestrong{неизвестная} строка \(s \in  \{0, 1\}^n\), для всех \(x, y \in \{0, 1\}^n\) выполняется:
\begin{equation*}
\begin{split}
    \large f(x) = f(y) \Leftrightarrow x \oplus y = s
  \end{split}
\end{equation*}
\sphinxAtStartPar
То есть, если мы для двух различных строк \(x\) и \(y\) имеем одинаковое значение \(f(x) = f(y)\), то \(x \oplus y\) равняется некоторой неизвестной строке \(s\).
Функция \(f(x)\) представляет собой чёрный ящик.

\sphinxAtStartPar
Задача состоит в том, чтобы \sphinxstylestrong{найти \(s\), выполнив при этом как можно меньшее количество вызовов \(f(x)\) .}


\section{Описание алгоритма}
\label{\detokenize{book/qcalgo/ru/simon_algorithm:id4}}
\sphinxAtStartPar
Сразу определим операцию на двух бинарных строках (они же бинарные векторы) \(x = x_0 x_1 x_2 ... x_{2^n-1}\), \(z = z_1 z_2 z_3 ... z_{2^n-1}\):
\begin{equation*}
\begin{split}
  \langle x, z\rangle = \bigoplus_{i=0}^{2^n-1} x_i \wedge z_i = x_0 \wedge z_0 \oplus x_1 \wedge z_1 \oplus ... \oplus x_{2^n-1} \wedge z_{2^n-1}
\end{split}
\end{equation*}
\sphinxAtStartPar
Принципиальная схема алгоритма Саймона:

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{simon_principal}.png}
\end{figure}

\sphinxAtStartPar
В принципе, есть небольшие вариации в реализации алгоритма, мы рассмотрим наиболее простую (все необходимые ссылки в конце приведены):
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Сначала приготовления. Вначале мы приготовим 2 набора квантовых регистров (каждый размерности \(n\)) в следующем состоянии:
\begin{equation*}
\begin{split}
      |\psi_0\rangle = |0\rangle|0\rangle
    \end{split}
\end{equation*}
\item {} 
\sphinxAtStartPar
Применяем гейты Адамара на первом регистре:
\begin{equation*}
\begin{split}
      (H^n \otimes I^n) |\psi_0\rangle = (H^n \otimes I^n) |0\rangle |0\rangle = |\psi_1 \rangle = \frac{1}{\sqrt{2^n}}\sum_{x \in \{ 0, 1\}^n}|x\rangle |0\rangle
    \end{split}
\end{equation*}
\item {} 
\sphinxAtStartPar
Применяем оператор \(U_f\), который выполняет следующее преобразование \(U_f(|x\rangle|0\rangle) = |x\rangle|f(x)\rangle\), т.е. во второй регистр записывается значение функции \(f(x)\):
\begin{equation*}
\begin{split}
      U_f(|\psi_1 \rangle) = U_f(\frac{1}{\sqrt{2^n}}\sum_{x \in \{ 0, 1\}^n}|x\rangle |0\rangle) = |\psi_2\rangle = \frac{1}{\sqrt{2^n}}\sum_{x \in \{ 0, 1\}^n}|x\rangle |f(x) \rangle
    \end{split}
\end{equation*}
\item {} 
\sphinxAtStartPar
Производим измерение на втором регистре. Измеренное значение будет соответствовать либо \(x\) либо \(y = x \oplus s\) . А первый регистр примет значение:
\begin{equation*}
\begin{split}
      |\psi \rangle_3 = \frac{1}{\sqrt{2}} \left( |x\rangle_1 + |y\rangle_1 \right)
    \end{split}
\end{equation*}
\item {} 
\sphinxAtStartPar
Снова применяем гейты Адамара на первом регистре:
\begin{equation*}
\begin{split}
      (H^n \otimes I^n) |\psi_2\rangle = |\psi_3\rangle = \frac{1}{2^n} \sum_{z \in \{ 0, 1\}^n}(-1^{\langle x, z\rangle} + -1^{\langle y, z\rangle}) |z\rangle,
    \end{split}
\end{equation*}
\sphinxAtStartPar
(операцию \(\langle x, z \rangle\) мы уже определяли выше).

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Для чисел \(x = 110111\) и \(z = 010101\) получим
\begin{equation*}
\begin{split}
    \langle x, z\rangle = 1 \wedge 0 \oplus 1 \wedge 1 \oplus 0 \wedge 0 \oplus 1 \wedge 1 \oplus 1 \wedge 0 \oplus 1 \wedge 1 = 1
  \end{split}
\end{equation*}\begin{equation*}
\begin{split}
    (-1)^{1} = -1
  \end{split}
\end{equation*}\end{sphinxadmonition}

\item {} 
\sphinxAtStartPar
Производим измерение на первом регистре. И здесь возможны 2 варианта исхода:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumii}{enumiii}{}{.}%
\item {} 
\sphinxAtStartPar
\( x \oplus y = s = 0^n \)

\sphinxAtStartPar
Учитывая \( x \oplus y = 0^n \) и то, что состояние всей системы описывается как
\begin{equation*}
\begin{split}
          \sum_{z \in \{0, 1\}^n}|z\rangle \otimes \frac{1}{2^n} \sum_{x \in \{0, 1\}^n}(-1^{\langle x, z\rangle}) |f(x) \rangle
        \end{split}
\end{equation*}
\sphinxAtStartPar
находим вероятность получить строку \(z\) на первом регистре
\begin{equation*}
\begin{split}
          p_z = \left\| \frac{1}{2^n} \sum_{z \in \{0, 1\}^n} \left((-1)^{\langle z, x\rangle} |f(x)\rangle \right) \right\|^2 = \frac{1}{2^n}
        \end{split}
\end{equation*}
\sphinxAtStartPar
т.е. в данном случае имеет место \sphinxstylestrong{равномерное распределение}.

\item {} 
\sphinxAtStartPar
\( x \oplus y = s \neq 0^n \)

\sphinxAtStartPar
Этот случай гораздо интереснее. Функция \(f\) преобразует два различных входных значения \(x_1, x_2 \in \{0,1\}^n\) в одно \(f(x_1) = f(x_2) = s \in \{0, 1\}^n\) .
Также \(x_1 \oplus x_2 = s\) эквивалентно \(x_1 \oplus s = x_2\).
\begin{equation*}
\begin{split}
          |\psi_3\rangle = \frac{1}{2^n}\sum_{z \in \{0, 1 \}^n}\sum_{x \in \{0, 1 \}^n} \frac{(-1)^{\langle z, x \rangle} (1 + (-1)^{\langle z, s\rangle})}{2} |z\rangle \oplus |f(x)\rangle=
        \end{split}
\end{equation*}\begin{equation*}
\begin{split}
          \frac{1}{2^n}\sum_{z \in \{0, 1 \}^n}|z\rangle \otimes \sum_{x \in \{0, 1 \}^n} \frac{(-1)^{\langle z,  x\rangle} (1 + (-1)^{\langle z, s\rangle})}{2} |f(x)\rangle
        \end{split}
\end{equation*}\begin{equation*}
\begin{split}
          p_z = \left\| \frac{1}{2^n} \sum_{x \in \{0, 1\}^n} \left((-1)^{\langle x, z\rangle} |f(x)\rangle \right) \right\|^2 =
        \left\| \frac{1}{2^n} \sum_{z \in A} \left(((-1)^{\langle x_1, z\rangle} + (-1)^{\langle x_2, z\rangle})|z\rangle \right) \right\|^2
        \end{split}
\end{equation*}\begin{equation*}
\begin{split}
        = \begin{cases}
            \frac{1}{2^{n-1}}, \text{ если } \langle z, s \rangle = 0 \\
            0, \text{ если }  \langle z, s \rangle = 1
          \end{cases}
        \end{split}
\end{equation*}
\end{enumerate}

\sphinxAtStartPar
Расчёты вероятностей можно найти в приложениях \sphinxhref{../../qcalgo/ru/simon\_algorithm.html\#id6}{Приложение 1}.

\sphinxAtStartPar
Выполняем алгоритм \(n\) раз. После чего у нас будет система \(n\) линейно независимых уравнений. Теперь приступаем к вычислению строки \(s\).

\item {} 
\sphinxAtStartPar
Постобработка.

\sphinxAtStartPar
Итак, для того, чтобы найти \(s = (s_0, s_1, s_2, ..., s_{n-1})^T\), нам потребуется \(n\) линейно независимых векторов \(\vec{z_i}\), для которых выполняется \(\langle \vec{z_i}, s \rangle = 0\).

\sphinxAtStartPar
После того как получена система из \(n\) линейно независимых уравнений, решение можно найти методом Гаусса.

\end{enumerate}


\section{Пример}
\label{\detokenize{book/qcalgo/ru/simon_algorithm:id5}}
\sphinxAtStartPar
Давайте возьмём n = 3, строку \(s = 100\), и функцию \(f\), которая соответствует критерию
\begin{equation*}
\begin{split}
  f(x) = f(y) \Leftrightarrow x \oplus s = y
\end{split}
\end{equation*}
\sphinxAtStartPar
Обычно функция \(f(x)\) задана наперёд. Ну а мы выберем её простейшей: \(f(x) = x \oplus s\).

\sphinxAtStartPar
Давайте посмотрим на таблицу истинности всех нужных переменных.
\begin{equation*}
\begin{split}
  \large
  \begin{array} {|r|r|r|}
  \hline x & x \oplus s & f(x) \\
  \hline 000 & 100 & 000 \\
  \hline 001 & 101 & 001 \\
  \hline 010 & 110 & 010 \\
  \hline 011 & 111 & 011 \\
  \hline 100 & 000 & 000 \\
  \hline 101 & 001 & 001 \\
  \hline 110 & 010 & 010 \\
  \hline 111 & 011 & 011 \\
  \hline  
  \end{array}
\end{split}
\end{equation*}
\sphinxAtStartPar
Нарисуем схему на Qiskit, которая будет показывать одну итерацию алгоритма:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{qiskit} \PYG{k+kn}{import} \PYG{n}{QuantumCircuit}\PYG{p}{,} \PYG{n}{ClassicalRegister}\PYG{p}{,} \PYG{n}{QuantumRegister}


\PYG{c+c1}{\PYGZsh{} Работаем в пространстве размерности n = 3}
\PYG{n}{n} \PYG{o}{=} \PYG{l+m+mi}{3}

\PYG{c+c1}{\PYGZsh{} Создаём необходимые регистры}
\PYG{n}{qr1} \PYG{o}{=} \PYG{n}{QuantumRegister}\PYG{p}{(}\PYG{n}{n}\PYG{p}{,} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{q1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{qr2} \PYG{o}{=} \PYG{n}{QuantumRegister}\PYG{p}{(}\PYG{n}{n}\PYG{p}{,} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{q2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{cr1} \PYG{o}{=} \PYG{n}{ClassicalRegister}\PYG{p}{(}\PYG{n}{n}\PYG{p}{,} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{c1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Шаг 1. Создаём квантовую схему (инициализация состояния)}
\PYG{n}{qc} \PYG{o}{=} \PYG{n}{QuantumCircuit}\PYG{p}{(}\PYG{n}{qr1}\PYG{p}{,} \PYG{n}{qr2}\PYG{p}{,} \PYG{n}{cr1}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Шаг 2. Применяем гейт Адамара ко всем кубитам первого регистра}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{h}\PYG{p}{(}\PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Шаг 3. Применяем U\PYGZus{}f}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{cx}\PYG{p}{(}\PYG{n}{qr1}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{qr2}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Шаг 4. Производим измерение второго регистра}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{measure}\PYG{p}{(}\PYG{n}{qr2}\PYG{p}{,} \PYG{n}{cr1}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Шаг 5. Ещё раз применяем гейт адамара к каждому из кубитов}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{h}\PYG{p}{(}\PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Шаг 6. Производим измерение первого регистра}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{measure}\PYG{p}{(}\PYG{n}{qr1}\PYG{p}{,} \PYG{n}{cr1}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Рисуем схему}
\PYG{n}{qc}\PYG{o}{.}\PYG{n}{draw}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
      ┌───┐     ┌───┐      ┌─┐
q1\PYGZus{}0: ┤ H ├──■──┤ H ├──────┤M├
      ├───┤  │  ├───┤┌─┐   └╥┘
q1\PYGZus{}1: ┤ H ├──┼──┤ H ├┤M├────╫─
      ├───┤  │  ├───┤└╥┘┌─┐ ║ 
q1\PYGZus{}2: ┤ H ├──┼──┤ H ├─╫─┤M├─╫─
      └───┘┌─┴─┐└┬─┬┘ ║ └╥┘ ║ 
q2\PYGZus{}0: ─────┤ X ├─┤M├──╫──╫──╫─
       ┌─┐ └───┘ └╥┘  ║  ║  ║ 
q2\PYGZus{}1: ─┤M├────────╫───╫──╫──╫─
       └╥┘  ┌─┐   ║   ║  ║  ║ 
q2\PYGZus{}2: ──╫───┤M├───╫───╫──╫──╫─
        ║   └╥┘   ║   ║  ║  ║ 
c1: 3/══╩════╩════╩═══╩══╩══╩═
        1    2    0   1  2  0 
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
При использовании Pennylane схема выглядит следующим образом:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{pennylane} \PYG{k}{as} \PYG{n+nn}{qml}
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{k+kn}{from} \PYG{n+nn}{typing} \PYG{k+kn}{import} \PYG{n}{Tuple}\PYG{p}{,} \PYG{n}{List}


\PYG{n}{n} \PYG{o}{=} \PYG{l+m+mi}{3}

\PYG{n}{dev} \PYG{o}{=} \PYG{n}{qml}\PYG{o}{.}\PYG{n}{device}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{default.qubit}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{shots}\PYG{o}{=}\PYG{l+m+mi}{128}\PYG{p}{,} \PYG{n}{wires}\PYG{o}{=}\PYG{n}{n}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}

\PYG{k}{def} \PYG{n+nf}{simon\PYGZus{}start}\PYG{p}{(}\PYG{n}{N}\PYG{p}{:} \PYG{n+nb}{int}\PYG{p}{)} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{k+kc}{None}\PYG{p}{:}
  \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{qml}\PYG{o}{.}\PYG{n}{Hadamard}\PYG{p}{(}\PYG{n}{wires}\PYG{o}{=}\PYG{n}{i}\PYG{p}{)}

\PYG{k}{def} \PYG{n+nf}{simon\PYGZus{}oracle}\PYG{p}{(}\PYG{n}{N}\PYG{p}{:} \PYG{n+nb}{int}\PYG{p}{)} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{k+kc}{None}\PYG{p}{:}
  \PYG{n}{qml}\PYG{o}{.}\PYG{n}{CNOT}\PYG{p}{(}\PYG{n}{wires}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{N}\PYG{p}{]}\PYG{p}{)}

\PYG{k}{def} \PYG{n+nf}{simon\PYGZus{}after\PYGZus{}oracle}\PYG{p}{(}\PYG{n}{N}\PYG{p}{:} \PYG{n+nb}{int}\PYG{p}{)} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{k+kc}{None}\PYG{p}{:}
  \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{qml}\PYG{o}{.}\PYG{n}{Hadamard}\PYG{p}{(}\PYG{n}{wires}\PYG{o}{=}\PYG{n}{i}\PYG{p}{)}


\PYG{n+nd}{@qml}\PYG{o}{.}\PYG{n}{qnode}\PYG{p}{(}\PYG{n}{dev}\PYG{p}{)}
\PYG{k}{def} \PYG{n+nf}{simon\PYGZus{}circuit}\PYG{p}{(}\PYG{n}{N}\PYG{p}{:} \PYG{n+nb}{int}\PYG{p}{)} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{Tuple}\PYG{p}{[}\PYG{n}{List}\PYG{p}{[}\PYG{n}{List}\PYG{p}{[}\PYG{n+nb}{int}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{n}{List}\PYG{p}{[}\PYG{n}{List}\PYG{p}{[}\PYG{n+nb}{int}\PYG{p}{]}\PYG{p}{]}\PYG{p}{]}\PYG{p}{:}
  \PYG{n}{simon\PYGZus{}start}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}
  \PYG{n}{simon\PYGZus{}oracle}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}
  \PYG{n}{simon\PYGZus{}after\PYGZus{}oracle}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}

  \PYG{n}{wx} \PYG{o}{=} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{N}\PYG{p}{)}
  \PYG{n}{wfx} \PYG{o}{=} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N}\PYG{p}{,} \PYG{n}{N}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}

  \PYG{k}{return} \PYG{n}{qml}\PYG{o}{.}\PYG{n}{sample}\PYG{p}{(}\PYG{n}{wires}\PYG{o}{=}\PYG{n}{wx}\PYG{p}{)}\PYG{p}{,} \PYG{n}{qml}\PYG{o}{.}\PYG{n}{sample}\PYG{p}{(}\PYG{n}{wires}\PYG{o}{=}\PYG{n}{wfx}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Схема возвращает массив результатов измерений первого}
\PYG{c+c1}{\PYGZsh{} регистра: x, и массив результатов измерения 2\PYGZhy{}го регистра: f(x).}
\PYG{c+c1}{\PYGZsh{} количестов измерений (samples) задано через shots}
\PYG{n}{x}\PYG{p}{,} \PYG{n}{fx} \PYG{o}{=} \PYG{n}{simon\PYGZus{}circuit}\PYG{p}{(}\PYG{n}{N}\PYG{o}{=}\PYG{n}{n}\PYG{p}{)}

\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{qml}\PYG{o}{.}\PYG{n}{draw\PYGZus{}mpl}\PYG{p}{(}\PYG{n}{simon\PYGZus{}circuit}\PYG{p}{)}\PYG{p}{(}\PYG{n}{N}\PYG{o}{=}\PYG{n}{n}\PYG{p}{)}
\PYG{n}{fig}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{simon_algorithm_3_0}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Созданная с помощью Pennylane схема визуально отличается от полученной с помощью Qiskit, так как Pennylane не позволяет выполнять операции с кубитами после выполнения измерения. Но так как с кубитами Y ({[}3, 4, 5{]}) после операции измерения не должно выполняться никаких действий, результат получается тот же самый.
\end{sphinxadmonition}

\sphinxAtStartPar
Теперь пройдём по всем шагам алгоритма:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Инициализация всех регистров в \(0\) состоянии:
\begin{equation*}
\begin{split}
      |\psi_0\rangle = |000\rangle_{1} |000\rangle_{2}
    \end{split}
\end{equation*}
\item {} 
\sphinxAtStartPar
Применяем Адамар к первому регистру:
\begin{equation*}
\begin{split}
      (H^n \otimes I)(|\psi_0\rangle) = |\psi_1\rangle = \frac{1}{\sqrt{8}}(|000\rangle + |001\rangle + |010\rangle + |011\rangle \\ + |100\rangle + |101\rangle + |110\rangle + |111\rangle)_1 |000 \rangle_{2})
    \end{split}
\end{equation*}
\item {} 
\sphinxAtStartPar
Применяем оракул \(U_f\):
\begin{align*}\!\begin{aligned}
U_f(|\psi_1\rangle = |\psi_2\rangle = \\\\
\frac{1}{\sqrt{8}} (|000\rangle_{1} |0 \oplus 0, 0, 0 \rangle_{2} \\
      + |001\rangle_{1} |0 \oplus 0, 0, 0 \rangle_{2} \\
      + |010\rangle_{1} |0 \oplus 0, 0, 0 \rangle_{2} \\
      + |011\rangle_{1} |0 \oplus 0, 0, 0 \rangle_{2} \\
      + |100\rangle_{1} |0 \oplus 1, 0, 0 \rangle_{2} \\
      + |101\rangle_{1} |0 \oplus 1, 0, 0 \rangle_{2} \\
      + |110\rangle_{1} |0 \oplus 1, 0, 0 \rangle_{2} \\
      + |111\rangle_{1} |0 \oplus 1, 0, 0 \rangle_{2} )\\
\end{aligned}\end{align*}
\item {} 
\sphinxAtStartPar
Измеряем второй регистр. С вероятностью \(\frac{1}{2}\) мы получим либо значение \(|000\rangle\) либо \(|100\rangle\). Допустим результат равен \(|100\rangle\). Тогда состояние первого регистра примет вид: \(|\psi_3\rangle = (|100\rangle_{1} + |101\rangle_{1} + |110\rangle_{1} + |111\rangle_{1})\).

\item {} 
\sphinxAtStartPar
Ещё один раз применяем гейты Адамара на первый регистр:
\begin{equation*}
\begin{split}
      |\psi_4 \rangle = \frac{1}{4} [ \left(|0\rangle - |1\rangle) \otimes (|0\rangle + |1\rangle) \otimes (|0\rangle + |1\rangle) \right)
    \end{split}
\end{equation*}\begin{equation*}
\begin{split}
      + \left(|0\rangle - |1\rangle) \otimes (|0\rangle + |1\rangle) \otimes (|0\rangle - |1\rangle) \right)
    \end{split}
\end{equation*}\begin{equation*}
\begin{split}
      + \left(|0\rangle - |1\rangle) \otimes (|0\rangle - |1\rangle) \otimes (|0\rangle + |1\rangle) \right)
    \end{split}
\end{equation*}\begin{equation*}
\begin{split}
      + \left(|0\rangle - |1\rangle) \otimes (|0\rangle - |1\rangle) \otimes (|0\rangle - |1\rangle) \right) ]
    \end{split}
\end{equation*}
\item {} 
\sphinxAtStartPar
Производим измерение первого регистра, записывая результат.

\sphinxAtStartPar
Выполняем шаги 1\sphinxhyphen{}6 \(n\) раз.

\item {} 
\sphinxAtStartPar
Здесь решаем систему уравнений.

\end{enumerate}


\section{Приложение}
\label{\detokenize{book/qcalgo/ru/simon_algorithm:id6}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Расчёт вероятностей.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumii}{enumiii}{}{.}%
\item {} 
\sphinxAtStartPar
Случай, когда \(x \oplus z = 0^n\) :
\begin{equation*}
\begin{split}
          \sum_{z \in \{0,1\}^n} |z\rangle \otimes \left( \frac{1}{2^n} \sum_{x \in \{0,1\}^n} ((-1)^{\langle x, z \rangle} |f(x)\rangle) \right)
        \end{split}
\end{equation*}
\sphinxAtStartPar
Вероятность получить какую\sphinxhyphen{}либо из \(2^n\) строк одинакова:
\begin{equation*}
\begin{split}
          p_z = \left\| \frac{1}{2^n} \sum_{z \in \{0, 1\}^n} \left((-1)^{\langle z, x\rangle} |f(x)\rangle \right) \right\|^2 = \frac{1}{2^n}
        \end{split}
\end{equation*}
\sphinxAtStartPar
Утверждение, данное выше, следует из того, что \(f(x)\) отличается от \(x\) лишь порядком во всём множестве строк \(\{0,1\}^n\):
\begin{equation*}
\begin{split}
          \left\| \frac{1}{2^n} \sum_{z \in \{0, 1\}^n} \left((-1)^{\langle z, x\rangle} |f(x)\rangle \right) \right\|^2 = \left\| \frac{1}{2^n} \sum_{z \in \{0, 1\}^n} \left((-1)^{\langle z, x\rangle} |x\rangle \right) \right\|^2
        \end{split}
\end{equation*}
\item {} 
\sphinxAtStartPar
Случай, когда \(x \oplus z = s \neq 0^n\):

\sphinxAtStartPar
Определим \(A = f(\{0,1\}^n)\) \sphinxhyphen{} образ функции \(f\), \(f(x_i) = \ell \in A\) \sphinxhyphen{} т.е. это какое\sphinxhyphen{}то значение функции \(f\). Здесь у нас имеются два таких значения \(x_1 \in \{0, 1\}^n \), \(x_2 \in \{0, 1\}^n \) , что для них выполняется \( x_2 = s \oplus x_1 \).
\begin{equation*}
\begin{split}
          p_z = \left\| \frac{1}{2^n} \sum_{\ell \in A} \left( ((-1)^{\langle z, x_1\rangle} + (-1)^{\langle z, x_2\rangle}) |\ell\rangle \right) \right\|^2 = \frac{1}{2^n}
        \end{split}
\end{equation*}
\sphinxAtStartPar
Перепишем коэффициенты \((-1)^{\langle x_1, z \rangle} + (-1)^{\langle x_2, z \rangle}\):
\begin{equation*}
\begin{split}
          (-1)^{\langle x_1, z \rangle} + (-1)^{\langle x_2, z \rangle} = (-1)^{\langle x_1, z \rangle} + (-1)^{\langle x_2 \oplus s, z \rangle}
        \end{split}
\end{equation*}
\sphinxAtStartPar
Также, заметим, что выполняется \(\langle x_1 \oplus s, z \rangle = \langle x_1, z \rangle \oplus \langle x_2, z \rangle\), тогда ещё раз перепишем:
\begin{equation*}
\begin{split}
          (-1)^{\langle x_1, z \rangle} (1 + (-1)^{\langle z, s \rangle})
        \end{split}
\end{equation*}
\sphinxAtStartPar
И собирая все полученные условия:
\begin{equation*}
\begin{split}
           p_z = \left\| \frac{1}{2^n} \sum_{\ell \in A} \left( (-1)^{\langle x_1, z \rangle} (1 + (-1)^{\langle z, s \rangle}) |\ell\rangle \right) \right\|^2 = \frac{1}{2^n}
        \end{split}
\end{equation*}
\sphinxAtStartPar
Если \(\langle z, s \rangle = 1\), то \((-1)^{\langle z, s \rangle} = -1\) и следовательно
\begin{equation*}
\begin{split}
          (-1)^{\langle x_1, z \rangle} (1 + (-1)^{\langle z, s \rangle}) = (-1)^{\langle x_1, z \rangle} (1 - 1) = 0
        \end{split}
\end{equation*}
\sphinxAtStartPar
И вероятность в таком случае равняется 0
\begin{equation*}
\begin{split}
          p_z = \left\| \frac{1}{2^n} \sum_{\ell \in A} \left( (-1)^{\langle x_1, z \rangle} (1 + (-1)^{\langle z, s \rangle}) |\ell\rangle \right) \right\|^2 = 0
        \end{split}
\end{equation*}
\sphinxAtStartPar
Иначе \(\langle z, s \rangle = 0\), и тогда \((-1)^{\langle z, s \rangle} = 1\):
\begin{equation*}
\begin{split}
          (-1)^{\langle x_1, z \rangle} (1 + (-1)^{\langle z, s \rangle}) = 2 (-1)^{\langle x_1, z \rangle}
        \end{split}
\end{equation*}
\sphinxAtStartPar
Вычисление вероятности
\begin{equation*}
\begin{split}
          p_z = \left\| \frac{1}{2^n} \sum_{\ell \in A} (-1)^{\langle x_1, z \rangle} 2 |\ell\rangle \right\|^2 =
        \end{split}
\end{equation*}\begin{equation*}
\begin{split}
          \left\| \frac{2}{2^n} \sum_{\ell \in A} (-1)^{\langle x_1, z \rangle} |\ell\rangle \right\|^2 = \left\| \frac{2}{2^n} \sum_{\ell \in A} (-1)^{\langle x_1, z \rangle} |\ell\rangle \right\|^2 = \left\| \frac{1}{2^{n-1}} \sum_{\ell \in A} (-1)^{\langle x_1, z \rangle} |\ell\rangle \right\|^2
        \end{split}
\end{equation*}\begin{equation*}
\begin{split}
          p_z = \begin{cases}
            \frac{1}{2^{n-1}}, \text{ если } \langle z, s \rangle = 0 \\
            0, \text{ если }  \langle z, s \rangle = 1
          \end{cases}
        \end{split}
\end{equation*}
\end{enumerate}

\end{enumerate}


\section{Ссылки}
\label{\detokenize{book/qcalgo/ru/simon_algorithm:id7}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://leimao.github.io/blog/Simon-Algorithm/}{Simon Algorithm}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://en.wikipedia.org/wiki/Simon\%27s\_problem}{Simon’s problem}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://qiskit.org/textbook/ch-algorithms/simon.html}{Qiskit Simon algorithm}

\end{itemize}

\sphinxstepscope


\part{Железо квантовых компьютеров}

\sphinxstepscope


\chapter{О блоке “Железо квантовых компьютеров”}
\label{\detokenize{book/hw/ru/hw_intro:hw-intro}}\label{\detokenize{book/hw/ru/hw_intro:id1}}\label{\detokenize{book/hw/ru/hw_intro::doc}}
\sphinxAtStartPar
Этот блок включает в себя обзор различных подходов к физической реализации квантовых вычислений. Как и классические компьютеры, квантовые компьютеры вовсе не обязаны быть основаны на какой\sphinxhyphen{}то одном физическом принципе работы: информация может храниться в токах и напряжениях в электрической схеме, спинах атомов, механическом положении или движении микроскопических частиц. Квантовая механика проявляется для любых достаточно малых систем. В качестве критерия малости можно использовать постоянную Планка \(\hbar\), которая имеет размерность фазового объема, или произведения координаты на импульс; это отражается и в принципе неопределенность Гейзенберга. Это значит, что если мы имеем систему, работающей на частоте \(\omega\), разность энергий уровней, в которых хранится информация, скорее всего будет порядка \(\hbar \omega\). Из\sphinxhyphen{}за того, что \(\hbar\sim 1.054\times 10^{-34}~\mathrm{J}\cdot\mathrm{s}\) – очень маленькое число, два квантовых состояния очень слабо отличаются друг от друга.

\sphinxAtStartPar
Из\sphinxhyphen{}за того, что все платформы для квантовых вычислений очень разные, делать конкретные утверждения про все сразу практически невозможно. В этом блоке будет дана обзорная классификация разных платформ по разным признакам со ссылками на оригинальные работы, а затем более подробная лекция про сверхпроводниковые кубиты.

\sphinxstepscope


\chapter{Обзор и классификация физических платформ для квантовых вычислений}
\label{\detokenize{book/hw/ru/hwreview:hwreview}}\label{\detokenize{book/hw/ru/hwreview:id1}}\label{\detokenize{book/hw/ru/hwreview::doc}}
\sphinxAtStartPar
Автор(ы):
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/ooovector}{Беседин Илья}

\end{itemize}


\section{Радиочастотные и оптические кубиты}
\label{\detokenize{book/hw/ru/hwreview:id2}}
\sphinxAtStartPar
Первый признак, по которому можно классифицировать разные кубиты, это характер тех двух квантовых состояний, в которых хранится информация. Рассмотрим, например, фрагмент структуры уровней для иона Yb\sphinxhyphen{}171+ {[}\hyperlink{cite.book/bibliography:id10}{Mon}{]}. Этот ион часто используют для квантовых вычислений.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{Yb171+_energy_levels}.png}
\caption{Фрагмент структуры энергетических уровней иона Yb\sphinxhyphen{}171+. У типичного атома очень много степеней свободы: спин ядра, спин электронной подсистемы, радиус орбитали электрона и проекция момента орбитали электрона. Переходы между состояниями имеют очень разные частоты, времена когерентности и восприимчивости к частот к внешним полям. Чтобы сделать из иона кубит, надо определиться, какой уровень будет “0”, а какой – “1”.}\label{\detokenize{book/hw/ru/hwreview:yb171-energy-levels}}\end{figure}

\sphinxAtStartPar
На сегодняшнем этапе все платформы для квантовых вычислений можно разделить на два класса: те, которые работают со сравнительно
низкими \(\omega/2\pi\sim10^{5}\dots10^{10}~\mathrm{Hz}\) частотами (вплоть до микроволновых), и те, которые работают на
высоких частотах \(\omega/2\pi\sim10^{13}\dots10^{15}~\mathrm{Hz}\). К первым относятся:
\begin{itemize}
\item {} 
\sphinxAtStartPar
сверхпроводниковые квантовые схемы;

\item {} 
\sphinxAtStartPar
кубиты на тонком и сверхтонком расщеплении в нейтральных атомах;

\item {} 
\sphinxAtStartPar
кубиты на сверхтонком расщеплении в ионах;

\item {} 
\sphinxAtStartPar
кубиты спинах в квантовых точках;

\item {} 
\sphinxAtStartPar
кубиты на экзотических квазичастицах, вроде Майорановских фермионов.

\end{itemize}

\sphinxAtStartPar
К второй группе относятся:
\begin{itemize}
\item {} 
\sphinxAtStartPar
оптические и телекоммуникационные фотонах;

\item {} 
\sphinxAtStartPar
кубиты на оптических переходах в атомах и ионах.

\end{itemize}

\sphinxAtStartPar
Квантовые компьютеры первого типа надо сильно охлаждать, так как они самовозбуждаются под действием броуновского движения и теплового излучения тел, находящихся при комнатной температуре.


\section{Природа степени свободы для кодирования информации}
\label{\detokenize{book/hw/ru/hwreview:id4}}
\sphinxAtStartPar
Можно классифицировать популярные платформы для квантовых вычислений и по другим признакам. Например, есть кубиты на естественных степенях свободы и кубиты на коллективных степенях свободы.

\sphinxAtStartPar
Естественные степени свободы – это:
\begin{itemize}
\item {} 
\sphinxAtStartPar
любые переходы в уединенных атомах и ионах;

\item {} 
\sphinxAtStartPar
фотоны в открытом пространстве.

\end{itemize}

\sphinxAtStartPar
Кубиты на естественных степенях свободы автоматически получаются одинаковыми: вы берете одинаковые атомы, и у них обязательно будут одинаковые переходы. Впрочем, если поместить их в какую\sphinxhyphen{}нибудь ловушку, то из\sphinxhyphen{}за того, что ловушки немного влияют на частоты переходов в атомах, эту эквивалентность легко испортить.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=666\sphinxpxdimen]{{cropatom-800x603}.jpg}
\caption{Фотография уединенного атома в ловушке. Источник: {[}\hyperlink{cite.book/bibliography:id42}{ion}{]}}\label{\detokenize{book/hw/ru/hwreview:single-atom}}\end{figure}

\sphinxAtStartPar
Кубиты на искусственных степенях свободы получаются когда имеет место коллективная динамика большого числа частиц, например поляризация в материала оптоволокна, или коллективное движение электронов в сверхпроводнике. Примеры искусственных степеней свободы:
\begin{itemize}
\item {} 
\sphinxAtStartPar
сверхпроводниковые электрические цепи;

\item {} 
\sphinxAtStartPar
фотоны в интегрально\sphinxhyphen{}оптической схеме;

\item {} 
\sphinxAtStartPar
фотоны в оптоволокне;

\item {} 
\sphinxAtStartPar
спины в квантовых точках;

\item {} 
\sphinxAtStartPar
любые квазичастицы в твердотельных системах.

\end{itemize}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{silicon-qubits}.png}
\caption{Изображение кремниевой микросхемой с кубитом на квантовой точке. Источник: {[}\hyperlink{cite.book/bibliography:id13}{SZK+18}{]}}\label{\detokenize{book/hw/ru/hwreview:silicon-qubits}}\end{figure}

\sphinxAtStartPar
На самом деле граница между естественными степенями свободы и искусственными вовсе не такая очевидная, как может показаться на первый взгляд. Так, например, фотон, находящийся в открытом пространстве, можно поместить между двумя зеркалами, которые образуют резонатор. Но в таком случае в зеркалах, и в носителях заряда в зеркале будет храниться часть энергии фотона – получается так называемый “поляритон”, который уже не совсем естественная степень свободы. Абсолютно тождественными могут быть только те носители информации, которые ни с чем не связаны.


\section{Способ кодирования информации}
\label{\detokenize{book/hw/ru/hwreview:id7}}
\sphinxAtStartPar
Только системы, где есть всего два уровня, а больше никакие не используются и не учитываются, строго говоря являются
кубитами. Такими являются, например:
\begin{itemize}
\item {} 
\sphinxAtStartPar
потоковые сверхпроводниковые кубиты;

\item {} 
\sphinxAtStartPar
логические кубиты, которые получаются выполнением кодов коррекции на большом числе физических кубитов любой природы.

\end{itemize}

\sphinxAtStartPar
Помимо “чистых” кубитов, у которых есть всего два дискретных состояния, существуют также “кудиты”, которые имеют \(d\) (\(d>2\)) состояний. Таковыми являются, например:
\begin{itemize}
\item {} 
\sphinxAtStartPar
ионы со сложной структурой уровней и правилами отбора переходов между ними;

\item {} 
\sphinxAtStartPar
сверхпроводниковые кубиты\sphinxhyphen{}трансмоны;

\item {} 
\sphinxAtStartPar
атомы и ридберговские состояния в них.

\end{itemize}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=550\sphinxpxdimen]{{transmon-wavefunctions}.png}
\caption{Потенциал и уровни энергии в сверхпровониковом кубите\sphinxhyphen{}трансмоне. Построено с помощью scqubits {[}\hyperlink{cite.book/bibliography:id5}{GK21}{]}. Как правило используются нижние два уровня, однако и остальные уровни можно использовать для алгоритмов}\label{\detokenize{book/hw/ru/hwreview:transmon-wavefunctions}}\end{figure}

\sphinxAtStartPar
Бывают модели квантовых вычислений на непрерывных степенях свободы, например:
\begin{itemize}
\item {} 
\sphinxAtStartPar
оптические вычисления на непрерывных переменных;

\item {} 
\sphinxAtStartPar
колебательное движение ионов в радиочастотных ловушках;

\item {} 
\sphinxAtStartPar
состояния микроволнового поля в сверхпроводниковых резонаторах.

\end{itemize}


\section{Способ выполнения операций}
\label{\detokenize{book/hw/ru/hwreview:id9}}
\sphinxAtStartPar
Модели вычислений в квантовых компьютерах можно классифицировать по признаку способа реализации операций в них. Самый простой и очевидный способ – воздействие на кубит (кудит, непрерывную переменную) при помощи короткого аналогового сигнала на резонансной частоте этой системы, причем амплитуда и фаза этого сигнала будет определять унитарную матрицу операции. Так работают
\begin{itemize}
\item {} 
\sphinxAtStartPar
сверхпроводниковые кубиты\sphinxhyphen{}трансмоны и потоковые кубиты;

\item {} 
\sphinxAtStartPar
кубиты на ионах в радиочастотных ловушках;

\item {} 
\sphinxAtStartPar
кубиты на нейтральных атомах в дипольных ловушках.

\end{itemize}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=666\sphinxpxdimen]{{ions-computation-schematic}.png}
\caption{Схема квантового компьютера на ионах. Источник: {[}\hyperlink{cite.book/bibliography:id16}{WBD+19}{]}. Кубиты расположены рядом друг с другом в вакуумной камере, а управляющие сигналы представляют собой лазерные лучи, направленные на каждый ион. Для однокубитных и двухкубитных операций используют разные лазеры, для считывания – еще лазер. Рассеянное на ионе излучение последнего лазера детектируется, чтобы определить состояние кубита. Похожим образом работают и кубиты на нейтральных атомах (там есть дополнительный оптический пинцет), и сверхпроводникые кубиты (там вместо лазеров используются микроволновые кабели).}\label{\detokenize{book/hw/ru/hwreview:ion-computation-schematic}}\end{figure}

\sphinxAtStartPar
Бывают вычислительные модели, в которых вместо временной последовательности управляющих сигналов носитель информации движется по “конвейеру”, вдоль которого с ним выполняются операции. Так работают, например, вычисления на:
\begin{itemize}
\item {} 
\sphinxAtStartPar
фотонах в интегральной оптике;

\item {} 
\sphinxAtStartPar
фотонах в открытом пространстве.

\end{itemize}

\sphinxAtStartPar
Некоторые модели вычислений вовсе не предполагают выполнения каких\sphinxhyphen{}то изолированных операций. Впрочем, для таких моделей вычислений и не выполняется большинство утверждений и теоретических предсказаний, связанных с квантовыми вычислениями. Таковыми моделями является, например, \sphinxstylestrong{квантовый аннилер D\sphinxhyphen{}Wave}. Важно отметить, что классические компьютеры работают совсем иначе, чем все вышеперечисленные квантовые компьютеры. В них операции осуществляются цифровыми сигналами, то есть от непосредственного значения уровня сигнала слабо зависит то, какая операция будет выполнена, главное, чтобы сигнал вовремя превысил некоторое пороговое значение. Цифровой характер классических компьютеров имеет очень важное значение для масштабирования алгоритмов, ведь именно он обеспечивает воспроизводимость и возможность безошибочной работы квантового компьютера. К моделям квантовых вычислений, нечувствительным к аналоговым ошибкам управляющих сигналов, или с пониженной чувствительностью к ним, можно отнести:
\begin{itemize}
\item {} 
\sphinxAtStartPar
кубиты на майорановских фермионах;

\item {} 
\sphinxAtStartPar
логические кубиты, которые получаются в результате работы алгоритмов квантовой коррекции ошибок на физических кубитах
любой природы;

\item {} 
\sphinxAtStartPar
сверхпроводниковые 0\sphinxhyphen{}пи кубиты, при условии, что гейты будут производиться специальным помехозащищенным образом, а не
через промежуточные уровни.

\end{itemize}


\section{Наборы инструкций и универсальность}
\label{\detokenize{book/hw/ru/hwreview:id11}}
\sphinxAtStartPar
Разные модели вычислений дают разные наборы инструкций для реализации квантовых алгоритмов. В зависимости от вероятности успешной реализации инструкций (квантовые компьютеры делают ошибки!) эти модели вычислений могут быть ближе, либо дальше от создания универсального масштабируемого квантового компьютера. По этому признаку:
\begin{itemize}
\item {} 
\sphinxAtStartPar
сверхпроводниковые кубиты;

\item {} 
\sphinxAtStartPar
нейтральные атомы;

\item {} 
\sphinxAtStartPar
ионы в радиочастотных ловушках

\end{itemize}

\sphinxAtStartPar
являются самыми очевидными. Набор инструкций в них содержит однокубитные и двухкубитные операции, инициализацию кубита в определенном состоянии и считывание. Чем выше точность операций – тем лучше, и все операции на сегодняшний день продемонстрированы с вероятностью положительного исхода выше 99\% – этого все еще мало для многих применений, но это уже что\sphinxhyphen{}то.

\sphinxAtStartPar
Для вычислений на линейнооптических схемах используются источники единичных эквивалентных фотонов, либо источники запутанных фотонов, либо источники сжатого света. Вероятность успеха операции по созданию такого излучения (либо степень сжатия света) на сегодняшний день сильно далека от того, что нужно для универсальности квантовых вычислений; здесь идет речь о сжатии порядка 10 дБ (грубо переводя на язык “успешного выполнения операции” 0,9), и вероятности испускания фотона 0,9. Однако отсутствие универсальности не означает, что линейнооптические схемы должны быть для всех задач вычислительно слабее, чем другие платформы: напротив, самое сильное квантовое превосходство на сегодняшний день достигнуто именно на таких устройствах.

\sphinxAtStartPar
Причина, по которой линейнооптические системы выделяются среди других заключается в том, что для полноценного компьютера (что классического, что квантового) нужны нелинейные элементы. В классическом компьютере  это транзисторы. На одних линейных индуктивностях и емкостях можно, в зависимости от способа кодирования информации, выполнять какой\sphinxhyphen{}то набор операций, но универсальным он не будет, потому что функция отклика линейной цепи является линейным. Алгоритмы, которые не сводятся к умножению матрицы на вектор в некотором представлении данных, на линейной системе выполнить не получится. Чтобы обойти это ограничение, линейно\sphinxhyphen{}оптические системы для квантовых вычислений принимают на часть своих входов, в дополнение к входным данным, сложные неклассические сигналы, а на выходе производится считывание числа фотонов, которое является квадратичным по отношению к амплитудам сигналов. Дополнение линейной оптики наборами нелинейных операций может сделать такие модели вычислений универсальными.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=550\sphinxpxdimen]{{xanadu}.png}
\caption{Принципиальная схема работы оптического квантого чипа Xanadu. Вязто из работы {[}\hyperlink{cite.book/bibliography:id2}{ABBradler+21}{]}.
a – квантовый алгоритм, выполняемый схемой: 1) сжатие света до 8 модах и создание запутанности
(формирование двухмодового сжатового состояния света, эквивлент однокубитных гейтов), 2) программируемые двухкубитные
гейты в каждом четырехмодовом подпространстве, 3) считывание всех 8 мод в фоковском базисе;
b – изображение чипа, на котором видны основные модули;
c – схема управляющих сигналов и приборов;
d – фотография всей системы (кроме управления детектором фотонов) в серверной стойке.}\label{\detokenize{book/hw/ru/hwreview:xanadu-principle-schematic}}\end{figure}

\sphinxAtStartPar
Наконец, кубиты с дискретными операциями, такие как логические кубиты и кубиты на майорановских фермионах, сами по себе не дают полный набор квантовых логических операций – в дополнение к ним нужны обычные кубиты. Впрочем, задача построения кубита на майорановских фермионах или на коррекции ошибок сама по себе настолько сложная, что необходимость связать с ним обыкновенные дополнительные кубиты не кажется такой сложной.


\section{Успехи в практической реализации}
\label{\detokenize{book/hw/ru/hwreview:id13}}
\sphinxAtStartPar
Платформы для квантовых вычислений можно отсортировать по максимальному размеру гильбертова пространства и точности операций (не только унитарных гейтов, но и считыванию и инициализации), которое удавалось реализовать экспериментально. В этом рейтинге только три верхние платформы находятся относительно близко к режиму квантового превосходства в подтвержденных экспериментальных работах. Итак, рейтинг:
\begin{itemize}
\item {} 
\sphinxAtStartPar
линейная оптика (фотоны) в открытом пространстве;

\item {} 
\sphinxAtStartPar
сверхпроводниковые кубиты\sphinxhyphen{}трансмоны;

\item {} 
\sphinxAtStartPar
ионы в линейных радиочастотных ловушках;

\item {} 
\sphinxAtStartPar
интегральнооптические фотоны;

\item {} 
\sphinxAtStartPar
нейтральные атомы в дипольных ловушках;

\item {} 
\sphinxAtStartPar
спины в квантовых точках.

\end{itemize}

\sphinxAtStartPar
Другие платформы существуют на сегодняшний день в лучшем случае в виде двухкубитной системы, чаще – одного кубита, а лучше вообще в виде теоретической концепции – которая может оказаться вовсе нереализуемой на практике.

\sphinxstepscope


\chapter{Сверхпроводниковые кубиты}
\label{\detokenize{book/hw/ru/scqubits:scqubits}}\label{\detokenize{book/hw/ru/scqubits:id1}}\label{\detokenize{book/hw/ru/scqubits::doc}}
\sphinxAtStartPar
Автор(ы):
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/ooovector}{Беседин Илья}

\end{itemize}

\sphinxAtStartPar
Сверхпроводниковые кубиты относятся к наиболее успешным типам кубитов для квантовых вычислений и симуляции на сегодняшний день. Google впервые продемонстрировала квантовое превосходство на квантовом процессоре из 53 сверхпроводниковых кубитов\sphinxhyphen{}трансмонов {[}\hyperlink{cite.book/bibliography:id68}{AAB+19}{]}. Кроме Google, сверхпроводниковые кубиты используют IBM (в том числе для своего открытого облачного проекта IBM Quantum Experience), Riggetti Computing и другие крупные фирмы и лаборатории по всему миру.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=550\sphinxpxdimen]{{two-qubit-chip}.png}
\caption{Фотографии, изображения со сканирующего электронного микроскопа и эквивалентная электрическая схема микросхемы сверхпроводникового квантового процессора с двумя кубитами\sphinxhyphen{}трансмонами. Синим отмечен электрод одного из трансмонов. Микросхема была изготовлена в НОЦ ФМН в МГТУ им. Баумана, топология разработана в НИТУ МИСиС.}\label{\detokenize{book/hw/ru/scqubits:two-qubit-quantum-processor}}\end{figure}

\sphinxAtStartPar
Квантовый процессор на сверхпроводниковых кубитах – это электрическая цепь. Эту электрическую цепь можно изобразить в схемы с квазисосредоточенными элементами.


\section{Квантование электрических цепей}
\label{\detokenize{book/hw/ru/scqubits:id3}}
\sphinxAtStartPar
Электрические цепи, как и любые другие физические объекты, могут быть описаны с помощью законов квантовой механики {[}\hyperlink{cite.book/bibliography:id14}{VD17}{]}. Для этого следует начать с гамильтонового описания, например с помощью функции Лагранжа. Энергия всей физической системы (электрической цепи) должна быть записана в виде суммы энергий, накопленных ее составными частями (сосредоточенных элементов), выраженной через динамическое переменные системы и их производные. Самые простые электрические элементы, такие как конденсаторы и индукторы, запасают энергию \(E_C\) и \(E_L\) в электрическом и магнитном поле, а выражение для них можно записать либо через заряд на обкладках \(Q\) и поток через кольцо \(\Phi\), либо через напряжение \(V\) и ток \(I\), соответственно:
\begin{equation*}
\begin{split}
E_C = \frac{Q^2}{2C}=\frac{CV^2}{2},
\end{split}
\end{equation*}\begin{equation*}
\begin{split}
E_L = \frac{\Phi^2}{2L}=\frac{LI^2}{2}.
\end{split}
\end{equation*}
\sphinxAtStartPar
Для третьего самого простого линейного элемента электрической цепи, резистора, так сделать не получится. Резистор не накапливает в себе энергию, он ее диссипирует. Диссипативные системы не могут быть описаны исключительно при помощи функции Лагранжа. Это не значит, что резистор совершенно невозможно адекватно описать в гамильтоновом формализме: он может быть представлен как бесконечный резервуар энергии, так как с точки зрения остальной цепи не слишком важно, осталась ли энергия в резисторе или она была рассеяна, если она никогда больше не вернется в остальные элементы цепи. Резисторы не слишком полезны в квантовой обработке информации, так как любые потери энергии приводят к неунитарной эволюции, потере когерентности и в конечном счете – ошибкам вентилей.

\sphinxAtStartPar
В электротехнике, как правило, используются переменные \(V\) и \(I\): напряжение и ток можно померить, правильно подключив измерительные приборы к проводникам цепи, в то время как измерения \(Q\) и \(\Phi\) затруднены, так как заряды и потоки локализованы внутри элементов. Но \(V\) и \(I\) не подходят в качестве переменных, от которых зависит функция Лагранжа, так как ни одна из них не является производной другой. Зато из закона сохранения заряда следует, что \(\dot{Q}=-I\), а закон индукции Фарадея говорит, что \(\dot{\Phi}=V\), а значит и \(\Phi\), и \(Q\) могут быть использованы в качестве динамических переменных системы.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=550\sphinxpxdimen]{{LC}.png}
\caption{Электрические схемы одного LC\sphinxhyphen{}контура и двух емкостно связанных LC\sphinxhyphen{}контуров.}\label{\detokenize{book/hw/ru/scqubits:lc-circuit}}\end{figure}

\sphinxAtStartPar
В случае одной степени свободы определения для величин \(Q\), \(\Phi\), \(V\) и \(I\) однозначны.
В более сложных случаях в классической электротехнике принято использовать метод контурных токов, либо узловых напряжений. Рассмотрим метод узловых напряжений. Для лагранжевого описания введем узловой поток \(\Phi_i(t)\) как первообразную напряжения на узле с номером \(i\) \(V_i(t)\):
\begin{equation*}
\begin{split}
\Phi_i(t) = \int\limits_0^t V_i(t) \mathrm{d}t.
\end{split}
\end{equation*}
\sphinxAtStartPar
Функция Лагранжа LC\sphinxhyphen{}контура имеет вид
\begin{equation*}
\begin{split}
L(\Phi_1, \dot{\Phi}_1) = \frac{C\dot{\Phi}_1^2}{2}-\frac{\Phi_1^2}{2L}.
\end{split}
\end{equation*}
\sphinxAtStartPar
Канонически сопряженный импульс \(Q_i\) к обобщенной переменной \(\Phi_i\) можно найти по формуле
\begin{equation*}
\begin{split}
Q_i = \frac{\partial L}{\partial \dot{\Phi}_i} = C\dot{\Phi}_i.
\end{split}
\end{equation*}
\sphinxAtStartPar
Физический смысл этого импульса – сумма зарядов на конденсаторах, примыкающих к узлу \(i\), или узловой заряд.

\sphinxAtStartPar
Функция Гамильтона \(H(\Phi_i, Q_i)\) представляет собой преобразование Лежандра от функции Лагранжа по парам \((\dot{\Phi}_i, Q_i)\),
то есть
\begin{equation*}
\begin{split}
H(\Phi_i, Q_i) = \dot{\Phi}_i \dot{Q}_i - L = \frac{Q_i^2}{2C} + \frac{\Phi_i^2}{2L}.
\end{split}
\end{equation*}
\sphinxAtStartPar
Оператор Гамильтона может быть получен из функции Гамильтона заменой переменных \(\Phi_1, Q_1\) на соответствующие операторы:
\begin{equation*}
\begin{split}
H = \frac{\hat{Q}_1^2}{2C} + \frac{\hat{\Phi}_1^2}{2L}.
\end{split}
\end{equation*}
\sphinxAtStartPar
Здесь \([\hat{Q}_1, \hat{\Phi}_1]=-i\hbar\) в силу того, что \(\Phi_1\) и \(Q_1\) – каноническая переменная и сопряженный к ней импульс. Волновая функция системы может быть записана в потоковом \(\psi_\Phi(\Phi_1)\) или зарядовом \(\psi_Q(Q_1)\) представлении. Переход от одного представления к другому, как в случае обыкновенных координат и импульсов, может быть произведен с помощью преобразования Фурье
\begin{equation*}
\begin{split}
\psi_\Phi(\Phi_1)=\frac{1}{\sqrt{2\pi}}\int e^{i\Phi_1 Q_1}\psi_Q(Q_1, Q_2)\mathrm{d}Q_1.
\end{split}
\end{equation*}
\sphinxAtStartPar
Как и в случае механических осцилляторов, для LC\sphinxhyphen{}осцилляторов очень полезен формализм операторов вторичного квантования \(\hat{a}\) и \(\hat{a}^\dagger\), которые можно определить как
\begin{equation*}
\begin{split}
\hat{Q}_1 = \sqrt{\frac{\hbar}{2Z}}(\hat{a}_1+\hat{a}_1^\dagger),
\end{split}
\end{equation*}\begin{equation*}
\begin{split}
\hat{\Phi}_1 = i\sqrt{\frac{\hbar Z}{2}}(\hat{a}_1-\hat{a}_1^\dagger),
\end{split}
\end{equation*}
\sphinxAtStartPar
где \(Z=\sqrt{L_1/C_1}\) – импеданс осциллятора. В этом формализме гамильтониан системы принимает вид
\begin{equation*}
\begin{split}
\hat{H} = \hbar\omega_1(\hat{a}_1^\dagger\hat{a}_1+\frac{1}{2}),
\end{split}
\end{equation*}
\sphinxAtStartPar
где \(\omega_1=(L_1C_1)^{-1/2}\) – частота осциллятора.


\section{Джозефсоновский контакт}
\label{\detokenize{book/hw/ru/scqubits:id5}}
\sphinxAtStartPar
Линейные электрические элементы, такие как емкости и индуктивности, очень полезны при создании электронных приборов. Но из линейных элементов можно создать только линейную электрическую цепь. Это означает, что любые выходные сигналы \(V^\mathrm{out}_i(\omega)\) выражаются через входные сигналы \(V^\mathrm{in}_j(\omega)\) с помощью линейного преобразования
\begin{equation*}
\begin{split}
V^\mathrm{out}_i(\omega)=\sum\limits_j S_{ij}(\omega) V^\mathrm{in}_j(\omega).
\end{split}
\end{equation*}
\sphinxAtStartPar
Это выражение остается справедливым и для квантового случая, где величина \(V^\mathrm{out}_i(\omega)\) является оператором. \(S_{ij}(\omega)\) \sphinxhyphen{} это передаточная функция, или S\sphinxhyphen{}параметр системы. Для линейной системы S\sphinxhyphen{}параметр зависит лишь от частоты сигнала, но не зависит от состояния системы. По существу линейные системы не обладают состоянием, т.е. не могут играть роль памяти. В частности, такие системы не могут эффективно симулировать машину Тьюринга и тем более квантовую машину Тьюринга. Они могут реализовывать некоторое линейное преобразование над входными данными, однако это линейное преобразование жестко задано топологией и номиналами емкостей и индуктивностей цепи.

\sphinxAtStartPar
Для того, чтобы создать архитектуру компьютера, в которой есть память или управление, нужны нелинейные элементы. В классической электронике в качестве нелинейного элемента чаще всего используют транзистор. Наиболее популярный в интегральных микросхемах \sphinxhyphen{} это полевой транзистор. Полевой транзистор имеет три контакта, причем напряжение между затвором и стоком управляет сопротивлением между стоком и истоком. Для квантовой обработки информации управление сопротивлением – не самый практичный вариант, в связи с тем, что протекание тока через конечные сопротивления приводит к ошибкам квантовых вентилей.

\sphinxAtStartPar
В качестве альтернативы полупроводниковым нелинейным элементам вроде транзистора и диода можно использовать сверхпроводниковые нелинейные элементы. Одним из таких элементов является джозефсоновский контакт сверхпроводник\sphinxhyphen{}изолятор\sphinxhyphen{}сверхпроводник (Superconductor\sphinxhyphen{}insulator\sphinxhyphen{}superconductor, SIS).

\sphinxAtStartPar
Для гамильтонового описания джозефсоновского контакта как элемента электрической цепи используется джозефсоновская энергия, которая определяется соотношением
\begin{equation*}
\begin{split}
E_J = \frac{I_c \Phi_0}{2\pi}(1-\cos \phi),
\end{split}
\end{equation*}
\sphinxAtStartPar
где \(I_c\) – критический ток контакта, \(\Phi_0 = h/2e\) – квант магнитного потока в сверхпроводнике, \(\phi = 2\pi \Phi/\Phi_0\) – обезразмеренная на квант потока разность узловых потоках на берегах контакта. Эта величина одновременно является фазой конденсата куперовских пар в сверхпроводнике. Для понимания принципов работы сверхпроводниковых кубитов совершенно необязательно понимать физику самой сверхпроводимости, что такое куперовская пара, что подразумевается под словом конденсат и что значит его фаза. С точки зрения схемотехники кубитов, все знания о физике сверхпроводников могут быть сведены к определению фазы и соотношением для энергии контакта в зависимости от фазы. Эти соотношения однозначно определяют поведение потоков и зарядов в цепи. Мы будем пользоваться фазой вместо узлового потока исключительно из\sphinxhyphen{}за того, что эта величина является безразмерной, и это позволит упростить все соотношения. Также заряд будет измеряться в единицах заряда куперовской пары, то есть \(2e\).

\sphinxAtStartPar
Дифференцируя соотношение для джозефсоновской энергии по потоку, можно получить выражение для индуктивности джозефсоновского контакта
\begin{equation*}
\begin{split}
L_J=\frac{1}{\frac{\partial^2 E}{\partial \Phi^2}} =
\frac{2\pi\Phi_0^2}{I_c \Phi_0 (2\pi)^2\cos \phi}=\frac{\Phi_0}{I_c 2\pi \cos \phi}.
\end{split}
\end{equation*}

\section{Трансмон}
\label{\detokenize{book/hw/ru/scqubits:id6}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{Transmon}.png}
\caption{Электрическая схема трансмона. \(I_c\) – критический ток контакта, \(C_S\) – шунтриующая емкость, \(C_J\) – емкость контакта}\label{\detokenize{book/hw/ru/scqubits:transmon-electric-circuit}}\end{figure}

\sphinxAtStartPar
Самый простой, и в то же время один самых успешных видов сверхпроводниковых кубитов – это трансмон{[}\hyperlink{cite.book/bibliography:id7}{KYG+07}{]}. Трансмон представляет собой ангармонический осциллятор на основе наноразмерного джозефсоновского контакта, шунтированного емкостью. Такая цепь хорошо известна в сверхпроводниковой электронике, а ее резонансная частота называется плазменной частотой:
\begin{equation*}
\begin{split}
\omega_{\mathrm{p}} = \frac{1}{\sqrt{L_{J}(C_J+C_S)}}.
\end{split}
\end{equation*}
\sphinxAtStartPar
В квантовом случае, свойства этого осциллятора могут зависеть от постоянного напряжения \(V_g\). Наступление квантового режима определяется произведением критического тока и емкости; фактически, в зависимости от этого произведения, такая схема может быть классическим осциллятором, трансмоном или зарядовым кубитом.

\sphinxAtStartPar
Гамильтониан трансмона (а также зарядового кубита) имеет вид
\begin{equation*}
\begin{split}
\hat{H} = \frac{(2e)^2(\hat{n}-n_\mathrm{g})^2}{2(C_J+C_S)} + \frac{I_c\Phi_0}{2\pi}(1-\cos\hat{\phi}),
\end{split}
\end{equation*}
\sphinxAtStartPar
где \(\hat{n}=\hat{Q}/2e\), \(\hat{\phi}=\frac{2e}{\hbar}\hat{\Phi}\) – безразмерные операторы числа и фазы куперовских пар на электроде, а \(n_\mathrm{g}\) – средний наведенный на острове внешними источниками напряжения заряд. Гамильтониан можно упростить, заменив произведения размерных константы на параметры
\begin{equation*}
\begin{split}
E_C=\frac{e^2}{2(C_J+C_S)}
\end{split}
\end{equation*}\begin{equation*}
\begin{split}
E_J=\frac{I_c\Phi_0}{2\pi},
\end{split}
\end{equation*}
\sphinxAtStartPar
которые называют емкостной и джозефсоновской энергией трансмона, соответственно. В этих обозначениях гамильтониан принимает вид
\begin{equation*}
\begin{split}
\hat{H} = 4E_C(\hat{n}-n_g)^2+E_J(1-\cos\hat{\phi}).
\end{split}
\end{equation*}
\sphinxAtStartPar
Уровни энергии стационарных состояний в такой системе будут зависеть от приложенного напряжения (вернее, от наведенного внешним напряжением \(V_g\) зарядом \(n_g\)). Однако эта зависимость ослабевает по мере того, как увеличивается соотношение \(E_J/E_C\).

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=550\sphinxpxdimen]{{transmon-wavefunctions}.png}
\caption{Уровни энергии в зарядовом кубите и в трансмоне}\label{\detokenize{book/hw/ru/scqubits:transmon-wavefunctions-and-potential}}\end{figure}

\sphinxAtStartPar
\sphinxstylestrong{Трансмоном} называется режим этой электрической цепи, когда \(E_J/E_C \sim 50\); при таком соотношении между константами зависимость от заряда практически отсутствует. Это очень хорошо, потому что наведенный заряд очень сложно контролировать на практике. Космические частицы и события радиоактивного распада в подложке приводят к запиранию зарядов в случайных местах в подложке, из\sphinxhyphen{}за чего зарядово\sphinxhyphen{}чувствительные кубиты могут менять частоту перехода между уровнями. Уровни энергии в трансмоне не чувствительны к таким воздействиям, что значительно улучшает их времена когерентности по сравнению с зарядовыми кубитами. Обратной стороной такой схемы является невысокий ангармонизм. Ангармонизмом \(\delta\) называется разность частот между переходами \(|0\rangle \leftrightarrow |1\rangle\) и \(|1\rangle \leftrightarrow |2\rangle\). У трансмона \(\delta = -E_C\). По существу, трансмон является слабо ангармоничным осциллятором. Однако расстояния между частотами переходов в трансмоне достаточно большие, чтобы можно было попасть в один переход и при этом не попасть в соседний.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=550\sphinxpxdimen]{{cpb-dispersion}.png}
\caption{Уровни энергии и волновые функции стационарных состояний трансмона с \(E_J/E_C=50\)}\label{\detokenize{book/hw/ru/scqubits:transmon-energy-levels-and-wavefunctions}}\end{figure}


\section{Считывание}
\label{\detokenize{book/hw/ru/scqubits:id8}}
\sphinxAtStartPar
Считывание состояния кубита в сверхпроводящих цепях, как правило, осуществляется методом дисперсионного считывания {[}\hyperlink{cite.book/bibliography:id15}{WSB+05}{]}. В основе дисперсионного считывания состояния сверхпроводниковых кубитов стоит архитектура квантовой электродинамики в электрической цепи, в которой сверхпроводниковый кубит связан с микроволновым резонатором. Концепция квантовой электродинамики в электрической цепи возникла по аналогии с квантовой электродинамикой в полости, где уединенный атом помещается в оптическую полость, которая выступает в роли резонатора. Взаимодействие такого атома с излучением сильно отличается от того, что происходит с таким атомом, помещенном в вакуум: из\sphinxhyphen{}за отражений от стенок полости, излучение не может эффективно покинуть атом. Это увеличивает время жизни атома, если резонансная частота полости находится вдали от спектральной линии кубита. Напротив, если атом находится в резонансе с полостью, то это стимулирует излучение.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{cQED}.png}
\caption{Эквивалентная электрическая схема трансмона, связанного с резонатором. Синий — электрод резонатора, зеленый — электрод трансмона}\label{\detokenize{book/hw/ru/scqubits:cqed-electric-circuit}}\end{figure}

\sphinxAtStartPar
Для многокубитных схем, как правило, в качестве микроволнового резонатора используется участок копланарной передающей линии на микросхеме. Микроволновый резонатор, в свою очередь, подключается к микроволновой линии.

\sphinxAtStartPar
Пропускание микроволновых сигналов через линию приводит к изменению квантового состояния электромагнитного излучения в резонаторе; это излучение взаимодействует с кубитом. Преимуществом данной схемы является то, что кубит может быть очень сильно связан с резонатором, но при этом сохраняет когерентность. Если пренебречь влиянием потерь в управляющую линию, то система описывается гамильтонианом вида
\begin{equation*}
\begin{split}
\hat{H}/\hbar =
\left(
    \omega_q+\frac{1}{2}\delta_q
    \left(
        \hat{a}^\dagger\hat{a}-1
    \right)
\right)\hat{a}^\dagger\hat{a} +
\left(
    \omega_r+\frac{1}{2}\delta_r
    \left(
        \hat{b}^\dagger\hat{b}-1
    \right)
\right)\hat{b}^\dagger\hat{b} +
\chi
\left(
    \hat{a}^\dagger\hat{a}+\frac{1}{2}
\right)
\left(
    \hat{b}^\dagger\hat{b}+\frac{1}{2}
\right),
\end{split}
\end{equation*}
\sphinxAtStartPar
где \(\omega_q\), \(\omega_r\) – частоты кубита и резонатора, соответственно; \(\delta_r, \delta_q\) – ангармонизмы мод трансмона и резонатора; \(\chi\) – дисперсионный сдвиг, или кросс\sphinxhyphen{}керровская нелинейность между трансмоном и резонатором, \(\hat{a}\), \(\hat{a}^\dagger\) – одночастичные операторы уничтожения и рождения, действующие на моду трансмона, \(\hat{b}\), \(\hat{b}^\dagger\) – одночастичные операторы рождения и уничтожения, действующие на моду резонатора, \(\Omega(t)\) – амплитуда возбуждения со стороны микроволновой линии.

\sphinxAtStartPar
Если емкость \(C_C\) между трансмоном и резонатором маленькая, а их частоты сильно отличаются, то взаимодействие между ними будет нерезонансным, и тогда ангармонизмом резонатора можно пренебречь. А вот наличие дисперсионного сдвига между модой кубита и резонатора приводит к тому, что частота эффективная резонатора, то есть сумма всех чисел перед множителем \(\hat{b}^\dagger\hat{b}\), зависит от населенности трансмона. В таком случае, измеряя отклик от резонатора на микроволновый импульс вблизи его резонансной частоты, мы можем получить информацию о состоянии кубита.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=550\sphinxpxdimen]{{avg_cov}.png}
\caption{Микроволновый прямоугольный импульс, отраженный от резонатора, при различных состояниях трансмона. Усреднено по 10000 повторениям.}\label{\detokenize{book/hw/ru/scqubits:dispersive-readout-mean-sample}}\end{figure}


\section{Микроволновые однокубитные операции}
\label{\detokenize{book/hw/ru/scqubits:id10}}
\sphinxAtStartPar
Логические операции над кубитами выполняют микроволновыми сигналами на резонансной частоте кубита. Поведение трансмона по отношению к внешнему излучению можно представить в виде гамильтониана
\begin{equation*}
\begin{split}
\hat{V} = V_\mathrm{ex1}(t) \frac{C_g}{C_g+C_{qs}} \hat{Q}
\end{split}
\end{equation*}
\sphinxAtStartPar
для схемы с возбуждением напряжением \(V_\mathrm{ex1}(t)\), подаваемым через маленький конденсатор. Пусть
\begin{equation*}
\begin{split}
V_\mathrm{ex1}(t) = V_I(t) \cos \left(\omega_q t + \phi(t) \right) + V_Q(t) \sin \left(\omega_q t + \phi(t) \right),
\end{split}
\end{equation*}
\sphinxAtStartPar
где \(V_I(t), V_Q(t)\) – медленно изменяющиеся огибающие напряжения, а \(\phi(t)\) – медленно изменяющаяся фаза. “Медленно изменяющаяся” здесь означает, что за переходы между уровнями будет отвечать только быстро осциллирующий множитель. Обозначим
\begin{equation*}
\begin{split}
\Omega(t) = I(t) - iQ(t) = \frac{C_g}{C_g+C_{qs}}\sqrt{\frac{\hbar}{2Z}}\left(V_I-iV_Q\right).
\end{split}
\end{equation*}
\sphinxAtStartPar
Полный гамильтониан трансмона с возбуждающим излучением будет иметь вид
\begin{equation*}
\begin{split}
\hat{H}_\mathrm{dr}/\hbar = \hat{H}/\hbar + \hat{V}/\hbar =
\left(\omega_q+\frac{1}{2}\delta_q\left(\hat{a}^\dagger\hat{a}-1\right)\right)\hat{a}^\dagger\hat{a} +
\frac{1}{2}\left(\Omega(t)e^{i\left(\omega_q t + \phi(t)\right)} + \Omega^*(t)e^{-i\left(\omega_q t + \phi(t)\right)}\right)
\left(\hat{a}+\hat{a}^\dagger\right).
\end{split}
\end{equation*}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{external-drive}.png}
\caption{Трансмон с линиями для микроволновых однокубитных операций. Слева – емкостно связанная линия (через конденсатор), справа – индуктивно связанная линия (через индуктивность).}\label{\detokenize{book/hw/ru/scqubits:externally-driven-transmon}}\end{figure}

\sphinxAtStartPar
Если трансмон использовать как кубит (то есть не возбуждать никаких уровней, кроме основного и первого возбужденного), можно перейти от операторов повышения и понижения к операторам Паули с помощью соотношений
\begin{equation*}
\begin{split}
\hat{a}^\dagger\hat{a} = -\frac{1}{2}\hat{\sigma}_z \\
\hat{a} + \hat{a}^\dagger = \hat{\sigma}_x \\
i\left(\hat{a}-\hat{a}^\dagger\right) = \hat{\sigma_y}.
\end{split}
\end{equation*}
\sphinxAtStartPar
Тогда мы получим гамильтониан вида
\begin{equation*}
\begin{split}
\hat{H}_\mathrm{dr}/\hbar =
\frac{1}{2}\left(\Omega(t)e^{i\left(\omega_q t + \phi(t) \right)} +
\Omega^*(t)e^{-i\left(\omega_q t + \phi(t) \right)}\right)\sigma_x.
\end{split}
\end{equation*}
\sphinxAtStartPar
Такое возбуждение отвечает модели Раби для двухуровневой системы. Модель Раби хорошо известна в квантовой оптике, так как она описывает когерентное взаимодействие одного атома с лазерным излучением. Здесь мы остановимся поподробнее, так как модель Раби имеет центральное значение для однокубитных операций на очень широком классе различных кубитов.

\sphinxAtStartPar
Пусть
\(
|\psi(t)\rangle =
\begin{pmatrix}
c_0 \\
c_1
\end{pmatrix}
\)
– решение уравнения Шредингера. Для того, чтобы решить уравнение Шредингера, которое является системой двух обыкновенных линейных дифференциальных уравнений относительно \(c_0(t)\) и \(c_1(t)\), нужно сделать замену
\begin{equation*}
\begin{split}
c_0(t) = d_0(t)e^{-i\omega_q t/2}, \\
c_1(t) = d_1(t)e^{+i\omega_q t/2}.
\end{split}
\end{equation*}
\sphinxAtStartPar
Эта замена называется переходом во вращающуюся систему отсчета. В данном случае, система отсчета вращается вместе с
быстро осциллирующей частью микроволнового сигнала. Эта замена может быть записана в виде произведения матрицы на вектор:
\begin{equation*}
\begin{split}
\begin{pmatrix}
c_0(t) \\
c_1(t)
\end{pmatrix} =
\begin{pmatrix}
e^{i\left(\omega_q t + \phi(t)\right)/2} & 0 \\
0 & e^{-i\left(\omega_q t + \phi(t)\right)/2}
\end{pmatrix}
\begin{pmatrix}
d_0(t) \\
d_1(t)
\end{pmatrix}.
\end{split}
\end{equation*}
\sphinxAtStartPar
Матрица этого линейного преобразования \(\hat{U} = e^{i\left(\omega_q t + \phi(t)\right)/2 \hat{\sigma}_z}\) является унитарной – ее собственные числа по модулю равны единице. Если подставить эту замену в уравнение Шредингера
\begin{equation*}
\begin{split}
i\hbar \partial |\psi \rangle /\partial t = \hat{H}_\mathrm{dr} |\psi \rangle,
\end{split}
\end{equation*}
\sphinxAtStartPar
то получим систему
\begin{equation*}
\begin{split}
i\dot{d}_0 e^{i\left(\omega_q t + \phi(t)\right)/2} + \frac{\omega_q + \dot{\phi}}{2} d_{0} e^{i\left(\omega_q t + \phi(t)\right)/2} & = & - \frac{\omega_q}{2} d_{0} e^{i\left(\omega_q t + \phi(t)\right)/2} + d_1 e^{i\left(\omega_q t + \phi(t)\right)/2} \left(\Omega(t)e^{i\left(\omega_q t + \phi(t)\right)} + \Omega^*(t)e^{-i\left(\omega_q t + \phi(t)\right)} \right), \\
i\dot{d}_1 e^{-i\left(\omega_q t + \phi(t)\right)/2} - \frac{\omega_q + \dot{\phi}}{2} d_{1} e^{-i\left(\omega_q t + \phi(t)\right)/2} & = & \frac{\omega_q}{2} d_{1} e^{-i\left(\omega_q t + \phi(t)\right)/2} + d_0 e^{i\left(\omega_q t + \phi(t)\right)/2} \left(\Omega(t)e^{i\left(\omega_q t + \phi(t)\right)} + \Omega^*(t)e^{-i\left(\omega_q t + \phi(t)\right)} \right).
\end{split}
\end{equation*}
\sphinxAtStartPar
Нехитрыми алгебраическими преобразованиями можно упростить гамильтониан до вида
\begin{equation*}
\begin{split}
i\dot{d}_0 + \frac{\dot{\phi}(t)}{2}d_0 & = & \left(\Omega(t)e^{i2\left(\omega_d t + \phi(t)\right)} + \Omega^*(t) \right)d_1, \\
i\dot{d}_1 - \frac{\dot{\phi}(t)}{2}d_1 & = & \left(\Omega(t) + \Omega^*(t)e^{-i2\left(\omega_d t + \phi(t)\right)} \right) d_0.
\end{split}
\end{equation*}
\sphinxAtStartPar
Далее используют “приближение вращающейся волны”, смысл которого в том, чтобы отбросить быстро осциллирующие слагаемые в гамильтониане с множителями \(e^{-2i\omega_d t}\) и \(e^{2i\omega_d t}\). При не очень больших амплитудах возбуждающих сигналов \(\Omega \ll \omega\), эти слагаемые слишком быстро меняются, чтобы оказать существенное влияние на более медленное изменение \(d_0(t)\) и \(d_1(t)\).

\sphinxAtStartPar
Получается система уравнений уже с постоянными коэффициентами
\begin{equation*}
\begin{split}
i\dot{d}_0 + \frac{\dot{\phi}(t)}{2}d_0 & = &~\Omega^*(t)d_1, \\
i\dot{d}_1 - \frac{\dot{\phi}(t)}{2}d_1 & = &~\Omega(t)d_0,
\end{split}
\end{equation*}
\sphinxAtStartPar
которую можно записать через операторы Паули в виде
\begin{equation*}
\begin{split}
i |\tilde{\psi}(t)\rangle = \left( I(t)\hat{\sigma}_x + Q(t)\hat{\sigma}_y - \frac{\dot{\phi}(t)}{2}\hat{\sigma}_z \right)|\tilde{\psi}(t)\rangle,
\end{split}
\end{equation*}
\sphinxAtStartPar
где \(|\tilde{\psi}(t)\rangle = \begin{pmatrix}d_0(t) \\ d_1(t) \end{pmatrix}\).

\sphinxAtStartPar
Такой гамильтониан отвечает вращению вектора состояния кубита в представлении сферы Блоха вокруг оси \(\vec{\Omega} = \{I(t), Q(t), \dot{\phi}(t)/2\}\) с угловой скоростью \(|\vec{\Omega}|\).

\sphinxAtStartPar
Наиболее часто используются микроволновые импульсы, отвечающие вращениям на углы \(\pi/2\) и \(\pi\) вокруг осей \(x\) или \(y\), однако реально любая однокубитная операция может быть реализована правильным подбором управляющих сигналов \(I(t)\), \(Q(t)\), или \(\phi(t)\).


\section{Декогеренция в сверхпроводниковых кубитах}
\label{\detokenize{book/hw/ru/scqubits:id11}}
\sphinxAtStartPar
В отличие от других типов кубитов, сверхпроводниковые кубиты имеют сравнительно низкие времена когерентности. Это означает, что информация, хранящаяся в сверхпроводниковом кубите, может испортиться. Для сверхпроводниковых кубитов декогеренцию можно понимать как неконтролируемое воздействие на кубит со стороны флуктуаций напряжения или тока. Природа флуктуаций может быть очень разной. Наиболее проблематичными являются флуктуации микроскопических зарядов и магнитных моментов внутри самой микросхемы.

\sphinxAtStartPar
Как правило различают шумы и наводки, которые могут привести самопроизвольному возбуждению или релаксации кубита, а также к переходу в недопустимые состояния типа уровней \(|2\rangle\) и выше, и шумы, которые влияют на частоту переходов между уровнями кубита.

\sphinxAtStartPar
В самой простой, марковской модели модели шума, события декогеренции независимы во времени и пространстве. Флуктуационный сигнал \(S_f(t)\), связывающийся с трансмоном посредством члена гамильтониана типа \(\hat{V} = S_f(t) \hat{a}^\dagger\hat{a}\), будет случайным образом менять частоту кубита. Это приведет к набегу фазы
\begin{equation*}
\begin{split}
\Delta \phi(t) = \int\limits_0^t S_f(t) \mathrm{d}t
\end{split}
\end{equation*}
\sphinxAtStartPar
на кубите. Если разложить флуктуационный сигнал по спектральным компонентам (то есть представить в виде Фурье\sphinxhyphen{}компонент), то получим
\begin{equation*}
\begin{split}
\Delta \phi(t) = \int\limits_{-\infty}^{+\infty} \frac{S_f(\omega)}{\omega} \operatorname{cos}(\frac{\omega t}{2}) \mathrm{d}\omega.
\end{split}
\end{equation*}
\sphinxAtStartPar
Таким образом, наиболее существенным с точки зрения случайного набега фазы (то есть дефазировки) является низкочастотный шум. К таким флуктуационным сигналам может относиться, например, тепловая населенность считывающего резонатора.

\sphinxAtStartPar
Другой тип флуктуационного сигнала связывается с трансмоном посредством дополнительного члена в гамильтониана, имеющего вид \(\hat{V} = i \Delta \Omega_\downarrow \left(\hat{a} - \hat{a}^\dagger\right)\). Такой флуктуационный сигнал приводит к самопроизвольному возбуждению и релаксации кубита под действием внешней силы. Наиболее существенными являются шумы, частота которых отвечает частоте кубита.

\sphinxAtStartPar
Помимо внешних воздействий, которые можно представить как случайное слагаемое в гамильтониане, существуют также и воздействия, которые нельзя представить в таком виде, например обыкновенную релаксацию кубита без сопутствующего теплового возбуждения. Такой канал декогеренции отвечает случайному действию оператора уничтожения \(\hat{a}\). Таковым является, например, релаксация трансмона в управляющую линию, через которую выполняются однокубитные операции.

\sphinxAtStartPar
В общем случае, для всех типов марковского шума можно ввести оператор коллапса \(\hat{c}\) и константу декогеренции \(\gamma\). В случае релаксации, \(\hat{c} = \hat{a}, \gamma=1/T_1\). Для дефазировки \(\hat{c} = \hat{\sigma}_z, \gamma = 1/2T_{\phi}\).

\sphinxAtStartPar
Для того, чтобы измерить эффекты декогеренции на сверхпроводниковые кубиты, используют два основных типа эксперимента. Первый типа эксперимента заключается в возбуждении кубита и считывании его состояния спустя время \(t\). Эксперимент повторяется много раз с различным временем задержки \(t\); результат можно зафитовать экспонентой. Время затухания экспоненты в \(e\) будет временем релаксации \(T_1\).

\sphinxAtStartPar
Такое измерение нечувствительно к дефазировке кубита. Чтобы измерить влияние дефазировки, кубит помещают в состояние суперпозиции при помощью вращения вокруг оси \(x\) на угол \(\pi/2\), ждут время \(t\), делают вращение вокруг оси \(z\) на угол, пропорциональный длительности паузы \(t\), а затем еще поворачивают на угол \(\pi/2\) вокруг оси \(x\). В случае идеальной двухкубитной системы зависимость результата измерений от длительности паузы \(t\) будет синусоидальной; при наличии декогеренции в марковской модели осцилляции будут затухать экспоненциально, причем константа затухания \(T_2\) может быть выражена как \(\frac{1}{T_2} = \frac{1}{2T_1} + \frac{1}{T_\phi}\).

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=550\sphinxpxdimen]{{decoherence}.png}
\caption{Эксперименты по измерению времени когерентности кубита}\label{\detokenize{book/hw/ru/scqubits:transmon-decoherence}}\end{figure}

\sphinxAtStartPar
Процессы декогеренции ограничивают длину алгоритмов, которые могут быть выполнены на сверхпроводниковом квантовом процессоре. Если хотя бы одно событие декогеренции произойдет в течение алгоритма, то результат выполнения может оказаться неправильным. Важно, что считывание в квантовом компьютере имеет принципиально дискретный характер: из\sphinxhyphen{}за этого в принципе возможно говорить о дискретных ошибках, а не о непрерывных ошибках, как в аналоговых компьютерах. Кроме того, как и в обычных цифровых компьютерах, в квантовых компьютерах возможна коррекция ошибок. Для того, чтобы измерить вероятность ошибки напрямую, используют рандомизированное тестирование (randomized benchmarking) квантовых вентилей.

\sphinxAtStartPar
Идея рандомизированного тестирования заключается в том, чтобы выполнять случайную последовательность операций, а зачем сравнивать результат ее выполнения с теоретическим. Существует ряд различных вариаций рандомизированного тестирования, которые отличаются тем, из какой совокупности берутся случайные последовательности. В самом простом случае используют вентили из группы Клиффорда – это такое подмножество логических операций, которые не образуют универсальный набор, но зато алгоритмы целиком состоящие только из таких вентилей можно быстро просимулировать на классическом компьютере даже при большом количестве кубитов. Кроме того, часто используют только такие последовательности вентилей, в конце которых система оказывается не в состоянии суперпозиции, а в определенном состоянии, например в состоянии \(|0\dots0\rangle\). Ошибки приводят к тому, что вероятность \(\langle F_n \rangle\) получить состояние \(|0\dots0\rangle\) экспоненциально убывает с увеличением длины последовательности вентилей \(N\):
\begin{equation*}
\begin{split}
\langle F_n \rangle_\mathrm{seq}(N)\sim e^{-F_1n}
\end{split}
\end{equation*}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=550\sphinxpxdimen]{{benchmarking-result}.png}
\caption{Схема микроволновых импульсов и пример результатов рандомизированного тестирования вентилей из группы Клиффорда. Каналы 1 и 2 генератора сигналов произволной формы подключены к линии считывания, каналы 3 и 4 – к линии управления кубитом. Измерена населенность кубита после случайных последовательностей вентилей разных длин; константа экспоненциального затухания населенности дает точность в расчете на один вентиль \(F_1 = 0.993\).}\label{\detokenize{book/hw/ru/scqubits:randomized-benchmarking-protocol-and-result}}\end{figure}


\section{Двухкубитные вентили}
\label{\detokenize{book/hw/ru/scqubits:id12}}
\sphinxAtStartPar
Для трансмонов существует целый ряд способов реализации двухкубитных операций. Как правило, для этого трансмоны связывают емкостным способом, напрямую или через элемент связи. Мы будем рассматривать двухкубитную операцию iSWAP, реализуемую при помощи параметрического изменения эффективной константы связи между кубитами.

\sphinxAtStartPar
Так же, как в случае кубита, связанного с резонатором, гамильтониан двух связанных трансмонов описывается в первом приближении соотношением
\begin{equation*}
\begin{split}
\hat{H}/\hbar =
\left(
    \omega_1+\frac{1}{2}\delta_q
    \left(
        \hat{a}^\dagger\hat{a}-1
    \right)
\right)\hat{a}^\dagger\hat{a} +
\left(
    \omega_2+\frac{1}{2}\delta_r
    \left(
        \hat{b}^\dagger\hat{b}-1
    \right)
\right)\hat{b}^\dagger\hat{b} +
\chi
\left(
    \hat{a}^\dagger\hat{a}+\frac{1}{2}
\right)
\left(
    \hat{b}^\dagger\hat{b}+\frac{1}{2}
\right),
\end{split}
\end{equation*}
\sphinxAtStartPar
где \(\hat{a}, \hat{a}^\dagger\) – операторы уничтожения и рождения одной степени свободы (трансмона), а \(\hat{b}, \hat{b}^\dagger\) – операторы другой степени свободы (трансмона).

\sphinxAtStartPar
Принцип работы элемента связи в том, что вместо одного джозефсоновского контакта, в нем есть два джозефсоновских контакта, соединенных параллельно. Такая цепь называется ПТ\sphinxhyphen{}СКВИД, или просто СКВИД (Superconducting Quantum Interference Device). Если у нас есть два джозефсоновских контакта в кольце, то такая структура будет вести себя по отношению к внешней цепи так же, как один контакт, но с управляемым критическим током. Управление критическим током можно осуществлять при помощи магнитного потока \(\Phi_x\), который проходит через кольцо СКВИДа. Соотношение для критического тока выглядит следующим образом:
\begin{equation*}
\begin{split}
I_{\mathrm{C SQUID}}(\Phi_x) = \sqrt{\left(I_{\mathrm{Cc1}} + I_{\mathrm{Cc2}}\right)^2 \cos^2 \left( \pi\Phi_x/\Phi_0 \right) +
\left(I_{\mathrm{Cc1}} - I_{\mathrm{Cc2}}\right)^2 \sin^2 \left( \pi\Phi_x/\Phi_0 \right)}.
\end{split}
\end{equation*}
\sphinxAtStartPar
Таким образом, элемент связи представляет собой слабо нелинейный LC\sphinxhyphen{}контур с перестраиваемой индуктивностью, а значит и частотой. В зависимости от его частоты будет менять эффективная константа связи между кубитами \(\chi\), а также – в меньшей мере – и остальные параметры системы.

\sphinxAtStartPar
Когда нет двухкубитной операции, желательно, чтобы кубиты не взаимодействовали, то есть \(\chi=0\). Все константы этого гамильтониана зависят от внешнего параметра – потока в СКВИДе элемента связи \(\Phi_x\). При быстром изменении этого параметра появляется дополнительное (диабатическое) слагаемое
\begin{equation*}
\begin{split}
\hat{V} = i\hbar \hat{U}\frac{\partial \hat{U}^\dagger}{\partial \Phi_x}\frac{\partial \Phi_x}{\partial t}
\sim \Omega\left(\hat{a}^\dagger + \hat{a}\right)\left(\hat{b}^\dagger + \hat{b}\right).
\end{split}
\end{equation*}
\sphinxAtStartPar
Мы не будем здесь подробно рассматривать природу этого слагаемого; подробнее об этом можно почитать, например, в работе {[}\hyperlink{cite.book/bibliography:id12}{RGM+17}{]}. Ограничимся тем, что это взаимодействие является поперечным, то есть \(xx\)\sphinxhyphen{}взаимодействием. Если модулировать поток в СКВИДе в резонансе с разностью частот между кубитами (\(n \omega_m = \omega_1 - \omega_2\), где \(n\) – номер гармоники), то возбуждение с одного кубита будет переходить на другой, и обратно.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=550\sphinxpxdimen]{{two-qubit-pulse-sequence-parametric}.png}
\caption{Последовательность сигналов, которую нужно подать, чтобы наблюдать осцилляции населенности между кубитами, и результат из наблюдения. iSWAP получается при длительности вентиля \(T_p=500~\mathrm{ns}\)}\label{\detokenize{book/hw/ru/scqubits:two-qubit-parametric-gate}}\end{figure}

\sphinxAtStartPar
Унитарная матрица этого вентиля имеет вид
\begin{equation*}
\begin{split}
\hat{U}(t) =
\begin{pmatrix}
1 & 0 & 0 & 0 \\
0 & \cos\Omega_g t & i \sin \Omega_g t & 0 \\
0 & i \sin \Omega_g t & \cos\Omega_g t  & 0 \\
0 & 0 & 0 & 1
\end{pmatrix}.
\end{split}
\end{equation*}
\sphinxAtStartPar
Помимо вентиля iSWAP, на трансмонах делают CPHASE, который физически можно реализовать импульсным увеличением константы \(\chi\), или, например, как IBM Quantum Experience – при помощи кросс\sphinxhyphen{}резонансных вентилей.


\section{Что почитать для дальнейшего изучения вопроса?}
\label{\detokenize{book/hw/ru/scqubits:id14}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://qiskit.org/learn/intro-qc-qh/}{Introduction to Quantum Computing and Quantum Hardware}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://arxiv.org/abs/1904.06560}{A Quantum Engineer’s Guide to Superconducting Qubits} {[}\hyperlink{cite.book/bibliography:id8}{KKY+19}{]}

\end{itemize}

\sphinxstepscope


\part{Квантовое машинное обучение}

\sphinxstepscope


\chapter{О блоке “Квантовое машинное обучение”}
\label{\detokenize{book/qmlkinds/ru/qmlkinds_intro:qmlkinds-intro}}\label{\detokenize{book/qmlkinds/ru/qmlkinds_intro:id1}}\label{\detokenize{book/qmlkinds/ru/qmlkinds_intro::doc}}
\sphinxAtStartPar
Этот блок включает в себя:
\begin{itemize}
\item {} 
\sphinxAtStartPar
общий рассказ о видах квантового машинного обучения;

\end{itemize}

\sphinxAtStartPar
Продвинутые темы блока дополнительно рассказывают:
\begin{itemize}
\item {} 
\sphinxAtStartPar
об алгоритме HHL;

\item {} 
\sphinxAtStartPar
о квантовом алгоритме ближайшего соседа;

\end{itemize}

\sphinxstepscope


\chapter{О квантовом машинном обучении}
\label{\detokenize{book/qmlkinds/ru/qmlkinds:qmlkinds}}\label{\detokenize{book/qmlkinds/ru/qmlkinds:id1}}\label{\detokenize{book/qmlkinds/ru/qmlkinds::doc}}
\sphinxAtStartPar
Автор(ы):
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/SemyonSinchenko}{Синченко Семен}

\end{itemize}

\sphinxAtStartPar
Квантовое машинное обучение – это на самом деле огромная область, и наш курс охватывает лишь небольшую ее часть. В этой обзорной лекции мы попробуем взглянуть на картину в целом и посмотреть, какие есть направления в этой интересной и динамично развивающейся области.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Эта статья является исключительно обзорной – в ней будет много красивых картинок, но мы не будем вдаваться в формулы, которые могут эти картинки объяснить. Цель лекции – познакомить читателя с тем, как машинное обучение может быть применено в разных задачах, связанных с квантовыми вычислениями и квантовой физикой.
\end{sphinxadmonition}


\section{Виды квантового машинного обучения}
\label{\detokenize{book/qmlkinds/ru/qmlkinds:id2}}
\sphinxAtStartPar
Как мы помним из {\hyperref[\detokenize{book/ml/ru/ml_l1::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{лекции по машинному обучению}}}}, в таких задачах у нас есть две важных составляющих – данные и алгоритм. В случае квантового машинного обучения у нас появляется некоторая “вариативность”:
\begin{itemize}
\item {} 
\sphinxAtStartPar
квантовые данные

\item {} 
\sphinxAtStartPar
квантовый алгоритм

\item {} 
\sphinxAtStartPar
классические данные

\item {} 
\sphinxAtStartPar
классический алгоритм

\end{itemize}

\sphinxAtStartPar
На базе этого можно построить классификацию машинного обучения.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=300\sphinxpxdimen]{{Qml_approaches}.png}
\caption{Виды машинного обучения в зависимости от типа данных и алгоритма.}\label{\detokenize{book/qmlkinds/ru/qmlkinds:id24}}\end{figure}

\sphinxAtStartPar
Когда мы имеем классические данные и классический алгоритм, то это как раз обычное машинное обучение, рассмотренное во вводной лекции курса. А вот остальные виды мы рассмотрим далее.


\section{Квантовые данные и классический алгоритм}
\label{\detokenize{book/qmlkinds/ru/qmlkinds:id3}}
\sphinxAtStartPar
Классическое машинное обучение применительно к квантовым данным – это очень активно развивающаяся область квантовой физики и квантовой химии. Главный вопрос в данном случае – что именно мы пониманием под “квантовыми данными”. Но мы будем придерживаться максимально широкой трактовки этого понятия. Далее рассмотрим примеры возможного применения ML в задачах квантовой физики и химии.


\subsection{NQS}
\label{\detokenize{book/qmlkinds/ru/qmlkinds:nqs}}\label{\detokenize{book/qmlkinds/ru/qmlkinds:id4}}
\sphinxAtStartPar
\sphinxstylestrong{N}eural \sphinxstylestrong{Q}uantum \sphinxstylestrong{S}tates это очень перспективное улучшение квантового Монте\sphinxhyphen{}Карло – популярного метода приближенного решения задач квантовой физики. Мы будем подробно рассматривать проблему нахождения энергетических спектров квантомеханических систем, а также моделирования квантовой динамики в блоке о проблемах квантового машинного обучения. Пока нам достаточно знания того, что эти задачи являются вычислительно трудными и их прямое численное решение очень быстро становится невозможным по мере увеличения размера системы и числа взаимодействующих частиц. В подходе \sphinxstylestrong{NQS}, впервые опубликованном в журнале \sphinxstyleemphasis{Science} {[}\hyperlink{cite.book/bibliography:id23}{CT17}{]}, предложено моделировать волновую функцию \(\ket{\Psi}\) физической системы при помощи глубокой нейронной сети. Это дает ряд преимуществ над обычным квантовым Монте\sphinxhyphen{}Карло в плане точности моделирования, а также позволяет явно симулировать \sphinxstyleemphasis{time\sphinxhyphen{}dependent} уравнение Шредингера. Относительно другого популярного метода, который называется \sphinxstyleemphasis{Matrix Product State} \sphinxstylestrong{NQS} дает лучшую масштабируемость и меньшую аппроксимацию сложность, которая оказывается линейной по числу частиц в физической системе.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=600\sphinxpxdimen]{{NQS1}.png}
\caption{Сходимость \sphinxstylestrong{NQS} по энергии в зависимости от числа эпох обучения. По вертикали значение энергии на один спин, по горизонтали эпохи обучения. Пунктиром отмечено точное значение, полученное прямой диагонализацией гамильтониана. Слева общий вид, справа – \sphinxstyleemphasis{сверхтонкая} сходимость вблизи энергии основного состояния. Источник {[}\hyperlink{cite.book/bibliography:id23}{CT17}{]}.}\label{\detokenize{book/qmlkinds/ru/qmlkinds:id25}}\end{figure}


\subsection{CNN над потенциалами}
\label{\detokenize{book/qmlkinds/ru/qmlkinds:cnn}}
\sphinxAtStartPar
Другим интересным подходом является применение \sphinxstyleemphasis{Convolutional Neural Networks} (\sphinxstyleemphasis{CNN}) – специального класса глубоких нейронных сетей, разработанных для обработки изображений, к физическим потенциалам. Дело в том, что трехмерный энергетический потенциал можно представить как 2D изображение. Например, можно взять периодическую потенциальную энергию, создаваемую атомами в кристаллической решетке и рассмотреть, как будет вести себя электрон в таком потенциале.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=650\sphinxpxdimen]{{CNN_over_psi}.png}
\caption{Иллюстрация применения \sphinxstyleemphasis{CNN} на энергетических потенциалах. Источник {[}\hyperlink{cite.book/bibliography:id52}{MST17}{]}.}\label{\detokenize{book/qmlkinds/ru/qmlkinds:id26}}\end{figure}

\sphinxAtStartPar
Существует ограниченный набор частных случаев, когда эта задача может быть решена аналитически. Используя такие точные решения, мы составляем обучающую выборку, тренируем \sphinxstyleemphasis{CNN}, а потом можем применять ее к другим, более сложным потенциалам.


\subsection{Решение уравнения Шредингера}
\label{\detokenize{book/qmlkinds/ru/qmlkinds:id8}}
\sphinxAtStartPar
Другим примером решения задачи об энергетических уровнях является применение глубокой нейронной сети, которая на вход принимает \sphinxstyleemphasis{Slater determinants}, \sphinxstyleemphasis{Jastrow factor} и другие известные способы приближенного описания квантомеханических систем. А на выходе из такой глубокой нейронной сети получаем волновую функцию системы. Таким образом, получается объединить все преимущества хорошо изученных физических представлений с высокой экспрессивностью глубоких нейронных сетей {[}\hyperlink{cite.book/bibliography:id36}{HSchatzleNoe20}{]}.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=350\sphinxpxdimen]{{PauliNet}.png}
\caption{Архитектура подхода \sphinxstyleemphasis{PauliNet}. Источник {[}\hyperlink{cite.book/bibliography:id36}{HSchatzleNoe20}{]}.}\label{\detokenize{book/qmlkinds/ru/qmlkinds:id27}}\end{figure}

\sphinxAtStartPar
Такой подход дает фантастическую точность по сравнению с другими подходами и выглядит очень перспективно, так как дополнительно позволяет получить очень хорошую масштабируемость из\sphinxhyphen{}за возможности снизить число \sphinxstyleemphasis{slater determinants}.


\subsection{RNN для моделирования волновых функций}
\label{\detokenize{book/qmlkinds/ru/qmlkinds:rnn}}
\sphinxAtStartPar
Другой похожий на {\hyperref[\detokenize{book/qmlkinds/ru/qmlkinds:nqs}]{\sphinxcrossref{\DUrole{std,std-ref}{NQS}}}} подход – это использовать для аппроксимации волновой функции рекуррентные нейронные сети вместо машин Больцмана.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=300\sphinxpxdimen]{{RNN}.png}
\caption{Результаты \sphinxstyleemphasis{RNN}\sphinxhyphen{}модели для аппроксимации волновых функций. Можно получать не только значение энергии, но и ожидаемые значения других операторов, например, операторов спина или операторов спиновых корреляций. Источник {[}\hyperlink{cite.book/bibliography:id37}{HAGH+20}{]}. На графике (a) приведена зависимость энергии от эпохи обучения. На графике (b) приведены зависимости собственного значения операторов спиновых корреляций 40\sphinxhyphen{}го (центрального) спина с \sphinxstyleemphasis{n}\sphinxhyphen{}ым от номера \sphinxstyleemphasis{n}. На графике (c) приведено распределение значений оператора спина по длине цепочки спинов.}\label{\detokenize{book/qmlkinds/ru/qmlkinds:id28}}\end{figure}

\sphinxAtStartPar
В данном подходе мы строим “последовательную” волновую функцию многочастичной квантовой системы, “подавая” туда по одной каждую частицу. А так как нейронная сеть – рекуррентная, мы по сути последовательно строим волновую функцию многочастичной системы.


\subsection{Квантовая томография}
\label{\detokenize{book/qmlkinds/ru/qmlkinds:id12}}
\sphinxAtStartPar
Мы немного рассказывали о задаче квантовой томографии в {\hyperref[\detokenize{book/qc/ru/mixedstates::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{лекции про смешанные состояния}}}}. Правда, там привели пример использования метода максимизации правдоподобия для решения задачи восстановления состояния по измерениям. Оказывается, что для этих целей можно использовать глубокие нейронные сети. Один из таких подходов описан в {[}\hyperlink{cite.book/bibliography:id17}{AMunozNK21}{]}. Суть подхода в том, что используются генеративные сети с условием – \sphinxstyleemphasis{Conditional GAN} (C\sphinxhyphen{}GAN) для восстановления состояния. Для создания матрицы плотности используется генератор, а для вычисления ошибки относительно реальных результатов измерений – дискриминатор.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=550\sphinxpxdimen]{{C-GAN}.png}
\caption{Иллюстрация подхода \sphinxstyleemphasis{C\sphinxhyphen{}GAN}.}\label{\detokenize{book/qmlkinds/ru/qmlkinds:id29}}\end{figure}


\subsection{Заключение к подразделу}
\label{\detokenize{book/qmlkinds/ru/qmlkinds:id14}}
\sphinxAtStartPar
В целом, применение классических алгоритмов машинного обучения к задачам квантовой физики и квантовой химии – очень перспективная область. Мы еще немного коснемся этой темы, когда будем рассматривать решение задачи о собственных значениях гамильтонианов. Однако, эта тема выходит за рамки нашего курса.


\section{Классические данные и квантовый алгоритм}
\label{\detokenize{book/qmlkinds/ru/qmlkinds:id15}}
\sphinxAtStartPar
Теперь перейдем к ситуации, когда мы рассматриваем классические данные (задачи классификации и регрессии) и применяем к ним машинное обучение, реализуемое на квантовом компьютере как набор операций над кубитами.


\subsection{HHL}
\label{\detokenize{book/qmlkinds/ru/qmlkinds:hhl}}
\sphinxAtStartPar
Один из самых известных алгоритмов квантового машинного обучения – это алгоритм \sphinxstylestrong{HHL} {[}\hyperlink{cite.book/bibliography:id6}{HHL09}{]}, которому в нашем курсе {\hyperref[\detokenize{book/qmlkinds/ru/hhl_algorithm::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{посвящена отдельная продвинутая лекция}}}}. Это алгоритм решения системы линейных уравнений за \(O(N \log N)\) операций. Так как к решению системы уравнений можно свести огромное число задач реального мира, этот алгоритм обладает огромным потенциалом. К сожалению, сегодня его практическое применение сильно ограничено несколькими вещами:
\begin{itemize}
\item {} 
\sphinxAtStartPar
необходимость эффективной генерации начального состояния – без этого достижения превосходства \sphinxstylestrong{HHL} невозможно;

\item {} 
\sphinxAtStartPar
высокие требования к точности операций, а также необходимость в большом числе кубитов.

\end{itemize}

\sphinxAtStartPar
Этот алгоритм является примером чисто квантового алгоритма, где абсолютно все операции выполняются на квантовом компьютере.


\subsection{Quantum k\sphinxhyphen{}NN}
\label{\detokenize{book/qmlkinds/ru/qmlkinds:quantum-k-nn}}
\sphinxAtStartPar
Другой пример полностью квантового алгоритма – это модификация классического алгоритма ближайшего соседа, с той лишь разницей, что для вычисления расстояний между точками в \(N\)\sphinxhyphen{}мерном пространстве мы используем квантовый компьютер. Этот алгоритм называется \sphinxstyleemphasis{Quantum k\sphinxhyphen{}NN} (\sphinxstyleemphasis{Quantum k Nearest Neighbours}). Сегодня существует довольно много потенциально эффективных реализаций этого алгоритма, которые отличаются в основном тем, какая используется метрика расстояния в гильбертовом пространстве. Одна из реализаций {\hyperref[\detokenize{book/qmlkinds/ru/qknn::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{рассмотрена в продвинутой лекции нашего курса}}}}. К сожалению, практическое использование таких алгоритмов сегодня ограничено тем, что для них требуется эффективная квантовая память – \sphinxstyleemphasis{quantum Random Access Memory}.


\subsection{Заключение к подразделу}
\label{\detokenize{book/qmlkinds/ru/qmlkinds:id17}}
\sphinxAtStartPar
Сегодня мы живем в так называемой \sphinxstyleemphasis{NISQ} (\sphinxstyleemphasis{Noisy Intermediate\sphinxhyphen{}Scale Quantum}) эпохе, то есть когда у нас есть квантовые компьютеры лишь ограниченного размера и с относительно большим уровнем шумов. А чисто квантовые алгоритмы квантового машинного обучения очень требовательны именно к точности вычислений. Также в таких алгоритмах большой проблемой является постоянная необходимость сложной операции перевода классических данных в квантовые. В теории, эта проблема исчезнет с появлением \sphinxstyleemphasis{qRAM}, однако сегодня такая “квантовая память” еще не существует и даже пока нет однозначного понимания того, как именно ее делать. Все это сильно ограничивает потенциал полностью квантовых подходов. Далее мы рассмотрим более перспективный в \sphinxstyleemphasis{NISQ}\sphinxhyphen{}эпоху подход – гибридное квантово\sphinxhyphen{}классическое машинное обучение.


\section{Гибридное обучение}
\label{\detokenize{book/qmlkinds/ru/qmlkinds:id18}}
\sphinxAtStartPar
Большая часть из оставшихся лекций нашего курса будет посвящена как раз гибридным методам квантового машинного обучения. В этих методах часть алгоритма реализуется в виде квантовых вентилей, а часть выполняется на классическом компьютере.


\subsection{VQC}
\label{\detokenize{book/qmlkinds/ru/qmlkinds:vqc}}
\sphinxAtStartPar
\sphinxstylestrong{V}ariational \sphinxstylestrong{Q}uantum \sphinxstylestrong{C}ircuits, или просто вариационные схемы, – это одно из центральных понятий в гибридном квантово\sphinxhyphen{}классическом обучении. Основная идея заключается в том, что мы используем квантовую операцию, которая задается каким\sphinxhyphen{}то классическим параметром. Обычно это одна или несколько операций “вращений” на сфере Блоха, про которые \sphinxhref{../../qc/ru/gates.html\#id5}{мы говорили в лекции про квантовые гейты}. При этом вариация классического параметра осуществляется на классическом компьютере, например, при помощи градиентного спуска.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=200\sphinxpxdimen]{{diagram}.png}
\caption{Схема работы вариционной квантовой схемы.}\label{\detokenize{book/qmlkinds/ru/qmlkinds:id30}}\end{figure}

\sphinxAtStartPar
В нашем курсе теме вариационных схем будет посвящено несколько лекций:
\begin{itemize}
\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{book/vqc/ru/vqc::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{вариационные квантовые схемы}}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{book/grads/ru/gradients::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{градиенты \sphinxstylestrong{VQC}}}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{book/grads/ru/hogradients::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{продвинутая лекция по градиентам \sphinxstylestrong{VQC}}}}}

\end{itemize}

\sphinxAtStartPar
Также мы часто будем возвращаться понятию VQC в теме квантовых нейросетей, а также в блоке про решение задачи собственных значений при помощи алгоритма \sphinxstyleemphasis{Variational Quantum Eigensolver}.


\subsection{Квантовые нейросети}
\label{\detokenize{book/qmlkinds/ru/qmlkinds:id19}}
\sphinxAtStartPar
Квантовые “нейронные сети” – это как раз пример, когда мы комбинируем вариационные слои вместе с обычными слоями нейронных сетей.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=550\sphinxpxdimen]{{qnntfq}.png}
\caption{Пример гибридной квантовой нейросети. Источник {[}\hyperlink{cite.book/bibliography:id22}{BVM+21}{]}.}\label{\detokenize{book/qmlkinds/ru/qmlkinds:id31}}\end{figure}

\sphinxAtStartPar
На картинке выше приведен пример комбинации вариационных квантовых схем и классических слоев обычных глубоких нейронных сетей. При этом оптимизация параметров выполняется при помощи единого процесса \sphinxstyleemphasis{backpropagation}, с той лишь разницей, что для классических и квантовых слоев немного по\sphinxhyphen{}разному вычисляется градиент для параметров конкретного слоя. Теме квантовых нейронных сетей в нашем курсе будет посвящен целый блок, где будет, в том числе, рассказано еще и об аналоге сверточного слоя с использованием \sphinxstylestrong{VQC}.


\subsection{Квантовые ядра}
\label{\detokenize{book/qmlkinds/ru/qmlkinds:id21}}
\sphinxAtStartPar
Квантовые ядра и квантовый алгоритм \sphinxstyleemphasis{Support Vector Machine} (\sphinxstyleemphasis{SVM}) – это другой пример, как можно объединить квантовые гейты с классическими алгоритмами. Математике “под капотом” классического \sphinxstyleemphasis{SVM} у нас будет посвящена отдельная лекция, но если кратко, то суть там в том, что решение задачи об оптимальной разделяющей гиперплоскости (другими словами, об оптимальной классификации) можно выразить через скалярные произведения точек обучающей выборки. Причем не обязательно в исходном пространстве, а в любом гильбертовом пространстве. А как мы помним, квантовые гейты как раз представляют собой операции в гильбертовом пространстве, причем экспоненциально большого размера. Так и появляется идея гибридного \sphinxstyleemphasis{SVM} – мы переписываем скалярные произведения точек как результат измерения параметризованных квантовых схем, где параметры это и есть компоненты каждой из точек. А дальше уже применяем классические методы решения оптимизационной задачи. Этой теме у нас будет посвящена отдельная лекция.


\subsection{Оптимизация энергии}
\label{\detokenize{book/qmlkinds/ru/qmlkinds:id22}}
\sphinxAtStartPar
Еще один интересный и перспективный класс задач, которые можно решать гибридными методами – это оптимизация энергии гамильтониана. Может показаться, что это еще что\sphinxhyphen{}то из области квантовой физики, но на самом деле в блоке о проблемах квантового машинного обучения мы покажем, как к задаче поиска основного состояния системы, описанной квантовым оператором – гамильтонианом, можно свести огромное число задач реального мира. Например, это задача Коммивояжера, очень важная в области логистики, или задача о нахождении энергий электронов, которая играет важную роль в разработке лекарств или создании новых материалов.


\section{Заключение}
\label{\detokenize{book/qmlkinds/ru/qmlkinds:id23}}
\sphinxAtStartPar
В этой лекции мы познакомились с тем, каким может быть квантовое машинное обучение. Мы узнали, что бывают:
\begin{itemize}
\item {} 
\sphinxAtStartPar
классические алгоритмы над квантовыми данными;

\item {} 
\sphinxAtStartPar
квантовые алгоритмы над классическими данными;

\item {} 
\sphinxAtStartPar
гибридные алгоритмы.

\end{itemize}

\sphinxAtStartPar
Именно гибридные алгоритмы наиболее перспективны в \sphinxstyleemphasis{NISQ}\sphinxhyphen{}эпоху, и именно им будет посвящена большая часть оставшихся лекций курса.

\sphinxstepscope


\chapter{Алгоритм HHL}
\label{\detokenize{book/qmlkinds/ru/hhl_algorithm:hhl}}\label{\detokenize{book/qmlkinds/ru/hhl_algorithm:hhl-algorithm}}\label{\detokenize{book/qmlkinds/ru/hhl_algorithm::doc}}
\sphinxAtStartPar
Автор(ы):
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/Carinetta}{Решетова Карина}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/polyzer}{Токарев Игорь}

\end{itemize}

\sphinxAtStartPar
Сегодня пришла пора поговорить о знаменитом алгоритме Харроу, Хассидима и Ллойда, более известном как HHL\sphinxhyphen{}алгоритме, способном решать системы линейных уравнений.

\sphinxAtStartPar
Очень надеюсь, что к данному занятию у вас уже есть представление об алгоритме фазовой оценки (QPE), использующем обратное квантовое преобразование Фурье, на котором и базируется HHL. Глубокое понимание всех тонкостей этого алгоритма потребует от вас уверенного владения математическим аппаратом. За детальным описанием вы всегда можете обратиться к статьям {[}\hyperlink{cite.book/bibliography:id27}{DHM+18}{]}, {[}\hyperlink{cite.book/bibliography:id6}{HHL09}{]}, и {[}\hyperlink{cite.book/bibliography:id40}{HZL+17}{]}. Приготовьтесь потратить время и умственные ресурсы, если алгоритм вас зацепит и вы решите в нем как следует покопаться. Мы же поможем вам заинтересоваться, рассмотрим основные принципы и небольшой пример.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Именно HHL\sphinxhyphen{}алгоритм произвел настоящую революцию в области квантового машинного обучения. Ведь решение систем линейных уравнений так или иначе находится “под капотом” почти любого известного алгоритма машинного обучения. И действительно:
\begin{itemize}
\item {} 
\sphinxAtStartPar
классические линейная и логистическая регрессия сводятся именно к этой задаче;

\item {} 
\sphinxAtStartPar
задача SVM может быть переформулирована в терминах решений систем линейных уравнений;

\item {} 
\sphinxAtStartPar
задача нахождения обартной матрицы (часто используется в глубоком обучении) внутри обычно решается через решение линейной системы;

\end{itemize}

\sphinxAtStartPar
И это только малая часть примеров!

\sphinxAtStartPar
Так что знакомство с QML не будет полным без ознакомления с этим прекрасным, но очень сложным алгоритмом!
\end{sphinxadmonition}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=350\sphinxpxdimen]{{614px-Seth_Lloyd}.jpg}
\caption{Сет Ллойд, профессор MIT и один из создателей HHL\sphinxhyphen{}алгоритма}\label{\detokenize{book/qmlkinds/ru/hhl_algorithm:lloyd}}\end{figure}


\section{Задача}
\label{\detokenize{book/qmlkinds/ru/hhl_algorithm:id4}}
\sphinxAtStartPar
Представим обычную систему линейных уравнений:
\begin{equation*}
\begin{split}
\left\{\begin{array}{l}
a_{11} x_{1}+a_{12} x_{2} = b_{1} \\
a_{21} x_{1}+a_{22} x_{2} = b_{2}
\end{array}\right.
\end{split}
\end{equation*}
\sphinxAtStartPar
Что в операторной форме можно переписать как:
\begin{equation*}
\begin{split}
\large A\vec{x} = \vec{b},
\end{split}
\end{equation*}
\sphinxAtStartPar
где \(A\) – эрмитова матрица.

\sphinxAtStartPar
Мы будем решать задачу на квантовом компьютере, то нам нужно перейти к квантовым состояниям:
\begin{equation*}
\begin{split}
\large A|x\rangle = |b\rangle
\end{split}
\end{equation*}
\sphinxAtStartPar
Чтобы найти искомый вектор \(|x\rangle\), все что нам по сути нужно сделать – это найти обратный к \(A\) оператор (обозначаемый \(A^{-1}\)), который находится из равенства:
\begin{equation*}
\begin{split}
\large AA^{-1} = A^{-1}A = I
\end{split}
\end{equation*}
\sphinxAtStartPar
Распишем применительно к нашей задаче поиска вектора \(|b\rangle\):
\begin{equation*}
\begin{split}
\large A|x\rangle = |b\rangle \\
\large A^{-1}A|x\rangle = A^{-1}|b\rangle \\
\large |x\rangle = A^{-1}|b\rangle \\
\end{split}
\end{equation*}
\sphinxAtStartPar
Оказывается, что и это все можно провернуть с помощью известных квантовых преобразований. Принципиальный вид нашей схемы представлен следующим образом:

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=800\sphinxpxdimen]{{hhl_circuit}.png}
\caption{Квантовая схема, реализующая алгоритм HHL}\label{\detokenize{book/qmlkinds/ru/hhl_algorithm:hhl-curcuit}}\end{figure}

\sphinxAtStartPar
В нижний регистр загружается вектор \(|b\rangle\), средний и нижний регистры участвуют в фазовой оценке, а верхний дополнительный кубит нужен для так называемого вращения, обусловленного собственными значениями. Давайте разбираться.


\section{Реализация HHL}
\label{\detokenize{book/qmlkinds/ru/hhl_algorithm:id5}}
\sphinxAtStartPar
Для начала мы должны подготовить наши регистры по всем квантовым законам: \(|b\rangle\) и \(|x\rangle\) должны быть пронормированы, а оператор \(A\) должен быть эрмитовым. Надеемся, что Вы помните про ортонормированный базис, сферу Блоха, комплексное представление векторов \(|0\rangle\) и \(|1\rangle\)… Если нет, то обратитесь к предыдущим разделам курса.

\sphinxAtStartPar
Мы будем использовать оператор \(U = e^{iAt}\), и нужно, чтобы он был обратим –\sphinxhyphen{} для этого \(А\) должна быть эрмитовой.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
В случае, когда \(A\) \sphinxstylestrong{не является эрмитовой}, нужно перейти к \sphinxstylestrong{эрмитовой матрице} \(C\):
\begin{equation*}
\begin{split}
C =
\begin{pmatrix}
  0 & A\\
  A^{\dagger} & 0
\end{pmatrix}
\end{split}
\end{equation*}
\sphinxAtStartPar
И рассматривается задача \(C \vec{y} = \left(\begin{array}{l}
  \;\vec{b}\; \\
  \;0\;
  \end{array}\right)\) для того, чтобы найти решение \(y = \left(\begin{array}{l}
  \;0\; \\
  \;\vec{x}\;
  \end{array}\right)\)
\end{sphinxadmonition}

\sphinxAtStartPar
Вспомним, что эрмитову матрицу \(A\) можно представить в виде суммы собственных векторов, умноженных на собственные значения, т.е. в виде спектрального разложения:
\begin{equation*}
\begin{split}
\begin{aligned}
&A=\sum_{j=0}^{N-1} \lambda_{j}\left|u_{j}\right\rangle\left\langle u_{j}\right| \\
&A^{-1}=\sum_{j=0}^{N-1} \lambda_{j}^{-1}\left|u_{j}\right\rangle\left\langle u_{j}\right|
\end{aligned}
\end{split}
\end{equation*}
\sphinxAtStartPar
Тогда вектор\(|b\rangle\) можно представить через собственные векторы \(A\):
\begin{equation*}
\begin{split}
|b\rangle = \sum_{j=0}^{N-1} b_{j} | u_j \rangle
\end{split}
\end{equation*}
\sphinxAtStartPar
Чтобы понять, почему это тоже ключевой момент, давайте вспомним, что значит собственный вектор и собственное значение матрицы.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Собственным вектором \(|u\rangle\) оператора \(A\) называется такой ненулевой вектор, для которого выполняется:
\begin{equation*}
\begin{split}\large A|u\rangle = \lambda |u\rangle\end{split}
\end{equation*}
\sphinxAtStartPar
\(\lambda\) – собственное значение оператора \(A\).
\end{sphinxadmonition}

\sphinxAtStartPar
Таким образом, искомый вектор \(|x\rangle\) – не что иное, как:
\begin{equation*}
\begin{split}
|x\rangle = A^{-1} |b \rangle = \sum_{j=0}^{N-1} \lambda_{j}^{-1}b_j | u_{j}\rangle
\end{split}
\end{equation*}
\sphinxAtStartPar
Итак, фазовая оценка. Мы применяем к кубитам второго регистра матрицы Адамара, тем самым приводим их в суперпозицию. Следом запускаем оператор \(U\):
\begin{equation*}
\begin{split}
U = e^{iAt} = \sum_{j=0}^{N-1} e^{i \lambda_j t} \left| u_j \rangle \langle u_j \right|
\end{split}
\end{equation*}
\sphinxAtStartPar
Для того, чтобы узнать собственное значение оператора \(U\), получения фазы (Quantum Phase Estimation – QPE), результатом которого получится следующее состояние:
\begin{equation*}
\begin{split}
QPE(U, |0\rangle|u\rangle) =
\end{split}
\end{equation*}\begin{equation*}
\begin{split}
\frac{1}{2^{m/2}}( |0\rangle + e^{2\pi i 2^{m-1} \psi} |1\rangle) \otimes (|0\rangle + e^{2\pi i 2^{m-2} \psi} |1\rangle) \otimes \dots \otimes  (|0\rangle + e^{2\pi i 2^{0} \psi} |1\rangle) \otimes |u\rangle =
\end{split}
\end{equation*}\begin{equation*}
\begin{split}
\frac{1}{2^{m/2}}\sum_{j=0}^{2^{m-1}} e^{2\pi i \psi j} |j\rangle |u\rangle = |\psi_{u}\rangle |u\rangle
\end{split}
\end{equation*}
\sphinxAtStartPar
Параметр \(t\) это нормировочная константа в случае \(U = e^{iAt}\):
\begin{equation*}
\begin{split}
e^{2\pi i \psi} = e^{i \lambda_j t}
\end{split}
\end{equation*}\begin{equation*}
\begin{split}
\psi = \frac{\lambda_j t}{2\pi}
\end{split}
\end{equation*}
\sphinxAtStartPar
Параметр \(t\) подбирается с учетом того, что на выходе алгоритма QPE собственные значения \(\lambda_j\) нормализуются к виду \(0 \leq \lambda_j \leq 1\) и обычно мы располагаем ограниченным числом кубитов, которое можно использовать для аппроксимации.

\sphinxAtStartPar
Алгоритм обратного квантового Фурье переводит фазу в конкретный вектор.

\sphinxAtStartPar
Принципиальная схема QPE выглядит следующим образом:

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=800\sphinxpxdimen]{{hhl_circuit2}.png}
\caption{Схема алгоритма QPE}\label{\detokenize{book/qmlkinds/ru/hhl_algorithm:hhl-curcuit2}}\end{figure}

\sphinxAtStartPar
Итак, мы подготовились, вспомнили много хорошего, теперь пошагово распишем наш алгоритм.

\sphinxAtStartPar
Стартуем мы со следующим состоянием:
\begin{equation*}
\begin{split}
\large |0\rangle_{a}|0\rangle_{r}|b\rangle_{m}
\end{split}
\end{equation*}
\sphinxAtStartPar
Т.е. наше состояние будет храниться в трех регистрах, в каждом из которых содержится столько кубитов, сколько нужно для решения задачи.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Применение QPE с использованием преобразования \(e^{iAt}\), после чего мы получим собственное значение оператора \(A\) во втором регистре:
\begin{equation*}
\begin{split}
   |0\rangle_{a}|0\rangle_{r}|b\rangle_{m} \rightarrow \sum_{j=0}^{N-1}b_j|0\rangle_{a}|\lambda_j\rangle_r|u_j\rangle_m
   \end{split}
\end{equation*}
\item {} 
\sphinxAtStartPar
Поворачиваем первый кубит (с индексом \(a\)), используя специальный оператор вращения \(R\):
\begin{equation*}
\begin{split}
   R|0\rangle_{a} = \sum_{j=0}^{N-1}\left(\sqrt{1-\frac{C^{2}}{\lambda_{j}^{2}}}|0\rangle_{a} + \frac{C}{\lambda_{j}}|1\rangle_{a}\right),
   \end{split}
\end{equation*}
\sphinxAtStartPar
где \(C\) – константа, которая должна быть меньше минимального из лямбда: \(|C| < \lambda_{min}\) {[}Почему?{]}.

\sphinxAtStartPar
Переводим первый кубит \(|0\rangle_a\):
\begin{equation*}
\begin{split}
   \sum_{j=0}^{N-1}b_j|0\rangle_{a}|\lambda_j\rangle_r|u_j\rangle_m \rightarrow
   \end{split}
\end{equation*}\begin{equation*}
\begin{split}
   \sum_{j=0}^{N-1}\left(\sqrt{1-\frac{C^{2}}{\lambda_{j}^{2}}}|0\rangle+\frac{C}{\lambda_j}|1\rangle\right)b_j\left|\lambda_{j}\right\rangle_{n}\left|u_{j}\right\rangle_{m}
   \end{split}
\end{equation*}
\item {} 
\sphinxAtStartPar
Применяем \(QPE^{\dagger}\) (т.е. обратное получение фазы) и получаем следующее состояние:
\begin{equation*}
\begin{split}
   \sum_{j=0}^{N-1}\left(\sqrt{1-\frac{C^{2}}{\lambda_{j}^{2}}}|0\rangle+\frac{C}{\lambda_j}|1\rangle\right)b_{j}|0\rangle_{n}\left|u_{j}\right\rangle_{m}
   \end{split}
\end{equation*}
\sphinxAtStartPar
В конце мы измеряем верхний кубит и если получаем единицу, то знаем, что в нижнем регистре хранится искомый \(|x\rangle\) с учетом нормировки:
\begin{equation*}
\begin{split}
   |x\rangle \approx \sum_{j=0}^{N-1}C(\frac{b_j}{\lambda_j})|u_j\rangle
   \end{split}
\end{equation*}
\end{enumerate}


\section{Пример}
\label{\detokenize{book/qmlkinds/ru/hhl_algorithm:id6}}
\sphinxAtStartPar
Рассмотрим небольшой, но удобный пример. Удобный в том отношении, что, вообще говоря, алгоритм HHL имеет определенное приближение. Если собственные значения не представимы в бинарной форме, то о 100\% точности говорить не приходится. Мы также опустим ряд вопросов, связанных с подбором параметров и количества кубитов второго регистра. Главное сейчас – понять, что происходит, и для этого наша матрица \(А\) эрмитова, все условия подобраны, а преобразования точны. Стоит помнить, что знать заранее значение собственных векторов и собственных значений нам совершенно не обязательно – это нужно лишь для наглядности.

\sphinxAtStartPar
Итак, пусть задача выглядит так :
\begin{equation*}
\begin{split}
\begin{aligned}
&A=\left(\begin{array}{ll}
1 & \frac{3}{5} \\
\frac{3}{5} & 1
\end{array}\right) \\
&|b\rangle=|1\rangle=\left[\begin{array}{l}
0 \\
1
\end{array}\right]
\end{aligned}
\end{split}
\end{equation*}\begin{equation*}
\begin{split}
\left\{\begin{array}{l}
x_{1}+\frac{3}{5} x_{2}=0 \\
\frac{3}{5} x_{1}+x_{2}=1
\end{array}\right.
\end{split}
\end{equation*}
\sphinxAtStartPar
Собственные значения и соответствующие собственные векторы:
\begin{equation*}
\begin{split}
\large
\begin{aligned}
&\lambda_{0}=\frac{2}{5},\left|u_{0}\right\rangle=\left[\begin{array}{c}
{-}1 \\
\;\;1
\end{array}\right] \\
&\lambda_{1}=\frac{8}{5},\left|u_{1}\right\rangle=\left[\begin{array}{l}
\;\;1\; \\
\;\;1\;
\end{array}\right]
\end{aligned}
\end{split}
\end{equation*}
\sphinxAtStartPar
Зададим параметр \(t\) и проанализируем фазу:
\begin{equation*}
\begin{split}
\ t = 2\pi \frac{5}{16}
\end{split}
\end{equation*}\begin{equation*}
\begin{split}
e^{2\pi i \psi} = e^{i \lambda_j t}
\end{split}
\end{equation*}\begin{equation*}
\begin{split}
\psi = \frac{\lambda_j t}{2\pi}
\end{split}
\end{equation*}\begin{equation*}
\begin{split}
\frac{\lambda_0 t}{2\pi} = \frac{1}{8}\text{,} \;\;\;\;\;\;\;\;  \frac{\lambda_1 t}{2\pi} = \frac{1}{2}
\end{split}
\end{equation*}
\sphinxAtStartPar
Как мы видим, для перевода угла \(\psi\) в векторную форму, нам понадобятся три кубита. После преобразования QPE мы имеем следующее состояние:
\begin{equation*}
\begin{split}
\begin{aligned}
&{QPE(|0\rangle_{a}|0\rangle_{r}|b\rangle_{m})=\sum_{j=0}^{1} \frac{1}{\sqrt{2}} \left |0\rangle_{a} |\lambda_{j} \rangle_{r} |u_{j}\right\rangle} = \frac{1}{\sqrt{2}}\left(|0\rangle_{a} |001\rangle_r \left|u_{0}\right\rangle + |0\rangle_{a} |100\rangle_r \left|u_{1}\right\rangle\right)
\end{aligned}
\end{split}
\end{equation*}
\sphinxAtStartPar
Подберем константу \(C\) (как мы помним, она должна быть меньше наименьшего из собственных чисел) и произведем вращение:
\begin{equation*}
\begin{split}
\begin{aligned}
&\frac{1}{\sqrt{2}} \left(\sqrt{1-\frac{(1 / 16)^{2}}{(1 / 8)^{2}}}|0\rangle+\frac{1 / 16}{1 / 8}|1\rangle\right)|001\rangle_r \left|u_{0}\right\rangle_m +\\
&+\frac{1}{\sqrt{2}}\left(\sqrt{1-\frac{(1 / 16)^{2}}{(1 / 2)^{2}}}|0\rangle_a+\frac{1 / 16}{1 / 2}|1\rangle_a\right)|100\rangle_r |u_{1}\rangle_m
\end{aligned}
\end{split}
\end{equation*}
\sphinxAtStartPar
В конце мы производим измерение верхнего кубита (с индексом \(a\)) и при получении единицы можем быть уверены, что нижний регистр содержит искомое решение с учетом нормировки:
\begin{equation*}
\begin{split}
\begin{aligned}
\frac{1}{2\sqrt{2}}|1\rangle_a|000\rangle_r\left|u_{0}\right\rangle_m + \frac{1}{8\sqrt{2}}|1\rangle_a|000\rangle_r\left|u_{1}\right\rangle_m
\end{aligned}\\
\end{split}
\end{equation*}\begin{equation*}
\begin{split}
|x\rangle \approx
\frac{1}{2 \sqrt{2}}/(\sqrt{\frac{17}{128}})|u_0\rangle + \frac{1}{8 \sqrt{2}}/(\sqrt{\frac{17}{128}})|u_1\rangle
\end{split}
\end{equation*}
\sphinxstepscope


\chapter{Quantum K\sphinxhyphen{}nearest neighbor}
\label{\detokenize{book/qmlkinds/ru/qknn:quantum-k-nearest-neighbor}}\label{\detokenize{book/qmlkinds/ru/qknn::doc}}
\sphinxAtStartPar
Автор(ы):
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/polyzer}{Токарев Игорь}

\end{itemize}


\section{Введение}
\label{\detokenize{book/qmlkinds/ru/qknn:id1}}
\sphinxAtStartPar
Если вы занимались машинным обучением, то, скорее всего, знакомы с классическим алгоритмом \(k\) ближайших соседей. Он относительно прост, применяется как в задачах классификации, так и в регрессии.
Кстати, классический knn можно вспомнить обратившись к \sphinxhref{https://habr.com/ru/company/ods/blog/322534/}{лекции} от ODS по классическому машинному обучению.

\sphinxAtStartPar
Давайте немножко вспомним задачу классификации с использованием классического \(kNN\) алгоритма:

\sphinxAtStartPar
У нас есть \(\vec{x} \in \{0, 1 \}^N\) – \sphinxstylestrong{тестовый образец}, а также \sphinxstylestrong{тренировочные образцы} – это набор векторов \(\vec{v_i} \in \{0, 1 \}^N\), в котором каждый вектор уже размечен. И наша задача подобрать правильную метку тестовому образцу.

\sphinxAtStartPar
Тогда мы пройдём следующие шаги:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Вычислим похожесть между тестовым образцом и \sphinxstylestrong{каждым} тренировочным образцом.

\item {} 
\sphinxAtStartPar
Найдем \(k\) ближайших к тестовому образцу соседей.

\item {} 
\sphinxAtStartPar
Подсчитаем количество представителей для каждого класса и приписываем метку самого часто встречающегося класса к тестовому образцу.

\end{enumerate}

\sphinxAtStartPar
Самой трудозатратным шагом является вычисление расстояния от тестового образца к каждому тренировочному. Также и в квантовой версии алгоритма.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
На текущий момент разработано несколько разных версий квантового алгоритма поиска ближайших соседей. Есть версия основанная расстоянии Хэмминга {[}\hyperlink{cite.book/bibliography:id49}{LTG21}{]}:

\sphinxAtStartPar
\sphinxhref{https://ru.wikipedia.org/wiki/\%D0\%A0\%D0\%B0\%D1\%81\%D1\%81\%D1\%82\%D0\%BE\%D1\%8F\%D0\%BD\%D0\%B8\%D0\%B5\_\%D0\%A5\%D1\%8D\%D0\%BC\%D0\%BC\%D0\%B8\%D0\%BD\%D0\%B3\%D0\%B0}{Расстояние Хэмминга} между векторами \(\vec{x}\) и \(\vec{v_i}\):
\begin{equation*}
\begin{split} d_i = |\vec{x} - \vec{v_i}| = \sum_{j=1}^{N} (x_j \oplus v_{ij}) \end{split}
\end{equation*}
\sphinxAtStartPar
Но в данной работе мы обратим внимание на версию, которая вычисляет fidelity между двумя векторами состояниями.
\end{sphinxadmonition}

\sphinxAtStartPar
Пусть задано Гильбертово пространство \(n\) кубитов, размерности \(N = 2^n\). Вектор \(|\psi\rangle \in H\) – это тестовое состояние, для которого нам нужно определить метку.

\sphinxAtStartPar
Пусть \(\{|\phi\rangle: j \in \{0, ..., M - 1 \}\} \subset H\) \sphinxhyphen{} это набор тренировочных состояний, для которых мы знаем их метки. \(M = 2^m, m \in \mathbb{Z}\)

\sphinxAtStartPar
Определим fidelity между тестовым состоянием и \(j\)\sphinxhyphen{}тым тренировочным \(|\phi_j\rangle\) как
\begin{equation*}
\begin{split}
  F_j = F(\psi, \phi_j) = |\langle \psi | \phi_j \rangle |^2
\end{split}
\end{equation*}
\sphinxAtStartPar
В свою очередь \(F = [F_0, F_1, ..., F_{M-1}]\) \sphinxhyphen{} это таблица fidelity значений между тестовым состоянием и каждым из тренировочных.

\sphinxAtStartPar
Заметим, что задача нахождения \(k\) ближайших соседей сводится к задаче нахождения \(k\) максимумов значений fidelity из таблицы \(F\). Для этого мы должны реализовать оракула
\begin{equation*}
\begin{split}
  O_{y, A} |j\rangle|0\rangle = |j\rangle|f_{y,A}(j)\rangle,
\end{split}
\end{equation*}
\sphinxAtStartPar
где \(f_{y,A}\) \sphinxhyphen{} это булева функция определённая как
\begin{equation*}
\begin{split}
  f_{y, A}(j) = \begin{cases}
        1 : F_j > F_y \text{ and } j \notin A, \\
        0 : \text{ otherwise },
        \end{cases}
\end{split}
\end{equation*}

\section{Алгоритм}
\label{\detokenize{book/qmlkinds/ru/qknn:id3}}
\sphinxAtStartPar
Далее мы алгоритм представленный в работе {[}\hyperlink{cite.book/bibliography:id20}{BAG21}{]}.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=800\sphinxpxdimen]{{qknn}.png}
\caption{Принципиальная схема QkNN алгоритма. Взято из работы {[}\hyperlink{cite.book/bibliography:id20}{BAG21}{]}.}\label{\detokenize{book/qmlkinds/ru/qknn:qknn}}\end{figure}

\sphinxAtStartPar
Квантовый алгоритм поиска \(k\) ближайших соседей будет состоять из двух основных шагов:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Используй оракул \(O_{y,A}\) (для алгоритма Гровера) мы находим \(k\) состояний \(\{|\phi_{j1}\rangle, ..., |\phi_{jk}\rangle\}\) для которых значение fidelity с тестовым состоянием максимально.

\item {} 
\sphinxAtStartPar
Найти преобладающую метку среди \(k\) найденных состояний и присвоить её тестовому состоянию.

\end{enumerate}

\sphinxAtStartPar
Самой нетривиальной задачей для нас будет построение оракула \(O_{y,A}\).
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Вначале нужно составить оператор \(\mathcal{F}\), который выполняет преобразование вида:
\begin{equation*}
\begin{split}
      \mathcal{F}|j\rangle|0\rangle = |j\rangle|F_j\rangle
    \end{split}
\end{equation*}
\sphinxAtStartPar
для \(j \in \{0, ..., M-1\}\). \(|F_j\rangle\) – это одно из базисных состояний вычислительного базиса (выражающее двоичное представление числа \(F_j\)).
\begin{itemize}
\item {} 
\sphinxAtStartPar
Выполняется преобразование: \(\xi^{amp}|j\rangle|0\rangle = |j\rangle|\psi_j\rangle\). В амплитуду состояния \(|\psi_j\rangle\) закодирована информация о числе \(F_j\) Делается это с помощью Swap test.

\sphinxAtStartPar
Swap test это применение контролируемой операции \(Swap\), которым можно пользоваться для того, чтобы статистически определять fidelity: \(F(\psi, \phi) = |\langle \psi | \phi\rangle|^2\) между двумя произвольными чистыми состояниями \(|\psi\rangle\) и \(|\phi\rangle\).
\begin{equation*}
\begin{split}
        CSWAP(|0\rangle|\psi\rangle|\phi\rangle) = |0\rangle|\psi\rangle|\phi\rangle\\
        CSWAP(|1\rangle|\psi\rangle|\phi\rangle) = |1\rangle|\psi\rangle|\phi\rangle
      \end{split}
\end{equation*}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=500\sphinxpxdimen]{{swap_test}.png}
\caption{Схема Swap test}\label{\detokenize{book/qmlkinds/ru/qknn:qknn-swap-test}}\end{figure}

\item {} 
\sphinxAtStartPar
Выполняется преобразование \(\xi^{dig}|j\rangle|\psi_j\rangle = |j\rangle|F_j\rangle\)

\sphinxAtStartPar
И тогда \(\mathcal{F} = \xi^{dig}\xi^{amp}\).

\end{itemize}

\item {} 
\sphinxAtStartPar
Берём 2 пары регистров \(i_1, f_1; i_2, f_2\). Инициализируются они в форме \(|j\rangle_{i_1}|0\rangle_{f_1}|y\rangle_{i_2}|0\rangle_{f_2}\)

\sphinxAtStartPar
Применяется \(\mathcal{F}\) на каждой паре:
\begin{equation*}
\begin{split}
      \mathcal{F}(|j\rangle_{i_1}|0\rangle_{f_1}) \mathcal{F}(|y\rangle_{i_2}|0\rangle_{f_2}) = |j\rangle_{i_1}|F_j\rangle_{f_1}|y\rangle_{i_2}|F_y\rangle_{f_2}
    \end{split}
\end{equation*}
\item {} 
\sphinxAtStartPar
Теперь информация закодирована в регистры и нам нужно реализовать функцию \(f_{y,A}\). И пусть \(\mathcal{C}\) это оператор, реализующий \(f_{y,A}\).
\begin{equation*}
\begin{split}
      \mathcal{C}(|j\rangle_{i_1}|F_j\rangle_{f_1}|y\rangle_{i_2}|F_y\rangle_{f_2}) = |j\rangle_{i_1}|0\rangle_{f_1}|f_{y,A}\rangle_{i_2}|0\rangle_{f_2}
    \end{split}
\end{equation*}
\end{enumerate}

\sphinxAtStartPar
Теперь займёмся вопросом конструирования оракула \(O_{y,A}\). Просьба держаться за ваши кресла.

\sphinxAtStartPar
Вначале мы подготовим состояния. Но чтобы это сделать нам нужны оракулы \(\mathcal{V}, \mathcal{W}\). Как их имплементировать указано в статье, которая указывалась выше.
\begin{equation*}
\begin{split}
  \mathcal{V}|0^n\rangle = |\psi \rangle
\end{split}
\end{equation*}\begin{equation*}
\begin{split}
  \mathcal{W}|j\rangle|0^n\rangle = |j\rangle|\phi\rangle
\end{split}
\end{equation*}
\sphinxAtStartPar
для всех \(j \in \{0, ..., M-1\}\).
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Инициализируем 4 регистра \(i\), \(tr\), \(tst\), \(B\) с соответствующим количеством кубитов в каждом \(m\), \(n\), \(n\), \(1\), где \(n = \log(N)\), \(m = \log(M)\).
\begin{equation*}
\begin{split}
      |j\rangle_{i}|0^{\otimes n}\rangle_{tr}|0^{\otimes n}\rangle_{tst}|0\rangle_B
    \end{split}
\end{equation*}
\item {} 
\sphinxAtStartPar
Применяем \(\mathcal{W}\)
\begin{equation*}
\begin{split}
      \mathcal{W}(|j\rangle_{i}|0^{\otimes n}\rangle_{tr}|0^{\otimes n}\rangle_{tst}|0\rangle_B) = |j\rangle_{i}|\phi_j\rangle_{tr}|0^{\otimes n}\rangle_{tst}|0\rangle_B
    \end{split}
\end{equation*}
\item {} 
\sphinxAtStartPar
Применяем \(\mathcal{V}\)
\begin{equation*}
\begin{split}
      \mathcal{V}(|j\rangle_{i}|\phi_j\rangle_{tr}|0^{\otimes n}\rangle_{tst}|0\rangle_B) = |j\rangle_{i}|\phi_j\rangle_{tr}|\psi_j\rangle_{tst}|0\rangle_B
    \end{split}
\end{equation*}
\item {} 
\sphinxAtStartPar
Применяем swap test между тренировочным регистром \(tr\) и тестовым регистром \(tst\), а регистр \(B\) будет выступать в качестве контрольного.
\begin{equation*}
\begin{split}
      \frac{1}{2} \left[
        \left(|\phi_j\rangle|\psi\rangle_{tst} + |\psi_j\rangle|\phi\rangle_{tst} \right)|0\rangle_B
              +\left( |\phi_j\rangle|\psi\rangle_{tst} - |\psi_j\rangle|\phi\rangle_{tst} \right)|1\rangle_B  
      \right] = |j\rangle_{i}|\psi_j\rangle_{tr,tst,B}
    \end{split}
\end{equation*}
\sphinxAtStartPar
Определим \(U\)  как унитарное преобразование, которое объединяет шаги 3\sphinxhyphen{}4. Кстати, если мы сейчас произведём измерение регистра \(B\), то будем иметь
\begin{equation*}
\begin{split}
      Pr(B = 0) = \frac{1 + F_j}{2} \\
      Pr(B = 1) = \frac{1 - F_j}{2}
    \end{split}
\end{equation*}
\sphinxAtStartPar
На этом шаге информация о \(fidelity\) теперь закодирована в амплитуды. Теперь же мы должны перевести \(fidelity\) из амплитуды в число.

\item {} 
\sphinxAtStartPar
Теперь мы будем конструировать новый гейт G. Вообще говоря, он описан в работе {[}\hyperlink{cite.book/bibliography:id11}{MKF19}{]}, где вы можете подробнее с ним ознакомиться.
\begin{equation*}
\begin{split}
      G = U_{tr,tst,B}\mathcal{W}_{i,tr}S_{0_{tr,tst,B}}\mathcal{W}_{i,tr}^{\dagger}U_{tr,tst,B}^{\dagger}Z_{B},
    \end{split}
\end{equation*}
\sphinxAtStartPar
где \(Z_B\) – это действие гейта \(Z\) на регистре \(B\), \(S_0 = I - 2|0\rangle\langle 0|\).

\item {} 
\sphinxAtStartPar
Текущее состояние \(|\psi\rangle_{tr,tst,B}\) может быть представлено в виде композиции двух состояний
\begin{equation*}
\begin{split}
      |\psi_j\rangle = \frac{-i}{\sqrt{2}}\left(e^{i\pi\theta_j}|\psi_{j+}\rangle - e^{-i\pi\theta_j}|\psi_{j-}\rangle \right)
    \end{split}
\end{equation*}
\item {} 
\sphinxAtStartPar
Теперь применяем алгоритм \sphinxhref{https://qiskit.org/textbook/ch-algorithms/quantum-phase-estimation.html}{QPE} (Quantum Phase Estimation), чтобы перевести значение фазы \(\theta_j\) в числовое представление.
\begin{equation*}
\begin{split}
      QPE(|\psi_j\rangle) = \frac{-i}{\sqrt{2}}|j\rangle_{i}\left[e^{i\pi\theta_j}|\theta_j\rangle_{ph}|\psi_{j+}\rangle_{tr,tst,B}  - e^{-i\pi\theta_j}|1 - \theta_j\rangle_{ph}|\psi_{j-}\rangle_{tr,tst,B}\right] = |j\rangle_{i}|\psi_{j,AE}\rangle_{ph,tr,tst,B}
    \end{split}
\end{equation*}
\item {} 
\sphinxAtStartPar
Применяем алгоритм квантовой арифметики:
\begin{equation*}
\begin{split}
      |j\rangle|F_j\rangle_{fid}|\psi_{j,AE}\rangle_{ph,tr,tst,B}
    \end{split}
\end{equation*}
\item {} 
\sphinxAtStartPar
Обнуляем регистры \(ph,tr,tst,B\) и получаем \(|j\rangle_{i}|F_j\rangle_{fid}\) На самом деле шаги 5\sphinxhyphen{}9 составляют оператор \(\xi^{dig}\), который мы упоминали ранее.

\item {} 
\sphinxAtStartPar
Теперь применяем оператор \(\mathcal{F}\)
\begin{equation*}
\begin{split}
      |j\rangle_{i1}|F_j\rangle_{f1}|y\rangle_{i2}|F_y\rangle_{f2}
    \end{split}
\end{equation*}
\item {} 
\sphinxAtStartPar
Добавим кубит \(Q_1\) для выполнения сравнения
\begin{equation*}
\begin{split}
      J|a\rangle|b\rangle|0\rangle = \begin{cases}
        |a\rangle|b\rangle|1\rangle : a > b, \\
        |a\rangle|b\rangle|0\rangle : a \leq b,
        \end{cases}
    \end{split}
\end{equation*}\begin{equation*}
\begin{split}
      |j\rangle_{i1}|F_j\rangle_{f1}|y\rangle_{i2}|F_y\rangle_{f2}|g(j)\rangle_{Q_1},
    \end{split}
\end{equation*}
\sphinxAtStartPar
где
\begin{equation*}
\begin{split}
      g(j) = \begin{cases}
        1 : F_j > F_y, \\
        0 : F_j \leq F_y,
        \end{cases}
    \end{split}
\end{equation*}
\sphinxAtStartPar
По кубиту \(Q_1\) мы сможем распознать все индексы \(j\) для которых \(F_j > F_y\).

\item {} 
\sphinxAtStartPar
Обнуляем регистры \(i2\), \(f2\).

\item {} 
\sphinxAtStartPar
Добавляем ещё один кубит \(Q_2\) для каждого \(i_l \in A\), применяя гейт \(D^{(i_l)}\)
\begin{equation*}
\begin{split}
      D^{(i_l)}|j\rangle|0\rangle = \begin{cases}
        |j\rangle|1\rangle : j = i_l, \\
        |j\rangle|0\rangle : j \neq i_l,
        \end{cases}
    \end{split}
\end{equation*}
\sphinxAtStartPar
на индексах регистра. И в результате получим состояние
\begin{equation*}
\begin{split}
      |j\rangle_{i1}|F_j\rangle_{f1}|g(j)\rangle_{Q_1}|\chi_A(j)\rangle_{Q_2}
    \end{split}
\end{equation*}
\item {} 
\sphinxAtStartPar
О да… Теперь мы добавляем ещё один кубит \(Q_3\). Применяем гейт \(X\) на кубите \(Q_2\) и гейт Тоффоли с контролирующими \((Q_1, Q_2)\) и целевой \(Q_3\)
\begin{equation*}
\begin{split}
      |j\rangle_{i1}|F_j\rangle_{f1}|g(j)\rangle_{Q_1}|\chi_A(j)\rangle_{Q_2}|f_{y,A}(j)\rangle_{Q_3}
    \end{split}
\end{equation*}
\item {} 
\sphinxAtStartPar
Обнуляем все регистры, кроме \(Q_3\)
\begin{equation*}
\begin{split}
      |j\rangle_{i1}|f_{y,A}(j)\rangle_{Q_3}
    \end{split}
\end{equation*}
\sphinxAtStartPar
Что ж, вот мы и построили преобразование \(O_{y,A}\) которое так хотели
\begin{equation*}
\begin{split}
      O_{y,A}|j\rangle|0\rangle = |j\rangle|f_{y,A}(j)\rangle
    \end{split}
\end{equation*}
\end{enumerate}

\sphinxstepscope


\part{Вариационные схемы}

\sphinxstepscope


\chapter{О блоке “Вариационные схемы”}
\label{\detokenize{book/vqc/ru/vqc_intro:vqc-intro}}\label{\detokenize{book/vqc/ru/vqc_intro:id1}}\label{\detokenize{book/vqc/ru/vqc_intro::doc}}
\sphinxAtStartPar
Этот блок включает в себя только вариационные квантовые схемы (VQC).

\sphinxstepscope


\chapter{Вариационные квантовые схемы}
\label{\detokenize{book/vqc/ru/vqc:vqc}}\label{\detokenize{book/vqc/ru/vqc:id1}}\label{\detokenize{book/vqc/ru/vqc::doc}}
\sphinxAtStartPar
Автор(ы):
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/SemyonSinchenko}{Синченко Семен}

\end{itemize}


\section{Описание лекции}
\label{\detokenize{book/vqc/ru/vqc:id2}}
\sphinxAtStartPar
На этой лекции мы впервые познакомимся непосредственно с квантовым машинным обучением. Лекция расскажет:
\begin{itemize}
\item {} 
\sphinxAtStartPar
в чем заключается идея квантово\sphinxhyphen{}классического обучения;

\item {} 
\sphinxAtStartPar
что такое вариационное машинное обучение;

\item {} 
\sphinxAtStartPar
как устроена вариационная квантовая схема и как закодировать в нее данные.

\end{itemize}


\section{Введение}
\label{\detokenize{book/vqc/ru/vqc:id3}}
\sphinxAtStartPar
В течение всего курса будем говорить преимущественно о комбинированном квантово\sphinxhyphen{}классическом машинном обучении, построенном на базе вариационных квантовых схем. Именно он является наиболее перспективным в эпоху {\hyperref[\detokenize{book/glossary:term-Noisy-intermediate-scale-quantum-NISQ-NISQ-Hardware}]{\sphinxtermref{\DUrole{xref,std,std-term}{NISQ}}}}. Давайте забежим немного вперед и посмотрим, как выглядит типичный цикл такого обучения.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[height=400\sphinxpxdimen]{{diagram}.png}
\caption{Пример цикла смешанного обучения}\label{\detokenize{book/vqc/ru/vqc:vqcdiag}}\end{figure}

\sphinxAtStartPar
Красным цветом на диаграмме помечены блоки, выполняемые на квантовом устройстве, зеленым – те, что считает обычный компьютер. Квантовая часть, которая включает в себя операторы \(\hat{U}(X)\) и \(\hat{U}(\theta)\), а также измерение наблюдаемой \(\hat{M}\), называется вариационной квантовой схемой. Именно ей посвящена данная лекция.

\sphinxAtStartPar
Но сначала сделаем шаг назад и обсудим в общих чертах идеи, которые лежат в основе квантово\sphinxhyphen{}классического обучения.


\section{Квантово\sphinxhyphen{}классическое обучение}
\label{\detokenize{book/vqc/ru/vqc:id4}}
\sphinxAtStartPar
Основная идея квантово\sphinxhyphen{}классического обучения заключается в том, что в эпоху Noisy Intermediate\sphinxhyphen{}Scale Quantum (\sphinxstyleemphasis{NISQ}) у нас нет больших работающих квантовых компьютеров и квантовой памяти. Это сильно ограничивает применение алгоритмов, более быстрых, чем классические. Нам остается только “встраивать” квантовые схемы в классический цикл обучения.

\sphinxAtStartPar
В этом случае мы разделяем классическую и квантовую части алгоритма. Выполняем предварительную обработку и подготовку данных на классическом компьютере, затем “прогоняем” их через квантовую схему. Она должна возвращать нам “классические” данные, а значит, должна включать в себя набор последовательно применяемых операторов и измерение. Со стороны классического компьютера такая схема выглядит как “черный ящик” или “оракул”, с которым уже можно работать. Например, можно варьировать параметры схемы таким образом, чтобы она “обучалась” так же, как “обучаются” нейронные сети или другие алгоритмы классического машинного обучения.

\sphinxAtStartPar
Давайте более детально посмотрим на квантовую схему, которую можно использовать в таком подходе.


\section{Вариационные квантовые схемы}
\label{\detokenize{book/vqc/ru/vqc:id5}}
\sphinxAtStartPar
В основе вариационных квантовых схем – Variational Quantum Circuits (\sphinxstylestrong{VQC}) – лежит простая идея. Чтобы проиллюстрировать ее, давайте сделаем схему, которая включает в себя набор унитарных операторов и переводит классические данные \(\mathbf{X}\) и параметры \(\theta\) в квантовое состояние \(\ket{\Psi}(\theta, \mathbf{X})\). Затем будем варьировать наше состояние \(\ket{\Psi}\), меняя параметры \(\theta\) так, чтобы при его измерении в каком\sphinxhyphen{}либо базисе мы получали нужный результат, например, результат классификации входных данных \(\mathbf{X}\).

\sphinxAtStartPar
Разберем написанное выше на примере.


\subsection{Аппроксимация матрицы Паули \sphinxstylestrong{X} оператором поворота}
\label{\detokenize{book/vqc/ru/vqc:x}}
\sphinxAtStartPar
Из предыдущих лекций мы помним, что оператор \(\hat{\mathbf{X}}\) работает как квантовый аналог оператора \(NOT\) – инвертирует значение кубита.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{pennylane} \PYG{k}{as} \PYG{n+nn}{qml}

\PYG{n}{dev} \PYG{o}{=} \PYG{n}{qml}\PYG{o}{.}\PYG{n}{device}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{default.qubit}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}

\PYG{n+nd}{@qml}\PYG{o}{.}\PYG{n}{qnode}\PYG{p}{(}\PYG{n}{dev}\PYG{p}{)}
\PYG{k}{def} \PYG{n+nf}{simple\PYGZus{}x\PYGZus{}gate}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{qml}\PYG{o}{.}\PYG{n}{PauliX}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{qml}\PYG{o}{.}\PYG{n}{expval}\PYG{p}{(}\PYG{n}{qml}\PYG{o}{.}\PYG{n}{PauliZ}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}


\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{simple\PYGZus{}x\PYGZus{}gate}\PYG{p}{(}\PYG{p}{)} \PYG{l+s+si}{= \PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
simple\PYGZus{}x\PYGZus{}gate() = tensor(\PYGZhy{}1., requires\PYGZus{}grad=True)
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{qml}\PYG{o}{.}\PYG{n}{drawer}\PYG{o}{.}\PYG{n}{use\PYGZus{}style}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{default}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{qml}\PYG{o}{.}\PYG{n}{draw\PYGZus{}mpl}\PYG{p}{(}\PYG{n}{simple\PYGZus{}x\PYGZus{}gate}\PYG{p}{)}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{fig}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{vqc_2_0}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
С другой стороны, у нас есть оператор \(\hat{RX}(\phi)\), который “вращает” состояние нашего кубита вокруг оси \(\mathbf{X}\) на угол \(\phi\). Сделаем параметризованную схему с одним параметром:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nd}{@qml}\PYG{o}{.}\PYG{n}{qnode}\PYG{p}{(}\PYG{n}{dev}\PYG{p}{)}
\PYG{k}{def} \PYG{n+nf}{vqc}\PYG{p}{(}\PYG{n}{phi}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{qml}\PYG{o}{.}\PYG{n}{RX}\PYG{p}{(}\PYG{n}{phi}\PYG{p}{,} \PYG{n}{wires}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{qml}\PYG{o}{.}\PYG{n}{expval}\PYG{p}{(}\PYG{n}{qml}\PYG{o}{.}\PYG{n}{PauliZ}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Теперь попробуем подобрать \(\phi\) так, чтобы параметризованная схема работала точно так же, как оператор \(\hat{X}\):

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{p}{[}\PYG{l+m+mf}{1.0}\PYG{p}{,} \PYG{l+m+mf}{2.0}\PYG{p}{,} \PYG{l+m+mf}{3.0}\PYG{p}{,} \PYG{l+m+mf}{3.14159265359}\PYG{p}{]}\PYG{p}{:}
  \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Try }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{i}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{vqc}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}  
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Try 1.0: 0.5403023058681394
Try 2.0: \PYGZhy{}0.41614683654714246
Try 3.0: \PYGZhy{}0.9899924966004454
Try 3.14159265359: \PYGZhy{}0.9999999999999998
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Получается, что нужный нам угол \(\phi\) составляет ровно \(\pi\). Это логично, мы могли бы это легко понять из простейших соображений линейной алгебры, либо взглянув на сферу Блоха. Но целью этого примера было проиллюстрировать работу VQC.

\sphinxAtStartPar
Наш процесс “подбора” параметра \(\phi\) крайне примитивный, на следующих лекциях мы рассмотрим, как посчитать градиент параметров квантовой схемы и задействовать всю мощь известных на сегодня методов оптимизации. А пока еще немного подумаем о том, как можно закодировать данные в квантовую схему.


\section{Кодирование данных в VQC}
\label{\detokenize{book/vqc/ru/vqc:id6}}
\sphinxAtStartPar
В конструировании VQC есть две важных части:
\begin{itemize}
\item {} 
\sphinxAtStartPar
кодирование классических данных в квантовые операторы;

\item {} 
\sphinxAtStartPar
выбор наблюдаемой для измерений.

\end{itemize}

\sphinxAtStartPar
Вот как можно закодировать данные.


\subsection{Кодирование поворотами}
\label{\detokenize{book/vqc/ru/vqc:id7}}
\sphinxAtStartPar
Один из самых популярных методов кодирования классических данных в квантовые схемы – это использование операторов поворота \(\hat{RY}, \hat{RZ}\). Представим, что мы хотим отображать вектор из двумерного пространства в один кубит \(\vec{x} \in \mathbb{R}^2 \to \mathbb{C}^2\).

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nd}{@qml}\PYG{o}{.}\PYG{n}{qnode}\PYG{p}{(}\PYG{n}{dev}\PYG{p}{)}
\PYG{k}{def} \PYG{n+nf}{angle\PYGZus{}vqc}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{qml}\PYG{o}{.}\PYG{n}{RY}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{wires}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{qml}\PYG{o}{.}\PYG{n}{RZ}\PYG{p}{(}\PYG{n}{b}\PYG{p}{,} \PYG{n}{wires}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}

    \PYG{k}{return} \PYG{n}{qml}\PYG{o}{.}\PYG{n}{expval}\PYG{p}{(}\PYG{n}{qml}\PYG{o}{.}\PYG{n}{PauliZ}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
А теперь давайте посмотрим, как такая схема преобразует данные. Для этого сгенерируем набор случайных двумерных данных в диапазоне \([0, 2\pi]\) и применим к каждой точке нашей схемы, затем визуализируем результаты:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}

\PYG{n}{aa} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{uniform}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{p}{,} \PYG{n}{size}\PYG{o}{=}\PYG{l+m+mi}{500}\PYG{p}{)}
\PYG{n}{bb} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{uniform}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{p}{,} \PYG{n}{size}\PYG{o}{=}\PYG{l+m+mi}{500}\PYG{p}{)}

\PYG{n}{res} \PYG{o}{=} \PYG{p}{[}\PYG{n}{angle\PYGZus{}vqc}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)} \PYG{k}{for} \PYG{n}{a}\PYG{p}{,} \PYG{n}{b} \PYG{o+ow}{in} \PYG{n+nb}{zip}\PYG{p}{(}\PYG{n}{aa}\PYG{p}{,} \PYG{n}{bb}\PYG{p}{)}\PYG{p}{]}

\PYG{n}{f} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{clb} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{scatter}\PYG{p}{(}\PYG{n}{aa}\PYG{p}{,} \PYG{n}{bb}\PYG{p}{,} \PYG{n}{c}\PYG{o}{=}\PYG{n}{res}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{b}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{n}{clb}\PYG{p}{)}

\PYG{n}{f}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{vqc_10_0}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Результат довольно необычный. Предсказать такое довольно сложно и хорошо видна возможность нелинейности \sphinxcode{\sphinxupquote{VQC}} схем. В дальнейших лекциях мы будем более подробно разбирать возможные варианты кодирования данных. Кстати, кодирование углами настолько популярно, что в \sphinxcode{\sphinxupquote{PennyLane}} для этого есть специальная функция, которая позволяет “повернуть” сразу множество кубитов, используя список из классических данных:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nd}{@qml}\PYG{o}{.}\PYG{n}{qnode}\PYG{p}{(}\PYG{n}{dev}\PYG{p}{)}
\PYG{k}{def} \PYG{n+nf}{angle\PYGZus{}vqc\PYGZus{}pl}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{qml}\PYG{o}{.}\PYG{n}{templates}\PYG{o}{.}\PYG{n}{embeddings}\PYG{o}{.}\PYG{n}{AngleEmbedding}\PYG{p}{(}\PYG{p}{[}\PYG{n}{a}\PYG{p}{]}\PYG{p}{,} \PYG{n}{wires}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{rotation}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Y}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n}{qml}\PYG{o}{.}\PYG{n}{templates}\PYG{o}{.}\PYG{n}{embeddings}\PYG{o}{.}\PYG{n}{AngleEmbedding}\PYG{p}{(}\PYG{p}{[}\PYG{n}{b}\PYG{p}{]}\PYG{p}{,} \PYG{n}{wires}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{rotation}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Z}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{qml}\PYG{o}{.}\PYG{n}{expval}\PYG{p}{(}\PYG{n}{qml}\PYG{o}{.}\PYG{n}{PauliZ}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Давайте убедимся, что это даст нам ровно тот же результат:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{res\PYGZus{}pl} \PYG{o}{=} \PYG{p}{[}\PYG{n}{angle\PYGZus{}vqc\PYGZus{}pl}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)} \PYG{k}{for} \PYG{n}{a}\PYG{p}{,} \PYG{n}{b} \PYG{o+ow}{in} \PYG{n+nb}{zip}\PYG{p}{(}\PYG{n}{aa}\PYG{p}{,} \PYG{n}{bb}\PYG{p}{)}\PYG{p}{]}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{allclose}\PYG{p}{(}\PYG{n}{res}\PYG{p}{,} \PYG{n}{res\PYGZus{}pl}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
True
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Важность многокубитных гейтов}
\label{\detokenize{book/vqc/ru/vqc:id8}}
\sphinxAtStartPar
При кодировании параметров целесообразно использовать многокубитные гейты, так как именно они создают запутанные состояния и раскрывают все преимущества квантовых компьютеров. Давайте попробуем это сделать.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{dev2} \PYG{o}{=} \PYG{n}{qml}\PYG{o}{.}\PYG{n}{device}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{default.qubit}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}

\PYG{n+nd}{@qml}\PYG{o}{.}\PYG{n}{qnode}\PYG{p}{(}\PYG{n}{dev2}\PYG{p}{)}
\PYG{k}{def} \PYG{n+nf}{cnot\PYGZus{}vqc}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{qml}\PYG{o}{.}\PYG{n}{RY}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{wires}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{n}{qml}\PYG{o}{.}\PYG{n}{RY}\PYG{p}{(}\PYG{n}{b}\PYG{p}{,} \PYG{n}{wires}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{n}{qml}\PYG{o}{.}\PYG{n}{RZ}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{wires}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{n}{qml}\PYG{o}{.}\PYG{n}{RZ}\PYG{p}{(}\PYG{n}{b}\PYG{p}{,} \PYG{n}{wires}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{n}{qml}\PYG{o}{.}\PYG{n}{CZ}\PYG{p}{(}\PYG{n}{wires}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{qml}\PYG{o}{.}\PYG{n}{expval}\PYG{p}{(}\PYG{n}{qml}\PYG{o}{.}\PYG{n}{PauliZ}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{@} \PYG{n}{qml}\PYG{o}{.}\PYG{n}{PauliZ}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
В этой схеме мы видим оператор \(\hat{CZ}\), который создает запутанное состояние. Посмотрим, как такая схема преобразует наше исходное пространство случайных точек.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{res} \PYG{o}{=} \PYG{p}{[}\PYG{n}{cnot\PYGZus{}vqc}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)} \PYG{k}{for} \PYG{n}{a}\PYG{p}{,} \PYG{n}{b} \PYG{o+ow}{in} \PYG{n+nb}{zip}\PYG{p}{(}\PYG{n}{aa}\PYG{p}{,} \PYG{n}{bb}\PYG{p}{)}\PYG{p}{]}

\PYG{n}{f} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{clb} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{scatter}\PYG{p}{(}\PYG{n}{aa}\PYG{p}{,} \PYG{n}{bb}\PYG{p}{,} \PYG{n}{c}\PYG{o}{=}\PYG{n}{res}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{b}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{n}{clb}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{vqc_18_0}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Результат выглядит гораздо интереснее. В целом можно сказать, что выбор способа кодирования данных – один из важнейших при проектировании \sphinxstylestrong{VQC}. Мы еще много раз будем обсуждать способы сделать это.


\section{Что мы узнали из лекции}
\label{\detokenize{book/vqc/ru/vqc:id9}}\begin{itemize}
\item {} 
\sphinxAtStartPar
В эпоху NISQ мы чаще всего ограничены комбинированием квантового и классического машинного обучения.

\item {} 
\sphinxAtStartPar
Ключевой элемент такого обучения – вариационные квантовые схемы (VQC). Основная идея VQC:
\begin{itemize}
\item {} 
\sphinxAtStartPar
кодируем классические данные в квантовые операторы;

\item {} 
\sphinxAtStartPar
измеряем состояние;

\item {} 
\sphinxAtStartPar
варьируем параметры на классическом компьютере так, чтобы измерение давало желаемый результат.

\end{itemize}

\item {} 
\sphinxAtStartPar
Один из широко применимых методов кодирования – использование операторов вращений \(\hat{RX}, \hat{RY}, \hat{RZ}\)

\end{itemize}

\sphinxstepscope


\part{Квантовые градиенты}

\sphinxstepscope


\chapter{О блоке “Квантовые градиенты”}
\label{\detokenize{book/grads/ru/grads_intro:grads-intro}}\label{\detokenize{book/grads/ru/grads_intro:id1}}\label{\detokenize{book/grads/ru/grads_intro::doc}}
\sphinxAtStartPar
Этот блок включает в себя обзор способов оценки градиента VQC.

\sphinxAtStartPar
Продвинутая тема блока рассказывает о квантовых градиентах старших порядков.

\sphinxstepscope


\chapter{Градиенты квантовых схем}
\label{\detokenize{book/grads/ru/gradients:gradients}}\label{\detokenize{book/grads/ru/gradients:id1}}\label{\detokenize{book/grads/ru/gradients::doc}}
\sphinxAtStartPar
Автор(ы):
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/SemyonSinchenko}{Синченко Семен}

\end{itemize}


\section{Описание лекции}
\label{\detokenize{book/grads/ru/gradients:id2}}
\sphinxAtStartPar
В этой лекции мы детально разберем, как можно оптимизировать параметры VQC:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Как выглядит цикл обучения квантовой схемы

\item {} 
\sphinxAtStartPar
Как работает оценка градиента “под капотом”
\begin{itemize}
\item {} 
\sphinxAtStartPar
Метод конечных отрезков

\item {} 
\sphinxAtStartPar
Parameter\sphinxhyphen{}shift rule

\end{itemize}

\end{itemize}


\section{Введение}
\label{\detokenize{book/grads/ru/gradients:id3}}
\sphinxAtStartPar
Как мы уже говорили ранее, VQC выступают в роли “черных ящиков”, которые имеют параметры и как\sphinxhyphen{}то преобразуют поступающие в них данные. В этом случае сам процесс оптимизации параметров выполняется на классическом компьютере. Одними из самых эффективных на сегодня методов решения задач непрерывной оптимизации являются градиентные методы. Для этих методов разработан широкий арсенал эвристик и приемов, который применяется в обучении классических глубоких нейронных сетей. Очень хочется применить весь этот арсенал и для квантового машинного обучения. Но как же посчитать градиент вариационной квантовой схемы?


\section{Задача лекции}
\label{\detokenize{book/grads/ru/gradients:id4}}
\sphinxAtStartPar
На этой лекции мы рассмотрим простую задачку по оптимизации параметров квантовой схемы и на ее примере увидим, как работают квантовые градиенты. В качестве задачи возьмем известный набор данных “Two Moon” из библиотеки \sphinxcode{\sphinxupquote{scikit\sphinxhyphen{}learn}}:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{pennylane} \PYG{k+kn}{import} \PYG{n}{numpy} \PYG{k}{as} \PYG{n}{np}
\PYG{k+kn}{import} \PYG{n+nn}{pennylane} \PYG{k}{as} \PYG{n+nn}{qml}
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{o}{\PYGZpc{}}\PYG{k}{config} InlineBackend.figure\PYGZus{}format = \PYGZsq{}retina\PYGZsq{}
\PYG{k+kn}{from} \PYG{n+nn}{sklearn}\PYG{n+nn}{.}\PYG{n+nn}{datasets} \PYG{k+kn}{import} \PYG{n}{make\PYGZus{}moons}

\PYG{n}{x}\PYG{p}{,} \PYG{n}{y} \PYG{o}{=} \PYG{n}{make\PYGZus{}moons}\PYG{p}{(}\PYG{n}{n\PYGZus{}samples}\PYG{o}{=}\PYG{l+m+mi}{50}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Для удобства мы сразу переведем метки классов из \(\{0, 1\} \to \{-1, 1\}\), а признаки \(\mathbf{X}\) переведем в \([0, \pi]\):

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{normalize}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    Переводит значения в интервал от 0 до pi}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{n}{min\PYGZus{}} \PYG{o}{=} \PYG{n}{x}\PYG{o}{.}\PYG{n}{min}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{max\PYGZus{}} \PYG{o}{=} \PYG{n}{x}\PYG{o}{.}\PYG{n}{max}\PYG{p}{(}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi} \PYG{o}{*} \PYG{p}{(}\PYG{n}{x} \PYG{o}{\PYGZhy{}} \PYG{n}{min\PYGZus{}}\PYG{p}{)} \PYG{o}{/} \PYG{p}{(}\PYG{n}{max\PYGZus{}} \PYG{o}{\PYGZhy{}} \PYG{n}{min\PYGZus{}}\PYG{p}{)}

\PYG{n}{x}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{n}{normalize}\PYG{p}{(}\PYG{n}{x}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{x}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n}{normalize}\PYG{p}{(}\PYG{n}{x}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{y} \PYG{o}{=} \PYG{n}{y} \PYG{o}{*} \PYG{l+m+mi}{2} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{cb} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{scatter}\PYG{p}{(}\PYG{n}{x}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{x}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{c}\PYG{o}{=}\PYG{n}{y}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{n}{cb}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{gradients_3_0}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Вариационная схема}
\label{\detokenize{book/grads/ru/gradients:id5}}
\sphinxAtStartPar
Перед тем как мы начнем обучение и будем считать градиенты, нам необходимо определиться с тем, как будет выглядеть наша вариационная схема. Мы посвятим кодированию данных, выбору архитектуры схемы, а также измеряемого оператора еще много занятий. Так что пока просто воспользуемся кодированием признаков \(\mathbf{X}\) вращениями, а сверху применим несколько параметризованных слоев вращений.


\subsection{Кодирование признаков}
\label{\detokenize{book/grads/ru/gradients:id6}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{dev} \PYG{o}{=} \PYG{n}{qml}\PYG{o}{.}\PYG{n}{device}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{default.qubit}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}

\PYG{k}{def} \PYG{n+nf}{encoding}\PYG{p}{(}\PYG{n}{x1}\PYG{p}{,} \PYG{n}{x2}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{qml}\PYG{o}{.}\PYG{n}{RY}\PYG{p}{(}\PYG{n}{x1}\PYG{p}{,} \PYG{n}{wires}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{n}{qml}\PYG{o}{.}\PYG{n}{RY}\PYG{p}{(}\PYG{n}{x2}\PYG{p}{,} \PYG{n}{wires}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{n}{qml}\PYG{o}{.}\PYG{n}{RZ}\PYG{p}{(}\PYG{n}{x1}\PYG{p}{,} \PYG{n}{wires}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{n}{qml}\PYG{o}{.}\PYG{n}{RZ}\PYG{p}{(}\PYG{n}{x2}\PYG{p}{,} \PYG{n}{wires}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{n}{qml}\PYG{o}{.}\PYG{n}{CZ}\PYG{p}{(}\PYG{n}{wires}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\subsection{Параметризованные слои}
\label{\detokenize{book/grads/ru/gradients:id7}}
\sphinxAtStartPar
В качестве одного слоя обучения мы будем использовать параметризованные вращения в связке с двухкубитным гейтом для создания запутанных состояний.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Более детально о запутанных состояниях, а также квантовой энтропии и черных дырах можно посмотреть в {\hyperref[\detokenize{book/qc/ru/mixedstates::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{продвинутой лекции}}}} блока про квантовые вычисления.
\end{sphinxadmonition}

\sphinxAtStartPar
В этой лекции у нас нет цели идеально решить поставленную задачу – на самом деле это чуть сложнее, чем может показаться на первый взгляд. Поэтому пока не будем излишне усложнять нашу \sphinxstylestrong{VQC}. Сделаем нашу \sphinxstylestrong{VQC} содержащей несколько “слоев” следующего вида:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Вращение 1\sphinxhyphen{}го кубита \(\hat{Rot}(\theta_1^1, \theta_1^2, \theta_1^3)\)

\item {} 
\sphinxAtStartPar
Вращение 2\sphinxhyphen{}го кубита \(\hat{Rot}(\theta_2^1, \theta_2^2, \theta_2^3)\)

\item {} 
\sphinxAtStartPar
“Запутывающий” оператор, который действует на оба кубита сразу – в нашем случае это \(\hat{CZ}\)

\end{itemize}

\sphinxAtStartPar
Как видно, на каждый “слой” у нас приходится шесть параметров. Реализуем это в коде:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{layer}\PYG{p}{(}\PYG{n}{theta}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{qml}\PYG{o}{.}\PYG{n}{Rot}\PYG{p}{(}\PYG{n}{theta}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{theta}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{theta}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{n}{wires}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{n}{qml}\PYG{o}{.}\PYG{n}{Rot}\PYG{p}{(}\PYG{n}{theta}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{theta}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{theta}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{n}{wires}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{n}{qml}\PYG{o}{.}\PYG{n}{CZ}\PYG{p}{(}\PYG{n}{wires}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Здесь у нас вращения каждого из кубитов по сфере Блоха и двухкубитное взаимодействие \(\hat{CZ}\).


\subsection{Все вместе}
\label{\detokenize{book/grads/ru/gradients:id8}}
\sphinxAtStartPar
Теперь давайте объединим все это вместе, добавим пару наблюдаемых и оформим как \sphinxcode{\sphinxupquote{qml.qnode}}:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nd}{@qml}\PYG{o}{.}\PYG{n}{qnode}\PYG{p}{(}\PYG{n}{dev}\PYG{p}{)}
\PYG{k}{def} \PYG{n+nf}{node}\PYG{p}{(}\PYG{n}{x1}\PYG{p}{,} \PYG{n}{x2}\PYG{p}{,} \PYG{n}{q}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{encoding}\PYG{p}{(}\PYG{n}{x1}\PYG{p}{,} \PYG{n}{x2}\PYG{p}{)}
    \PYG{k}{for} \PYG{n}{q\PYGZus{}} \PYG{o+ow}{in} \PYG{n}{q}\PYG{p}{:}
        \PYG{n}{layer}\PYG{p}{(}\PYG{n}{q\PYGZus{}}\PYG{p}{)}

    \PYG{k}{return} \PYG{n}{qml}\PYG{o}{.}\PYG{n}{expval}\PYG{p}{(}\PYG{n}{qml}\PYG{o}{.}\PYG{n}{PauliZ}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{@} \PYG{n}{qml}\PYG{o}{.}\PYG{n}{PauliY}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\subsection{Функция “скоринга”}
\label{\detokenize{book/grads/ru/gradients:id9}}
\sphinxAtStartPar
Наша квантовая схема принимает на вход лишь одну точку данных, а у нас их 50. Поэтому удобно сразу написать функцию, которая может работать с массивами \sphinxcode{\sphinxupquote{NumPy}}:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{apply\PYGZus{}node}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{q}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{res} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}

    \PYG{k}{for} \PYG{n}{x\PYGZus{}} \PYG{o+ow}{in} \PYG{n}{x}\PYG{p}{:}
        \PYG{n}{vqc\PYGZus{}output} \PYG{o}{=} \PYG{n}{node}\PYG{p}{(}\PYG{n}{x\PYGZus{}}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{x\PYGZus{}}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
        \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{vqc\PYGZus{}output} \PYG{o}{+} \PYG{n}{q}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}

    \PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Может показаться немного запутанно, но так получилось. Дело в том, что параметры схемы это только углы поворотов. Но мы также хотим добавить еще и смещение, поэтому \sphinxcode{\sphinxupquote{tuple}} параметров у нас содержит два элемента: массив параметров схемы, а также значение смещения. Так как схема у нас принимает на вход лишь одну пару значений \(x_1, x_2\), то для того, чтобы “проскорить” массив данных мы должны:
\begin{itemize}
\item {} 
\sphinxAtStartPar
итерироваться по строкам двумерного массива

\item {} 
\sphinxAtStartPar
для каждой строки вычислять результат схемы – это функция от \(x_1, x_2, \theta\) – массив параметров \(\theta\) у нас первый элемент \sphinxcode{\sphinxupquote{tuple}}

\item {} 
\sphinxAtStartPar
добавлять смещение – это второй элемент \sphinxcode{\sphinxupquote{tuple}}

\item {} 
\sphinxAtStartPar
результат добавлять в итоговый массив

\end{itemize}

\sphinxAtStartPar
Именно это и реализовано в коде.


\subsection{Визуализация}
\label{\detokenize{book/grads/ru/gradients:id10}}
\sphinxAtStartPar
Давайте инициализируем нашу схему случайными параметрами и посмотрим, как она “сходу” классифицирует данные. Возьмем 4 параметризованных слоя.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{seed}\PYG{p}{(}\PYG{l+m+mi}{42}\PYG{p}{)}
\PYG{n}{q} \PYG{o}{=} \PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{uniform}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{p}{,} \PYG{n}{size}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{cb} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{scatter}\PYG{p}{(}\PYG{n}{x}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{x}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{c}\PYG{o}{=}\PYG{n}{apply\PYGZus{}node}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{q}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{n}{cb}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{gradients_13_0}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Как видно, результат “не очень” и наша цель – попытаться его улучшить.


\section{Функция потерь}
\label{\detokenize{book/grads/ru/gradients:id11}}
\sphinxAtStartPar
Прежде чем варьировать параметры схемы, нам для начала необходимо понять, а что именно мы хотим оптимизировать. Для этого нам необходимо выбрать функцию потерь.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Если у Вас трудности с функциями потерь в таком контексте, то рекомендуем вернуться к вводной лекции про классическое машинное обучение, где эта тема раскрыта достаточно подробно.
\end{sphinxadmonition}


\subsection{Квадратичное отклонение}
\label{\detokenize{book/grads/ru/gradients:id12}}
\sphinxAtStartPar
В качестве функции потерь, которая является дифференцируемой, мы будем использовать наиболее простой вариант – среднеквадратичное отклонения. Это не самый лучший выбор для задач классификации, но зато самый простой. Простой вариант – это именно то, что нам нужно в этой лекции:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{cost}\PYG{p}{(}\PYG{n}{q}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{preds} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{apply\PYGZus{}node}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{q}\PYG{p}{)}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{np}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{square}\PYG{p}{(}\PYG{n}{preds} \PYG{o}{\PYGZhy{}} \PYG{n}{y}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\subsection{Точность классификации}
\label{\detokenize{book/grads/ru/gradients:id13}}
\sphinxAtStartPar
В качестве метрики качества среднеквадратичное отклонение вообще не подходит – понять по этой цифре, хорошо или плохо работает модель почти невозможно! Поэтому для оценки модели в целом мы будем использовать точность:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{acc}\PYG{p}{(}\PYG{n}{q}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{preds} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sign}\PYG{p}{(}\PYG{n}{apply\PYGZus{}node}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{q}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{res} \PYG{o}{=} \PYG{l+m+mi}{0}
    \PYG{k}{for} \PYG{n}{p\PYGZus{}}\PYG{p}{,} \PYG{n}{y\PYGZus{}} \PYG{o+ow}{in} \PYG{n+nb}{zip}\PYG{p}{(}\PYG{n}{preds}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{if} \PYG{n}{np}\PYG{o}{.}\PYG{n}{abs}\PYG{p}{(}\PYG{n}{y\PYGZus{}} \PYG{o}{\PYGZhy{}} \PYG{n}{p\PYGZus{}}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}2}\PYG{p}{:}
            \PYG{n}{res} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}

    \PYG{k}{return} \PYG{n}{res} \PYG{o}{/} \PYG{n}{y}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\section{Решение средствами \sphinxstyleliteralintitle{\sphinxupquote{PennyLane}}}
\label{\detokenize{book/grads/ru/gradients:pennylane}}
\sphinxAtStartPar
Библиотека \sphinxcode{\sphinxupquote{PennyLane}} может использовать один из нескольких движков для автоматического дифференцирования:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{NumPy Autograd}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{PyTorch}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Tensorflow}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Jax}}

\end{itemize}

\sphinxAtStartPar
По больше части, на наших занятиях мы будем использовать \sphinxcode{\sphinxupquote{NumPy}} из\sphinxhyphen{}за простоты и привычности. Перед тем как разбираться с тем, как же именно происходит дифференцирование квантовой схемы, давайте посмотрим на весь цикл обучения.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Внимание, процесс обучения на обычном ноутбуке может занять около минуты! Это связано с трудностью симуляции квантового компьютера на классическом.
\end{sphinxadmonition}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{opt} \PYG{o}{=} \PYG{n}{qml}\PYG{o}{.}\PYG{n}{optimize}\PYG{o}{.}\PYG{n}{GradientDescentOptimizer}\PYG{p}{(}\PYG{n}{stepsize}\PYG{o}{=}\PYG{l+m+mf}{0.05}\PYG{p}{)}
\PYG{n}{acc\PYGZus{}} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{cost\PYGZus{}} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{ii} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{75}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{batch} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{randint}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{x\PYGZus{}batch} \PYG{o}{=} \PYG{n}{x}\PYG{p}{[}\PYG{n}{batch}\PYG{p}{,} \PYG{p}{:}\PYG{p}{]}
    \PYG{n}{y\PYGZus{}batch} \PYG{o}{=} \PYG{n}{y}\PYG{p}{[}\PYG{n}{batch}\PYG{p}{]}
    \PYG{n}{q} \PYG{o}{=} \PYG{n}{opt}\PYG{o}{.}\PYG{n}{step}\PYG{p}{(}\PYG{k}{lambda} \PYG{n}{q\PYGZus{}}\PYG{p}{:} \PYG{n}{cost}\PYG{p}{(}\PYG{n}{q\PYGZus{}}\PYG{p}{,} \PYG{n}{x\PYGZus{}batch}\PYG{p}{,} \PYG{n}{y\PYGZus{}batch}\PYG{p}{)}\PYG{p}{,} \PYG{n}{q}\PYG{p}{)}

    \PYG{k}{if} \PYG{n}{i} \PYG{o}{\PYGZpc{}} \PYG{l+m+mi}{5} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{:}
        \PYG{n}{ii}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}
        \PYG{n}{acc\PYGZus{}}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{acc}\PYG{p}{(}\PYG{n}{q}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}\PYG{p}{)}
        \PYG{n}{cost\PYGZus{}}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{cost}\PYG{p}{(}\PYG{n}{q}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
/home/runner/work/qmlcourse/qmlcourse/.venv/lib/python3.8/site\PYGZhy{}packages/pennylane/\PYGZus{}grad.py:95: UserWarning: Starting with PennyLane v0.21.0, when using Autograd, inputs have to explicitly specify requires\PYGZus{}grad=True (or the argnum argument must be passed) in order for trainable parameters to be identified.
  warnings.warn(
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
И посмотрим на получившиеся графики точности и функции потерь:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{f}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{,} \PYG{n}{sharex}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\PYG{n}{ax}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{ii}\PYG{p}{,} \PYG{n}{acc\PYGZus{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{.\PYGZhy{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Accuracy}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{ii}\PYG{p}{,} \PYG{n}{cost\PYGZus{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{.\PYGZhy{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Cost}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{gradients_21_0}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
А также на результаты классификации:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{cb} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{scatter}\PYG{p}{(}\PYG{n}{x}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{x}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{c}\PYG{o}{=}\PYG{n}{apply\PYGZus{}node}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{q}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{n}{cb}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{gradients_23_0}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{А как оно работает?}
\label{\detokenize{book/grads/ru/gradients:id14}}
\sphinxAtStartPar
Теперь, когда мы увидели процесс оптимизации квантовой схемы, давайте попробуем подумать, а как оно на самом деле работает?


\subsection{Метод конечных отрезков}
\label{\detokenize{book/grads/ru/gradients:id15}}
\sphinxAtStartPar
Для начала вспомним то, что является геометрическом (или визуальной) интерпретацией градиента функции. Правильно, градиент в каждой точке – это касательная. А приближенное значение угла наклона любой прямой можно найти, взяв конечные отрезки:
\begin{equation*}
\begin{split}
\frac{df}{dx} \simeq \frac{\Delta f}{\Delta x} = \frac{f(x + \Delta x) - f(x)}{\Delta x}
\end{split}
\end{equation*}
\sphinxAtStartPar
Давайте попробуем посчитать градиент нашей квантовой схемы. Для этого инициализируем ее заново случайными параметрами, а потом сравним это с тем значением, которое считает \sphinxcode{\sphinxupquote{Autograd}}.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{seed}\PYG{p}{(}\PYG{l+m+mi}{42}\PYG{p}{)}
\PYG{n}{q} \PYG{o}{=} \PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{uniform}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{p}{,} \PYG{n}{size}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{)}


\PYG{k}{def} \PYG{n+nf}{naive\PYGZus{}grad}\PYG{p}{(}\PYG{n}{cost}\PYG{p}{,} \PYG{n}{params}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{f0}\PYG{p}{,} \PYG{n}{delta}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{p}{(}\PYG{n}{cost}\PYG{p}{(}\PYG{n}{params}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{f0}\PYG{p}{)} \PYG{o}{/} \PYG{n}{delta}

\PYG{k}{def} \PYG{n+nf}{grad\PYGZus{}i}\PYG{p}{(}\PYG{n}{q}\PYG{p}{,} \PYG{n}{f0}\PYG{p}{,} \PYG{n}{cost}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{i}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{new\PYGZus{}params} \PYG{o}{=} \PYG{n}{q}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{copy}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{flatten}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{new\PYGZus{}params}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mf}{0.05}

    \PYG{k}{return} \PYG{n}{naive\PYGZus{}grad}\PYG{p}{(}\PYG{n}{cost}\PYG{p}{,} \PYG{p}{(}\PYG{n}{new\PYGZus{}params}\PYG{o}{.}\PYG{n}{reshape}\PYG{p}{(}\PYG{n}{q}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{)}\PYG{p}{,} \PYG{n}{q}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{f0}\PYG{p}{,} \PYG{l+m+mf}{0.05}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
В качестве эталона возьмем тот градиент, который нам считает \sphinxcode{\sphinxupquote{Autograd}}:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{grad} \PYG{o}{=} \PYG{n}{qml}\PYG{o}{.}\PYG{n}{grad}\PYG{p}{(}\PYG{n}{cost}\PYG{p}{,} \PYG{n}{argnum}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Сравним первые пять значений \sphinxcode{\sphinxupquote{Autograd}} с нашим наивным алгоритмом, взяв \(\Delta = 0.05\):

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Осторожно! Так как мы считаем градиенты очень наивно и на всех точках сразу, то следующий блок кода работает долго!
\end{sphinxadmonition}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{autograd} \PYG{o}{=} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{q}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}
\PYG{n}{f0} \PYG{o}{=} \PYG{n}{cost}\PYG{p}{(}\PYG{n}{q}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}
\PYG{n}{pretty\PYGZus{}print} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{g\PYGZus{}i} \PYG{o}{=} \PYG{n}{grad\PYGZus{}i}\PYG{p}{(}\PYG{n}{q}\PYG{p}{,} \PYG{n}{f0}\PYG{p}{,} \PYG{n}{cost}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{i}\PYG{p}{)}
    \PYG{n}{pretty\PYGZus{}print} \PYG{o}{+}\PYG{o}{=} \PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Naive grad: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{g\PYGZus{}i}\PYG{l+s+si}{:}\PYG{l+s+s2}{.3f}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s2}{Autograd result: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{autograd}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{flatten}\PYG{p}{(}\PYG{p}{)}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{l+s+si}{:}\PYG{l+s+s2}{.3f}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{pretty\PYGZus{}print}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Naive grad: \PYGZhy{}0.028	Autograd result: \PYGZhy{}0.029
Naive grad: 0.081	Autograd result: 0.081
Naive grad: 0.025	Autograd result: 0.025
Naive grad: 0.013	Autograd result: 0.008
Naive grad: \PYGZhy{}0.000	Autograd result: \PYGZhy{}0.011
Naive grad: 0.009	Autograd result: 0.004
Naive grad: 0.025	Autograd result: 0.025
Naive grad: 0.002	Autograd result: \PYGZhy{}0.003
Naive grad: \PYGZhy{}0.068	Autograd result: \PYGZhy{}0.069
Naive grad: 0.009	Autograd result: 0.004
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Можно заметить, что даже с таким большим значением \(\Delta\) наши оценки получились достаточно близкими к тем, которые получены в \sphinxcode{\sphinxupquote{Autograd}}. Хотя, конечно, для некоторых значений расхождения заметны и иногда они даже в знаке частной производной.


\subsection{Parameter\sphinxhyphen{}shift rule}
\label{\detokenize{book/grads/ru/gradients:parameter-shift-rule}}
\sphinxAtStartPar
Более точная оценка может быть получена методом, который называется \sphinxstylestrong{Parameter\sphinxhyphen{}shift}. Он основан на том, что для квантового “черного ящика” \(\hat{U}(\theta)\), которым является наша схема, частная производная по параметру \(\theta_i\) выражается так:
\begin{equation*}
\begin{split}
\nabla_{\theta_i}\langle \hat{U} \rangle (\mathbf{\theta}) = \frac{1}{2}[\langle \hat{U} \rangle (\mathbf{\theta} + \frac{\pi}{2}\mathbf{e_i}) - \langle \hat{U} \rangle (\mathbf{\theta} - \frac{\pi}{2}\mathbf{e_i})]
\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Более строгую формулировку, а также вывод правила parameter\sphinxhyphen{}shift можно посмотреть в продвиной лекции этого блока про производные высших порядков.
\end{sphinxadmonition}

\sphinxAtStartPar
Если по\sphinxhyphen{}простому, то оценка частной производной по \(i\)\sphinxhyphen{}му параметру может быть получена вычислением сначала ожидаемого значения схемы с параметром \(\theta_i\), смещенным на \(\frac{\pi}{2}\) в одну сторону, а потом – в другую. Давайте запишем это в коде, но перед этим давайте вспомним, как будет выглядеть производная функции потерь (а именно она нам нужна):
\begin{equation*}
\begin{split}
\frac{\partial L}{\partial \theta_i} = \frac{\partial (\langle \hat{U} \rangle (\theta) - y)^2}{\partial \theta_i} = 2 (\langle \hat{U} \rangle - y) \frac{\partial \langle \hat{U} \rangle}{\partial \theta_i}
\end{split}
\end{equation*}
\sphinxAtStartPar
Реализуем явно и наивно эту формулу в коде:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{parameter\PYGZus{}shift\PYGZus{}i}\PYG{p}{(}\PYG{n}{q}\PYG{p}{,} \PYG{n}{cost}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{i}\PYG{p}{,} \PYG{n}{y\PYGZus{}hat}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{new\PYGZus{}params} \PYG{o}{=} \PYG{n}{q}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{copy}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{flatten}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{new\PYGZus{}params}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi} \PYG{o}{/} \PYG{l+m+mi}{2}

    \PYG{n}{forward} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{apply\PYGZus{}node}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{p}{(}\PYG{n}{new\PYGZus{}params}\PYG{o}{.}\PYG{n}{reshape}\PYG{p}{(}\PYG{n}{q}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{)}\PYG{p}{,} \PYG{n}{q}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}

    \PYG{n}{new\PYGZus{}params} \PYG{o}{=} \PYG{n}{q}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{copy}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{flatten}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{new\PYGZus{}params}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi} \PYG{o}{/} \PYG{l+m+mi}{2}

    \PYG{n}{backward} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{apply\PYGZus{}node}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{p}{(}\PYG{n}{new\PYGZus{}params}\PYG{o}{.}\PYG{n}{reshape}\PYG{p}{(}\PYG{n}{q}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{)}\PYG{p}{,} \PYG{n}{q}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}

    \PYG{n}{diff} \PYG{o}{=} \PYG{p}{(}\PYG{n}{y\PYGZus{}hat} \PYG{o}{\PYGZhy{}} \PYG{n}{y}\PYG{p}{)}

    \PYG{k}{return} \PYG{n}{np}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{diff} \PYG{o}{*} \PYG{p}{(}\PYG{l+m+mf}{0.5} \PYG{o}{*} \PYG{p}{(}\PYG{n}{forward} \PYG{o}{\PYGZhy{}} \PYG{n}{backward}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
И также проверим на первых 10 точках:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{y\PYGZus{}hat} \PYG{o}{=} \PYG{n}{apply\PYGZus{}node}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{q}\PYG{p}{)}
\PYG{n}{pretty\PYGZus{}print} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{g\PYGZus{}i} \PYG{o}{=} \PYG{n}{parameter\PYGZus{}shift\PYGZus{}i}\PYG{p}{(}\PYG{n}{q}\PYG{p}{,} \PYG{n}{cost}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{i}\PYG{p}{,} \PYG{n}{y\PYGZus{}hat}\PYG{p}{)}
    \PYG{n}{pretty\PYGZus{}print} \PYG{o}{+}\PYG{o}{=} \PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Naive grad: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{g\PYGZus{}i}\PYG{l+s+si}{:}\PYG{l+s+s2}{.3f}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s2}{Autograd result: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{autograd}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{flatten}\PYG{p}{(}\PYG{p}{)}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{l+s+si}{:}\PYG{l+s+s2}{.3f}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{pretty\PYGZus{}print}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Naive grad: \PYGZhy{}0.029	Autograd result: \PYGZhy{}0.029
Naive grad: 0.081	Autograd result: 0.081
Naive grad: 0.025	Autograd result: 0.025
Naive grad: 0.008	Autograd result: 0.008
Naive grad: \PYGZhy{}0.011	Autograd result: \PYGZhy{}0.011
Naive grad: 0.004	Autograd result: 0.004
Naive grad: 0.025	Autograd result: 0.025
Naive grad: \PYGZhy{}0.003	Autograd result: \PYGZhy{}0.003
Naive grad: \PYGZhy{}0.069	Autograd result: \PYGZhy{}0.069
Naive grad: 0.004	Autograd result: 0.004
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Как видно, этот результат уже совпадает с тем, что делает “под капотом” \sphinxcode{\sphinxupquote{PennyLane}} и \sphinxcode{\sphinxupquote{Autograd}}. На самом деле, правило \sphinxstylestrong{parameter\sphinxhyphen{}shift} позволяет использовать много интересных хитростей и оптимизаций, но их не получится легко показать без погружения в математические детали метода.


\section{Что мы узнали?}
\label{\detokenize{book/grads/ru/gradients:id16}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Мы попробовали провести полный цикл оптимизации параметров \sphinxstylestrong{VQC}

\item {} 
\sphinxAtStartPar
Научились использовать автоматический расчет градиентов в \sphinxcode{\sphinxupquote{PennyLane}}

\item {} 
\sphinxAtStartPar
Познакомились с двумя способами оценки градиента:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Метод конечных отрезков

\item {} 
\sphinxAtStartPar
Parameter\sphinxhyphen{}shift rule

\end{itemize}

\end{itemize}

\sphinxstepscope


\chapter{Градиенты высших порядков}
\label{\detokenize{book/grads/ru/hogradients:hogradients}}\label{\detokenize{book/grads/ru/hogradients:id1}}\label{\detokenize{book/grads/ru/hogradients::doc}}
\sphinxAtStartPar
Автор(ы):
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/SemyonSinchenko}{Синченко Семен}

\end{itemize}


\section{План лекции}
\label{\detokenize{book/grads/ru/hogradients:id2}}
\sphinxAtStartPar
В этой лекции мы посмотрим на ту математику, которая лежит “под капотом” у \sphinxstyleemphasis{parameter\sphinxhyphen{}shift rule}. Мы познакомимся с обобщением \sphinxstyleemphasis{parameter shift}, а также увидим, как можно оптимизировать этот метод. В конце мы узнаем, как можно посчитать производную второго порядка за минимальное количество обращений к квантовому компьютеру.

\sphinxAtStartPar
Для более детального погружения в вопрос можно сразу рекомендовать статью {[}\hyperlink{cite.book/bibliography:id38}{MBK21}{]}.


\section{Важность гейтов вращений}
\label{\detokenize{book/grads/ru/hogradients:id4}}
\sphinxAtStartPar
Если задуматься, то одним из основных (если не единственных) способов сделать параметризованную квантовую схему является использование гейтов вращений, таких как \(\hat{RX}, \hat{RY}, \hat{RZ}\). Более формально это можно выразить так, что нас больше всего интересуют операторы вида:
\begin{equation*}
\begin{split}
U(\theta) = e^{-\frac{i}{2}H\theta}
\end{split}
\end{equation*}
\sphinxAtStartPar
где \(H\) – оператор “вращения”, который удовлетворяет условию \(H^2 = \mathbf{1}\). Другой возможный вариант записи – представить матрицу \(H\) как линейную комбинацию операторов Паули \(\sigma^x, \sigma^y, \sigma^z\).

\sphinxAtStartPar
Если представить схему, содержащую множество параметризованных операторов, то итоговая запись имеет вид:
\begin{equation*}
\begin{split}
U_{j...k} = U_j, ..., U_k \ket{\Psi}
\end{split}
\end{equation*}

\section{Производная от измерения}
\label{\detokenize{book/grads/ru/hogradients:id5}}
\sphinxAtStartPar
Давайте вспомним, как выглядит квантово\sphinxhyphen{}классическая схема обучения с \sphinxstylestrong{VQC}.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[height=400\sphinxpxdimen]{{diagram}.png}
\caption{Квантово\sphinxhyphen{}классическая схема}\label{\detokenize{book/grads/ru/hogradients:quantclassical}}\end{figure}

\sphinxAtStartPar
Видно, что мы хотим считать производную не от самой параметризованной схемы \(U_{j...k}\), а от наблюдаемой. Для тех, кто забыл, что такое \sphinxstyleemphasis{наблюдаемая}, рекомендуем вернуться к {\hyperref[\detokenize{book/qc/ru/qubit::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{лекции про кубит}}}}. Если кратко, то это тот оператор, который мы “измеряем” на нашем квантовом компьютере. Математически производная, которая нам интересна, может быть записана для выбранного параметра \(i\) таким образом:
\begin{equation*}
\begin{split}
G_i = \frac{\partial \bra{U_{j...k}\Psi}\hat{M}\ket{U_{j...k}\Psi}}{\partial \theta_i}
\end{split}
\end{equation*}
\sphinxAtStartPar
То есть нам важно посчитать производную от результата измерения, так как именно результат измерения у нас будет определять “предсказание” нашей квантовой нейронной сети. Причем нам нужно уметь считать производную от любого параметра \(\theta_i\) в цепочке \(\theta_j, ...\theta_i, ...\theta_k\).


\section{Parameter\sphinxhyphen{}shift для гейтов Паули}
\label{\detokenize{book/grads/ru/hogradients:parameter-shift}}
\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Тут мы для простоты предложим, что \(U_1\) это просто оператор вращения, иначе выкладки станут совсем сложными.
\end{sphinxadmonition}

\sphinxAtStartPar
Тогда сам оператор \(U_i\) может быть также записан так:
\begin{equation*}
\begin{split}
U_i = e^{-\frac{i}{2}P_i\theta_i}
\end{split}
\end{equation*}
\sphinxAtStartPar
Запишем результат математического ожидания через состояние \(\Psi_i\), которое пришло на вход \(i\)\sphinxhyphen{}го гейта в нашей последовательности:
\begin{equation*}
\begin{split}
\langle M(\theta) \rangle = Tr(M U_{k, ..., 1} \rho_i U_{k, ..., 1}^\dagger)
\end{split}
\end{equation*}
\sphinxAtStartPar
где \(\rho\) это матрица плотности (\(\ket{\Psi}\bra{\Psi}\)). Подробнее о матрицах плотности можно почитать в ранней продвинутой лекции про смешанные состояния.

\sphinxAtStartPar
Тогда частная производная от математического ожидания по \(i\)\sphinxhyphen{}му параметру \(\theta_i\) записывается (подробнее в {[}\hyperlink{cite.book/bibliography:id55}{MNKF18}{]}) через коммутатор исходного состояния \(\rho\), которое “пришло” на вход гейта \(U_i\) и того оператора Паули \(P_i\), который мы используем в \(U_i\):
\begin{equation*}
\begin{split}
\frac{\partial \langle M \rangle}{\partial \theta_i} = -\frac{i}{2}Tr(M U_{k, ..., i}[P_i, U_{i-1, ..., 1}\rho_i U_{i-1, ..., 1}^\dagger]U_{k, ..., i}^\dagger)
\end{split}
\end{equation*}
\sphinxAtStartPar
Этот коммутатор может быть переписан следующим образом:
\begin{equation*}
\begin{split}
[P_i, \rho] = i[U_i \Bigl( \frac{\pi}{2} \Bigr ) \rho_i U_i^\dagger \Bigl ( \frac{\pi}{2} \Bigr ) - U_i \Bigl( -\frac{\pi}{2} \Bigr ) \rho_i U_i^\dagger \Bigl ( -\frac{\pi}{2} \Bigr )]
\end{split}
\end{equation*}
\sphinxAtStartPar
Тогда соответствующий градиент \(\frac{\partial}{\partial \theta_i}\) можно записать через смещения на \(\pm\frac{\pi}{2}\):
\begin{equation*}
\begin{split}
\begin{gathered}
\frac{\partial \langle M \rangle}{\partial \theta_i} = \frac{\langle M_i^+ \rangle - \langle M_i^- \rangle}{2} \\
\langle M_i^{\pm} \rangle = \frac{1}{2} Tr [M U_{k, ..., i+1} U_i(\pm \frac{\pi}{2})\rho_i^` U_i^\dagger (\pm \frac{\pi}{2}) U_{k, ..., i+1}^\dagger] \\
\rho_i^` = U_{j, ..., 1} \rho_i U_{j, ..., 1}^\dagger
\end{gathered}
\end{split}
\end{equation*}
\sphinxAtStartPar
По аналогии с классическими нейронными сетями и \sphinxstyleemphasis{backpropagation} (для тех, кто забыл это понятие, рекомендуем вернуться к вводным лекциями про классическое машинное обучение) тут явно можно выделить \sphinxstyleemphasis{forward} проход со смещением \(\theta_i\) на значения \(\frac{\pi}{2}\) и \sphinxstyleemphasis{backward} со смещением на \(-\frac{\pi}{2}\).


\section{Обобщенный parameter\sphinxhyphen{}shift}
\label{\detokenize{book/grads/ru/hogradients:id7}}
\sphinxAtStartPar
Предложенное в {[}\hyperlink{cite.book/bibliography:id55}{MNKF18}{]} выражение может быть на самом деле получено в более общем виде из других соображений. Так, выражение для нашей наблюдаемой \(\langle M \rangle\) может всегда быть представлено {[}\hyperlink{cite.book/bibliography:id38}{MBK21}{]} как сумма вида:
\begin{equation*}
\begin{split}
\bra{U_i(\theta_i)}\hat{M}\ket{U_i(\theta_i)} = \hat{A} + \hat{B}\cos{\theta_i} + \hat{C}\sin{\theta_i}
\end{split}
\end{equation*}
\sphinxAtStartPar
где \(\hat{A}, \hat{B}, \hat{C}\) – операторы, не зависящие от параметра \(\theta_i\).

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Действительно, явно выписав выражение для наблюдаемой и вспомнив формулы для косинуса и синуса двойного угла, а также воспользовавшись тем, что \(U(\theta) = e^{-\frac{1}{2}H\theta} = \cos{\frac{\theta}{2}}\mathbf{1} - i\sin{\frac{\theta}{2}}H\), получаем:
\begin{equation*}
\begin{split}
\begin{gathered}
(\cos{\frac{\theta}{2}}\mathbf{1} + i\sin{\frac{\theta}{2}}H)\hat{M}(\cos{\frac{\theta}{2}}\mathbf{1} - i\sin{\frac{\theta}{2}}H) = \\
\cos^2{\frac{\theta}{2}}\hat{M} + i \sin{\frac{\theta}{2}}\cos{\frac{\theta}{2}}H\hat{M} - i \sin {\frac{\theta}{2}}\cos{\frac{\theta}{2}}\hat{M}H + \sin^2{\frac{\theta}{2}}H\hat{M}H = \\
\frac{1}{2} \cos{\theta}\hat{M}+\frac{1}{2}\hat{M}+\frac{i}{2} \sin{\theta}H\hat{M} - \frac{i}{2}\sin{\theta}\hat{M}H + \frac{1}{2}H\hat{M}H - \frac{1}{2}\cos{\theta}H\hat{M}H = \\
\frac{1}{2}(\hat{M} + H\hat{M}H) + \frac{1}{2}(\hat{M} - H\hat{M}H)\cos{\theta} + \frac{i}{2}(H\hat{M} - \hat{M}H)\sin{\theta}
\end{gathered}
\end{split}
\end{equation*}\end{sphinxadmonition}

\sphinxAtStartPar
Тогда можно воспользоваться правилами тригонометрии, а именно, тем что для любого \(s \neq k\pi, \text{   } k \in {1, 2, ..., }\) справедливо:
\begin{equation*}
\begin{split}
\begin{gathered}
\frac{d \cos {\theta}}{d \theta} = \frac{\cos (\theta + s) - \cos (\theta - s)}{2\sin{s}} \\
\frac{d \sin {\theta}}{d \theta} = \frac{\sin (\theta + s) - \sin (\theta - s)}{2\sin{s}} \\
\end{gathered}
\end{split}
\end{equation*}
\sphinxAtStartPar
И подставим это в выражение для \(\frac{\partial \langle M \rangle}{\partial \theta_i}\):
\begin{equation*}
\begin{split}
\frac{\partial \langle M(\theta_i) \rangle}{\partial \theta_i} = \frac{\langle M(\theta_i + s) \rangle - \langle M(\theta_i - s) \rangle}{2\sin{s}}
\end{split}
\end{equation*}
\sphinxAtStartPar
Легко заметить, что подстановка сюда \(s = \frac{\pi}{2}\) дает нам классический \sphinxstyleemphasis{parameter shift}, описанный в {[}\hyperlink{cite.book/bibliography:id55}{MNKF18}{]}.

\sphinxAtStartPar
Наконец, запишем полученное выражение в более удобном виде, который позволит нам более эффективно выписывать производные высших порядков. Для этого введем вектор \(\mathbf{e_i}\) – единичный вектор для \(i\)\sphinxhyphen{}го параметра, то есть вектор, где все компоненты кроме \(i\)\sphinxhyphen{}й равны нулю, а \(i\)\sphinxhyphen{}я равна 1. Тогда наше финальное выражение для обобщенного \sphinxstyleemphasis{parameter shift} примет следующий вид:
\begin{equation*}
\begin{split}
\boxed{\frac{\partial f(\mathbf{\theta})}{\partial \theta_i} = \frac{f(\mathbf{\theta} + s\mathbf{e_i}) - f(\mathbf{\theta} - s\mathbf{e_i})}{2\sin{s}}}
\end{split}
\end{equation*}

\section{Вторая производная и гессиан}
\label{\detokenize{book/grads/ru/hogradients:id11}}
\sphinxAtStartPar
В классической теории оптимизации, также как и в машинном обучении, очень часто на первый план выходят так называемые методы 2\sphinxhyphen{}го порядка. Эти методы похожи на обычный градиентный спуск, но для ускорения сходимости они также используют информацию из матрицы вторых производных, которая называется гессианом. Более подробно про методы 2\sphinxhyphen{}го порядка и гессиан можно посмотреть в вводных лекциях курса.

\sphinxAtStartPar
Методы второго порядка требуют больше вызовов, чтобы вычислить гессиан, но взамен они обеспечивают гораздо лучшую сходимость, а также менее склонны “застревать” в локальных минимумах. Это обеспечивает, в итоге, более быстрое обучение. В классических нейронных сетях вычисление гессиана это часто проблема, так как это матрица размерности \(\sim O(N^2)\), где \(N\) – число весов нейронной сети, и эта матрица получается слишком большой. Но, как мы помним, основная “фича” \sphinxstylestrong{VQC} это их экспоненциальная экспрессивность – возможность линейным числом параметров (и гейтов) обеспечить преобразование, эквивалентное экспоненциальному числу весов классической нейронной сети. А значит, для них проблема размерности гессиана не стоит так остро. При этом использование гессиана теоретически позволит в итоге обучить \sphinxstylestrong{VQC} за меньшее число вызовов. Именно поэтому методы второго порядка потенциально очень интересны в квантово\sphinxhyphen{}классическом обучении. Но для начала нам необходимо разобраться, как именно можно посчитать матрицу вторых производных.

\sphinxAtStartPar
Пользуясь обобщенным правилом \sphinxstyleemphasis{parameter shift}, можно выписать выражение для второй производной {[}\hyperlink{cite.book/bibliography:id38}{MBK21}{]}:
\begin{equation*}
\begin{split}
\frac{\partial_2 f}{\partial \theta_i \theta_j} = \frac{f(\mathbf{\theta} + s_1\mathbf{e_i} + s_2\mathbf{e_j}) + f(\mathbf{\theta} - s_1\mathbf{e_i} - s_2 \mathbf{e_j}) - f(\mathbf{\theta} + s_1 \mathbf{e_i} - s_2 \mathbf{e_j}) - f(\mathbf{\theta} - s_1 \mathbf{e_i} + s_2 \mathbf{e_j})}{4\sin{s_1}\sin{s_2}}
\end{split}
\end{equation*}
\sphinxAtStartPar
Взяв \(s_1 = s_2\), можно упростить это выражение к следующему виду:
\begin{equation*}
\begin{split}
\begin{gathered}
\frac{f(\mathbf{\theta} + s\mathbf{a}) + f(\mathbf{\theta} + s\mathbf{b}) - f(\mathbf{\theta} + s\mathbf{c}) - f(\mathbf{\theta} + s\mathbf{d})}{(2\sin{s}) ^2} \\
\mathbf{a} = \mathbf{e_i} + \mathbf{e_j} \\
\mathbf{b} = -\mathbf{e_i} - \mathbf{e_j} \\
\mathbf{c} = \mathbf{e_i} - \mathbf{e_j} \\
\mathbf{d} = -\mathbf{e_i} + \mathbf{e_j}
\end{gathered}
\end{split}
\end{equation*}
\sphinxAtStartPar
Но чаще всего нам необходимо не просто посчитать гессиан, а еще и посчитать градиент, так как в большинстве методов 2\sphinxhyphen{}го порядка требуются оба эти значения. В этом случае хочется попробовать подобрать такое значение для \(s_g\) при вычислении вектора градиента, а также такое значение \(s_h\) при вычислении гессиана, чтобы максимально переиспользовать результаты квантовых вызовов и уменьшить их общее количество.

\sphinxAtStartPar
Внимательно взглянув на выражение для 2\sphinxhyphen{}х производных, можно заметить, что оптимизация там возможна при расчете диагональных элементов гессиана. Давайте выпишем выражение для диагонального элемента явно:
\begin{equation*}
\begin{split}
\frac{f(\mathbf{\theta} + 2s\mathbf{e_i}) + f(\mathbf{\theta} - 2s\mathbf{e_i}) - 2 f(\mathbf{\theta})}{(2\sin{s})^2}
\end{split}
\end{equation*}
\sphinxAtStartPar
Можно заметить, что, например, использование \(s = \frac{\pi}{4}\) для гессиана, а также “стандартного” \(s=\frac{\pi}{2}\) для градиента позволит полностью переиспользовать в диагональных элементах гессиана значения, которые мы получили при расчете градиента. А значение \(f(\mathbf{\theta})\) вообще считается один раз для всех диагональных вызовов.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
На самом деле, диагональные элементы гессиана можно использовать и сами по себе, например для квазиньютоновских методов оптимизации, где матрица Гессе аппроксимируется какой\sphinxhyphen{}то другой матрицей, чтобы не считать все вторые производные. Например, она может быть аппроксимирована диагональной матрицой, как в работе {[}\hyperlink{cite.book/bibliography:id28}{And19}{]}.
\end{sphinxadmonition}


\section{Заключение}
\label{\detokenize{book/grads/ru/hogradients:id14}}
\sphinxAtStartPar
В этой лекции мы познакомились с классическим \sphinxstyleemphasis{parameter shift rule}, а также его обобщением. Также мы узнали, как можно посчитать гессиан \sphinxstylestrong{VQC}, и даже узнали маленькие хитрости, которые можно применять для уменьшения общего количества вызовов квантовой схемы.

\sphinxstepscope


\part{Квантовый SVM}

\sphinxstepscope


\chapter{О блоке “Квантовый SVM”}
\label{\detokenize{book/qsvm/ru/qsvm_intro:svm}}\label{\detokenize{book/qsvm/ru/qsvm_intro:qsvm-intro}}\label{\detokenize{book/qsvm/ru/qsvm_intro::doc}}
\sphinxAtStartPar
Этот блок включает в себя только квантово\sphinxhyphen{}классический SVM.

\sphinxAtStartPar
Продвинутая тема блока дополнительно рассказывает о классическом SVM.

\sphinxstepscope


\chapter{Квантово\sphinxhyphen{}классический SVM}
\label{\detokenize{book/qsvm/ru/hybridsvm:svm}}\label{\detokenize{book/qsvm/ru/hybridsvm:hybridsvm}}\label{\detokenize{book/qsvm/ru/hybridsvm::doc}}
\sphinxAtStartPar
Автор(ы):
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/SemyonSinchenko}{Синченко Семен}

\end{itemize}


\section{Описание лекции}
\label{\detokenize{book/qsvm/ru/hybridsvm:id1}}
\sphinxAtStartPar
Лекция будет построена следующим образом:
\begin{itemize}
\item {} 
\sphinxAtStartPar
посмотрим, как можно использовать \sphinxstylestrong{VQC} как ядро SVM;

\item {} 
\sphinxAtStartPar
напишем и применим код обучения смешанного SVM.

\end{itemize}

\sphinxAtStartPar
Перед тем как приступить, рекомендуется освежить {\hyperref[\detokenize{book/qsvm/ru/classic_svm::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{материал}}}} по классическому методу опорных векторов, в частности, нужно понимать, как работает ядерный трюк.


\section{VQC как ядерная функция}
\label{\detokenize{book/qsvm/ru/hybridsvm:vqc}}
\sphinxAtStartPar
Как мы много говорили в более ранних лекциях, квантовые схемы позволяют нам оперировать в гильбертовых пространствах волновых функций. Эти пространства имеют экспоненциально большую размерность, при этом они параметризуются линейным количеством параметров. А еще в этих пространствах определены скалярные произведения волновых функций, более того, именно результат выборки из скалярного произведения мы чаще всего и получаем как результат измерений!

\sphinxAtStartPar
Давайте попробуем посмотреть, что общего у \sphinxstylestrong{VQC} и ядер.
\begin{itemize}
\item {} 
\sphinxAtStartPar
оба оперируют в пространстве большой (или бесконечной размерности);

\item {} 
\sphinxAtStartPar
и там, и там работа идет в гильбертовом пространстве и определено скалярное произведение;

\item {} 
\sphinxAtStartPar
и там, и там результат вычисляется как скалярное произведение.

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Это интересно, что многие специалисты в области \sphinxstylestrong{QML} сегодня даже предлагают вместо термина “квантовая нейросеть” использовать термин “квантовое ядро”, так как математически \sphinxstylestrong{VQC} гораздо ближе именно к ядрам, чем к слоям современных глубоких сетей.
\end{sphinxadmonition}

\sphinxAtStartPar
Очевидная идея – попробовать как\sphinxhyphen{}то воспользоваться квантовой схемой, чтобы реализовать скалярное произведение двух классических векторов. Именно это и сделали авторы работы {[}\hyperlink{cite.book/bibliography:id58}{HavlivcekCorcolesT+19}{]}.


\subsection{Преобразование состояния}
\label{\detokenize{book/qsvm/ru/hybridsvm:id3}}
\sphinxAtStartPar
На самом деле, если просто использовать какие\sphinxhyphen{}то простые квантовые операции, мы не получим какого\sphinxhyphen{}то преимущества над классическим ядерным SVM – ведь все то же самое можно будет сделать и на классическом компьютере.

\sphinxAtStartPar
Чтобы получить реальное преимущество, нам необходимо использовать запутывание и прочие “фишки” квантовых вычислений.

\sphinxAtStartPar
Дальше мы не станем изобретать велосипеды, а вместо этого воспользуемся примерами хороших преобразований из работы {[}\hyperlink{cite.book/bibliography:id59}{SYG+20}{]}. Рассмотрим, что именно там описано.


\subsubsection{Общая схема}
\label{\detokenize{book/qsvm/ru/hybridsvm:id5}}
\sphinxAtStartPar
Для простоты формул мы не будем выписывать обобщенные формулы, а все будем писать для нашего двумерного пространства. Тогда наша схема может быть разделена на несколько частей:
\begin{itemize}
\item {} 
\sphinxAtStartPar
гейты Адамара и гейты \(CNOT\);

\item {} 
\sphinxAtStartPar
операции, основанные на элементах входного вектора;

\item {} 
\sphinxAtStartPar
попарные операции над парами элементов вектора.

\end{itemize}

\sphinxAtStartPar
Мы начинаем с того, что переводим кубиты в состояние суперпозиции, применяя операторы Адамара. Далее мы применяем однокубитные параметризованные операции и снова гейты Адамара. После этого мы применяем связку \(CNOT \to\) параметризованная парой операция \(\to CNOT\).


\subsubsection{Выбор операции}
\label{\detokenize{book/qsvm/ru/hybridsvm:id6}}
\sphinxAtStartPar
Следуя идее упомянутой статьи, в качестве что одно\sphinxhyphen{}элементной, что двух\sphinxhyphen{}элементной операции мы будем использовать гейт \(U_1\). Разница будет лишь в том, что мы передаем на вход в качестве параметра.


\subsubsection{Feature function}
\label{\detokenize{book/qsvm/ru/hybridsvm:feature-function}}
\sphinxAtStartPar
В качестве параметров на входе гейта \(U_1\), как мы уже говорили, выступают один или два элемента вектора \(x\). Строго это можно записать как функцию такого вида:
\begin{equation*}
\begin{split}
\phi(x_1, x_2) = \begin{cases}
\phi(x),\text{    }x_1 = x_2 \\
\phi(x_1, x_2),\text{    }x_1 \neq x_2
\end{cases}
\end{split}
\end{equation*}
\sphinxAtStartPar
Мы будем называть ее \sphinxstyleemphasis{feature function}. В некотором смысле можно сказать, что именно эта функция определяет тип ядра по аналогии с классическим SVM. В работе {[}\hyperlink{cite.book/bibliography:id59}{SYG+20}{]} описано много разных вариантов таких \sphinxstyleemphasis{feature function}, мы будем использовать следующую:
\begin{equation*}
\begin{split}
\begin{gathered}
\phi(x) = x \\
\phi(x_1, x_2) = \pi \cos{x_1} \cos{x_2}
\end{gathered}
\end{split}
\end{equation*}

\subsubsection{Скалярное произведение}
\label{\detokenize{book/qsvm/ru/hybridsvm:id8}}
\sphinxAtStartPar
Все что мы описали выше, обозначим как квантовую схему \(U(x)\). Она преобразует нам вектор классических данных \(x\) в квантовое состояние \(\ket{\Psi}\). Но нам то нужно получить скалярное произведение \(\braket{U(x_1)|U(x_2)}\)! Выглядит сложно, но на самом деле существует эффективный способ получить эту величину без необходимости восстанавливать весь вектор состояния. Можно показать, что величина \(\braket{U(x_1)|U(x_2)}\) равна вероятности нулевой битовой строки (\(\ket{0, 0, ...., 0}\)) при измерении другой схемы: \(U(x_1)U(x_2)^\dagger\).

\sphinxAtStartPar
Все это может казаться сложным и запутанным, но должно стать гораздо понятнее, когда мы посмотрим на пример реализации от начала и до конца.


\section{Пример реализации}
\label{\detokenize{book/qsvm/ru/hybridsvm:id9}}

\subsection{Схема}
\label{\detokenize{book/qsvm/ru/hybridsvm:id10}}
\sphinxAtStartPar
Для начала необходимые импорты.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{pennylane} \PYG{k}{as} \PYG{n+nn}{qml}
\PYG{k+kn}{from} \PYG{n+nn}{pennylane} \PYG{k+kn}{import} \PYG{n}{numpy} \PYG{k}{as} \PYG{n}{np}
\PYG{k+kn}{from} \PYG{n+nn}{sklearn}\PYG{n+nn}{.}\PYG{n+nn}{datasets} \PYG{k+kn}{import} \PYG{n}{make\PYGZus{}moons}

\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{o}{\PYGZpc{}}\PYG{k}{config} InlineBackend.figure\PYGZus{}format = \PYGZsq{}retina\PYGZsq{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Помимо всех привычных, нам еще потребуется классический SVM из \sphinxcode{\sphinxupquote{scikit\sphinxhyphen{}learn}}:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{sklearn}\PYG{n+nn}{.}\PYG{n+nn}{svm} \PYG{k+kn}{import} \PYG{n}{SVC}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Мы будем работать с уже привычным нам набором “Tow Moons”. Только в этом случае мы будем использовать чуть\sphinxhyphen{}чуть другую нормализацию – для нашего ядра элементы вектора \(x\) должны быть в интервале \([-1, 1]\). Сразу переведем наши данные в этот диапазон:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{normalize}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Переводит значения в интервал от \PYGZhy{}1 до 1\PYGZdq{}\PYGZdq{}\PYGZdq{}}

    \PYG{k}{return} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{p}{(}\PYG{n}{x} \PYG{o}{\PYGZhy{}} \PYG{n}{x}\PYG{o}{.}\PYG{n}{min}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)} \PYG{o}{/} \PYG{p}{(}\PYG{n}{x}\PYG{o}{.}\PYG{n}{max}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{x}\PYG{o}{.}\PYG{n}{min}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{x\PYGZus{}samples}\PYG{p}{,} \PYG{n}{y\PYGZus{}samples} \PYG{o}{=} \PYG{n}{make\PYGZus{}moons}\PYG{p}{(}\PYG{n}{n\PYGZus{}samples}\PYG{o}{=}\PYG{l+m+mi}{50}\PYG{p}{)}
\PYG{n}{y\PYGZus{}samples} \PYG{o}{=} \PYG{n}{y\PYGZus{}samples} \PYG{o}{*} \PYG{l+m+mi}{2} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}

\PYG{n}{x\PYGZus{}samples}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{n}{normalize}\PYG{p}{(}\PYG{n}{x\PYGZus{}samples}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{x\PYGZus{}samples}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n}{normalize}\PYG{p}{(}\PYG{n}{x\PYGZus{}samples}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{cb} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{scatter}\PYG{p}{(}\PYG{n}{x\PYGZus{}samples}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{x\PYGZus{}samples}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{c}\PYG{o}{=}\PYG{n}{y\PYGZus{}samples}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{n}{cb}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{hybridsvm_6_0}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
И привычное нам объявление устройства.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{dev} \PYG{o}{=} \PYG{n}{qml}\PYG{o}{.}\PYG{n}{device}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{default.qubit}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Теперь давайте для начала реализуем наше преобразование над одним из векторов (\(U(x)\)).

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{var\PYGZus{}layer}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{qml}\PYG{o}{.}\PYG{n}{Hadamard}\PYG{p}{(}\PYG{n}{wires}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{n}{qml}\PYG{o}{.}\PYG{n}{Hadamard}\PYG{p}{(}\PYG{n}{wires}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}

    \PYG{n}{qml}\PYG{o}{.}\PYG{n}{U1}\PYG{p}{(}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{wires}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{n}{qml}\PYG{o}{.}\PYG{n}{U1}\PYG{p}{(}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{wires}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}

    \PYG{n}{qml}\PYG{o}{.}\PYG{n}{Hadamard}\PYG{p}{(}\PYG{n}{wires}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{n}{qml}\PYG{o}{.}\PYG{n}{Hadamard}\PYG{p}{(}\PYG{n}{wires}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}

    \PYG{n}{qml}\PYG{o}{.}\PYG{n}{CNOT}\PYG{p}{(}\PYG{n}{wires}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{qml}\PYG{o}{.}\PYG{n}{U1}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,} \PYG{n}{wires}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{n}{qml}\PYG{o}{.}\PYG{n}{CNOT}\PYG{p}{(}\PYG{n}{wires}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
А теперь реализуем
\begin{equation*}
\begin{split}
\braket{U(x_1)|U(x_2)} = \bra{U(x_1)U(x_2)^\dagger \Psi} M_0 \ket{U(x_1)U(x_2)^\dagger \Psi},
\end{split}
\end{equation*}
\sphinxAtStartPar
где \(M_0\) – проектор на один из собственных векторов системы кубитов, а именно на “нулевой”:
\begin{equation*}
\begin{split}
M_0 = \ket{0, ..., 0}\bra{0, ..., 0}.
\end{split}
\end{equation*}
\sphinxAtStartPar
Проще говоря, мы реализуем схему, которая нам дает вероятности каждой из битовых строк (а дальше мы просто возьмем первую, она и отвечает строке \(0,...0\)):

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nd}{@qml}\PYG{o}{.}\PYG{n}{qnode}\PYG{p}{(}\PYG{n}{dev}\PYG{p}{)}
\PYG{k}{def} \PYG{n+nf}{dot\PYGZus{}prod}\PYG{p}{(}\PYG{n}{x1}\PYG{p}{,} \PYG{n}{x2}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{var\PYGZus{}layer}\PYG{p}{(}\PYG{n}{x1}\PYG{p}{)}
    \PYG{n}{qml}\PYG{o}{.}\PYG{n}{adjoint}\PYG{p}{(}\PYG{n}{var\PYGZus{}layer}\PYG{p}{)}\PYG{p}{(}\PYG{n}{x2}\PYG{p}{)}

    \PYG{k}{return} \PYG{n}{qml}\PYG{o}{.}\PYG{n}{probs}\PYG{p}{(}\PYG{n}{wires}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Ну и сразу вспомогательную функцию, которая нам считает то, что нам было нужно:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{q\PYGZus{}dot\PYGZus{}prod}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{i}\PYG{p}{,} \PYG{n}{j}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{x1} \PYG{o}{=} \PYG{p}{(}\PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{x}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{x2} \PYG{o}{=} \PYG{p}{(}\PYG{n}{x}\PYG{p}{[}\PYG{n}{j}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{x}\PYG{p}{[}\PYG{n}{j}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}

    \PYG{k}{return} \PYG{n}{dot\PYGZus{}prod}\PYG{p}{(}\PYG{n}{x1}\PYG{p}{,} \PYG{n}{x2}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Для самопроверки убедимся в том, что наше “скалярное произведение” симметрично:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{allclose}\PYG{p}{(}\PYG{n}{q\PYGZus{}dot\PYGZus{}prod}\PYG{p}{(}\PYG{n}{x\PYGZus{}samples}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{q\PYGZus{}dot\PYGZus{}prod}\PYG{p}{(}\PYG{n}{x\PYGZus{}samples}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
True
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
И сразу посмотрим на то, как выглядит наша схема:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{qml}\PYG{o}{.}\PYG{n}{draw}\PYG{p}{(}\PYG{n}{dot\PYGZus{}prod}\PYG{p}{)}\PYG{p}{(}\PYG{n}{x\PYGZus{}samples}\PYG{p}{,} \PYG{n}{y\PYGZus{}samples}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
 0: ──H──U1(M0)──H──╭C──────────╭C──╭C──────────────╭C──H──U1(\PYGZhy{}1)──H──╭┤ Probs 
 1: ──H──U1(M1)──H──╰X──U1(M2)──╰X──╰X──U1(\PYGZhy{}0.917)──╰X──H──U1(1)───H──╰┤ Probs 
M0 =
[ 0.50587936 \PYGZhy{}0.95456777]
M1 =
[\PYGZhy{}0.1607873   0.95456777]
M2 =
[2.71265777 1.04941617]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Гибридный SVM}
\label{\detokenize{book/qsvm/ru/hybridsvm:id11}}
\sphinxAtStartPar
Мы не будем сами с нуля писать решение задачи квадратичного программирования, просто воспользуемся готовой рутиной из \sphinxcode{\sphinxupquote{scikit\sphinxhyphen{}learn}}. Используемая там реализация позволяет вместо ядерной функции передать сразу матрицу Грама (\sphinxhref{https://en.wikipedia.org/wiki/Gram\_matrix}{Gram matrix}). На самом деле это просто матрица всех попарных скалярных произведений наших векторов. Вычислим ее, сразу воспользовавшись тем, что
\begin{equation*}
\begin{split}
\braket{U(x)|U(x)} = 1 \quad \text{и} \quad \braket{U(x_1)|U(x_2)} = \braket{U(x_2)|U(x_1)}
\end{split}
\end{equation*}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{gram\PYGZus{}mat} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{n}{x\PYGZus{}samples}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{x\PYGZus{}samples}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{x\PYGZus{}samples}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{x\PYGZus{}samples}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{if} \PYG{n}{i} \PYG{o}{==} \PYG{n}{j}\PYG{p}{:}
            \PYG{n}{gram\PYGZus{}mat}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{1}
        \PYG{k}{if} \PYG{n}{i} \PYG{o}{\PYGZgt{}} \PYG{n}{j}\PYG{p}{:}
            \PYG{n}{r} \PYG{o}{=} \PYG{n}{q\PYGZus{}dot\PYGZus{}prod}\PYG{p}{(}\PYG{n}{x\PYGZus{}samples}\PYG{p}{,} \PYG{n}{i}\PYG{p}{,} \PYG{n}{j}\PYG{p}{)}
            \PYG{n}{gram\PYGZus{}mat}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{n}{r}
            \PYG{n}{gram\PYGZus{}mat}\PYG{p}{[}\PYG{n}{j}\PYG{p}{,} \PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{r}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Обучим нашу модель:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{model} \PYG{o}{=} \PYG{n}{SVC}\PYG{p}{(}\PYG{n}{kernel}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{precomputed}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{model}\PYG{o}{.}\PYG{n}{fit}\PYG{p}{(}\PYG{n}{gram\PYGZus{}mat}\PYG{p}{,} \PYG{n}{y\PYGZus{}samples}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
SVC(kernel=\PYGZsq{}precomputed\PYGZsq{})
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Посчитаем предсказания и посмотрим на результат:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{preds} \PYG{o}{=} \PYG{n}{model}\PYG{o}{.}\PYG{n}{predict}\PYG{p}{(}\PYG{n}{X}\PYG{o}{=}\PYG{n}{gram\PYGZus{}mat}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{cb} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{scatter}\PYG{p}{(}\PYG{n}{x\PYGZus{}samples}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{x\PYGZus{}samples}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{c}\PYG{o}{=}\PYG{n}{preds}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{n}{cb}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{hybridsvm_24_0}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Результат выглядит неплохо!


\section{Заключение}
\label{\detokenize{book/qsvm/ru/hybridsvm:id12}}
\sphinxAtStartPar
Расчет полной матрицы скалярных произведений дает нам сложность \(O(N^2)\) вызовов. Но основной потенциал гибридного SVM в том, что задачу квадратичной оптимизации на самом деле можно тоже решать на квантовом компьютере, используя алгоритм Гровера (про него рассказано в ранних лекциях), причем за сложность всего \(O(N)\) и без расчета полной матрицы Грама!

\sphinxAtStartPar
Многие считают, что NISQ квантовые компьютеры могут стать для SVM чем\sphinxhyphen{}то типа видеокарт для нейронных сетей и вернуть этот алгоритм на пьедестал лучших алгоритмов машинного обучения!

\sphinxstepscope


\chapter{Классический SVM}
\label{\detokenize{book/qsvm/ru/classic_svm:svm}}\label{\detokenize{book/qsvm/ru/classic_svm:classicsvm}}\label{\detokenize{book/qsvm/ru/classic_svm::doc}}
\sphinxAtStartPar
Автор(ы):
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/yorko}{Кашницкий Юрий}

\end{itemize}


\section{Описание лекции}
\label{\detokenize{book/qsvm/ru/classic_svm:id1}}
\sphinxAtStartPar
В этой лекции мы рассмотрим классический метод опорных векторов (SVM) и разберем стоящую за ним математику. С согласия Евгения Соколова, мы во многом переиспользуем конспекты лекций \sphinxhref{https://github.com/esokolov/ml-course-hse}{курса} “Машинное обучение”, читаемого на ФКН ВШЭ.

\sphinxAtStartPar
План лекции такой:
\begin{itemize}
\item {} 
\sphinxAtStartPar
линейная классификация;

\item {} 
\sphinxAtStartPar
интуиция метода опорных векторов;

\item {} 
\sphinxAtStartPar
метод опорных векторов для линейно\sphinxhyphen{}разделимой выборки;

\item {} 
\sphinxAtStartPar
метод опорных векторов для линейно\sphinxhyphen{}неразделимой выборки;

\item {} 
\sphinxAtStartPar
решение задачи метода опорных векторов;

\item {} 
\sphinxAtStartPar
ядерный переход;

\item {} 
\sphinxAtStartPar
плюсы и минусы SVM.

\end{itemize}


\section{Линейная классификация}
\label{\detokenize{book/qsvm/ru/classic_svm:id2}}
\sphinxAtStartPar
Основная идея линейного классификатора заключается в том, что признаковое пространство может быть разделено гиперплоскостью на два полупространства, в каждом из которых прогнозируется одно из двух значений целевого класса. Если это можно сделать без ошибок, то обучающая выборка называется \sphinxstyleemphasis{линейно разделимой}.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=350\sphinxpxdimen]{{lin_classifier}.png}
\caption{Линейная классификация}\label{\detokenize{book/qsvm/ru/classic_svm:lin-classifier}}\end{figure}

\sphinxAtStartPar
Рассмотрим задачу бинарной классификации, в которой \(\mathbb{X} = \mathbb{R}^d\) – пространство объектов,
\(Y = \{-1, +1\}\) – множество допустимых ответов (целевой признак),
\(X = \{(x_i, y_i)\}_{i = 1}^\ell\) – обучающая выборка. Будем класс \(+1\) называть положительным, а класс \(-1\) – отрицательным. Здесь \(d\) – размерность признакового пространства, \(\ell\) – количество примеров в обучающей выборке.

\sphinxAtStartPar
\sphinxstylestrong{Линейная модель классификации} определяется следующим образом:
\begin{equation*}
\begin{split}
    a(x) =
    \text{sign} \left(
        \langle w, x \rangle + b
    \right)
    =
    \text{sign} \left(
        \sum_{j = 1}^{d} w_j x_j + b
    \right),
\end{split}
\end{equation*}
\sphinxAtStartPar
где \(w \in \mathbb{R}^d\) – вектор весов, \(b \in \mathbb{R}\) – сдвиг (bias), \(\text{sign}(\cdot)\) – функция “сигнум”, возвращающая знак своего аргумента, \(a(x)\) – ответ классификатора на примере \(x\).

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Хорошо бы для векторов ставить стрелку и писать \(\vec{w}\), но мы этого не будем делать, предполагая, что из контекста ясно, что вектор, а что скаляр. В частности, в формуле выше \(w\) и \(x\) – вектора, а \(a(x), w_j, x_j, d\) и \(b\) – скаляры.
\end{sphinxadmonition}

\sphinxAtStartPar
Часто считают, что среди признаков
есть константа, \(x_{d + 1} = 1\).
В этом случае нет необходимости вводить сдвиг \(b\),
и линейный классификатор можно задавать как
\begin{equation*}
\begin{split}
    a(x) = \text{sign} \langle w, x \rangle.
\end{split}
\end{equation*}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{distance_to_the_plane}.png}
\caption{Расстояние от точки до плоскости}\label{\detokenize{book/qsvm/ru/classic_svm:distance-to-the-plane}}\end{figure}

\sphinxAtStartPar
Геометрически линейный классификатор соответствует гиперплоскости с вектором нормали \(w\), которая задается уравнением \(\langle w, x \rangle = 0\). Величина скалярного произведения \(\langle w, x \rangle\) пропорциональна расстоянию от гиперплоскости до точки \(x\), а его знак показывает, с какой стороны от гиперплоскости находится данная точка. Если быть точным, расстояние от точки с радиус\sphinxhyphen{}вектором \(x_A\) до плоскости \(\langle w, x \rangle = 0\):
\begin{equation*}
\begin{split}
\rho(x_A, \langle w, x \rangle = 0) = \frac{\langle w, x_A \rangle}{||w||}.
\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Упражнение на метод Лагранжа}

\sphinxAtStartPar
\sphinxhref{https://en.wikipedia.org/wiki/Lagrange\_multiplier}{Метод Лагранжа} – очень важный метод оптимизации функций при наличии органичений. Этот же метод вовсю используется ниже в методе опорных векторов.

\sphinxAtStartPar
Рекомендуется ознакомиться с методом Лагранжа и решить (ручками!) простую оптимизационную задачу вида
\begin{equation*}
\begin{split}
\begin{equation}
    \left\{
        \begin{aligned}
            & x + y \to \min_{x,y} \\
            & x^2 + y^2 = 1
        \end{aligned}
    \right.
\end{equation}
\end{split}
\end{equation*}
\sphinxAtStartPar
А мы выведем указанную выше формулу расстояния от точки до плоскости. Вообще это можно сделать разными способами – алгебраически и геометрически. Но давайте посмотрим на эту задачу (внезапно) как на задачу оптимизации и решим ее методом Лагранжа. Это послужит неплохой тренировкой перед тем как окунуться в SVM.

\sphinxAtStartPar
Итак, представим задачу в таком виде: хотим найти точку \(x\) на плоскости \(\langle w, x \rangle = 0\) такую, что расстояние от \(x\) до точки \(x_0\) минимально:
\begin{equation*}
\begin{split}
\begin{equation}
    \left\{
        \begin{aligned}
            & \rho(x, x_0) \to \min_{x} \\
            & \langle w, x \rangle = 0
        \end{aligned}
    \right.
\end{equation}
\end{split}
\end{equation*}
\sphinxAtStartPar
Лагранжиан: \(\mathcal{L}(x, \lambda) = {||x - x_0||}^2 + 2 \lambda \langle w, x \rangle\). Тут мы для \(\rho(x, x_0)\) подставили квадрат расстояния \({||x - x_0||}^2\) (такой переход от росстояния к его квадрат хорошо бы обосновать монотонностью оптимизируемой функции, но мы это опустим), а также перед коэффициентом \(\lambda\) для удобства поставили 2, что несущественно.

\sphinxAtStartPar
Далее надо приравнять нулю частные производные лагранжиана по его аргументам. Из
\(\frac{\partial \mathcal{L}}{\partial x} = 0\) получаем: \(2(x - x_0) + 2 \lambda w = 0 \Rightarrow x = x_0 - \lambda w\).

\sphinxAtStartPar
Теперь домножим это уравнение скалярно на \(w\) и выразим \(\lambda\):
\begin{equation*}
\begin{split}
\langle w, x \rangle  = \langle w, x_0 \rangle - \lambda {||w||}^2 \Rightarrow \lambda = \frac{\langle w, x_0 \rangle}{{||w||}^2 }
\end{split}
\end{equation*}
\sphinxAtStartPar
Тогда наконец
\begin{equation*}
\begin{split}
\min_{x,  \langle w, x \rangle = 0} \rho(x, x_0) = ||x - x_0|| = ||(x_0 - \lambda w) - x_0|| = |\lambda| ||w|| = \frac{\langle w, x_0 \rangle}{||w||}\ \ \square.
\end{split}
\end{equation*}\end{sphinxadmonition}

\sphinxAtStartPar
Таким образом, линейный классификатор разделяет пространство на две части с помощью гиперплоскости, и при этом одно полупространство относит к положительному классу, а другое – к отрицательному.

\sphinxAtStartPar
Пожалуй, самый известный и популярный на практике представитель семейства линейных классификаторов – логистическая регрессия. На русском языке про нее можно почитать в \sphinxhref{https://habr.com/ru/company/ods/blog/323890/}{статье} открытого курса по машинному обучению или в упомянутых \sphinxhref{https://github.com/esokolov/ml-course-hse/tree/master/2021-fall/lecture-notes}{лекциях} Евгения Соколова. В этих лекциях также объясняется, как происходит обучение модели (подбор весов \(w\)) за счет минимизации функции потерь.


\subsection{Отступ классификации}
\label{\detokenize{book/qsvm/ru/classic_svm:id3}}
\sphinxAtStartPar
Оказывается полезным рассмотреть выражение \(M(x_i, y_i, w) = y_i \cdot \langle w, x \rangle.\)

\sphinxAtStartPar
Это \sphinxstylestrong{отступ классификации} (margin) для объекта обучающей выборки \((x_i, y_i)\). К сожалению, его очень легко перепутать с зазором классификации, который появится чуть ниже в изложении интуиции метода опорных векторов. Чтобы не путать: отступ определен на конкретном объекте обучающей выборки.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{margin_toy_example}.png}
\caption{Иллюстрация к понятию отступа классификации}\label{\detokenize{book/qsvm/ru/classic_svm:margin-toy-example}}\end{figure}

\sphinxAtStartPar
Отступ – это своего рода “уверенность” модели в классификации объекта \((x_i, y_i)\):
\begin{itemize}
\item {} 
\sphinxAtStartPar
если отступ большой (по модулю) и положительный, это значит, что метка класса поставлена правильно, а объект находится далеко от разделяющей гиперплоскости (такой объект классифицируется уверенно). На рисунке – \(x_3\).

\item {} 
\sphinxAtStartPar
если отступ большой (по модулю) и отрицательный, значит метка класса поставлена неправильно, а объект находится далеко от разделяющей гиперплоскости (скорее всего такой объект – аномалия, например, его метка в обучающей выборке поставлена неправильно). На рисунке – \(x_1\).

\item {} 
\sphinxAtStartPar
если отступ малый (по модулю), то объект находится близко к разделяющей гиперплоскости, а знак отступа определяет, правильно ли объект классифицирован. На рисунке – \(x_2\) и \(x_4\).

\end{itemize}

\sphinxAtStartPar
Далее увидим, что понятие отступа классификации – часть функции потерь, которая оптимизируется в методе опорных векторов.


\section{Интуиция метода опорных векторов}
\label{\detokenize{book/qsvm/ru/classic_svm:id4}}
\sphinxAtStartPar
Метод опорных векторов (Support Vector Machine, SVM) основан на идее максимизации зазора между классами. Пока не вводим этот термин формально, но передадим интуицию метода. На Рис. \hyperref[\detokenize{book/qsvm/ru/classic_svm:linclass-margins}]{Fig.\@ \ref{\detokenize{book/qsvm/ru/classic_svm:linclass-margins}}} показана линейно\sphinxhyphen{}разделимая выборка, кружки соответствуют положительным примерам, а квадраты – отрицательным (или наоборот), а оси – некоторым признакам этих примеров. На рисунке слева показаны две прямые (в общем случае – гиперплоскости), разделяющие выборку. Кажется, что синяя прямая лучше тем, что она дальше отстоит от примеров обучающей выборки, чем красная прямая (зазор – больше), и потому лучше будет разделять другие примеры из того же распределения, что и примеры обучающей выборки. То есть такой линейный классификатор будет лучше обобщаться на новые данные. Теория подтверждает описанную интуицию {[}\hyperlink{cite.book/bibliography:id9}{MRT18}{]}.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=450\sphinxpxdimen]{{linclass_margins}.png}
\caption{Слева показаны две прямые (в общем случае – гиперплоскости), разделяющие выборку. Справа показана прямая, максимизирующая зазор между классами. Источник: \sphinxhref{https://www.cs.cornell.edu/courses/cs4780/2018fa/lectures/lecturenote09.html}{лекция} Cornell}\label{\detokenize{book/qsvm/ru/classic_svm:linclass-margins}}\end{figure}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Одним из ключевых авторов алгоритма SVM является Владимир Вапник – советский и американский (с 1991\sphinxhyphen{}го года) ученый, который также сделал огромный вклад в теорию классического машинного обучения. Его имя носит одно из ключевых теоретических понятий машинного обучения – размерность Вапника\sphinxhyphen{}Червоненкиса.
\end{sphinxadmonition}


\section{Метод опорных векторов для линейно\sphinxhyphen{}разделимой выборки}
\label{\detokenize{book/qsvm/ru/classic_svm:id6}}
\sphinxAtStartPar
Будем рассматривать линейные классификаторы вида
\begin{equation*}
\begin{split} a(x) = \text{sign} (\langle w, x \rangle + b), \qquad w \in \mathbb{R}^d, b \in \mathbb{R}. \end{split}
\end{equation*}
\sphinxAtStartPar
Заметьте, что мы вернули сдвиг (bias) \(b\). Будем считать, что существуют такие параметры \(w_*\) и \(b_*\), что соответствующий им классификатор \(a(x)\) не допускает ни одной ошибки на обучающей выборке. В этом случае говорят, что выборка \sphinxstylestrong{линейно разделима}.

\sphinxAtStartPar
Заметим, что если одновременно умножить параметры \(w\) и \(b\) на одну и ту же положительную константу, то классификатор не изменится. Распорядимся этой свободой выбора и отнормируем параметры так, что
\begin{equation*}
\begin{split}
    \min_{x \in X} | \langle w, x \rangle + b| = 1.
\end{split}
\end{equation*}
\sphinxAtStartPar
Как мы увидели выше, расстояние от произвольной точки \(x_0 \in \mathbb{R}^d\) до гиперплоскости, определяемой данным классификатором, равно
\begin{equation*}
\begin{split}
    \rho(x_0, a)
    =
    \frac{
        |\langle w, x \rangle + b|
    }{
        \|w\|
    }.
\end{split}
\end{equation*}
\sphinxAtStartPar
Тогда расстояние от гиперплоскости до ближайшего примера из обучающей выборки равно
\begin{equation*}
\begin{split}
    \min_{x \in X}
    \frac{
        |\langle w, x \rangle + b|
    }{
        \|w\|
    }
    =
    \frac{1}{\|w\|} \min_{x \in X} |\langle w, x \rangle + b|
    =
    \frac{1}{\|w\|}.
\end{split}
\end{equation*}
\sphinxAtStartPar
Данная величина также называется \sphinxstylestrong{зазором} (margin). Опять же, эту величину очень легко перепутать с отступом классификации, про который мы говорили выше и который тоже margin в англоязычном варианте. Заметим, что отступ – функция параметров \(w\) и конкретного примера обучающей выборки \((x_i, y_i)\), а зазор – функция только параметров \(w\) при описанном трюке с нормировкой \(w\) и \(b\) (в противном случае зазор – также функция сдвига \(b\) и всех примеров \(x\)).

\sphinxAtStartPar
Таким образом, если классификатор без ошибок разделяет обучающую выборку, то ширина его разделяющей полосы равна \(\frac{2}{\|w\|}\).
Максимизация ширины разделяющей полосы приводит
к повышению обобщающей способности классификатора {[}\hyperlink{cite.book/bibliography:id9}{MRT18}{]}. На повышение обобщающей способности направлена и регуляризация,
которая штрафует большую норму весов – а чем больше норма весов,
тем меньше ширина разделяющей полосы.

\sphinxAtStartPar
Итак, требуется построить классификатор, идеально разделяющий обучающую выборку, и при этом имеющий максимальный отступ.

\sphinxAtStartPar
Запишем соответствующую оптимизационную задачу,
которая и будет определять метод опорных векторов для линейно разделимой выборки (hard margin support vector machine):
\begin{equation*}
\begin{split}
\left\{
    \begin{aligned}
        & \frac{1}{2} \|w\|^2 \to \min_{w, b} \\
        & y_i \left(
            \langle w, x_i \rangle + b
        \right) \geq 1, \quad i = 1, \dots, \ell.
    \end{aligned}
\right.
\end{split}
\end{equation*}
\sphinxAtStartPar
Здесь мы воспользовались тем, что линейный классификатор дает правильный ответ на примере \(x_i\) тогда и только тогда, когда \(y_i (\langle w, x_i \rangle + b) \geq 0\) (вспомним, что \(M_i = y_i (\langle w, x_i \rangle + b)\) – отступ классификации для примера \((x_i, y_i)\) обучающей выборки). Более того, из условия нормировки \(\min_{x \in X} | \langle w, x \rangle + b| = 1\) следует, что \(y_i (\langle w, x_i \rangle + b) \geq 1\).

\sphinxAtStartPar
В данной задаче функционал является строго выпуклым, а ограничения линейными, поэтому сама задача является выпуклой и имеет единственное решение. Более того, задача является квадратичной и может быть решена крайне эффективно.


\section{Метод опорных векторов для линейно\sphinxhyphen{}неразделимой выборки}
\label{\detokenize{book/qsvm/ru/classic_svm:id8}}
\sphinxAtStartPar
Рассмотрим теперь общий случай, когда выборку
невозможно идеально разделить гиперплоскостью.
Это означает, что какие бы \(w\) и \(b\) мы ни взяли,
хотя бы одно из ограничений в предыдущей задаче
будет нарушено:
\begin{equation*}
\begin{split}
    \exists \ x_i \in X:\
    y_i \left(
        \langle w, x_i \rangle + b
    \right) < 1.
\end{split}
\end{equation*}
\sphinxAtStartPar
Сделаем эти ограничения \sphinxstyleemphasis{мягкими}, введя штраф \(\xi_i \geq 0\) за их нарушение:
\begin{equation*}
\begin{split}
    y_i \left(
        \langle w, x_i \rangle + b
    \right) \geq 1 - \xi_i, \quad i = 1, \dots, \ell.
\end{split}
\end{equation*}
\sphinxAtStartPar
Отметим, что если отступ объекта лежит между нулем и
единицей (\(0 \leq y_i \left( \langle w, x_i \rangle + b \right) < 1\)), то объект верно классифицируется, но имеет ненулевой штраф \(\xi > 0\). Таким образом, мы штрафуем объекты за попадание внутрь разделяющей полосы.

\sphinxAtStartPar
Величина \(\frac{1}{\|w\|}\) в данном случае называется \sphinxstylestrong{мягким зазором} (soft margin). С одной стороны, мы хотим максимизировать зазор, с другой – минимизировать
штраф за неидеальное разделение выборки \(\sum_{i = 1}^{\ell} \xi_i\).

\sphinxAtStartPar
Эти две задачи противоречат друг другу: как правило, излишняя подгонка под выборку приводит к маленькому зазору, и наоборот – максимизация зазора приводит к большой ошибке на обучении.
В качестве компромисса будем минимизировать взвешенную сумму двух указанных величин.

\sphinxAtStartPar
Приходим к оптимизационной задаче, соответствующей методу опорных векторов для линейно неразделимой выборки (soft margin support vector machine):
\begin{equation*}
\begin{split}
\left\{
    \begin{aligned}
        & \frac{1}{2} \|w\|^2 + C \sum_{i = 1}^{\ell} \xi_i \to \min_{w, b, \xi} \\
        & y_i \left(
            \langle w, x_i \rangle + b
        \right) \geq 1 - \xi_i, \quad i = 1, \dots, \ell, \\
        & \xi_i \geq 0, \quad i = 1, \dots, \ell.
    \end{aligned}
\right.
\end{split}
\end{equation*}
\sphinxAtStartPar
Чем больше здесь параметр \(C\), тем сильнее мы будем настраиваться на обучающую выборку. Данная задача также является выпуклой и имеет единственное решение.


\subsection{Сведение к безусловной задаче оптимизации}
\label{\detokenize{book/qsvm/ru/classic_svm:id9}}
\sphinxAtStartPar
Покажем, что задачу метода опорных векторов можно свести к задаче безусловной оптимизации функционала, который имеет вид верхней оценки на долю неправильных ответов.

\sphinxAtStartPar
Перепишем условия задачи:
\begin{equation*}
\begin{split}
    \left\{
    \begin{aligned}
        &\xi_i \geq 1 - y_i (\langle w, x_i \rangle + b) \\
        &\xi_i \geq 0
    \end{aligned}
    \right.
\end{split}
\end{equation*}
\sphinxAtStartPar
Поскольку при этом в функционале требуется, чтобы штрафы \(\xi_i\) были как можно меньше, то можно получить следующую явную формулу для них:
\begin{equation*}
\begin{split}
    \xi_i
    =
    \max(0,
        1 - y_i (\langle w, x_i \rangle + b)).
\end{split}
\end{equation*}
\sphinxAtStartPar
Данное выражение для \(\xi_i\) уже учитывает в себе все ограничения задачи, описанной выше.
Значит, если подставить его в функционал, получим безусловную задачу оптимизации:
\begin{equation*}
\begin{split}
    \frac{1}{2} \|w\|^2
    +
    C
    \sum_{i = 1}^{\ell}
        \max(0,
            1 - y_i (\langle w, x_i \rangle + b))
    \to
    \min_{w, b}
\end{split}
\end{equation*}
\sphinxAtStartPar
Эта задача является негладкой, поэтому решать её может быть достаточно тяжело. Тем не менее, она показывает, что метод опорных векторов, по сути, как и логистическая регрессия, строит верхнюю оценку на долю ошибок и добавляет к ней стандартную квадратичную регуляризацию. Только если в случае логистической регрессии этой верхней оценкой была логистическая функция потерь (опять сделаем отсылку к \sphinxhref{https://habr.com/ru/company/ods/blog/323890/}{статье} из открытого курса машинного обучения), то в случае метода опорных векторов это функция вида  \(L(y, z) = \max(0, 1 - yz)\), которая называется \sphinxstylestrong{кусочно\sphinxhyphen{}линейной функцией потерь (hinge loss)}.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=450\sphinxpxdimen]{{loss_functions_logistic_and_hinge}.png}
\caption{Пороговая, кусочно\sphinxhyphen{}линейная и логистическая функции потерь}\label{\detokenize{book/qsvm/ru/classic_svm:loss-functions-logistic-and-hinge}}\end{figure}

\sphinxAtStartPar
Это становится понятнее в терминах упомянутого выше отступа \(M_i = y_i (\langle w, x_i \rangle + b)\) на примере обучающей выборки. В идеале мы хотели бы штрафовать классификатор за ошибку на примере: \(L_{1/0} (M_i) = [M_i < 0]\). Это пороговая функция потерь (zero\sphinxhyphen{}one loss), ее график изображен черным на \hyperref[\detokenize{book/qsvm/ru/classic_svm:loss-functions-logistic-and-hinge}]{Fig.\@ \ref{\detokenize{book/qsvm/ru/classic_svm:loss-functions-logistic-and-hinge}}} как функция от отступа. К сожалению, напрямую мы не можем эффективно оптимизировать такую функцию градиентными методами из\sphinxhyphen{}за разрыва в нуле, поэтому оптимизируется верхняя оценка zero\sphinxhyphen{}one loss. В случае логистической регрессии – логистическая функция потерь \(L(M_i) = \log(1+ e^{-M_i})\) (красная на рисунке выше), а в случае метода опорных векторов – кусочно\sphinxhyphen{}линейная функция \(L(M_i) = \max(0, 1 - M_i)\) (зеленая на рисунке выше).

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Бытует мнение, что метод опорных векторов сегодня нигде не используется из\sphinxhyphen{}за его сложности (как минимум квадратичной по числу примеров). Однако, это не так. Линейный SVM вполне неплохо можно применять в задачах с высокой размерностью объектов обучающей выборки, например, для классификации текстов с \sphinxhref{https://en.wikipedia.org/wiki/Tf\%E2\%80\%93idf}{Tf\sphinxhyphen{}Idf} или любым другим разреженным представлением. В частности, \sphinxhref{https://vowpalwabbit.org/}{Vowpal Wabbit} – очень эффективная утилита для решения многих задачах машинного обучения – по умолчанию использует hinge\sphinxhyphen{}loss для задач классификации, то есть по сути в этом сценарии применения является линейным SVM. Кусочно\sphinxhyphen{}линейная функция потерь хороша тем, что у нее очень простая производная – положительная константа либо ноль. Это удобно использовать с SGD и большими выборками, когда приходится делать миллиарды обновлений весов.

\sphinxAtStartPar
Про прелести Vowpal Wabbit и обучение на гигабайтах данных за считанные минуты можно почитать в \sphinxhref{https://habr.com/ru/company/ods/blog/326418/}{статье} открытого курса машинного обучения.
\end{sphinxadmonition}


\section{Решение задачи метода опорных векторов}
\label{\detokenize{book/qsvm/ru/classic_svm:id10}}
\sphinxAtStartPar
Итак, метод опорных векторов сводится к решению задачи оптимизации
\begin{equation*}
\begin{split}
    \left\{
        \begin{aligned}
            & \frac{1}{2} \|w\|^2 + C \sum_{i = 1}^{\ell} \xi_i \to \min_{w, b, \xi} \\
            & y_i \left(
                \langle w, x_i \rangle + b
            \right) \geq 1 - \xi_i, \quad i = 1, \dots, \ell, \\
            & \xi_i \geq 0, \quad i = 1, \dots, \ell.
        \end{aligned}
    \right.
\end{split}
\end{equation*}
\sphinxAtStartPar
Для решения таких \sphinxstyleemphasis{условных} задач оптимизации с условиями в виде неравенств или равенств часто используют лагранжиан и двойственную задачу оптимизации. Этот подход исчерпывающе описан в классической книге Бойда по оптимизации {[}\hyperlink{cite.book/bibliography:id3}{BV04}{]}, а на русском языке можно обратиться к \sphinxhref{http://www.machinelearning.ru/wiki/images/f/fe/Sem6\_linear.pdf}{конспекту} Евгения Соколова. Также для понимания материала рекомендуется рассмотреть \sphinxhref{https://github.com/esokolov/ml-course-hse/blob/master/2016-spring/seminars/sem16-svm.pdf}{“игрушечный” пример} решения задачи метода опорных векторов в случае линейно\sphinxhyphen{}разделимой выборки из 5 примеров.

\sphinxAtStartPar
Построим двойственную задачу к задаче метода опорных векторов.
Запишем лагранжиан:
\begin{equation*}
\begin{split}
    L(w, b, \xi, \lambda, \mu)
    =
    \frac{1}{2} \|w\|^2 + C \sum_{i = 1}^{\ell} \xi_i
    -
    \sum_{i = 1}^{\ell} \lambda_i \left[
        y_i \left(
                \langle w, x_i \rangle + b
            \right) - 1 + \xi_i
    \right]
    -
    \sum_{i = 1}^{\ell}
        \mu_i \xi_i.
\end{split}
\end{equation*}
\sphinxAtStartPar
Выпишем условия Куна\sphinxhyphen{}Таккера:
\begin{equation}\label{equation:book/qsvm/ru/classic_svm:KuckTuckerCond1}
\begin{split}\nabla_w L = w - \sum_{i = 1}^{\ell} \lambda_i y_i x_i = 0
  \quad\Longrightarrow\quad
    w = \sum_{i = 1}^{\ell} \lambda_i y_i x_i\end{split}
\end{equation}\begin{equation}\label{equation:book/qsvm/ru/classic_svm:KuckTuckerCond2}
\begin{split}\nabla_b L = - \sum_{i = 1}^{\ell} \lambda_i y_i = 0
    \quad\Longrightarrow\quad
    \sum_{i = 1}^{\ell} \lambda_i y_i = 0\end{split}
\end{equation}\begin{equation}\label{equation:book/qsvm/ru/classic_svm:KuckTuckerCond3}
\begin{split}  \nabla_{\xi_i} L = C - \lambda_i - \mu_i
    \quad\Longrightarrow\quad
    \lambda_i + \mu_i = C\end{split}
\end{equation}\begin{equation}\label{equation:book/qsvm/ru/classic_svm:KuckTuckerCond4}
\begin{split}\lambda_i \left[
        y_i \left(
                \langle w, x_i \rangle + b
            \right) - 1 + \xi_i
        \right] = 0
    \quad\Longrightarrow\quad
    (\lambda_i = 0)
        \ \text{или}\
        \left(
            y_i \left(
                \langle w, x_i \rangle + b
            \right)
            =
            1 - \xi_i
        \right)\end{split}
\end{equation}\begin{equation}\label{equation:book/qsvm/ru/classic_svm:KuckTuckerCond5}
\begin{split}\mu_i \xi_i = 0
    \quad\Longrightarrow\quad
    (\mu_i = 0)
        \ \text{или}\
        (\xi_i = 0)\end{split}
\end{equation}\begin{equation}\label{equation:book/qsvm/ru/classic_svm:KuckTuckerCond6}
\begin{split}    \xi_i \geq 0, \lambda_i \geq 0, \mu_i \geq 0.\end{split}
\end{equation}
\sphinxAtStartPar
Проанализируем полученные условия. Из \eqref{equation:book/qsvm/ru/classic_svm:KuckTuckerCond1} следует, что вектор весов, полученный в результате настройки SVM, можно записать как линейную комбинацию объектов, причем веса в этой линейной комбинации можно найти как решение двойственной задачи.

\sphinxAtStartPar
В зависимости от значений \(\xi_i\) и \(\lambda_i\) объекты \(x_i\) разбиваются на три категории:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\(\xi_i = 0\), \(\lambda_i = 0\). Такие объекты не влияют решение \(w\) (входят в него с нулевым весом \(\lambda_i\)), правильно классифицируются (\(\xi_i = 0\)) и лежат вне разделяющей полосы. Объекты этой категории называются \sphinxstyleemphasis{периферийными}.

\item {} 
\sphinxAtStartPar
\(\xi_i = 0\), \(0 < \lambda_i < C\). Из условия \eqref{equation:book/qsvm/ru/classic_svm:KuckTuckerCond4} следует, что \(y_i \left(\langle w, x_i \rangle + b \right) = 1\), то есть объект лежит строго на границе разделяющей полосы. Поскольку \(\lambda_i > 0\), объект влияет на решение \(w\). Объекты этой категории называются \sphinxstyleemphasis{опорными граничными}.

\item {} 
\sphinxAtStartPar
\(\xi_i > 0\), \(\lambda_i = C\). Такие объекты могут лежать внутри разделяющей полосы (\(0 < \xi_i < 2\)) или выходить за ее пределы (\(\xi_i \geq 2\)). При этом если \(0 < \xi_i < 1\), то объект классифицируется правильно, в противном случае – неправильно. Объекты этой категории называются \sphinxstyleemphasis{опорными нарушителями}.

\end{itemize}

\sphinxAtStartPar
Отметим, что варианта \(\xi_i > 0\), \(\lambda_i < C\) быть не может, поскольку при \(\xi_i > 0\) из условия дополняющей нежесткости \eqref{equation:book/qsvm/ru/classic_svm:KuckTuckerCond5} следует, что \(\mu_i = 0\), и отсюда из уравнения \eqref{equation:book/qsvm/ru/classic_svm:KuckTuckerCond3} получаем, что \(\lambda_i = C\).

\sphinxAtStartPar
Итак, итоговый классификатор зависит только от объектов, лежащих на границе разделяющей полосы, и от объектов\sphinxhyphen{}нарушителей (с \(\xi_i > 0\)).

\sphinxAtStartPar
Построим двойственную функцию. Для этого подставим выражение \eqref{equation:book/qsvm/ru/classic_svm:KuckTuckerCond1} в лагранжиан и воспользуемся уравнениями \eqref{equation:book/qsvm/ru/classic_svm:KuckTuckerCond2} и \eqref{equation:book/qsvm/ru/classic_svm:KuckTuckerCond3} (данные
три уравнения выполнены для точки минимума лагранжиана при
любых фиксированных \(\lambda\) и \(\mu\)):
\begin{equation*}
\begin{split}
\begin{align*}
    L &= \frac{1}{2} \left\|
            \sum_{i = 1}^{\ell}
                \lambda_i y_i x_i
        \right\|^2
        -
        \sum_{i, j = 1}^{\ell}
            \lambda_i \lambda_j y_i y_j \langle x_i, x_j \rangle
        -
        b
        \underbrace{\sum_{i = 1}^{\ell}
            \lambda_i y_i}_{0}
        +
        \sum_{i = 1}^{\ell}
            \lambda_i
        +
        \sum_{i = 1}^{\ell}
            \xi_i \underbrace{(C - \lambda_i - \mu_i)}_{0} \\
    &=
    \sum_{i = 1}^{\ell}
        \lambda_i
    -
    \frac{1}{2} \sum_{i, j = 1}^{\ell}
        \lambda_i \lambda_j y_i y_j \langle x_i, x_j \rangle.
\end{align*}
\end{split}
\end{equation*}
\sphinxAtStartPar
Мы должны потребовать выполнения условий \eqref{equation:book/qsvm/ru/classic_svm:KuckTuckerCond2} и \eqref{equation:book/qsvm/ru/classic_svm:KuckTuckerCond3} (если они не выполнены, то двойственная функция обращается в минус бесконечность), а также неотрицательность двойственных переменных \(\lambda_i \geq 0\), \(\mu_i \geq 0\). Ограничение на \(\mu_i\) и условие \eqref{equation:book/qsvm/ru/classic_svm:KuckTuckerCond3}, можно объединить, получив \(\lambda_i \leq C\). Приходим к следующей двойственной задаче:
\begin{equation}\label{equation:book/qsvm/ru/classic_svm:svmDual}
\begin{split}
    \left\{
        \begin{aligned}
            & \sum_{i = 1}^{\ell}
                \lambda_i
            -
            \frac{1}{2} \sum_{i, j = 1}^{\ell}
                \lambda_i \lambda_j y_i y_j \langle x_i, x_j \rangle
            \to \max_{\lambda} \\
            & 0 \leq \lambda_i \leq C, \quad i = 1, \dots, \ell, \\
            & \sum_{i = 1}^{\ell} \lambda_i y_i = 0.
        \end{aligned}
    \right.\end{split}
\end{equation}
\sphinxAtStartPar
Она также является вогнутой, квадратичной и имеет единственный максимум.


\section{Ядерный переход}
\label{\detokenize{book/qsvm/ru/classic_svm:id12}}
\sphinxAtStartPar
Двойственная задача SVM \eqref{equation:book/qsvm/ru/classic_svm:svmDual} зависит только от скалярных произведений объектов – отдельные признаковые описания никак не входят в неё.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Обратите внимание, как много это значит: решение SVM зависит только от скалярных произведений объектов (то есть \sphinxstyleemphasis{похожести}, если упрощать), но не от их признаковых описаний объектов. Это значит, что метод обобщается и на те случаи, когда признаковых описаний объектов нет или их получить очень дорого, но зато есть способ задать расстояние (то есть “измерить сходство”) между объектами.
\end{sphinxadmonition}

\sphinxAtStartPar
Значит, можно сделать ядерный переход:
\begin{equation*}
\begin{split}
\left\{
    \begin{aligned}
        & \sum_{i = 1}^{\ell}
            \lambda_i
        -
        \frac{1}{2} \sum_{i, j = 1}^{\ell}
            \lambda_i \lambda_j y_i y_j K(x_i, x_j)
        \to \max_{\lambda} \\
        & 0 \leq \lambda_i \leq C, \quad i = 1, \dots, \ell, \\
        & \sum_{i = 1}^{\ell} \lambda_i y_i = 0.
    \end{aligned}
\right.
\end{split}
\end{equation*}
\sphinxAtStartPar
Здесь \(K(x_i, x_j)\) – это функция\sphinxhyphen{}ядро, определенная на парах векторов, которая должна быть симметричной и неотрицательно определенной (\sphinxhref{http://www.machinelearning.ru/wiki/index.php?title=\%D0\%A2\%D0\%B5\%D0\%BE\%D1\%80\%D0\%B5\%D0\%BC\%D0\%B0\_\%D0\%9C\%D0\%B5\%D1\%80\%D1\%81\%D0\%B5\%D1\%80\%D0\%B0}{теорема Мерсера}).

\sphinxAtStartPar
Вернемся к тому, какое представление классификатора дает двойственная задача. Из уравнения \eqref{equation:book/qsvm/ru/classic_svm:KuckTuckerCond1} следует, что вектор весов \(w\) можно представить как линейную комбинацию объектов из обучающей выборки. Подставляя это представление \(w\) в классификатор, получаем
\begin{equation*}
\begin{split}
a(x) = \text{sign} \left(
    \sum_{i = 1}^{\ell} \lambda_i y_i \langle x_i, x \rangle + b
\right).
\end{split}
\end{equation*}
\sphinxAtStartPar
Таким образом, классификатор измеряет сходство нового объекта с объектами из обучающей выборки, вычисляя скалярное произведение между ними. Это выражение также зависит только от скалярных произведений, поэтому в нём тоже можно перейти к ядру.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Опять подчеркнем, что классификация нового примера зависит только от скалярных произведений – “похожести” нового примера на примеры из обучающей выборки, и то не все, а только опорные.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
В указанном выше представлении фигурирует переменная сдвига \(b\), которая не находится непосредственно в двойственной задаче. Однако ее легко восстановить по любому граничному опорному объекту \(x_i\), для которого выполнено \(\xi_i = 0, 0 < \lambda_i < C\). Для него выполнено \(y_i \left(\langle w, x_i \rangle + b \right) = 1\), откуда получаем
\begin{equation*}
\begin{split}
    b = y_i - \langle w, x_i \rangle.
\end{split}
\end{equation*}
\sphinxAtStartPar
Как правило, для численной устойчивости берут медиану данной величины по
всем граничным опорным объектам:
\begin{equation*}
\begin{split}
    b = med \ y_i - \langle w, x_i \rangle, \xi_i = 0, 0 < \lambda_i < C.
\end{split}
\end{equation*}\end{sphinxadmonition}

\sphinxAtStartPar
\hyperref[\detokenize{book/qsvm/ru/classic_svm:kerneltrick}]{Fig.\@ \ref{\detokenize{book/qsvm/ru/classic_svm:kerneltrick}}} – пожалуй, самый известный рисунок в контексте SVM, он иллюстрирует ядерный трюк, в свою очередь, одну из самых красивых идей в истории машинного обучения. За счет ядерного перехода можно достигнуть линейной разделимости выборки даже в том случае, когда исходная обучающая выборка не является линейно разделимой.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=600\sphinxpxdimen]{{kernel_trick_idea}.png}
\caption{Пример разделимости в новом пространстве}\label{\detokenize{book/qsvm/ru/classic_svm:kerneltrick}}\end{figure}

\sphinxAtStartPar
Наиболее часто используемые ядра:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Линейное} \(K(x, y) = \langle x , y \rangle\) – по сути, линейный SVM, рассмотренный выше;

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Полиномиальное ядро} \(K(x, y) = (\langle x , y \rangle + c)^d\), определенное для степени ядра \(d\) и параметра нормализации \(c\);

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Гауссово ядро}, также известное как RBF (radial\sphinxhyphen{}basis functions) \(K(x, y) = e^{-\frac{||x - y||^2}{\sigma}}\) c параметром ядра \(\sigma\).

\end{itemize}


\section{Плюсы и минусы SVM}
\label{\detokenize{book/qsvm/ru/classic_svm:id13}}
\sphinxAtStartPar
Плюсы:
\begin{itemize}
\item {} 
\sphinxAtStartPar
хорошо изучены, есть важные теоретические результаты;

\item {} 
\sphinxAtStartPar
красиво формулируется как задача оптимизации;

\item {} 
\sphinxAtStartPar
линейный SVM быстрый, может работать на очень больших выборках;

\item {} 
\sphinxAtStartPar
линейный SVM так же хорошо интерпретируется, как и прочие линейные модели;

\item {} 
\sphinxAtStartPar
решение зависит только от скалярных произведений векторов, а идея “ядерного трюка” – одно из самых красивых в истории машинного обучения;

\item {} 
\sphinxAtStartPar
нелинейный SVM обобщается на работу с самыми разными типами данных (последовательности, графы и т.д.) за счет специфичных ядер.

\end{itemize}

\sphinxAtStartPar
Минусы:
\begin{itemize}
\item {} 
\sphinxAtStartPar
нелинейный SVM имеет высокую вычислительную сложность и принципиально плохо масштабируется (оптимизационную задачу нельзя “решить на подвыборках” и как\sphinxhyphen{}то объединить решения);

\item {} 
\sphinxAtStartPar
нелинейный SVM по сути не интерпретируется (“black box”);

\item {} 
\sphinxAtStartPar
в задачах классификации часто хочется выдать вероятность отнесения к классу, SVM это не умеет делать, а эвристики, как правило, приводят к плохо откалиброванным вероятностям;

\item {} 
\sphinxAtStartPar
ядерный SVM уступает специфичным нейронным сетям уже во многих задачах, например, в в приложениях к графам

\end{itemize}

\sphinxstepscope


\part{Квантовые нейронные сети}

\sphinxstepscope


\chapter{О блоке “Квантовые нейронные сети”}
\label{\detokenize{book/qnn/ru/qnn_intro:qnn-intro}}\label{\detokenize{book/qnn/ru/qnn_intro:id1}}\label{\detokenize{book/qnn/ru/qnn_intro::doc}}
\sphinxAtStartPar
Этот блок включает в себя обзор:
\begin{itemize}
\item {} 
\sphinxAtStartPar
квантовых нейронных сетей;

\item {} 
\sphinxAtStartPar
сверточных вариационных квантовых схем.

\end{itemize}

\sphinxstepscope


\chapter{Квантовые нейронные сети}
\label{\detokenize{book/qnn/ru/qnn:id1}}\label{\detokenize{book/qnn/ru/qnn::doc}}
\sphinxAtStartPar
Автор(ы):
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/magnus-the-collectioner}{Щуцкий Никита}

\end{itemize}


\section{Описание лекции}
\label{\detokenize{book/qnn/ru/qnn:id2}}
\sphinxAtStartPar
В этой лекции мы пройдёмся по расширению идеи нейронных сетей на квантовые компьютеры – мы уже прошли и {\hyperref[\detokenize{book/vqc/ru/vqc::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{вариационные квантовые схемы (VQC)}}}}, и комбинацию {\hyperref[\detokenize{book/grads/ru/grads_intro::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{квантовых и классических градиентов в них}}}} в соответствующих блоках. Всё что осталось – это объединить всё изученное в общую картину и заняться обучением этих самых квантовых нейронных сетей. Для того чтобы лучше разобраться в том, какие ограничения и возможности предоставляет этот подход, мы приведём несколько публикаций о квантовых и гибридных генеративных состязательных сетях.


\section{Введение}
\label{\detokenize{book/qnn/ru/qnn:id3}}
\sphinxAtStartPar
Как уже было упомянуто в {\hyperref[\detokenize{book/vqc/ru/vqc::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{лекции по \sphinxstylestrong{VQC}}}}}, на данный момент квантовые вычислители ещё недостаточно развиты для того, чтобы в одиночку решать большие задачи, имеющие практическое значение для индустрии – это в особенной степени актуально для нейронных сетей, которые и в классическом сценарии требуют значительных вычислительных ресурсов. Именно поэтому на данный момент наиболее популярна категория гибридных вариационных алгоритмов, которые обучают квантовую параметрическую схему (\sphinxstylestrong{QNN}) при помощи классической оптимизации, например, \sphinxstylestrong{VQ Eigensolvers} и \sphinxstylestrong{Quantum Approximate Optimization Algorithms}. В общем и целом идея гибридных алгоритмов заключается в оптимизации над некоторым классом параметрических вычислений для минимизации энергии волновой функции (\sphinxstylestrong{VQE}/\sphinxstylestrong{QAOA}), экстракции нелокальной информации (\sphinxstylestrong{QNN Classifiers}) или генерации данных, соответствующих квантовому распределению (\sphinxstylestrong{Quantum Generative Models}).


\section{Применение}
\label{\detokenize{book/qnn/ru/qnn:id4}}
\sphinxAtStartPar
Лучше всего понять адекватность и применимость какой\sphinxhyphen{}то технологии, особенно основанной на комплексном научном базисе, позволяет как раз таки ее применение \sphinxhyphen{} чего удалось добиться кому\sphinxhyphen{}то на практике и насколько результаты пригодны для того, чтобы хвататься за технологию. Вместе с тем, практические результаты дадут нам глубже понять и в последствии объяснить, как гибридные сети работают под капотом. Приведём два примера, которые хорошо показывают разницу в ограничениях при использовании полностью квантовых и гибридных квантово\sphinxhyphen{}классических сетей.

\sphinxAtStartPar
В первом примере была построена полностью квантовая генеративная состязательная сеть, задачей которой являлось воспроизвести \sphinxhref{https://en.wikipedia.org/wiki/MNIST\_database}{MNIST}, однако у всего эксперимента был один нюанс. Из\sphinxhyphen{}за текущего размера квантовых вычислителей было предложено уменьшить размерность MNIST с 784 до 4 при помощи метода главных компонент (\sphinxhref{https://en.wikipedia.org/wiki/Principal\_component\_analysis}{PCA}), чтобы его хоть как\sphinxhyphen{}то можно было отправить в квантовую схему. Очевидно, сеть такого размера не в состоянии тягаться с классическими сетями на десятки тысяч весов, поэтому конечным результатом стало сравнение по количеству весов при идентичных результатах. Полностью квантовая сеть смогла получить такие же результаты, как и классическая, при это имея на 95\% меньше параметров. Эти результаты всё ещё поднимают вопрос того, будут ли они справедливыми для моделей, адекватно справляющихся с задачей.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=700\sphinxpxdimen]{{qugan}.png}
\caption{Схема квантовой генеративной состязательной сети из публикации {[}\hyperlink{cite.book/bibliography:id65}{SBC+21}{]}.}\label{\detokenize{book/qnn/ru/qnn:qugan}}\end{figure}

\sphinxAtStartPar
Во втором примере была построена гибридная квантово\sphinxhyphen{}классическая генеративная состязательная сеть, задачей которой являлось воспроизвести QM\sphinxhyphen{}9 – популярный датасет молекул до 9 атомов, представленный молекулярным графом в виде матрицы 9 на 9 и атомарным вектором из 9 элементов. Генеративная часть модели состояла из нескольких квантовых схем и, по большей части, классической сети, предсказывающей узлы и связи между ними. Дискриминативная часть была полностью классической во всех вариациях модели. В конечном итоге им удалось добиться снижения числа параметров по сравнению с полностью классической сетью на 85\% и, при увеличении числа кубитов, на 98\%. Таким образом они показали, что комбинация классических и квантовых схем должна соответствовать той же самой закономерности, что и полностью квантовые сети.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=700\sphinxpxdimen]{{molgan}.png}
\caption{Схема гибридной генеративной состязательной сети из публикации {[}\hyperlink{cite.book/bibliography:id49}{LTG21}{]}.}\label{\detokenize{book/qnn/ru/qnn:molgan}}\end{figure}

\sphinxAtStartPar
За счёт большей актуальности на текущих практических задачах именно последнего, гибридного подхода, дальнейшая часть лекции будет рассматривать именно его.


\section{Архитектура}
\label{\detokenize{book/qnn/ru/qnn:id7}}
\sphinxAtStartPar
В идеале этот подход подразумевал бы, что при помощи классического оптимизатора мы обучаем некоторую параметрическую схему на квантовом вычислителе, однако в текущих реалиях \sphinxstyleemphasis{NISQ} этот подход невозможен, поэтому большая часть параметрической схемы остаётся на классических вычислителях. В данном блоке мы поговорим о подходе, связанном с \sphinxstylestrong{QNN Classifiers}, которые следуют вышеупомянутому принципу и обучаются градиентным спуском практически так же, как и обычные классические сети, позволяя градиенту протекать между квантовой и классической частью сети.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=700\sphinxpxdimen]{{qnntfq2}.png}
\caption{Схема обучения гибридной нейронной сети из {[}\hyperlink{cite.book/bibliography:id22}{BVM+21}{]}.}\label{\detokenize{book/qnn/ru/qnn:qnn}}\end{figure}

\sphinxAtStartPar
На изображении гибридной сети процедура практически идентична классическому обучению сетей, в котором добавляется процесс кодирования классических данных в квантовые операторы и процесс измерения квантового состояния для того, чтобы передать уже классическую информацию для дальнейших вычислений на классическом устройстве, как это было описано в {\hyperref[\detokenize{book/vqc/ru/vqc::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{лекции по \sphinxstylestrong{VQC}}}}}.


\section{Анзац}
\label{\detokenize{book/qnn/ru/qnn:id9}}
\sphinxAtStartPar
Зачастую в литературе по \sphinxstylestrong{VQC}, особенно когда речь идёт о нейронных сетях, упоминается такая вещь как \sphinxstylestrong{ansatz} – по своей сути это заранее подготовленные участки параметрической схемы, которые могут быть использованы как составные блоки сети. Если проводить параллели с классическим машинным обучением, то в рамках библиотеки \sphinxcode{\sphinxupquote{PennyLane}} эти схемы называются \sphinxstylestrong{templates} (шаблоны) и могут представлять собой, например, свёрточный слой или эмбеддинг, а также более общие элементы квантовой схемы вроде подготовки состояний или перестановок между кубитами. Более подробно мы остановимся на них слегка позже в курсе, в одной из следующих глав, а пока что в общих чертах пройдёмся по обучению квантовых нейронных сетей без сложностей внутренней кухни.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Интересно, но термин \sphinxstyleemphasis{anzatz} пришел в квантовые вычисления и QML из теоретической физики. Этот термин имеет немецкое происхождение, так как в первой половине XX века именно немецкие научные журналы были самыми передовыми. Частое употребление этого термина в отношении квантового машинного обучения объясняется тем, что большая часть специалистов в этой области это именно люди, занимающиеся теоретической физикой.
\end{sphinxadmonition}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=800\sphinxpxdimen]{{layer_cvqnn}.png}
\caption{Ansatz, соответствующий свёрточному слою нейронной сети в \sphinxcode{\sphinxupquote{PennyLane}}. \sphinxhref{https://pennylane.readthedocs.io/en/ising/code/templates/layers.html}{Источник}}\label{\detokenize{book/qnn/ru/qnn:ansatz}}\end{figure}


\section{Функция потерь}
\label{\detokenize{book/qnn/ru/qnn:id10}}
\sphinxAtStartPar
Функция потерь работает таким же образом, как и в полностью классических сетях, так как оптимизация происходит на классическом железе. Единственное, что отличается, – это объединение квантовых и классических градиентов. Градиент по нашей квантовой схеме получается при помощи замера состояния, которое может варьироваться из\sphinxhyphen{}за вероятностной природы кубита, поэтому несколько замеров позволяют аппроксимировать ожидаемый градиент при помощи методов вроде {\hyperref[\detokenize{book/grads/ru/gradients::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{finite differences}}}} или {\hyperref[\detokenize{book/grads/ru/hogradients::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{parameter\sphinxhyphen{}shift}}}}, после чего остаётся только совместить его с классическим градиентом.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[height=400\sphinxpxdimen]{{qnngrads}.png}
\caption{Распространение градиентов от функции потерь в гибридной схеме.}\label{\detokenize{book/qnn/ru/qnn:grads}}\end{figure}


\section{Сеть от начала до конца}
\label{\detokenize{book/qnn/ru/qnn:id11}}
\sphinxAtStartPar
В конечном итоге мы имеем следующую последовательность действий для того, чтобы собрать гибридную нейронную сеть:
\begin{itemize}
\item {} 
\sphinxAtStartPar
трансформировать данные из классических в квантовые представления;

\item {} 
\sphinxAtStartPar
отправить эти данные для вычисления на квантовой схеме;

\item {} 
\sphinxAtStartPar
просэмплировать и замерить результат квантовой схемы;

\item {} 
\sphinxAtStartPar
отправить результаты для вычисления на классической схеме;

\item {} 
\sphinxAtStartPar
оценить ошибку, рассчитать градиенты и обновить параметры.

\end{itemize}


\section{Что мы узнали из лекции}
\label{\detokenize{book/qnn/ru/qnn:id12}}\begin{itemize}
\item {} 
\sphinxAtStartPar
В ближайшие годы полностью квантовые нейронные сети не смогут решать задачи целиком, поэтому будут использоваться в качестве составляющей гибридного квантово\sphinxhyphen{}классического решения.

\item {} 
\sphinxAtStartPar
Так же как и для полностью квантовых сетей, гибридные сети позволяют уменьшить количество необходимых параметров по сравнению с полностью классическими сетями.

\item {} 
\sphinxAtStartPar
Обучение подобных сетей практически идентично обучению классических сетей за исключением нескольких трюков, необходимых для работы с параметрами квантовых схем.

\end{itemize}

\sphinxstepscope


\chapter{Сверточные вариационные квантовые схемы}
\label{\detokenize{book/qnn/ru/qconv:qconv}}\label{\detokenize{book/qnn/ru/qconv:id1}}\label{\detokenize{book/qnn/ru/qconv::doc}}
\sphinxAtStartPar
Автор(ы):
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/belgraviton}{Петров Вадим}

\end{itemize}


\section{Описание лекции}
\label{\detokenize{book/qnn/ru/qconv:id2}}
\sphinxAtStartPar
На этой лекции мы рассмотрим аналог сверточных слоев нейронной сети и приведем пример их использования. Лекция расскажет:
\begin{itemize}
\item {} 
\sphinxAtStartPar
как работают “классические” свертки в нейронных сетях;

\item {} 
\sphinxAtStartPar
что такое сверточные вариационные квантовые схемы;

\item {} 
\sphinxAtStartPar
как их можно использовать для задач машинного обучения на примере датасета MNIST.

\end{itemize}


\section{Сверточные нейронные сети}
\label{\detokenize{book/qnn/ru/qconv:id3}}
\sphinxAtStartPar
Данный тип нейронных сетей нацелен на обработку изображений и представляет из себя последовательный набор \sphinxcode{\sphinxupquote{сверточных слоев}}, чередующиеся с другими вспомогательными слоями, например, с функциями нелинейного преобразования (активациями). Пример работы \sphinxcode{\sphinxupquote{сверточного слоя}} представлен на рисунке ниже.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{2D_Convolution_Animation}.png}
\caption{Классическая свертка}\label{\detokenize{book/qnn/ru/qconv:d-convolution-animation}}\end{figure}

\sphinxAtStartPar
Свое название \sphinxcode{\sphinxupquote{сверточный слой}} получил из\sphinxhyphen{}за наличия операции свертки (конволюции), суть которой в том, что каждый фрагмент входного изображения (input) умножается на матрицу (ядро размера 3х3, kernel) свертки поэлементно, а результат суммируется и записывается в аналогичную позицию выходного изображения (output).

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Сверточные слои}} являются ключевыми элементами алгоритмов по распознаванию и классификации изображений. Большинство успехов в области компьютерного зрения за последнее десятилетие связано именно с ними.


\section{Квантовая свертка}
\label{\detokenize{book/qnn/ru/qconv:id4}}
\sphinxAtStartPar
Активное развитие квантовых вычислений создает запрос на построение квантового аналога светки. Работа \sphinxhref{https://arxiv.org/abs/1904.04767}{(Henderson M. et.al., 2019)}, описывающая подобный подход, предлагает следующую схему реализации на основе вариационных квантовых схем:
\begin{itemize}
\item {} 
\sphinxAtStartPar
изображение разбивается на блоки размера 2х2;

\item {} 
\sphinxAtStartPar
для каждого блока осуществляется кодирование входного сигнала к квантовому состоянию, которое в данной лекции осуществляется параметризованным вращением кубита из основного состояния;

\item {} 
\sphinxAtStartPar
квантовые вычисления выполняются над входными кубитами посредством случайной квантовой цепи;

\item {} 
\sphinxAtStartPar
проводится измерение квантовой системы для получения классических величин;

\item {} 
\sphinxAtStartPar
выполняя данную процедуру для всех 2х2 областей на выходе получается многоканальное изображение (четырехканальное на примере ниже), которое будет использоваться в следующих слоях классической или квантовой нейронной сети.

\end{itemize}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=700\sphinxpxdimen]{{qconv_net4}.png}
\caption{Квантовая свертка}\label{\detokenize{book/qnn/ru/qconv:qconv-net4}}\end{figure}

\sphinxAtStartPar
Основное отличие по отношению к классической свертке состоит в том, что квантовая схема может генерировать очень сложные ядра, вычисления которых могут быть классически невоспроизводимыми. Указанные сложные ядра, а именно ядра в высокоразмерном пространстве Гильберта, могут дать преимущества квантовым сверткам по отношению к классическим.

\sphinxAtStartPar
Пример реализации и работы такого блока квантовой свертки будет продемонстрирован ниже.


\section{Подготовка модели и данных}
\label{\detokenize{book/qnn/ru/qconv:id5}}
\sphinxAtStartPar
Пример кода реализации гибридной квантово\sphinxhyphen{}классической сети с квантовым сверточным слоем взят из \sphinxhref{https://pennylane.ai/qml/demos/tutorial\_quanvolution.html}{документации} библиотеки \sphinxcode{\sphinxupquote{PennyLane}} с небольшими изменениями.

\sphinxAtStartPar
Сначала загружаем библиотеки \sphinxcode{\sphinxupquote{PennyLane}} для квантовых вычислений, \sphinxcode{\sphinxupquote{tensorflow}} для обучения классификатора и \sphinxcode{\sphinxupquote{matplotlib}} для отрисовки результатов.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{pennylane} \PYG{k}{as} \PYG{n+nn}{qml}
\PYG{k+kn}{from} \PYG{n+nn}{pennylane} \PYG{k+kn}{import} \PYG{n}{numpy} \PYG{k}{as} \PYG{n}{np}
\PYG{k+kn}{from} \PYG{n+nn}{pennylane}\PYG{n+nn}{.}\PYG{n+nn}{templates} \PYG{k+kn}{import} \PYG{n}{RandomLayers}

\PYG{k+kn}{import} \PYG{n+nn}{os}
\PYG{n}{os}\PYG{o}{.}\PYG{n}{environ}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{TF\PYGZus{}CPP\PYGZus{}MIN\PYGZus{}LOG\PYGZus{}LEVEL}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{2}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{k+kn}{import} \PYG{n+nn}{tensorflow} \PYG{k}{as} \PYG{n+nn}{tf}
\PYG{k+kn}{from} \PYG{n+nn}{tensorflow} \PYG{k+kn}{import} \PYG{n}{keras}

\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{o}{\PYGZpc{}}\PYG{k}{config} InlineBackend.figure\PYGZus{}format = \PYGZsq{}retina\PYGZsq{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Устанавливаем параметры модели для обучения: число эпох, число слоев квантовой свертки и его выходных каналов, а также число тренировочных и тестовых примеров. Нужно использовать 4 кубита, для обработки каждого из 4 пикселей входного блока и генерации 4 каналов.  Число примеров выбрано малым для увеличения скорости демонстрации. Также фиксируем инициализацию генераторов случайных чисел для \sphinxcode{\sphinxupquote{numpy}} и \sphinxcode{\sphinxupquote{tensorflow}}.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{n\PYGZus{}epochs} \PYG{o}{=} \PYG{l+m+mi}{20}   \PYG{c+c1}{\PYGZsh{} Количество эпох обучения}
\PYG{n}{n\PYGZus{}layers} \PYG{o}{=} \PYG{l+m+mi}{1}    \PYG{c+c1}{\PYGZsh{} Число случайных квантовых блоков}
\PYG{n}{n\PYGZus{}wires} \PYG{o}{=} \PYG{l+m+mi}{4}     \PYG{c+c1}{\PYGZsh{} Число выходных каналов после квантовых блоков}
\PYG{n}{n\PYGZus{}train} \PYG{o}{=} \PYG{l+m+mi}{20}    \PYG{c+c1}{\PYGZsh{} Размер тренировочного датасета}
\PYG{n}{n\PYGZus{}test} \PYG{o}{=} \PYG{l+m+mi}{10}     \PYG{c+c1}{\PYGZsh{} Размер тестового датасета}

\PYG{c+c1}{\PYGZsh{} Инициализация генераторов случайных чисел}
\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{seed}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}  
\PYG{n}{tf}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{set\PYGZus{}seed}\PYG{p}{(}\PYG{l+m+mi}{255}\PYG{p}{)}  
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Для демонстрации используем датасет MNIST, который создан для предсказания цифры (от 0 до  9) по его изображению

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mnist\PYGZus{}dataset} \PYG{o}{=} \PYG{n}{keras}\PYG{o}{.}\PYG{n}{datasets}\PYG{o}{.}\PYG{n}{mnist}
\PYG{p}{(}\PYG{n}{train\PYGZus{}images}\PYG{p}{,} \PYG{n}{train\PYGZus{}labels}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{n}{test\PYGZus{}images}\PYG{p}{,} \PYG{n}{test\PYGZus{}labels}\PYG{p}{)} \PYG{o}{=} \PYG{n}{mnist\PYGZus{}dataset}\PYG{o}{.}\PYG{n}{load\PYGZus{}data}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Ограничение размера датасета}
\PYG{n}{train\PYGZus{}images} \PYG{o}{=} \PYG{n}{train\PYGZus{}images}\PYG{p}{[}\PYG{p}{:}\PYG{n}{n\PYGZus{}train}\PYG{p}{]}
\PYG{n}{train\PYGZus{}labels} \PYG{o}{=} \PYG{n}{train\PYGZus{}labels}\PYG{p}{[}\PYG{p}{:}\PYG{n}{n\PYGZus{}train}\PYG{p}{]}
\PYG{n}{test\PYGZus{}images} \PYG{o}{=} \PYG{n}{test\PYGZus{}images}\PYG{p}{[}\PYG{p}{:}\PYG{n}{n\PYGZus{}test}\PYG{p}{]}
\PYG{n}{test\PYGZus{}labels} \PYG{o}{=} \PYG{n}{test\PYGZus{}labels}\PYG{p}{[}\PYG{p}{:}\PYG{n}{n\PYGZus{}test}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} Нормализация изображений из диапазона (0, 255) в (0, 1)}
\PYG{n}{train\PYGZus{}images} \PYG{o}{=} \PYG{n}{train\PYGZus{}images} \PYG{o}{/} \PYG{l+m+mi}{255}
\PYG{n}{test\PYGZus{}images} \PYG{o}{=} \PYG{n}{test\PYGZus{}images} \PYG{o}{/} \PYG{l+m+mi}{255}

\PYG{c+c1}{\PYGZsh{} Добавление дополнительной размерности к данным для сверточных каналов}
\PYG{n}{train\PYGZus{}images} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{train\PYGZus{}images}\PYG{p}{[}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,} \PYG{n}{tf}\PYG{o}{.}\PYG{n}{newaxis}\PYG{p}{]}\PYG{p}{,} \PYG{n}{requires\PYGZus{}grad}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}
\PYG{n}{test\PYGZus{}images} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{test\PYGZus{}images}\PYG{p}{[}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,} \PYG{n}{tf}\PYG{o}{.}\PYG{n}{newaxis}\PYG{p}{]}\PYG{p}{,} \PYG{n}{requires\PYGZus{}grad}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Downloading data from https://storage.googleapis.com/tensorflow/tf\PYGZhy{}keras\PYGZhy{}datasets/mnist.npz

   16384/11490434 [..............................] \PYGZhy{} ETA: 0s
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]

 4096000/11490434 [=========\PYGZgt{}....................] \PYGZhy{} ETA: 0s
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]

 4202496/11490434 [=========\PYGZgt{}....................] \PYGZhy{} ETA: 0s
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]

11493376/11490434 [==============================] \PYGZhy{} 0s 0us/step
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]

11501568/11490434 [==============================] \PYGZhy{} 0s 0us/step
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Случайная квантовая цепь}
\label{\detokenize{book/qnn/ru/qconv:id6}}
\sphinxAtStartPar
В качестве блока квантовой свертки используется \sphinxstylestrong{случайная квантовая цепь} (RandomLayers в \sphinxcode{\sphinxupquote{PennyLane}}). Блок реализуется путем случайного выбора для части кубитов операций вращения, а для части пар кубитов парных квантовых гейтов. На последнем этапе генерации блока осуществляется случайное перемешивание очередности применения операций.

\sphinxAtStartPar
В нашем примере случайная квантовая цепь обрабатывает 4 кубита. Таким образом часть из 4 кубитов получит какие\sphinxhyphen{}либо операции вращения, а часть из 6 пар кубитов \sphinxhyphen{} гейты. Финальная очередность операций будет случайной.

\sphinxAtStartPar
Следует заметить, что в нашем примере используется фиксированный (необучаемый) блок случайной квантовой цепи. Он будет использован как блок препроцессинга. В будущем, когда в библиотеке будет реализована возможность расчета градиентов и изменения параметров блока на их основании, указанный блок тоже можно будет обучать.


\section{Реализация квантовой свертки}
\label{\detokenize{book/qnn/ru/qconv:id7}}
\sphinxAtStartPar
Далее создаем устройство, симулирующее работу 4 кубитов. Оно состоит из трех частей:
\begin{itemize}
\item {} 
\sphinxAtStartPar
кодировщик, преобразующий входные данные в квантовые состояния с помощью \(RY\) поворотов;

\item {} 
\sphinxAtStartPar
случайная квантовая цепь;

\item {} 
\sphinxAtStartPar
измерения, дающие 4 выходных значения.

\end{itemize}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{dev} \PYG{o}{=} \PYG{n}{qml}\PYG{o}{.}\PYG{n}{device}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{default.qubit}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{wires}\PYG{o}{=}\PYG{n}{n\PYGZus{}wires}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Генерация значений параметров для квантовых слоев}
\PYG{n}{rand\PYGZus{}params} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{uniform}\PYG{p}{(}\PYG{n}{high}\PYG{o}{=}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{p}{,} \PYG{n}{size}\PYG{o}{=}\PYG{p}{(}\PYG{n}{n\PYGZus{}layers}\PYG{p}{,} \PYG{n}{n\PYGZus{}wires}\PYG{p}{)}\PYG{p}{)}

\PYG{n+nd}{@qml}\PYG{o}{.}\PYG{n}{qnode}\PYG{p}{(}\PYG{n}{dev}\PYG{p}{)}
\PYG{k}{def} \PYG{n+nf}{circuit}\PYG{p}{(}\PYG{n}{phi}\PYG{p}{)}\PYG{p}{:}
    \PYG{c+c1}{\PYGZsh{} Кодирование 4 классических входных данных}
    \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n\PYGZus{}wires}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{qml}\PYG{o}{.}\PYG{n}{RY}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi} \PYG{o}{*} \PYG{n}{phi}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{,} \PYG{n}{wires}\PYG{o}{=}\PYG{n}{j}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} Случайная квантовая цепь}
    \PYG{n}{RandomLayers}\PYG{p}{(}\PYG{n}{rand\PYGZus{}params}\PYG{p}{,} \PYG{n}{wires}\PYG{o}{=}\PYG{n+nb}{list}\PYG{p}{(}\PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n\PYGZus{}wires}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} Измерения, которые дают 4 классических выходных значений для следующих слоев}
    \PYG{k}{return} \PYG{p}{[}\PYG{n}{qml}\PYG{o}{.}\PYG{n}{expval}\PYG{p}{(}\PYG{n}{qml}\PYG{o}{.}\PYG{n}{PauliZ}\PYG{p}{(}\PYG{n}{j}\PYG{p}{)}\PYG{p}{)} \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n\PYGZus{}wires}\PYG{p}{)}\PYG{p}{]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Следующая функция \sphinxcode{\sphinxupquote{quanv}} определяет квантовую свертку по следующей схеме:
\begin{itemize}
\item {} 
\sphinxAtStartPar
разделение изображения на блоки 2х2 пикселей;

\item {} 
\sphinxAtStartPar
обработку каждого блока квантовой цепью \sphinxcode{\sphinxupquote{circuit}}, описанной выше;

\item {} 
\sphinxAtStartPar
4 выходных значения для каждого блока помещаются в 4 разных канала одного пикселя выходного изображения.

\end{itemize}

\sphinxAtStartPar
Описанный выше процесс уменьшает разрешение входного изображения в 2 раза, что эквивалентно классической свертки с ядром 2х2 и шагом 2

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{quanv}\PYG{p}{(}\PYG{n}{image}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Функция квантовой свертки над входным изображением.\PYGZdq{}\PYGZdq{}\PYGZdq{}}

    \PYG{n}{out} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{14}\PYG{p}{,} \PYG{l+m+mi}{14}\PYG{p}{,} \PYG{n}{n\PYGZus{}wires}\PYG{p}{)}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} Циклы по координатам верхнего левого пикселя блоков 2х2}
    \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{28}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{28}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{:}
            \PYG{c+c1}{\PYGZsh{} Обработка блока 2x2 из изображения квантовой цепью}
            \PYG{n}{q\PYGZus{}results} \PYG{o}{=} \PYG{n}{circuit}\PYG{p}{(}
                \PYG{p}{[}
                    \PYG{n}{image}\PYG{p}{[}\PYG{n}{j}\PYG{p}{,} \PYG{n}{k}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
                    \PYG{n}{image}\PYG{p}{[}\PYG{n}{j}\PYG{p}{,} \PYG{n}{k} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
                    \PYG{n}{image}\PYG{p}{[}\PYG{n}{j} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{k}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
                    \PYG{n}{image}\PYG{p}{[}\PYG{n}{j} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{k} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}
                \PYG{p}{]}
            \PYG{p}{)}
            \PYG{c+c1}{\PYGZsh{} Запись результатов наблюдения в выходной пиксель (j/2, k/2)}
            \PYG{k}{for} \PYG{n}{c} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n\PYGZus{}wires}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{out}\PYG{p}{[}\PYG{n}{j} \PYG{o}{/}\PYG{o}{/} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{k} \PYG{o}{/}\PYG{o}{/} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{c}\PYG{p}{]} \PYG{o}{=} \PYG{n}{q\PYGZus{}results}\PYG{p}{[}\PYG{n}{c}\PYG{p}{]}
    \PYG{k}{return} \PYG{n}{out}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\section{Подготовка датасета}
\label{\detokenize{book/qnn/ru/qconv:id8}}
\sphinxAtStartPar
Так как квантовый сверточный слой в нашем случае не обучается, то лучше провести предварительную обработку им всех используемых изображений из датасета. Подготовленные данные будут использоваться классической нейронной сетью для обучения модели классификатора.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{q\PYGZus{}train\PYGZus{}images} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{idx}\PYG{p}{,} \PYG{n}{img} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{train\PYGZus{}images}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{q\PYGZus{}train\PYGZus{}images}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{quanv}\PYG{p}{(}\PYG{n}{img}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{q\PYGZus{}train\PYGZus{}images} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{asarray}\PYG{p}{(}\PYG{n}{q\PYGZus{}train\PYGZus{}images}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Препроцессинг тренировочных изображений квантовой сверткой выполнен.}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{n}{q\PYGZus{}test\PYGZus{}images} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{idx}\PYG{p}{,} \PYG{n}{img} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{test\PYGZus{}images}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{q\PYGZus{}test\PYGZus{}images}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{quanv}\PYG{p}{(}\PYG{n}{img}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{q\PYGZus{}test\PYGZus{}images} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{asarray}\PYG{p}{(}\PYG{n}{q\PYGZus{}test\PYGZus{}images}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Препроцессинг тестовых изображений квантовой сверткой выполнен.}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Препроцессинг тренировочных изображений квантовой сверткой выполнен.
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Препроцессинг тестовых изображений квантовой сверткой выполнен.
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Давайте посмотрим на 4 первых тренировочных примера (первый ряд) и их 4 канала подготовленных данных (2\sphinxhyphen{}5 строки)

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{n\PYGZus{}samples} \PYG{o}{=} \PYG{l+m+mi}{4}
\PYG{n}{n\PYGZus{}channels} \PYG{o}{=} \PYG{n}{n\PYGZus{}wires}
\PYG{n}{fig}\PYG{p}{,} \PYG{n}{axes} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{+} \PYG{n}{n\PYGZus{}channels}\PYG{p}{,} \PYG{n}{n\PYGZus{}samples}\PYG{p}{,} \PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n\PYGZus{}samples}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{axes}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Input}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{k}{if} \PYG{n}{k} \PYG{o}{!=} \PYG{l+m+mi}{0}\PYG{p}{:}
        \PYG{n}{axes}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{k}\PYG{p}{]}\PYG{o}{.}\PYG{n}{yaxis}\PYG{o}{.}\PYG{n}{set\PYGZus{}visible}\PYG{p}{(}\PYG{k+kc}{False}\PYG{p}{)}
    \PYG{n}{axes}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{k}\PYG{p}{]}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{train\PYGZus{}images}\PYG{p}{[}\PYG{n}{k}\PYG{p}{,} \PYG{p}{:}\PYG{p}{,} \PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{cmap}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{gray}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} Отрисовка}
    \PYG{k}{for} \PYG{n}{c} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n\PYGZus{}channels}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{axes}\PYG{p}{[}\PYG{n}{c} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylabel}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Output [ch. }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{c}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{]}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{k}{if} \PYG{n}{k} \PYG{o}{!=} \PYG{l+m+mi}{0}\PYG{p}{:}
            \PYG{n}{axes}\PYG{p}{[}\PYG{n}{c}\PYG{p}{,} \PYG{n}{k}\PYG{p}{]}\PYG{o}{.}\PYG{n}{yaxis}\PYG{o}{.}\PYG{n}{set\PYGZus{}visible}\PYG{p}{(}\PYG{k+kc}{False}\PYG{p}{)}
        \PYG{n}{axes}\PYG{p}{[}\PYG{n}{c} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{k}\PYG{p}{]}\PYG{o}{.}\PYG{n}{imshow}\PYG{p}{(}\PYG{n}{q\PYGZus{}train\PYGZus{}images}\PYG{p}{[}\PYG{n}{k}\PYG{p}{,} \PYG{p}{:}\PYG{p}{,} \PYG{p}{:}\PYG{p}{,} \PYG{n}{c}\PYG{p}{]}\PYG{p}{,} \PYG{n}{cmap}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{gray}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{tight\PYGZus{}layout}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{qconv_13_0}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
По обработанным данным (последние 4 ряда) видно уменьшение разрешения в 2 раза, а также то, что пространственная структура цифр сохраняется, что и должно наблюдаться для сверточных слоев


\section{Гибридная квантово\sphinxhyphen{}классическая модель}
\label{\detokenize{book/qnn/ru/qconv:id9}}
\sphinxAtStartPar
Ниже опишем классическую часть нейронной сети, которая будет обучена для классификации 10 цифр. Будет использована очень простая модель, основанная на одном полносвязном слое и финальном применении функции softmax, которая выдает вероятности представленных 10 классов.

\sphinxAtStartPar
Обучение будет осуществлено с помощью оптимизатора \sphinxcode{\sphinxupquote{Adam}} по функции потерь, в качестве которой используется кросс\sphinxhyphen{}энтропия.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{MyModel}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Функция инициализирует и возвращает keras модель, готовая к обучению\PYGZdq{}\PYGZdq{}\PYGZdq{}}

    \PYG{n}{model} \PYG{o}{=} \PYG{n}{keras}\PYG{o}{.}\PYG{n}{models}\PYG{o}{.}\PYG{n}{Sequential}\PYG{p}{(}\PYG{p}{[}
        \PYG{n}{keras}\PYG{o}{.}\PYG{n}{layers}\PYG{o}{.}\PYG{n}{Flatten}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
        \PYG{n}{keras}\PYG{o}{.}\PYG{n}{layers}\PYG{o}{.}\PYG{n}{Dense}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{activation}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{softmax}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{p}{]}\PYG{p}{)}

    \PYG{n}{model}\PYG{o}{.}\PYG{n}{compile}\PYG{p}{(}
        \PYG{n}{optimizer}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{adam}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
        \PYG{n}{loss}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{sparse\PYGZus{}categorical\PYGZus{}crossentropy}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
        \PYG{n}{metrics}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{accuracy}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,}
    \PYG{p}{)}
    \PYG{k}{return} \PYG{n}{model}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\section{Тренировка моделей}
\label{\detokenize{book/qnn/ru/qconv:id10}}
\sphinxAtStartPar
Сначала обучим модель на данных, подготовленных с помощью квантовой цепи.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{q\PYGZus{}model} \PYG{o}{=} \PYG{n}{MyModel}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{q\PYGZus{}history} \PYG{o}{=} \PYG{n}{q\PYGZus{}model}\PYG{o}{.}\PYG{n}{fit}\PYG{p}{(}
    \PYG{n}{q\PYGZus{}train\PYGZus{}images}\PYG{p}{,}
    \PYG{n}{train\PYGZus{}labels}\PYG{p}{,}
    \PYG{n}{validation\PYGZus{}data}\PYG{o}{=}\PYG{p}{(}\PYG{n}{q\PYGZus{}test\PYGZus{}images}\PYG{p}{,} \PYG{n}{test\PYGZus{}labels}\PYG{p}{)}\PYG{p}{,}
    \PYG{n}{batch\PYGZus{}size}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{,}
    \PYG{n}{epochs}\PYG{o}{=}\PYG{n}{n\PYGZus{}epochs}\PYG{p}{,}
    \PYG{n}{verbose}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,}
\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Для сравнения с результатами чисто классической модели проведем ее обучение на входных необработанных картинках.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{c\PYGZus{}model} \PYG{o}{=} \PYG{n}{MyModel}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{c\PYGZus{}history} \PYG{o}{=} \PYG{n}{c\PYGZus{}model}\PYG{o}{.}\PYG{n}{fit}\PYG{p}{(}
    \PYG{n}{train\PYGZus{}images}\PYG{p}{,}
    \PYG{n}{train\PYGZus{}labels}\PYG{p}{,}
    \PYG{n}{validation\PYGZus{}data}\PYG{o}{=}\PYG{p}{(}\PYG{n}{test\PYGZus{}images}\PYG{p}{,} \PYG{n}{test\PYGZus{}labels}\PYG{p}{)}\PYG{p}{,}
    \PYG{n}{batch\PYGZus{}size}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{,}
    \PYG{n}{epochs}\PYG{o}{=}\PYG{n}{n\PYGZus{}epochs}\PYG{p}{,}
    \PYG{n}{verbose}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,}
\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\section{Сравнение результатов}
\label{\detokenize{book/qnn/ru/qconv:id11}}
\sphinxAtStartPar
Сравнение проведем на основе тестовой точности и значению функции потерь в зависимости от номера эпохи

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{style}\PYG{o}{.}\PYG{n}{use}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{seaborn}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{fig}\PYG{p}{,} \PYG{p}{(}\PYG{n}{ax1}\PYG{p}{,} \PYG{n}{ax2}\PYG{p}{)} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{ax1}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{q\PYGZus{}history}\PYG{o}{.}\PYG{n}{history}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{val\PYGZus{}accuracy}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}ob}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{With quantum layer}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{ax1}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{c\PYGZus{}history}\PYG{o}{.}\PYG{n}{history}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{val\PYGZus{}accuracy}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}og}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Without quantum layer}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{ax1}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Accuracy}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{ax1}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylim}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{ax1}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Epoch}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{ax1}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{ax2}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{q\PYGZus{}history}\PYG{o}{.}\PYG{n}{history}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{val\PYGZus{}loss}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}ob}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{With quantum layer}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{ax2}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{c\PYGZus{}history}\PYG{o}{.}\PYG{n}{history}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{val\PYGZus{}loss}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}og}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Without quantum layer}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{ax2}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Loss}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{ax2}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylim}\PYG{p}{(}\PYG{n}{top}\PYG{o}{=}\PYG{l+m+mf}{2.5}\PYG{p}{)}
\PYG{n}{ax2}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Epoch}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{ax2}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{tight\PYGZus{}layout}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
/tmp/ipykernel\PYGZus{}2142/1050205299.py:1: MatplotlibDeprecationWarning: The seaborn styles shipped by Matplotlib are deprecated since 3.6, as they no longer correspond to the styles shipped by seaborn. However, they will remain available as \PYGZsq{}seaborn\PYGZhy{}v0\PYGZus{}8\PYGZhy{}\PYGZlt{}style\PYGZgt{}\PYGZsq{}. Alternatively, directly use the seaborn API instead.
  plt.style.use(\PYGZdq{}seaborn\PYGZdq{})
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{qconv_21_1}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Из рисунков видно наличие сильного сходства результатов для двух моделей: гибридной и чисто классической. В наших малых экспериментах достигнута довольно низкая точность в 50\% (классический аналог \sphinxhyphen{} 40\%). Однако при увеличении числа используемых примеров точность должна быть существенно выше.


\section{Замечания}
\label{\detokenize{book/qnn/ru/qconv:id12}}\begin{itemize}
\item {} 
\sphinxAtStartPar
в статье авторов подхода \sphinxhref{https://arxiv.org/abs/1904.04767}{(Henderson M. et.al., 2019)} для гибридной и чисто классической сети с большим количеством слоев (см. схему сети) и большим объемом данных, достигнута ожидаемая высокая точность выше 95\%;

\item {} 
\sphinxAtStartPar
блоки квантовой свертки сейчас особо интересны, так как они ориентированы на использование малого количества кубитов, которое доступно в текущий период времени для устройств с промежуточным количеством кубитов (NISQ).

\end{itemize}


\section{Что мы узнали из лекции}
\label{\detokenize{book/qnn/ru/qconv:id13}}\begin{itemize}
\item {} 
\sphinxAtStartPar
существует аналог сверточных нейронных сетей для квантовых вычислений;

\item {} 
\sphinxAtStartPar
аналог квантовой свертки может быть реализован с использованием случайной квантовой цепи;

\item {} 
\sphinxAtStartPar
использование квантовой свертки позволяет достичь результатов схожих с классическими сетями;

\item {} 
\sphinxAtStartPar
основное преимущество квантовой свертки по отношению к классической в том, что первая является более широкой операцией, которая не может быть описана классическим случаем.

\end{itemize}

\sphinxstepscope


\part{Проблемы квантового машинного обучения}

\sphinxstepscope


\chapter{О блоке “Проблемы квантового машинного обучения”}
\label{\detokenize{book/problems/ru/problems_intro:problems-intro}}\label{\detokenize{book/problems/ru/problems_intro:id1}}\label{\detokenize{book/problems/ru/problems_intro::doc}}
\sphinxAtStartPar
Этот блок будет полностью посвящен описанию тех задач реального мира, для которых использование квантового машинного обучения на NISQ\sphinxhyphen{}компьютерах выглядит наиболее перспективно.

\sphinxAtStartPar
Тут мы рассмотрим:
\begin{itemize}
\item {} 
\sphinxAtStartPar
основы квантовой химии;

\item {} 
\sphinxAtStartPar
модель Изинга;

\item {} 
\sphinxAtStartPar
задачи комбинаторной оптимизации.

\end{itemize}

\sphinxAtStartPar
Продвинутые темы блока более подробно расскажут об этих темах.

\sphinxstepscope


\chapter{Квантовая химия. Введение.}
\label{\detokenize{book/problems/ru/quantchembasic:quantchembasic}}\label{\detokenize{book/problems/ru/quantchembasic:id1}}\label{\detokenize{book/problems/ru/quantchembasic::doc}}
\sphinxAtStartPar
Автор(ы):
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/zimka}{Зимка Борис}

\end{itemize}


\section{Описание лекции}
\label{\detokenize{book/problems/ru/quantchembasic:id2}}
\sphinxAtStartPar
Из этой лекции узнаем:
\begin{itemize}
\item {} 
\sphinxAtStartPar
что такое квантовая химия, что с ее помощью можно сделать, а что – нельзя;

\item {} 
\sphinxAtStartPar
как устроена самая простая теория, описывающая квантовую физику атома;

\item {} 
\sphinxAtStartPar
какие у этой теории есть ограничения.

\end{itemize}


\section{Введение}
\label{\detokenize{book/problems/ru/quantchembasic:id3}}
\sphinxAtStartPar
В предыдущих лекциях говорили о применении квантовой механики для вычислений и обработки информации. Однако, исторически квантовая теория развивалась в первую очередь из\sphinxhyphen{}за того, что классическая физика не могла объяснить некоторые наблюдаемые эффекты: дискретный спектр излучения атомов, фотоэффект в металлах, интерференцию частиц на дифракционных щелях.

\sphinxAtStartPar
Считается, что квантовая механика дает полное и точное описание состояния и эволюции любой системы при нерелятивистских условиях – по крайней мере, на сегодняшний день этому нет экспериментальных или теоретических противоречий. Это значит, что в теории возможно для любой системы частиц записать уравнения Шредингера, решить их и предсказать, как себя поведет система. Между тем, на практике оказывается, что в реальных задачах вроде моделирования лекарств и материалов, просто “взять и посчитать” – задача весьма сложная, а иногда – неразрешимая.

\sphinxAtStartPar
Проблемами применения квантовой механики к химии и материаловедению занимается квантовая химия. Она делает это уже около 100 лет, по теме написаны толстые книжки с многоэтажными формулами, так что в лекции будут даны основы и простые примеры без полного вывода.

\sphinxAtStartPar
Предполагается, что читатель знаком с уравнением Шредингера и основными операторами (импульса, эволюции), бра\sphinxhyphen{}кет нотацией, а также помнит основы физики и химии на уровне старших классов школы.


\section{Атом водорода}
\label{\detokenize{book/problems/ru/quantchembasic:id4}}

\subsection{В чем проблема?}
\label{\detokenize{book/problems/ru/quantchembasic:id5}}
\sphinxAtStartPar
Спектр излучения и поглощения атомов – то есть на какой длине волны происходит поглощение и излучение света веществом – был одной из первых “нерешаемых” проблем, приведших в итоге к появлению квантовой физики. Для \sphinxhref{https://ru.wikipedia.org/wiki/\%D0\%9F\%D1\%80\%D0\%BE\%D1\%81\%D1\%82\%D1\%8B\%D0\%B5\_\%D0\%B2\%D0\%B5\%D1\%89\%D0\%B5\%D1\%81\%D1\%82\%D0\%B2\%D0\%B0}{простых веществ} в газообразной форме спектр является дискретным, и для атома водорода спектры поглощения и излучения в видимом диапазоне выглядят так:

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{HydrogenSpectrum}.png}
\caption{Спектр поглощения и излучения водорода в видимом диапазоне}\label{\detokenize{book/problems/ru/quantchembasic:hydrogenspectrum}}\end{figure}

\sphinxAtStartPar
В конце 19 века было уже известно, что атом водорода состоит из двух заряженных частиц – протона и электрона, но из классической физики следовало, что спектр излучения такой системы должен быть непрерывным, что никак не стыковалось с наблюдениями (дискретные линии на графике). Попробуем вслед за исследователями квантовой физики начала 20 века разобраться с этой проблемой.

\begin{sphinxadmonition}{note}{Про имена}

\sphinxAtStartPar
“Квантовая физика” и “квантовая механика” – связанные понятия, но не тождественные.

\sphinxAtStartPar
Квантовая механика – это теория (а точнее, множество теорий с различающимися терминологиями), в основе которой лежит аксиоматика о том, что сущности описываются волновыми функциями, что они эволюционируют и, что зная эти функции, можно посчитать физические величины – например, энергию.

\sphinxAtStartPar
Квантовая физика – это область физики, исследующая квантовые эффекты, при этом она местами может не иметь строгого обоснования – лишь бы предсказания работали.

\sphinxAtStartPar
С квантовой химией тоже есть некоторая путаница – в двадцатом веке под ней имели в виду аналитические и численные методы решения задач квантовой механики применительно к молекулам и кристаллам. Но с развитием квантовых компьютеров эту область стали иногда называть вычислительной химией, а квантовой химией – применение квантовых компьютеров к этой области.
\end{sphinxadmonition}


\subsection{Быстрое и неправильное решение}
\label{\detokenize{book/problems/ru/quantchembasic:id6}}
\sphinxAtStartPar
Первой теорией в квантовой физике была \sphinxhref{https://ru.wikipedia.org/wiki/\%D0\%91\%D0\%BE\%D1\%80\%D0\%BE\%D0\%B2\%D1\%81\%D0\%BA\%D0\%B0\%D1\%8F\_\%D0\%BC\%D0\%BE\%D0\%B4\%D0\%B5\%D0\%BB\%D1\%8C\_\%D0\%B0\%D1\%82\%D0\%BE\%D0\%BC\%D0\%B0}{“Боровская теория”} – почти классическая теория, основанная на постулатах, разрешающих противоречия классической физики с экспериментами на уровне “хардкода”. Главный постулат заключается в том, что момент импульса может принимать только определенные дискретные значения (кванты), а не произвольные:
\begin{equation*}
\begin{split}
p \cdot r = n \cdot \hbar,
\end{split}
\end{equation*}
\sphinxAtStartPar
и отсюда
\begin{equation*}
\begin{split}
p = \frac{n \cdot \hbar}{r},
\end{split}
\end{equation*}
\sphinxAtStartPar
где \(p = mv\) – импульс электрона, \(r\) – радиус орбиты электрона, \(\hbar\) – постоянная Планка, \(n\) – любое целое число. Если применить этот постулат к атому водорода – паре из протона и электрона, то получится, что:
\begin{itemize}
\item {} 
\sphinxAtStartPar
электрон вокруг протона “летает по орбите”;

\item {} 
\sphinxAtStartPar
спектр (уровни энергии электрона) – дискретный.

\end{itemize}

\sphinxAtStartPar
Можно показать это следующим образом.

\sphinxAtStartPar
Во\sphinxhyphen{}первых, поскольку частиц две и протон имеет массу много больше массы электрона, можно перейти в почти инерциальную систему отсчета протона, где он неподвижен, и решить задачу только для электрона.

\sphinxAtStartPar
Из классической механики берем \sphinxhref{https://ru.wikipedia.org/wiki/\%D0\%92\%D0\%B8\%D1\%80\%D0\%B8\%D0\%B0\%D0\%BB}{теорему о вириале} (“для стабильной системы из двух частиц, связанных потенциальными силами, в среднем кинетическая энергия равна половине потенциальной”):
\begin{equation*}
\begin{split}
E_{k} = -E_{p} / 2 \\
E = E_{k} + E_{p} = E_{p} / 2
\end{split}
\end{equation*}
\sphinxAtStartPar
Записываем кинетическую энергию и потенциал Кулона для электрона в поле протона (в СИ):
\begin{equation*}
\begin{split}
\frac{p^2}{2m} = k \frac{e^2}{2 R},
\end{split}
\end{equation*}
\sphinxAtStartPar
где \(k\) – постоянная из закона Кулона.

\sphinxAtStartPar
Используем постулат Бора и выразим “радиус” орбиты:
\begin{equation*}
\begin{split}
\frac{n^2 \hbar^2}{2 m R^2} = k \frac{e^2}{2R} \\
R = \frac{n^2 \hbar^2}{k m e ^2}
\end{split}
\end{equation*}
\sphinxAtStartPar
Находим полную энергию:
\begin{equation}\label{equation:book/problems/ru/quantchembasic:eqn:hydroenergylevels}
\begin{split}
E = E_{p} / 2 = - \frac{k e^2}{2 R} = - \frac{k^2}{n^2} \frac{me^4}{2 \hbar^2}
\end{split}
\end{equation}
\sphinxAtStartPar
Уровни энергии пропорциональны \(\frac{1}{n^2}\) и именно \sphinxhref{https://en.wikipedia.org/wiki/Hydrogen\_spectral\_series}{такая зависимость} наблюдается в эксперименте.

\sphinxAtStartPar
Посчитаем минимальную энергию (\(n = 1\)):

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{scipy} \PYG{k+kn}{import} \PYG{n}{constants} \PYG{k}{as} \PYG{n}{consts}

\PYG{c+c1}{\PYGZsh{} постоянная кулона}
\PYG{n}{k} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{/} \PYG{p}{(}\PYG{l+m+mi}{4} \PYG{o}{*} \PYG{n}{consts}\PYG{o}{.}\PYG{n}{pi} \PYG{o}{*} \PYG{n}{consts}\PYG{o}{.}\PYG{n}{epsilon\PYGZus{}0}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} энергия в Джоулях}
\PYG{n}{E1} \PYG{o}{=} \PYG{o}{\PYGZhy{}} \PYG{n}{k}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{consts}\PYG{o}{.}\PYG{n}{m\PYGZus{}e} \PYG{o}{*} \PYG{n}{consts}\PYG{o}{.}\PYG{n}{e}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{4} \PYG{o}{/} \PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{consts}\PYG{o}{.}\PYG{n}{hbar} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} энергия в электрон\PYGZhy{}вольтах}
\PYG{n}{E1\PYGZus{}ev} \PYG{o}{=} \PYG{n}{E1} \PYG{o}{/} \PYG{n}{consts}\PYG{o}{.}\PYG{n}{e}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Hydrogen Bohr ground state energy: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{E1\PYGZus{}ev}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ eV}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Hydrogen Bohr ground state energy: \PYGZhy{}13.605693122885837 eV
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Получившийся ответ (13.6 eV) в точности совпадает с экспериментальным значением энергии ионизации водорода.

\sphinxAtStartPar
Итого: постулировав несколько очень удачных гипотез (главная – что момент импульса квантуется, то есть принимает только дискретные значения), удалось разрешить фундаментальную нестыковку между классической теорией и экспериментом: энергия стала дискретной, линии спектра (длины волн) стали обратно пропорциональны \(\left( \frac{1}{n_{final}^2} - \frac{1}{n_{initial}^2} \right)\), значения энергии ионизации совпадают с реальными измерениями.

\sphinxAtStartPar
Казалось бы, замечательно, проблема решена! Однако теория Бора имеет ряд проблем. Главная из них заключается в том, что теория работает только для “водородоподобных” атомов, то есть состоящих из ядра и одного электрона на внешней оболочке. Уже для атома гелия спектр не согласуется с боровской теорией.

\sphinxAtStartPar
Кроме того, с точки зрения науки, теория Бора – это в некоторым смысле “читерство”. Выбрав удачные постулаты и подставив соответствующие формулы в законы классической физики, получили правильный результат. Но будь постулаты другими, результат получился бы тоже другой, так что фактически постулаты Бора – это гениальная догадка, позволившая угадать правильные результаты для некоторых систем.

\sphinxstepscope


\chapter{Квантовая химия. Теория самосогласованного поля.}
\label{\detokenize{book/problems/ru/quantchemadvancedscf:quantchemadvancedscf}}\label{\detokenize{book/problems/ru/quantchemadvancedscf:id1}}\label{\detokenize{book/problems/ru/quantchemadvancedscf::doc}}
\sphinxAtStartPar
Автор(ы):
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/zimka}{Зимка Борис}

\end{itemize}


\section{Описание лекции}
\label{\detokenize{book/problems/ru/quantchemadvancedscf:id2}}
\sphinxAtStartPar
Из этой лекции узнаем:
\begin{itemize}
\item {} 
\sphinxAtStartPar
как с помощью квантовой химии предсказать спектр атома водорода “из первых принципов”;

\item {} 
\sphinxAtStartPar
как посчитать энергию атома с помощью Python;

\item {} 
\sphinxAtStartPar
какие бывают волновые функции электронов и как их вычислять методом Self\sphinxhyphen{}Consistent Field;

\item {} 
\sphinxAtStartPar
как посчитать энергию спирта.

\end{itemize}


\subsection{Введение}
\label{\detokenize{book/problems/ru/quantchemadvancedscf:id3}}
\sphinxAtStartPar
Боровская теория оказалось недостаточной для описания таких сложных систем, как молекулы или не\sphinxhyphen{}водородоподобные атомы. В этой лекции разберемся с теорией самосогласованного поля – это один из первых вычислительных методов квантовой химии, пригодный на практике для моделирования разных систем (атомов, молекул, кристаллов).

\sphinxAtStartPar
Несмотря на то, что основа метода была разработана чуть ли не сто лет назад, он активно используется и сегодня, особенно с различными модификациями и дополнениями.


\subsection{Что мы ищем?}
\label{\detokenize{book/problems/ru/quantchemadvancedscf:id4}}
\sphinxAtStartPar
С точки зрения квантовой химии, чаще всего хотим для произвольного набора частиц (атомов для молекулы или кристалла, протонов и электронов для атома) с известным потенциалом взаимодействия предсказывать стационарное состояние, т.е. находить стационарные волновые функции всех частиц системы. Квантовая механика постулирует, что для любой наблюдаемой физической величины существует оператор, которым можем подействовать на волновую функцию и получить измеренное значение этой величины.

\sphinxAtStartPar
Например, если волновые функции электронов и ядер в кристалле известны, то можно предсказать теплопроводность кристалла. Или электрическую проводимость, или еще что\sphinxhyphen{}нибудь – поэтому основной задачей квантовой химии является поиск волновых функций\sphinxhyphen{}решений уравнения Шредингера для системы частиц.


\subsection{Долгое и правильное решение, часть 1}
\label{\detokenize{book/problems/ru/quantchemadvancedscf:id5}}
\sphinxAtStartPar
Начнем с атома водорода и определения его уровней энергии – их можно сравнить с экспериментальными данными, а также результатами Боровской теории. Квантовая механика позволяет решить эту задачу, исходя только из “первых принципов”, то есть аксиоматики квантовой механики. При этом после некоторых усилий решения успешно обобщаются с атома водорода на любой другой.

\sphinxAtStartPar
Давайте опишем атом водорода – систему из электрона и протона – на языке квантовой механики, то есть в виде уравнения Шредингера, и посмотрим, что получится.

\sphinxAtStartPar
Электрон находится в потенциале протона, и его волновая функция должна зависеть от расстояния до протона.

\sphinxAtStartPar
Уравнение Шредингера для электрона будет следующим:
\begin{equation*}
\begin{split}
\dot{\imath} \hbar \frac{d}{dt} {\ket{\Psi(t, \vec{r})}} = (\frac{ \hat{p}^{2} }{2 m} + \hat{V}(\vec{r})) {\ket{\Psi (t, \vec{r})}}
\end{split}
\end{equation*}
\sphinxAtStartPar
Мы ищем решение, в котором электрон остается в атоме, то есть решаем стационарное уравнение, в котором \(\ket{\Psi}\) не зависит от времени. Тогда оператор эволюции (в левой части уравнения Шредингера) при применении к \(\ket{\Psi}\) должен вернуть нам тот же вектор \(\ket{\Psi}\), умноженный на \(E\) (энергия частицы).

\sphinxAtStartPar
С точки зрения математики, искомая волновая функция является собственным вектором оператора эволюции, а энергия – собственным значением (подробнее в разделе {\hyperref[\detokenize{book/linalg/ru/matrices:matrices}]{\sphinxcrossref{\DUrole{std,std-ref}{Матрицы}}}}). Если объяснять “на пальцах”, то оператор эволюции при применении к волновой функции должен вернуть нам новую (эволюционировавшую или изменившуюся во времени) волновую функцию. Если ищем стационарную – не меняющуюся во времени – волновую функцию, то при применении к ней оператора эволюции она не должна изменяться, иначе будет уже не стационарной.
\begin{equation*}
\begin{split}
    \dot{\imath} \hbar \frac{d}{dt} {\ket{\Psi(t, \vec{r})}}
    \equiv
    \dot{\imath} \hbar \frac{d}{dt} {\ket{\Psi(\vec{r})}}
    \equiv
    E { \ket{\Psi(\vec{r})} }
\end{split}
\end{equation*}
\sphinxAtStartPar
Оператор импульса раскрывается через градиент так:
\begin{equation*}
\begin{split}
\hat{p} =  \dot{\imath} \hbar \nabla
\end{split}
\end{equation*}
\sphinxAtStartPar
Потенциал взаимодействия двух частиц с противоположными единичными зарядами раскрывается так:
\begin{equation*}
\begin{split}
\hat{V}(\vec{r}) = -\frac{e^2}{r}
\end{split}
\end{equation*}
\sphinxAtStartPar
Итого имеем:
\begin{equation}\label{equation:book/problems/ru/quantchemadvancedscf:eqn:shrstable}
\begin{split}
(-\frac{\hbar^2}{2m}\nabla^2  - \frac{e^2}{r} ){\ket{\Psi(\vec{r})}} = E {\ket{\Psi(\vec{r})}}
\end{split}
\end{equation}
\sphinxAtStartPar
Прежде чем погружаться глубже в решение этого уравнения, нам надо разобраться с квантовыми числами.


\subsection{Про квантовые числа}
\label{\detokenize{book/problems/ru/quantchemadvancedscf:id6}}
\sphinxAtStartPar
Теория Бора базируется на идее квантования импульса, и ее следствием является возникшее в формуле энергии \eqref{equation:book/problems/ru/quantchembasic:eqn:hydroenergylevels} число \(n\). Каждое число \(n\) соответствует определенному состоянию, в котором может находиться электрон, и эти состояния отличаются энергией.

\sphinxAtStartPar
Идея, что электрон может находиться в одном состоянии из некоторого конечного набора вариантов, характеризуемого дискретными (квантовыми) числами, оказалась правильной. В дальнейшем она получила развитие в квантовой механике.

\sphinxAtStartPar
Число \(n\) называется главным \sphinxhref{https://en.wikipedia.org/wiki/Quantum\_number}{квантовым числом}, оно определяет энергетический уровень электрона.

\sphinxAtStartPar
Из анализа свойств операторов гамильтониана и момента импульса в квантовой механике выводятся еще три квантовых числа:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\(\ell\) – орбитальное квантовое число, \(0 \leq \ell \leq n-1\);

\item {} 
\sphinxAtStartPar
\(m\) – магнитное квантовое число, \(-\ell \leq m \leq \ell\);

\item {} 
\sphinxAtStartPar
\(s\) – спиновое квантовое число, \(s = 0|1\) (для атома водорода оно не играет роли, так как электрон только один).

\end{itemize}

\sphinxAtStartPar
В химии они \sphinxhref{https://en.wikipedia.org/wiki/Electron\_configuration}{используются} в другой форме записи для описания орбиталей электронов в атоме.

\sphinxAtStartPar
Эти числа нам скоро понадобятся, чтобы описывать электрон в атоме.

\sphinxAtStartPar
Любая функция \(\ket{\Psi}\), для которой уравнение \eqref{equation:book/problems/ru/quantchemadvancedscf:eqn:shrstable} верно, описывает электрон, который стабильно находится где\sphinxhyphen{}то около ядра и не покидает его, то есть образует с ним атом. При этом функций\sphinxhyphen{}решений у уравнения на самом деле много, что физически соответствует тому, что электрон может находиться на разных орбиталях. Каждая орбиталь характеризуется квантовыми числами – \(n\), \(\ell\), \(m\) и \(s\), и обозначается как \(\ket{\Psi_{n \ell m}} \). \(\ket{\Psi}\) (орбиталь) с минимальной энергией \(E\) соответствует основному состоянию (ground state) – она описывает невозбужденный электрон. У водорода только один электрон, поэтому единственная \(\ket{\Psi}\) с минимальной энергией соответствует невозбужденному атому водорода.

\sphinxAtStartPar
В целом, основная задача квантовой химии – найти ground state произвольной системы частиц. В реальности материя редко находятся непосредственно в ground state состоянии, т.к. при ненулевой температуре какие\sphinxhyphen{}то флуктуации неизбежно возникают. Тем не менее, ground state обычно в наибольшей степени определяет поведение системы, а другие состояния являются “поправками” к нему.

\sphinxAtStartPar
Частицы могут переходить из одного состояния в другое: если электрону в основном состоянии придать энергии, например, попасть в него другой частицей, то он может перейти на другую орбиталь, при этом оставшись частью атома. Со временем возбужденные атомы рано или поздно переходят в основное состояния, выбрасывая лишнюю энергию в виде фотона, что и дает спектр излучения атома.

\sphinxAtStartPar
Итого: \(\ket{\Psi_{n \ell m}(\vec{r})}\) – это функция, соответствующая какой\sphinxhyphen{}то стабильной “траектории” (распределению плотности вероятности) электрона вокруг ядра, она является решением уравнения Шредингера, то есть собственной функцией гамильтониана. Соответствующее ей собственное число – энергия электрона на этой орбитали. Для всех волновых функций с одним \(n\) энергия одинакова, но одной энергии может соответствовать несколько волновых функций, каждая \sphinxhyphen{} со своим уникальным набором волновых чисел.

\sphinxAtStartPar
Если электрон описывается такой волновой функцией, то он часть атома, и если какой\sphinxhyphen{}либо электрон – часть атома, то он описывается такой волновой функцией. Электрон может переходить между этими волновыми функциями, получая и отдавая энергию, оставаясь при этом частью атома.

\sphinxAtStartPar
Волновая функция \(\ket{\Psi_{100}}\) (т.е. с числами \(n=1, \ell=0, m=0\)) соответствует минимальной энергии для единственного электрона в атоме водорода. Т.к. в атоме водорода есть лишь один электрон, и других вкладов в энергию нет – весь атом водорода в такой конфигурации имеет минимальную энергию.


\subsection{Долгое и правильное решение, часть 2}
\label{\detokenize{book/problems/ru/quantchemadvancedscf:id7}}
\begin{sphinxadmonition}{note}{А зачем нам вообще сдался спектр и энергии?}

\sphinxAtStartPar
Вслед за физиками двадцатого века нам приходится продираться через дебри уравнений, абстракций и формул. Дело это непростое и может возникнуть резонный вопрос – а зачем оно все надо?

\sphinxAtStartPar
Помимо фундаментальной ценности в виде лучшего понимания устройства мира, объясняющая спектр теория дает крутую возможность: по измеренному спектру понять, что за вещество перед нами и какие процессы в нем протекают. Например, изучение спектров – один из немногих способов узнать что\sphinxhyphen{}то про процессы в звездах или биологических клетках. Для совсем практиков: спектроскопия также используется для детекции взрывчатых и наркотических веществ в малых дозах, а полевые транзисторы (основа большинства современных вычислительные устройства) работают на основе туннельного эффекта – квантового явления. Так что можно сказать, что квантовая механика используется сплошь и рядом!
\end{sphinxadmonition}

\sphinxAtStartPar
Если перейти в уравнении \eqref{equation:book/problems/ru/quantchemadvancedscf:eqn:shrstable} в сферические координаты со следующей параметризацией \(\ket{\Psi(\vec{r})} = \frac{\chi(r)}{r} Y(\theta, \phi)\) и воспользоваться несколькими волшебными выводами квантмеха {[}\hyperlink{cite.book/bibliography:id48}{89}{]}, то получится:
\begin{equation*}
\begin{split}
-\frac{{\hbar}^2}{2 m} \frac{d^2 \chi}{d r^2} +
(-\frac{e^2}{r} + \frac{\hbar^2 \ell (\ell + 1)}{2mr^2} -E) \chi(\vec{r}) = 0
\end{split}
\end{equation*}
\sphinxAtStartPar
Все константы (массы, заряда, импульса, энергии) можно убрать, если перейти в кулоновские единицы измерений, где они приняты за единицу (то есть 1 единица заряда = заряд электрона, 1 единица массы = масса электрона).
\begin{equation*}
\begin{split}
-\frac{\chi''(r)}{2} +
(\frac{\ell(\ell+1)}{2r^2} -\frac{1}{r})\chi(r)
= 0
\end{split}
\end{equation*}
\sphinxAtStartPar
Опустим несколько страниц выкладок {[}\hyperlink{cite.book/bibliography:id39}{15a}{]}, учтем граничные условия и получим следующее решение:
\begin{equation*}
\begin{split}
R_{n\ell}(r) = r^\ell \cdot e^{-r/n} \cdot \sum_{k=0}^{n -\ell -1} \frac{(-2r/n)^k}{ (2\ell + 2 +k)! (n-\ell-k-1)! k!} \cdot C \\
\ket{\Psi(r, \theta, \phi)} = R_{n\ell}(r) Y_{\ell m} (\theta, \phi),
\end{split}
\end{equation*}
\sphinxAtStartPar
где \(Y_{\ell m}(\theta, \phi)\) – \sphinxhref{https://en.wikipedia.org/wiki/Spherical\_harmonics}{сферические функции}.

\sphinxAtStartPar
Если подставить это решение в уравнение Шредингера и найти энергию, то получим:
\begin{equation*}
\begin{split}
E_{n} = -\frac{1}{n^2} \frac{me^4}{2\hbar^2}
\end{split}
\end{equation*}
\sphinxAtStartPar
То есть получим ту же формулу, что и в теории Бора, и тот же численный результат – 13.6 eV.

\sphinxAtStartPar
Здесь начинает проступать основная проблема квантовой химии – математическая и вычислительная сложность. Пока что проблема только концептуальная (сложно разобраться в формулах и уравнениях), но при росте числа частиц в системе даже отличное владение матаппаратом окажется недостаточным.


\subsection{От теории к практике}
\label{\detokenize{book/problems/ru/quantchemadvancedscf:id10}}
\sphinxAtStartPar
Вернемся из начала двадцатого века обратно в день сегодняшний. Сто лет назад невычислимые аналитически интегралы и замороченные дифференциальные уравнения были почти непреодолимыми препятствиями, поэтому поначалу теория квантовой химии развивалась в сторону более хитрых приближений и упрощений, позволяющих решить эти уравнения аналитически.

\sphinxAtStartPar
Сегодня реальные научные задачи решаются численно – и для этого написано множество высокопроизводительных пакетов, позволяющих на основе входных данных и ограничений вычислить определенным методом желаемые характеристики.

\sphinxAtStartPar
Как и в задачах машинного обучения, в первом приближении достаточно подготовить данные, скормить их волшебному программному пакету\sphinxhyphen{}вычислителю и забрать ответ, но без понимания происходящего под капотом есть шансы получить что\sphinxhyphen{}то неправильное.

\sphinxAtStartPar
В этой лекции воспользуемся Python\sphinxhyphen{}пакетом \sphinxhref{https://psicode.org/posts/psi4education\_setup/}{\sphinxcode{\sphinxupquote{psi4}}}. Он реализует многие алгоритмы квантовой химии и имеет неплохое Python API.

\sphinxAtStartPar
Давайте посчитаем c помощью \sphinxcode{\sphinxupquote{psi4}} энергию основного состояния атома водорода. Некоторые параметры сейчас придется использовать, “поверив на слово”. Их смысл будет объяснен в дальнейшем.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{psi4}
\PYG{n}{psi4}\PYG{o}{.}\PYG{n}{core}\PYG{o}{.}\PYG{n}{be\PYGZus{}quiet}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} отключаем логирование в stdout}

\PYG{n}{h\PYGZus{}atom} \PYG{o}{=} \PYG{n}{psi4}\PYG{o}{.}\PYG{n}{geometry}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{H}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Мы задали атом водорода, по умолчанию атом помещается в начало координат.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{psi4}\PYG{o}{.}\PYG{n}{set\PYGZus{}options}\PYG{p}{(}\PYG{p}{\PYGZob{}}
  \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{basis}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{STO\PYGZhy{}3G}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
  \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{reference}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{rohf}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
\PYG{p}{\PYGZcb{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Тут уже поинтереснее – объяснение этих параметров пока отложим и вернемся после объяснения теории. В целом они определяют, каким именно методом и в каком базисе нужно численно решить уравнение Шредингера.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{scipy}\PYG{n+nn}{.}\PYG{n+nn}{constants} \PYG{k+kn}{import} \PYG{n}{physical\PYGZus{}constants}

\PYG{n}{h2ev} \PYG{o}{=} \PYG{n}{physical\PYGZus{}constants}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{hartree\PYGZhy{}electron volt relationship}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}

\PYG{k}{def} \PYG{n+nf}{e\PYGZus{}in\PYGZus{}ev}\PYG{p}{(}\PYG{n}{energy\PYGZus{}in\PYGZus{}ht}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n}{energy\PYGZus{}in\PYGZus{}ht} \PYG{o}{*} \PYG{n}{h2ev}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} энергия в единицах Hartree}
\PYG{n}{e\PYGZus{}in\PYGZus{}ht} \PYG{o}{=} \PYG{n}{psi4}\PYG{o}{.}\PYG{n}{energy}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{scf}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Hydrogen ground state energy: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{e\PYGZus{}in\PYGZus{}ev}\PYG{p}{(}\PYG{n}{e\PYGZus{}in\PYGZus{}ht}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ eV}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Здесь посчитали энергию в единицах Хартри – специальной физической системе единиц, где истинная энергия атома водорода равна 1/2, и перевели ее в электрон\sphinxhyphen{}вольты. Результат не очень точный (правильный, как помним, равен 13.6 eV), и мы его улучшим после того как разберемся, что и как только что посчитали. Это будет удобнее сделать на примере атома гелия, потому что в атоме водорода есть только один электрон, а в любой реальной системе – больше одного.


\section{Теория самосогласованного поля}
\label{\detokenize{book/problems/ru/quantchemadvancedscf:id11}}

\subsection{Атом гелия}
\label{\detokenize{book/problems/ru/quantchemadvancedscf:id12}}
\sphinxAtStartPar
Следующим “по простоте” после атома водорода идет атом гелия – как говорит нам школьная химия, это атом из двух протонов, двух нейтронов и двух электронов. Протоны и нейтроны находятся близко друг к другу в ядре и имеют почти одинаковую массу, так что можно просто считать, что есть ядро с зарядом +2 и массой 4. А вот с электронами все сложнее: с одной стороны, это независимые частицы, а с другой – они взаимодействуют друг с другом по закону Кулона, так как оба имеют отрицательный заряд.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Для гравитационного взаимодействия \sphinxhref{https://ru.wikipedia.org/wiki/\%D0\%97\%D0\%B0\%D0\%B4\%D0\%B0\%D1\%87\%D0\%B0\_\%D1\%82\%D1\%80\%D1\%91\%D1\%85\_\%D1\%82\%D0\%B5\%D0\%BB}{“проблема трех тел”} не имеет известного аналитического решения. Это означает, что если мы знаем, что где\sphinxhyphen{}то в глубоком космосе вдалеке от остального мира есть три объекта с известными массами, импульсами и координатами, то, увы, в общем случае не сможем предсказать их движение аналитически (хотя сможем предсказать численно, либо найти приближенное аналитическое решение, если масса одного объекта много больше других, например).

\sphinxAtStartPar
Для трех классических тел с кулоновским потенциалом все тоже сложно – можно посмотреть \sphinxhref{https://www.wolframcloud.com/objects/demonstrations/ThreeBodyCoulombProblem-source.nb}{тут}, как поведет себя система трех тел с различными зарядами.
\end{sphinxadmonition}

\sphinxAtStartPar
Попробуем записать уравнение Шредингера для системы из ядра и двух электронов:
\begin{equation*}
\begin{split}
\dot{\imath} \hbar \frac{d}{dt} {\ket{\Psi(t, \vec{r_A}, \vec{r_B})}} = (
  \frac{ \hat{p_A}^{2} }{2m} - \frac{2e \cdot e}{r_A} +
  \frac{ \hat{p_B}^{2} }{2m} - \frac{2e \cdot e}{r_B} +
  \frac{e \cdot e}{|r_A - r_B|}
) {\ket{\Psi(t, \vec{r_A}, \vec{r_B})}}
\end{split}
\end{equation*}
\sphinxAtStartPar
Оно состоит из кинетической и потенциальной энергии двух электронов в поле ядра и (последнее слагаемое) потенциала взаимодействия двух электронов. Учитывая, что уравнение примерно такое же, как у водорода, только еще более сложное, решение стоит искать численно и с использованием приближений, а не аналитически.

\sphinxAtStartPar
Если бы не последний член гамильтониана, то можно было бы разбить все выражение на две независимых части – с переменными электрона \(А\) и с переменными электрона \(B\). Так как это дифференциальное уравнение, можно было бы воспользоваться разделением переменных и найти отдельные решения для двух электронов – задача аналогична атому водорода, а ее мы уже решили.

\sphinxAtStartPar
Но из\sphinxhyphen{}за потенциала взаимодействия решение существенно усложняется, поскольку электроны влияют друг на друга. Придется прибегнуть к упрощениям – и одним из наиболее популярных подходов является \sphinxstyleemphasis{теория самосогласованного поля} (Self\sphinxhyphen{}Consistent Field).


\subsection{Теория самосогласованного поля}
\label{\detokenize{book/problems/ru/quantchemadvancedscf:id13}}
\sphinxAtStartPar
Теория самосогласованного поля (self\sphinxhyphen{}consistent field theory) – это подход итеративного решения уравнения Шредингера для многочастичной системы, на основе которого построено много квантово\sphinxhyphen{}химических методов, наиболее известный из которых – метод Хартри\sphinxhyphen{}Фока. В сниппете выше строчка \sphinxcode{\sphinxupquote{psi4.energy('scf')}} означает, что энергия посчитана этим методом.

\sphinxAtStartPar
Основная идея теории заключается в следующем.

\sphinxAtStartPar
У нас есть несколько частиц, которые взаимодействуют между собой, и найти цельное решение уравнения Шредингера для всех сразу не получается. Тогда вместо этого будем рассматривать частицы по очереди и считать, что все остальные действуют “в среднем” на выбранную частицу. То есть будем считать усредненный по пространству потенциал вместо точного.

\sphinxAtStartPar
Для электрона \(А\) в атоме гелия нам нужно учесть усредненное влияние электрона \(B\). Можем для электрона \(B\) взять волновую функцию от атома водорода, посчитать на ее основе усредненное влияние на электрон \(А\):
\begin{equation*}
\begin{split}
(h_A + \hat{V}_{eff}) \ket{\psi_A}  =  (h_A +  \bra{\psi_B} \frac{e^2}{r_{AB}} \ket{\psi_B}) \ket{\psi_A}  = \epsilon_A \ket{\psi_A},
\end{split}
\end{equation*}
\sphinxAtStartPar
где \(h_A\) – это кинетическая энергия и потенциал ядра для электрона \(A\), \(V_{eff}\) – влияние электрона \(B\) на электрон \(А\) и вычисляется как влияние усредненной электронной плотности, распределенной в соответствии с \(\psi_B\).

\sphinxAtStartPar
На этом шаге считаем, что \(\psi_B\) – фиксированная волновая функция и находим “переменную” \(\psi_A\). Однако \(\psi_A\) тоже будет влиять на \(\psi_B\) и, записав аналогичное уравнение для частицы \(B\), следующим шагом найдем новую \(\psi_B\).

\sphinxAtStartPar
После изменения волновых функций каждого электрона можем заново записать их уравнения с новыми волновыми функциями и так по кругу, пока волновые функции и их энергии не сойдутся к какому\sphinxhyphen{}то стабильному (самосогласованному) решению.

\sphinxAtStartPar
Все вместе это создает итеративную процедуру:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
на основе имеющихся волновых функций посчитать среднее поле, которое создают частицы (например, электрон \(B\) для электрона \(А\));

\item {} 
\sphinxAtStartPar
решить уравнение Шредингера с потенциалом, учитывающим среднее поле, то есть вычислить энергии и новые волновые функции;

\item {} 
\sphinxAtStartPar
вернуться к шагу 1.

\end{enumerate}

\sphinxAtStartPar
Для инициализации можно взять какие\sphinxhyphen{}то приблизительные волновые функции для всех частиц (двух электронов гелия), например, решения из уравнения водорода, то есть водородоподобные волновые функции. Далее итерацию повторяют, пока волновые функции и их энергии не перестанут изменяться, то есть самосогласуются.

\sphinxAtStartPar
Система таких уравнений, записанных для каждого электрона, называется \sphinxstylestrong{уравнениями \sphinxhref{https://ru.wikipedia.org/wiki/\%D0\%A5\%D0\%B0\%D1\%80\%D1\%82\%D1\%80\%D0\%B8,\_\%D0\%94\%D1\%83\%D0\%B3\%D0\%BB\%D0\%B0\%D1\%81\_\%D0\%A0\%D0\%B5\%D0\%B9\%D0\%BD\%D0\%B5\%D1\%80}{Хартри}}. На основе таких волновых функций для отдельных электронов можно собрать общую волновую функцию \(\Psi(\vec{r_A}, \vec{r_B})\), самый простой вариант – это \(\Psi(\vec{r_A}, \vec{r_B}) = \psi_A(\vec{r_A}) \psi_B(\vec{r_B})\), он и был предложен первоначально. Однако есть проблема: такая \(\Psi\) получается не антисимметричной, а только такие волновые функции для системы электронов являются “физичными”, то есть могут существовать в реальности.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Один из основополагающих принципов квантовой механики – тождественность частиц и их неразличимость. Принцип означает, что все частицы одного типа (например, электроны) одинаковы и характеризуются только своим состоянием. Например, если мы “переставим местами” два электрона в атоме (не только пространственно, но и в смысле их состояния и энергий), то получившийся атом будет неотличим от исходного.

\sphinxAtStartPar
Из принципа тождественности следует, что при перестановке не должна меняться плотность вероятности:
\begin{equation*}
\begin{split}
| {\Psi}(X_A, X_B) |^2 = | {\Psi}(X_B, X_A) |^2
\end{split}
\end{equation*}
\sphinxAtStartPar
Кроме того, представим что мы обменяли частицы дважды: \(A\) с \(B\) и обратно. Никакие физические свойства системы из\sphinxhyphen{}за этого измениться не должны. В общем случае, из этого не следует что волновая функция не изменилась – например, так как глобальная фаза волновой функции неизмерима, то могли получить \(\Psi' = e^{2 i \pi \theta} \Psi\).

\sphinxAtStartPar
Но, если работаем больше чем в двух пространственных измерениях, то такой двойной обмен эквивалентен отсутсвию обмена. Для начала представим, что обмениваем частицы медленно, описывая полукруг частицей \(A\) вокруг частицы \(B\) и потом сдвигая обе частицы. Тогда двойной обмен значит, что частица \(A\) описывает полный круг вокруг частицы \(B\). Также, если непрерывно изменим ее маршрут не приближая ее к частице \(B\), то ожидаем получить тот же результат.

\sphinxAtStartPar
Итак, какие замкнутые маршруты можем получить непрерывно деформируя маршрут в евклидовом пространстве без точки (\(B\))? Ответ для любого измерения больше 2 – \sphinxhref{https://en.wikipedia.org/wiki/Homotopy\_groups\_of\_spheres}{любые}. Следовательно двойной обмен должен давать такой же результат как и если бы просто оставили частицу \(А\) на месте {[}\hyperlink{cite.book/bibliography:id70}{NSS+08}{]}. Это свойство задает ограничение на то, какими могут быть волновые функции.

\sphinxAtStartPar
У этого ограничения есть два решения: либо \({\Psi}(X_A, X_B) = {\Psi}(X_B, X_A)\) (симметричность), либо \(\Psi(X_A, X_B) = - \Psi(X_B, X_A)\) (антисимметричность). У антисимметричных функций есть интересное свойство: если функция \(f(x_1, x_2)\) антисимметрична, то \(f(x_1=X, x_2=X) = 0\), то есть антисимметричная функция равна нулю, если ее аргументы одинаковы. В этом легко убедиться на примере \(f = x_1 - x_2\).

\sphinxAtStartPar
Для антисимметричной волновой функции это означает, что две частицы не могут иметь полностью одинаковое состояние – волновая функциия (и вероятность) такой конфигурации равна нулю.

\sphinxAtStartPar
В эксперименте это строго выполняется для всех частиц с полуцелым спином (фермионов), к которым относятся электроны, а частицы с целым спином (бозоны), например, фотоны, имеют симметричную волновую функцию и могут иметь одинаковые состояния.

\sphinxAtStartPar
Для квантовой химии это все имеет одно важное следствие: электроны – это фермионы и волновая функция, описывающая всю систему электронов целиком, должна быть антисимметрична относительно перестановки (замены пары индексов). Любое не антисимметричное решение не физично, поскольку допускает существование электронов в одинаковом состоянии, а такого не бывает. В химии этот вывод называется \sphinxhref{https://ru.wikipedia.org/wiki/\%D0\%9F\%D1\%80\%D0\%B8\%D0\%BD\%D1\%86\%D0\%B8\%D0\%BF\_\%D0\%9F\%D0\%B0\%D1\%83\%D0\%BB\%D0\%B8}{принцип запрета Паули}.
\end{sphinxadmonition}

\sphinxAtStartPar
Чтобы сделать волновую функцию системы из двух электронов антисимметричной, используется такой прием:
\begin{equation*}
\begin{split}
\Psi(X_A, X_B) = \psi_A(X_A) \psi_B(X_B) - \psi_B(X_A) \psi_A(X_B)
\end{split}
\end{equation*}
\sphinxAtStartPar
Во\sphinxhyphen{}первых, легко проверить, что если поменять местами \(X_A\) и \(X_B\), то вся функция просто изменит знак. Во\sphinxhyphen{}вторых, можно заметить, что формулу можно записать как определитель матрицы:
\begin{equation*}
\begin{split}
\Psi(X_A, X_B) =
  \begin{vmatrix}
    \psi_A(X_A) & \psi_B(X_A) \\
    \psi_A(X_B) & \psi_B(X_B)
  \end{vmatrix}
\end{split}
\end{equation*}
\sphinxAtStartPar
Из курса линейной алгебры можно вспомнить, что определитель меняет знак при перестановке двух столбцов или двух строк – это свойство позволяет делать антисимметричные волновые функции систем из \(N\) волновых функций отдельных электронов, если использовать метод Хартри не для атома гелия, а для системы с большим числом электронов. Для этого составляется определитель \(N \times N\) по аналогии с формулой выше: элемент в строке \(i\), столбце \(j\) – это \(i\)\sphinxhyphen{}я волновая функция с параметрами \(j\)\sphinxhyphen{}го электрона в качестве аргумента. Волновая функция системы частиц вычисляется как нормированный определитель матрицы, а определитель всегда антисимметричен. Такой вариант сборки волновой функции системы частиц называется “определитель \sphinxhref{https://ru.wikipedia.org/wiki/\%D0\%A1\%D0\%BB\%D0\%B5\%D0\%B9\%D1\%82\%D0\%B5\%D1\%80,\_\%D0\%94\%D0\%B6\%D0\%BE\%D0\%BD\_\%D0\%9A\%D0\%BB\%D0\%B0\%D1\%80\%D0\%BA}{Слэтера}”.

\sphinxAtStartPar
Так как весь подход является аппроксимацией, не любая система может быть точно представлена таким детерминантом, но он является очень распространенным методом “сборки” волновой функции системы электронов в квантовой химии. Его использование также немного меняет вид одноэлектронных уравнений: чтобы корректно учесть антисимметрию, в эффективный потенциал добавляется так называемое “обменное взаимодействие”.

\sphinxAtStartPar
Все вместе составляет метод Хартри\sphinxhyphen{}\sphinxhref{https://ru.wikipedia.org/wiki/\%D0\%A4\%D0\%BE\%D0\%BA,\_\%D0\%92\%D0\%BB\%D0\%B0\%D0\%B4\%D0\%B8\%D0\%BC\%D0\%B8\%D1\%80\_\%D0\%90\%D0\%BB\%D0\%B5\%D0\%BA\%D1\%81\%D0\%B0\%D0\%BD\%D0\%B4\%D1\%80\%D0\%BE\%D0\%B2\%D0\%B8\%D1\%87}{Фока}:
\begin{itemize}
\item {} 
\sphinxAtStartPar
итеративная процедура самосогласованного поля;

\item {} 
\sphinxAtStartPar
усредненное действие электронов друг на друга, учет обменного взаимодействия;

\item {} 
\sphinxAtStartPar
детерминант Слетера.

\end{itemize}


\subsection{SCF в psi4}
\label{\detokenize{book/problems/ru/quantchemadvancedscf:scf-psi4}}
\sphinxAtStartPar
Теперь можно вернуться к коду и взглянуть на него чуть более осмысленно. При вычислении энергии явно передаем, что хотим посчитать ее методом Self\sphinxhyphen{}Consistent Field:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{e\PYGZus{}in\PYGZus{}ht} \PYG{o}{=} \PYG{n}{psi4}\PYG{o}{.}\PYG{n}{energy}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{scf}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Но что происходит в настройках, пока по\sphinxhyphen{}прежнему неясно:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{psi4}\PYG{o}{.}\PYG{n}{set\PYGZus{}options}\PYG{p}{(}
  \PYG{p}{\PYGZob{}}
    \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{basis}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{STO\PYGZhy{}3G}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
    \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{reference}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{rohf}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
  \PYG{p}{\PYGZcb{}}
\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Начнем с параметра \sphinxcode{\sphinxupquote{basis}}. \sphinxhref{https://en.wikipedia.org/wiki/STO-nG\_basis\_sets}{\sphinxcode{\sphinxupquote{STO\sphinxhyphen{}3G}}} – не стандарт связи, а \sphinxstylestrong{S}later \sphinxstylestrong{T}ype \sphinxstylestrong{O}rbital с \sphinxstylestrong{3} \sphinxstylestrong{Г}ауссианами в базисном наборе, то есть базис на основе детерминанта Слетера. В описании метода SCF мы собирались начинать итерации с водородоподобных волновых функций, но так как весь метод является аппроксимирующим, нам никто не мешает выбрать другие волновые функции, если результаты лучше согласуются с экспериментом. Выбор базиса может существенно влиять на результат вычислений и современные базисы сложнее, чем Слетеровский детерминант – он просто один из первых и наиболее популярных.

\sphinxAtStartPar
Параметр \sphinxcode{\sphinxupquote{reference}} означает, какие предположения о волновой функции делаем, в данном случае используется \sphinxhref{https://en.wikipedia.org/wiki/Restricted\_open-shell\_Hartree\%E2\%80\%93Fock}{Restricted Open Shell Hartree\sphinxhyphen{}Fock}, так как у атома водорода только один электрон и его оболочка не заполнена (на уровне энергии \(n = 1\) для этого нужно 2 электрона).

\sphinxAtStartPar
Давайте повторим вычисления с более “современными” опциями.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{psi4}\PYG{o}{.}\PYG{n}{core}\PYG{o}{.}\PYG{n}{clean}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{h\PYGZus{}atom} \PYG{o}{=} \PYG{n}{psi4}\PYG{o}{.}\PYG{n}{geometry}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{H}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{n}{psi4}\PYG{o}{.}\PYG{n}{set\PYGZus{}options}\PYG{p}{(}\PYG{p}{\PYGZob{}}
  \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{basis}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{d\PYGZhy{}aug\PYGZhy{}cc\PYGZhy{}pv5z}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{c+c1}{\PYGZsh{} разбор этого базиса выходит за рамки этого интро}
  \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{scf\PYGZus{}type}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pk}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
  \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{reference}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{rohf}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
\PYG{p}{\PYGZcb{}}\PYG{p}{)}

\PYG{n}{e\PYGZus{}in\PYGZus{}ht} \PYG{o}{=} \PYG{n}{psi4}\PYG{o}{.}\PYG{n}{energy}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{scf}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Better hydrogen ground state energy: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{e\PYGZus{}in\PYGZus{}ev}\PYG{p}{(}\PYG{n}{e\PYGZus{}in\PYGZus{}ht}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ eV}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Та\sphinxhyphen{}дам! Используя более прокачанные базисы, получили правильный ответ.

\sphinxAtStartPar
Давайте посмотрим, что еще можно сделать с помощью self\sphinxhyphen{}consistent field.


\subsection{Атом Гелия (численно)}
\label{\detokenize{book/problems/ru/quantchemadvancedscf:id15}}
\sphinxAtStartPar
Раз мы разобрали SCF на примере атома гелия, то наверняка можно посчитать его энергию в \sphinxcode{\sphinxupquote{psi4}}.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{psi4}\PYG{o}{.}\PYG{n}{core}\PYG{o}{.}\PYG{n}{clean}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{he\PYGZus{}atom} \PYG{o}{=} \PYG{n}{psi4}\PYG{o}{.}\PYG{n}{geometry}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{He}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{n}{psi4}\PYG{o}{.}\PYG{n}{set\PYGZus{}options}\PYG{p}{(}\PYG{p}{\PYGZob{}}
  \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{basis}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{STO\PYGZhy{}3G}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
  \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{reference}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{rohf}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
\PYG{p}{\PYGZcb{}}\PYG{p}{)}

\PYG{n}{e\PYGZus{}in\PYGZus{}ht} \PYG{o}{=} \PYG{n}{psi4}\PYG{o}{.}\PYG{n}{energy}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{scf}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Helium ground state energy: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{e\PYGZus{}in\PYGZus{}ev}\PYG{p}{(}\PYG{n}{e\PYGZus{}in\PYGZus{}ht}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ eV}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Экспериментальное значение энергии атома гелия \sphinxhref{https://en.wikipedia.org/wiki/Helium\_atom\#Experimental\_value\_of\_ionization\_energy}{равно} \sphinxhyphen{}79.0 eV.


\subsection{Молекула водорода}
\label{\detokenize{book/problems/ru/quantchemadvancedscf:id16}}
\sphinxAtStartPar
Пока рассматривали только атомы, но SCF можно использовать и для молекул – потенциалы становятся сложнее, электронов больше, но общая логика не меняется.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{psi4}\PYG{o}{.}\PYG{n}{core}\PYG{o}{.}\PYG{n}{clean}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} задаем 2 атома водорода с явными координатами}
\PYG{n}{h\PYGZus{}mol} \PYG{o}{=} \PYG{n}{psi4}\PYG{o}{.}\PYG{n}{geometry}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+s2}{H 0 0 0}
\PYG{l+s+s2}{H 0 0 0.74}
\PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}\PYG{p}{)}

\PYG{n}{psi4}\PYG{o}{.}\PYG{n}{set\PYGZus{}options}\PYG{p}{(}\PYG{p}{\PYGZob{}}
  \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{basis}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{STO\PYGZhy{}3G}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
  \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{reference}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{rohf}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
\PYG{p}{\PYGZcb{}}\PYG{p}{)}

\PYG{n}{e\PYGZus{}in\PYGZus{}ht\PYGZus{}h} \PYG{o}{=} \PYG{n}{psi4}\PYG{o}{.}\PYG{n}{energy}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{scf}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{molecule}\PYG{o}{=}\PYG{n}{h\PYGZus{}mol}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Hydrogen ground state energy: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{e\PYGZus{}in\PYGZus{}ev}\PYG{p}{(}\PYG{n}{e\PYGZus{}in\PYGZus{}ht\PYGZus{}h}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ eV}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Здесь задали явно координаты обоих атомов водорода в молекуле и энергия электронов была высчитана в предположении, что ядра водородов неподвижны. Здесь расстояние в 0.74 Ангстрема взято из \sphinxhref{https://cccbdb.nist.gov/exp2x.asp?casno=1333740\&charge=0}{экспериментальных данных}. Если бы задали неправильные координаты, то рассчитанная энергия окажется неверной. Точнее, она соответствовала бы нефизичной ситуации, когда неведомая сила “удерживает” ядра водорода на месте.

\sphinxAtStartPar
В \sphinxcode{\sphinxupquote{psi4}} есть метод для оптимизации геометрии молекулы \sphinxcode{\sphinxupquote{psi4.optimize}}; он не фиксирует положение ядер и возвращает минимальную возможную энергию с учетом вариации положения атомов.

\sphinxAtStartPar
Вычисления с оптимизацией геометрии занимают значительно больше времени.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{psi4}\PYG{o}{.}\PYG{n}{core}\PYG{o}{.}\PYG{n}{clean}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{h\PYGZus{}mol\PYGZus{}bad} \PYG{o}{=} \PYG{n}{psi4}\PYG{o}{.}\PYG{n}{geometry}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+s2}{H 0 0 0}
\PYG{l+s+s2}{H 0 0 1.5}
\PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} 1.5 \PYGZhy{} неверное расстояние в ангстремах, верное \PYGZhy{} 0.74}

\PYG{n}{psi4}\PYG{o}{.}\PYG{n}{set\PYGZus{}options}\PYG{p}{(}\PYG{p}{\PYGZob{}}
  \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{basis}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{STO\PYGZhy{}3G}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
  \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{reference}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{rohf}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
\PYG{p}{\PYGZcb{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} рассчитываем энергию \PYGZdq{}в точке\PYGZdq{} с неправильной геометрией}
\PYG{n}{e\PYGZus{}in\PYGZus{}ht\PYGZus{}h\PYGZus{}bad} \PYG{o}{=} \PYG{n}{psi4}\PYG{o}{.}\PYG{n}{energy}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{scf}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{molecule}\PYG{o}{=}\PYG{n}{h\PYGZus{}mol\PYGZus{}bad}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} рассчитываем энергию, оптимизируя по ходу геометрию}
\PYG{n}{e\PYGZus{}in\PYGZus{}ht\PYGZus{}h\PYGZus{}optimized} \PYG{o}{=} \PYG{n}{psi4}\PYG{o}{.}\PYG{n}{optimize}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{scf}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{molecule}\PYG{o}{=}\PYG{n}{h\PYGZus{}mol\PYGZus{}bad}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Hydrogen molecule, incorrect ground state energy: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{e\PYGZus{}in\PYGZus{}ev}\PYG{p}{(}\PYG{n}{e\PYGZus{}in\PYGZus{}ht\PYGZus{}h\PYGZus{}bad}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ eV}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Hydrogen molecule, optimized ground state energy: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{e\PYGZus{}in\PYGZus{}ev}\PYG{p}{(}\PYG{n}{e\PYGZus{}in\PYGZus{}ht\PYGZus{}h\PYGZus{}optimized}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ eV}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Для некорректной геометрии получилась завышенная энергия, а после оптимизации – почти что такая же энергия, как при вычислении с фиксированным расстоянием 0.74. В оптимальном состоянии энергия системы должна быть минимальна, так что результаты вполне разумны.

\sphinxAtStartPar
Подобный метод можно использовать и для поиска геометрии куда более сложных молекул.


\subsection{Молекула этилового спирта}
\label{\detokenize{book/problems/ru/quantchemadvancedscf:id17}}
\sphinxAtStartPar
Молекула водорода – это все еще почти игрушечный пример. Давайте попробуем обсчитать молекулу этанола.

\sphinxAtStartPar
Задавать руками геометрию молекулы \(C_2H_5OH\) можно, но будет явно сложнее, чем для молекулы водорода. К счастью, это необязательно: \sphinxcode{\sphinxupquote{psi4}} умеет скачивать геометрию из базы данных \sphinxhref{https://pubchem.ncbi.nlm.nih.gov/}{PubChem} по номенклатурному имени либо уникальному ChemId.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{psi4}\PYG{o}{.}\PYG{n}{core}\PYG{o}{.}\PYG{n}{clean}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{eth} \PYG{o}{=} \PYG{n}{psi4}\PYG{o}{.}\PYG{n}{geometry}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pubchem:ethanol}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{n}{psi4}\PYG{o}{.}\PYG{n}{set\PYGZus{}options}\PYG{p}{(}\PYG{p}{\PYGZob{}}
  \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{basis}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{STO\PYGZhy{}3G}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
  \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{reference}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{rohf}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
\PYG{p}{\PYGZcb{}}\PYG{p}{)}

\PYG{n}{e\PYGZus{}in\PYGZus{}ht\PYGZus{}eth} \PYG{o}{=} \PYG{n}{psi4}\PYG{o}{.}\PYG{n}{energy}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{scf}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{molecule}\PYG{o}{=}\PYG{n}{eth}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Ethanol ground state energy: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{e\PYGZus{}in\PYGZus{}ev}\PYG{p}{(}\PYG{n}{e\PYGZus{}in\PYGZus{}ht\PYGZus{}eth}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ eV}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\section{Что мы узнали?}
\label{\detokenize{book/problems/ru/quantchemadvancedscf:id18}}
\sphinxAtStartPar
Разобрались с базовой теорией квантовой химии:
\begin{itemize}
\item {} 
\sphinxAtStartPar
как записать уравнение Шредингера для атома;

\item {} 
\sphinxAtStartPar
какое получается аналитическое решение для атома водорода;

\item {} 
\sphinxAtStartPar
как устроен метод Self\sphinxhyphen{}Consistent Field для вычисления волновых функций и энергии для задачи многих тел;

\item {} 
\sphinxAtStartPar
как использовать SCF в python пакете \sphinxcode{\sphinxupquote{psi4}}.

\end{itemize}

\sphinxAtStartPar
В примерах везде вычисляли ground state энергию, но, конечно, зная волновые функции, можно посчитать много чего еще. Например, можно вычислить спектр поглощения и энергию ионизации (энергии возбужденных состояний), моделировать взаимодействие молекул (найти равновесное состояние для двух систем), с помощью плагинов можно смоделировать рассеяние рентгена на молекуле… Квантовая механика постулирует, что любая измеримая величина является усреднением определенного оператора по волновой функции, поэтому в теории любую физическую величину можно посчитать, зная волновую функцию. Возможности ограничены в основном вычислительной сложностью, а не теорией.

\sphinxAtStartPar
Для более глубокого погружения в практику квантовой химии можно пройти лабораторные работы \sphinxcode{\sphinxupquote{psi4}}: \sphinxhref{https://psicode.netlify.app/posts/psi4education/}{раз}, \sphinxhref{http://education.molssi.org/qm-tools/}{два}.

\sphinxstepscope


\chapter{Модель Изинга}
\label{\detokenize{book/problems/ru/ising:ising}}\label{\detokenize{book/problems/ru/ising:id1}}\label{\detokenize{book/problems/ru/ising::doc}}
\sphinxAtStartPar
Автор(ы):
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/SemyonSinchenko}{Синченко Семен}

\end{itemize}

\sphinxAtStartPar
В этой лекции познакомимся с моделью Изинга, которая изначально была разработана для описания магнетизма, но оказалась настолько удачной и универсальной, что сегодня к решению именно этой задачи стараются свести многие проблемы реального мира, причем не только из физики. В следующем блоке подробно покажем, как к гамильтонианам типа Изинга, или, по\sphinxhyphen{}другому, “спиновым стеклам” могут быть сведены задачи комбинаторной оптимизации и квантовой химии. Так что знакомство с этой удивительной моделью, а также описывающим ее гамильтонианом нам просто необходимо!

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Специальные квантовые компьютеры компании D\sphinxhyphen{}Wave сконструированы так, что они могут решать вообще только одну задачу – нахождения основного состояния гамильтонианов типа Изинга. Но эта задача настолько распространена и важна, что эти компьютеры стали первыми в мире коммерческими квантовыми компьютерами! Кстати, далее этим компьютерам у нас посвящена {\hyperref[\detokenize{book/dwave/ru/dwave::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{отдельная лекция}}}}.
\end{sphinxadmonition}

\sphinxAtStartPar
Ближайшее время посвятим довольно много времени объяснению этой модели. Это может показаться скучным и занудным, но это важно для понимания того, как это все работает и как решать с помощью вариационных квантовых алгоритмов реальные задачи!


\section{Задача Изинга в одномерном случае}
\label{\detokenize{book/problems/ru/ising:id2}}
\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Ниже попробуем на пальцах объяснить модель Изинга. Пробовать будем через цепочку атомов антиферромагнетика во внешнем магнитном поле. Ели вы плохо помните физику и вам это объяснение покажется сложным, то не расстраивайтесь – дальше также объясним задачу Изинга как задачу о поиске максимального разреза в графе – известную задачу комбинаторной оптимизации.
\end{sphinxadmonition}

\sphinxAtStartPar
Пусть у нас есть, например, цепочка атомов, которые обладают магнитным моментом. Например, цепочка атомов антиферромагнетика. И мы прикладываем к этой цепочке внешнее магнитное поле.

\sphinxAtStartPar
Тогда, если поле маленькое, наши атомы будут стараться выстроиться в антиферромагнитный порядок, когда соседние из них имеют моменты, направленные в разные стороны. Но если поле уже большое, то оно будет стремиться “повернуть” моменты по своему направлению. А если еще вспомнить, что магнитный момент атома является квантовой величиной и может быть в суперпозиции состояний в одну сторону и в противоположную, то не очень маленькое, но и не слишком большое поле будет переводить часть атомов именно в такие суперпозиции.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=450\sphinxpxdimen]{{af_ordering}.png}
\caption{Иллюстрация антиферромагнитного порядка}\label{\detokenize{book/problems/ru/ising:id5}}\end{figure}

\begin{sphinxadmonition}{note}{Reminder о квантовой физике}

\sphinxAtStartPar
В квантовой механике есть фундаментальное уравнение, которое описывает динамику квантовых систем. Оно называется уравнением Шредингера: \(\imath \hbar \frac{\partial \Psi}{\partial t} = \hat{H} \Psi\), где \(\hat{H}\) – это оператор Гамильтона, или гамильтониан. Также его называют оператором полной энергии системы, так как в общем случае он равен сумме операторов кинетической и потенциальной энергии. Начиная с этой лекции будем очень часто обращаться к этому оператору, но в целом в нем нет ничего принципиально сложного. Это такой же эрмитов оператор, как и другие. А наблюдаемая величина, которую получаем при \sphinxhref{../qc/qubit.html\#id23}{измерении} этого оператора – это энергия системы.
\end{sphinxadmonition}

\sphinxAtStartPar
Давайте теперь запишем гамильтониан такой системы. Для представления магнитных моментов будем использовать оператор \(\sigma^z\) – другими словами, спин в направлении оси \(Z\). Если кто\sphinxhyphen{}то забыл, как выглядит оператор \(\sigma^z\), то рекомендуем еще раз просмотреть раздел про \sphinxhref{../../qc/ru/qubit.html\#id24}{операторы Паули} первой лекции. Далее будем очень активно использовать эти матрицы для представления задач реального мира!

\sphinxAtStartPar
Для начала, в случае если внешнего поля нет, мы должны записать взаимодействие соседних атомов. Так как у нас антиферромагнетик, минимальная энергия достигается в случае, если каждый спин противонаправлен с соседними. Это просто оператор \(\sigma^z_j \sigma^z_{j+1}\), который действует на все пары соседних спинов. Ну и сразу введем некоторую константу обменного взаимодействия \(J\), чтобы потом нам было удобно сравнивать ее с внешним полем. В итоге, для цепочки из \(N\) спинов, получаем:
\begin{equation*}
\begin{split}
\hat{H}_{h=0} = J \sum_{i=0}^{N-1} \sigma^{z}_i \sigma^{z}_{i+1}
\end{split}
\end{equation*}
\sphinxAtStartPar
А теперь давайте добавим внешнее поле \(h\). В этом случае поле просто действует на все спины и пытается выстроить их в зависимости от своего направления, например, вниз. Тогда полный гамильтониан такой системы можно записать в виде:
\begin{equation*}
\begin{split}
\hat{H}_{h\neq 0} = J \sum_{i=0}^{N-1} \hat{\sigma}^{z}_i\hat{\sigma}^{z}_{i+1} - h\sum_{i=0}^N \hat{\sigma}^{z}_i
\end{split}
\end{equation*}

\section{Задача Изинга как задача о максимальном разрезе в графе}
\label{\detokenize{book/problems/ru/ising:id3}}
\sphinxAtStartPar
Задача о максимальном разрезе в графе – это очень известная задача комбинаторики. Она относится к классу \(NP\)\sphinxhyphen{}трудных, и к ней можно свести все другие \(NP\) задачи. При этом ее формулировка одна из самых простых среди всего класса задач. Формулируется она следующим образом.

\sphinxAtStartPar
Нам дан граф – набор вершин \(V\) и связывающих их ребер \(E\). Нам надо найти такое разделение вершин \(V\) на два непересекающихся набора \(V_1, V_2\), что число ребер между вершинами из разных наборов будет максимально.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{Max-cut}.png}
\caption{Иллюстрация задачи о максимальном разрезе в графе}\label{\detokenize{book/problems/ru/ising:maxcut}}\end{figure}

\sphinxAtStartPar
Теперь давайте представим, что каждой вершине нашего графа сопоставили кубит. Для этих кубитов можем \sphinxhref{../../qc/ru/qubit.html\#id23}{производить измерения} по оси \(Z\), чтобы понять, как направлен тот или иной спин. И давайте запишем вот такой гамильтониан и внимательно на него посмотрим:
\begin{equation*}
\begin{split}
\hat{H} = \sum_{u,v \in E} \hat{\sigma}^z_u \hat{\sigma}^z_v
\end{split}
\end{equation*}
\sphinxAtStartPar
Тут суммирование \(u,v \in E\) идет по всем ребрам графа, а \(u,v\) – вершины инцидентные ребрам. Если вспомнить, что собственные значения \(\sigma^z\) это \(\pm 1\) для, соответственно, спина “вверх” и спина “вниз”, то не трудно понять, в каком случае у нас будет минимум энергии этого гамильтониана. А будет он тогда, когда максимальное число пар вершин \(u,v\) имеют разную ориентацию своих спинов. Ведь если они имеют одинаковую направленность (причем не важно, \(+1\) или \(-1\)), их произведение будет равно \(1\), но если направленность разная, то их произведение даст нам \(-1\). Таким образом, минимум энергии такого гамильтониана достигается тогда, когда мы разбили наши вершины на две группы – спин “вверх” и спин “вниз” – причем число ребер между этими группами максимальное. А это в чистом виде формулировка задачи о максимальном разрезе в графе!

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Тематика квантовой физики мало обсуждалась в первых лекциях, но нам пока достаточно знать лишь то, что для любая физическая система (включая квантовую) стремится в состояние с минимальной энергией. Например, тело, подброшенное вверх, стремится упасть на землю, а возбужденный атом стремится релаксировать в невозбужденное состояние.
\end{sphinxadmonition}

\sphinxAtStartPar
При этом из квантовой физики помним, что для реальных физических систем наиболее вероятными являются состояния с минимальной энергии и системы стремятся в эти состояния прийти. Теперь для простоты предположим, что наш граф – это просто цепочка, то есть ребра есть лишь между соседними в одномерном пространстве вершинами. Ну и теперь давайте сформулируем нашу задачу о максимальном разрезе чуточку сложнее – нам надо найти не просто максимальный разрез, а такой разрез, который самый большой при наименьшем числе вершин в наборе \(V_1\). И поскольку теперь у нас два вклада в стоимость, то нам нужны коэффициенты, которые покажут, что важнее. Пусть это будут \(J\) и \(h\). Тогда гамильтониан соответствующей модели Изинга можно записать так:
\begin{equation*}
\begin{split}
\hat{H} = J \sum_{i=0}^{N-1} \hat{\sigma}^{z}_i\hat{\sigma}^{z}_{i+1} - h\sum_{i=0}^N \hat{\sigma}^{z}_i
\end{split}
\end{equation*}
\sphinxAtStartPar
Как видно, это тот же самый гамильтониан, который получили и для моделирования антиферромагнетиков. То есть задача об основном состоянии цепочки антиферромагнитных частиц во внешнем поле эквивалентна задаче о максимальном разрезе в графе\sphinxhyphen{}цепочке при некотором штрафе за одно из выделенных направлений спинов. Эквивалентность в данном случае значит, что:
\begin{itemize}
\item {} 
\sphinxAtStartPar
решив задачу о максимальном разрезе, можно найти и основное состояние физической системы;

\item {} 
\sphinxAtStartPar
как\sphinxhyphen{}то смоделировав физическую систему, подождав пока она релаксирует, после чего измерив ее, получим конфигурацию, отвечающую решению задачи о максимальном разрезе.

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Одномерная цепочка атомов, или поиск максимального разреза в графе\sphinxhyphen{}цепочке, является простым случаем и не является \(NP\)\sphinxhyphen{}задачей. Однако уже в двумерном случае эта задача становится сильно сложнее, как и, например, если в цепочке атомов ферромагнетика добавим взаимодействие не только соседних спинов, но и взаимодействие с соседями соседа. Аналогично, модель вида Изинга сильно усложняется при добавлении недиагональных (off\sphinxhyphen{}diagonal elements) элементов гамильтониана, например, когда внешнее поле направлено в другом направлении и второй член гамильтониана принимает вид \(h\sum_{i=N} \sigma^{x}_i\). Более подробное исследование данной модели приводится в {\hyperref[\detokenize{book/problems/ru/advising::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{этой продвинутой лекции}}}}.
\end{sphinxadmonition}


\section{Модель Изинга на чистом NumPy}
\label{\detokenize{book/problems/ru/ising:numpy}}
\sphinxAtStartPar
Давайте попробуем реализовать одномерный гамильтониан Изинга на чистом \sphinxcode{\sphinxupquote{NumPy}}/\sphinxcode{\sphinxupquote{SciPy}} в виде разреженной матрицы. Для этого вспомним, что действуя оператором \(\sigma^z\) на \(i\)\sphinxhyphen{}й кубит, одновременно действуем единичным оператором на все остальные, а потом перемножаем все операторы произведением Кронекера. Из {\hyperref[\detokenize{book/linalg/ru/linalg_intro::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{лекций по линейной алгебре}}}} помним также об ассоциативности произведения Кронекера, чем и воспользуемся:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{from} \PYG{n+nn}{scipy} \PYG{k+kn}{import} \PYG{n}{sparse}
\PYG{k+kn}{from} \PYG{n+nn}{scipy}\PYG{n+nn}{.}\PYG{n+nn}{sparse} \PYG{k+kn}{import} \PYG{n}{linalg} \PYG{k}{as} \PYG{n}{sl}

\PYG{k}{def} \PYG{n+nf}{sigmaz\PYGZus{}k}\PYG{p}{(}\PYG{n}{k}\PYG{p}{:} \PYG{n+nb}{int}\PYG{p}{,} \PYG{n}{n}\PYG{p}{:} \PYG{n+nb}{int}\PYG{p}{)} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{sparse}\PYG{o}{.}\PYG{n}{csr\PYGZus{}matrix}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{left\PYGZus{}part} \PYG{o}{=} \PYG{n}{sparse}\PYG{o}{.}\PYG{n}{eye}\PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*}\PYG{o}{*} \PYG{n}{k}\PYG{p}{)}
    \PYG{n}{right\PYGZus{}part} \PYG{o}{=} \PYG{n}{sparse}\PYG{o}{.}\PYG{n}{eye}\PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*}\PYG{o}{*} \PYG{p}{(}\PYG{n}{n} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}} \PYG{n}{k}\PYG{p}{)}\PYG{p}{)}

    \PYG{k}{return} \PYG{n}{sparse}\PYG{o}{.}\PYG{n}{kron}\PYG{p}{(}
        \PYG{n}{sparse}\PYG{o}{.}\PYG{n}{kron}\PYG{p}{(}
            \PYG{n}{left\PYGZus{}part}\PYG{p}{,}
            \PYG{n}{sparse}\PYG{o}{.}\PYG{n}{csr\PYGZus{}matrix}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{p}{]}\PYG{p}{,}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{)}\PYG{p}{,}
        \PYG{n}{right\PYGZus{}part}
    \PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
А теперь можем реализовать и сам оператор Изинга:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{ising}\PYG{p}{(}\PYG{n}{j}\PYG{p}{:} \PYG{n+nb}{float}\PYG{p}{,} \PYG{n}{h}\PYG{p}{:} \PYG{n+nb}{float}\PYG{p}{,} \PYG{n}{n}\PYG{p}{:} \PYG{n+nb}{int}\PYG{p}{)} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{sparse}\PYG{o}{.}\PYG{n}{csr\PYGZus{}matrix}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{res} \PYG{o}{=} \PYG{n}{sparse}\PYG{o}{.}\PYG{n}{csr\PYGZus{}matrix}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*}\PYG{o}{*} \PYG{n}{n}\PYG{p}{,} \PYG{l+m+mi}{2} \PYG{o}{*}\PYG{o}{*} \PYG{n}{n}\PYG{p}{)}\PYG{p}{,} \PYG{n}{dtype}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{complex64}\PYG{p}{)}

    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{res} \PYG{o}{+}\PYG{o}{=} \PYG{n}{j} \PYG{o}{*} \PYG{n}{sigmaz\PYGZus{}k}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{n}\PYG{p}{)} \PYG{o}{*} \PYG{n}{sigmaz\PYGZus{}k}\PYG{p}{(}\PYG{n}{i} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{n}\PYG{p}{)}
        \PYG{n}{res} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{h} \PYG{o}{*} \PYG{n}{sigmaz\PYGZus{}k}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{n}\PYG{p}{)}

    \PYG{n}{res} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{h} \PYG{o}{*} \PYG{n}{sigmaz\PYGZus{}k}\PYG{p}{(}\PYG{n}{n} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{n}\PYG{p}{)}

    \PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Если внешнего поля нет, спины выстраиваются в полный антиферромагнитный порядок, в чем легко убедиться. Создадим оператор для такой модели и, например, 10 спинов (или 10 вершин в графе, если говорим в терминах Max\sphinxhyphen{}Cut):

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{op} \PYG{o}{=} \PYG{n}{ising}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}
\PYG{n}{solution} \PYG{o}{=} \PYG{n}{sl}\PYG{o}{.}\PYG{n}{eigs}\PYG{p}{(}\PYG{n}{op}\PYG{p}{,} \PYG{n}{which}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{SR}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{k}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{return\PYGZus{}eigenvectors}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Energy: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{solution}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Energy: (\PYGZhy{}9.000000000000018\PYGZhy{}2.208468631860285e\PYGZhy{}16j)
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Тут пользуемся функциями из \sphinxcode{\sphinxupquote{ARPACK}} – набором рутин для линейной алгебры разреженных систем. Более подробно о способах и алгоритмах классических решений задачи о собственных значениях расскажем в {\hyperref[\detokenize{book/problems2qml/ru/eigenvals::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{одной из следующих лекций}}}}, полностью посвещнной этой теме. Пока же просто используем эту рутину как “черный ящик”. Более подробное описание этой функции и ее аргументов можно посмотреть в \sphinxhref{https://scipy.github.io/devdocs/reference/generated/scipy.sparse.linalg.eigs.html}{документации библиотеки \sphinxcode{\sphinxupquote{SciPy}}}.
\end{sphinxadmonition}

\sphinxAtStartPar
Эта энергия соответствует антиферромагнитному порядку, в этом легко убедиться, нарисовав спины и формулу на бумажке. Внимательный читатель заметил, что в этот раз вернули также и первый собственный вектор, который в нашем случае является волновой функцией основного состояния. А как знаем, квадраты элементов вектора волновой функции дают нам вероятности соответствующих битовых строк (если для вас это все звучит дико, то очень рекомендуем вернуться к {\hyperref[\detokenize{book/qc/ru/qubit::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{лекции про кубит}}}}). Давайте посмотрим на эту битовую строку, иначе на порядок наших спинов в решении (или на разбиение вершин графа на два подмножества в терминах Max\sphinxhyphen{}Cut):

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{probs2bit\PYGZus{}str}\PYG{p}{(}\PYG{n}{probs}\PYG{p}{:} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{)} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n+nb}{str}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{size} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{log2}\PYG{p}{(}\PYG{n}{probs}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{bit\PYGZus{}s\PYGZus{}num} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{where}\PYG{p}{(}\PYG{n}{probs} \PYG{o}{==} \PYG{n}{probs}\PYG{o}{.}\PYG{n}{max}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}

    \PYG{n}{s} \PYG{o}{=} \PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{bit\PYGZus{}s\PYGZus{}num}\PYG{l+s+si}{:}\PYG{l+s+s2}{b}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}
    \PYG{n}{s} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{*} \PYG{p}{(}\PYG{n}{size} \PYG{o}{\PYGZhy{}} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}\PYG{p}{)} \PYG{o}{+} \PYG{n}{s}

    \PYG{k}{return} \PYG{n}{s}

\PYG{n}{probs} \PYG{o}{=} \PYG{n}{solution}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{*} \PYG{n}{solution}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{conj}\PYG{p}{(}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{probs2bit\PYGZus{}str}\PYG{p}{(}\PYG{n}{probs}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
0101010101
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Теперь давайте попробуем добавить внешнее поле с коэффициентом, равным удвоенному значению константы обменного взаимодействия. В терминах комбинаторной задачи, добавляем штраф, равный \(2\) умножить на число спинов, направленных вверх.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{external\PYGZus{}field}\PYG{p}{(}\PYG{n}{j}\PYG{p}{:} \PYG{n+nb}{float}\PYG{p}{,} \PYG{n}{h}\PYG{p}{:} \PYG{n+nb}{float}\PYG{p}{,} \PYG{n}{n}\PYG{p}{:} \PYG{n+nb}{int}\PYG{p}{)} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{k+kc}{None}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{op} \PYG{o}{=} \PYG{n}{ising}\PYG{p}{(}\PYG{n}{j}\PYG{p}{,} \PYG{n}{h}\PYG{p}{,} \PYG{n}{n}\PYG{p}{)}
    \PYG{n}{solution} \PYG{o}{=} \PYG{n}{sl}\PYG{o}{.}\PYG{n}{eigs}\PYG{p}{(}\PYG{n}{op}\PYG{p}{,} \PYG{n}{which}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{SR}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{k}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{return\PYGZus{}eigenvectors}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Energy: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{solution}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

    \PYG{n}{probs} \PYG{o}{=} \PYG{n}{solution}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{*} \PYG{n}{solution}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{conj}\PYG{p}{(}\PYG{p}{)}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{probs2bit\PYGZus{}str}\PYG{p}{(}\PYG{n}{probs}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{external\PYGZus{}field}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Energy: (\PYGZhy{}11.000000000000007\PYGZhy{}1.05712250567288e\PYGZhy{}16j)
0101010010
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Видим, что теперь наш антиферромагнитный порядок уже не полный. В целом, данная модель довольно интересная, так как при некотором отношении \(\frac{h}{J}\) у нас происходит фазовый переход от полной упорядоченности, а при дальнейшем росте \(h\) приходим к одинаковой ориентации всех спинов, в чем легко убедиться, взяв, например, \(h = 100\):

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{external\PYGZus{}field}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{100}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Energy: (\PYGZhy{}991.0000000000039\PYGZhy{}3.488261257113687e\PYGZhy{}14j)
0000000000
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Заключение}
\label{\detokenize{book/problems/ru/ising:id4}}
\sphinxAtStartPar
В этой лекции на базовом уровне познакомились с моделью Изинга – очень важным концептом в квантовом машинном обучении. Узнали, что:
\begin{itemize}
\item {} 
\sphinxAtStartPar
модель Изинга изначально была создана для объяснения магнетизма;

\item {} 
\sphinxAtStartPar
нахождение решений для модели Изинга в общем случае – \sphinxstyleemphasis{\(NP\)\sphinxhyphen{}полная} задача;

\item {} 
\sphinxAtStartPar
модель Изинга также может быть сформулирована в терминах задачи о максимальном разрезе в графе (и наоборот);

\item {} 
\sphinxAtStartPar
в классической модели Изинга существуют интересные фазовые переходы;

\item {} 
\sphinxAtStartPar
модель Изинга легко реализовать в коде, используя \sphinxcode{\sphinxupquote{SciPy}}, но размерность задачи растет очень быстро.

\end{itemize}

\sphinxstepscope


\chapter{Точное аналитическое решение одномерной модели Изинга. Метод трансфер\sphinxhyphen{}матрицы.}
\label{\detokenize{book/problems/ru/advising:advising}}\label{\detokenize{book/problems/ru/advising:id1}}\label{\detokenize{book/problems/ru/advising::doc}}
\sphinxAtStartPar
Автор(ы):
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/dbazhanov}{Бажанов Дмитрий}

\end{itemize}

\sphinxAtStartPar
В этой лекции более подробно обсудим модель Изинга, {\hyperref[\detokenize{book/problems/ru/ising::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{рассмотренную ранее}}}}. Чуть глубже погрузимся в физику этой модели, а также рассмотрим ее частные случае, которые имеют точные аналитические решения. Для этого также познакомимся с методом \sphinxstyleemphasis{трансфер\sphinxhyphen{}матрицы}.


\section{Модель Изинга}
\label{\detokenize{book/problems/ru/advising:id2}}
\sphinxAtStartPar
Модель Изинга представляет собой широко распространенную математическую модель статистической физики, которая может применяться в различных областях человеческой деятельности.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Несмотря на свою известность, многие не знают, что модель названа в честь Эрнеста Изинга – автора работы, опубликованной в 1925 г. {[}\hyperlink{cite.book/bibliography:id43}{Isi25}{]}, в которой он впервые представил данную модель и которая стала его первой и по сути \sphinxstyleemphasis{единственной} публикацией.
\end{sphinxadmonition}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=300\sphinxpxdimen]{{Ernst_Ising}.png}
\caption{Эрнст Изинг, 1900\sphinxhyphen{}1998}\label{\detokenize{book/problems/ru/advising:id7}}\end{figure}

\sphinxAtStartPar
Суть самой модели можно постичь, например, при стремлении описать свойства намагничивания материала. Представим себе, что имеется магнитная решетка (она может быть одномерной, двумерной или трехмерной) каждой вершине которой сопоставляется число называемое \sphinxstyleemphasis{спином} (\(\sigma\)) и принимающее значение \(+1\) или \(−1\) (соответственно поле  “\(\uparrow\)” или поле “\(\downarrow\)”). Каждому из \(2^N\) (где \(N\) – число вершин решетки) возможных вариантов расположения спинов (или намагниченности) приписывается энергия, величина которой определяется условиями попарного взаимодействия спинов соседних вершин. Например, энергия одномерной модели Изинга, в которой спины взаимодействуют только c ближайшими соседями (посредством параметра обменного взаимодействия \(J\)) и с однородным внешним полем (\(H\)), имеет вид:
\begin{equation}\label{equation:book/problems/ru/advising:eqn:1}
\begin{split}
E(\{\sigma\}) = -J\sum_{i=1}^N \sigma_i \sigma_{i+1} - H\sum_{i=1}^N \sigma_i.
\end{split}
\end{equation}
\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Обратите внимание, что в этой лекции используется терминология из физики (а не области квантовых вычислений, которая используется в большинстве других лекций): \(H\) – это внешнее поле, не гамильтониан, или энергия. А энергия обозначается классическим для физики \(E\).

\sphinxAtStartPar
Это выражение соответствует периодическим граничным условиям, при которых первый и \(N+1\)\sphinxhyphen{}й спины отождествляются, то есть
\begin{equation*}
\begin{split}
\sigma_{N+1} \equiv \sigma_1.
\end{split}
\end{equation*}
\sphinxAtStartPar
В этом случае можно считать, что система спинов находится на окружности, то есть первый и \(N\)\sphinxhyphen{}й спины являются ближайшими соседями и взаимодействуют между собой. Для описания такой системы необходимо найти статистическую сумму \(Z\), в которой содержится полная информация о всех состояниях системы. Тогда другие характеристики системы, такие как удельная энергия, свободная энергия, энтропия, намагниченность, магнитная восприимчивость и др. вычисляются через статистическую сумму или ее производные.

\sphinxAtStartPar
Статистическая сумма рассматриваемой модели при температуре \(\theta\) есть сумма по всем спиновым конфигурациям \(\{\sigma\}\):
\begin{equation}\label{equation:book/problems/ru/advising:eqn:2}
\begin{split}
Z(\theta,H,N) = \sum_{\{\sigma\}} e^{-\frac{E(\{\sigma\})}{\theta}}.
\end{split}
\end{equation}
\sphinxAtStartPar
Сумму по состояниям \(\{\sigma\}\) можно понимать как последовательное суммирование по значениям всех переменных \(\sigma_i\):
\begin{equation*}
\begin{split}
\sum_{\{\sigma\}} \equiv \sum_{\sigma_1 = \pm 1} \sum_{\sigma_2 = \pm 1} \ldots \sum_{\sigma_N = \pm 1}.
\end{split}
\end{equation*}
\sphinxAtStartPar
Следует заметить, что количество членов статистической суммы экспоненциально растет с увеличением числа вершин, соответственно увеличивается и время расчета термодинамических параметров для большого количества частиц.
\end{sphinxadmonition}


\section{Матричный подход}
\label{\detokenize{book/problems/ru/advising:id4}}
\sphinxAtStartPar
Для аналитического решения модели Изинга как правило применяется матричный подход. В рамках такого подхода статистическая сумма многих решеточных моделей Изинга может быть записана в виде следа некоторой степени \sphinxstyleemphasis{трансфер\sphinxhyphen{}матрицы}. Чтобы выразить статистическую сумму \eqref{equation:book/problems/ru/advising:eqn:2} через трансфер\sphinxhyphen{}матрицу, сначала представим гиббсовскую экспоненту в виде произведения \(N\) множителей
\begin{equation}\label{equation:book/problems/ru/advising:eqn:3}
\begin{split}
e^{-\frac{E(\{\sigma\})}{\theta}} = T_{\sigma_1 \sigma_2} T_{\sigma_2 \sigma_3} \ldots  T_{\sigma_{N-1} \sigma_N} T_{\sigma_N \sigma_1} = \prod_{j=1}^N T_{\sigma_j, \sigma_{j + 1}},
\end{split}
\end{equation}
\sphinxAtStartPar
где
\begin{equation}\label{equation:book/problems/ru/advising:eqn:4}
\begin{split}
T_{\sigma \sigma'} = \langle \sigma|T|\sigma' \rangle = e^{t\sigma\sigma' +\frac{h}{2}(\sigma + \sigma')},
\end{split}
\end{equation}
\sphinxAtStartPar
а \(t\) и \(h\) введены для более компактного написания формул и выражаются через \(J\), \(H\) и \(\theta\) следующим образом
\begin{equation*}
\begin{split}
t = \frac{J}{\theta}, \quad h = \frac{H}{\theta}.
\end{split}
\end{equation*}
\sphinxAtStartPar
Числа \(T_{\sigma \sigma'}\) \eqref{equation:book/problems/ru/advising:eqn:4} будем дальше рассматривать как матричные элементы матрицы \(T\), строки и столбцы которой вместо натуральных чисел нумеруются изинговскими переменными \(\sigma\) и \(\sigma'\). Так как изинговские переменные принимают два значения: \(\sigma, \sigma' = \pm 1\), то матрица \(T\) является квадратной матрицей размера \(2 \times 2\). Договоримся дальше считать, что значение \(\sigma = 1\) (\(\sigma' = 1\)) соответствует первой строке (первому столбцу), а значение \(\sigma = -1\) (\(\sigma' = -1\)) соответствует второй строке (второму столбцу). Матрица \(T\) с элементами \eqref{equation:book/problems/ru/advising:eqn:4} в таком случае имеет следующий явный вид:
\begin{equation}\label{equation:book/problems/ru/advising:eqn:5}
\begin{split}
T = \begin{pmatrix}
    T_{1,1} & T_{1,-1} \\
    T_{-1, 1} & T_{-1, -1}
    \end{pmatrix}
= \begin{pmatrix}
    e^{t+h} & e^{-t} \\
    e^{-t} & e^{t-h}
    \end{pmatrix}
\end{split}
\end{equation}
\sphinxAtStartPar
Матрица \(T\) называется \sphinxstyleemphasis{трансфер\sphinxhyphen{}матрицей} Крамерса–Ваннье.

\sphinxAtStartPar
Равенство \eqref{equation:book/problems/ru/advising:eqn:3} позволяет записать статистическую сумму \eqref{equation:book/problems/ru/advising:eqn:2} в следующем виде
\begin{equation}\label{equation:book/problems/ru/advising:eqn:6}
\begin{split}
Z(\theta, H, N) = \sum_{\sigma_1 = \pm 1} \sum_{\sigma_2 = \pm 1} \ldots \sum_{\sigma_{N-1} = \pm 1}\sum_{\sigma_N = \pm 1} T_{\sigma_1 \sigma_2} T_{\sigma_2 \sigma_3} \ldots T_{\sigma_{N-1} \sigma_N}  T_{\sigma_N \sigma_1}.
\end{split}
\end{equation}
\sphinxAtStartPar
Структура слагаемых позволяет переписать сумму в правой части последнего равенства следующим образом:
\begin{equation}\label{equation:book/problems/ru/advising:eqn:7}
\begin{split}
\sum_{\sigma_1 = \pm 1} \sum_{\sigma_2 = \pm 1} \ldots \sum_{\sigma_{N-1} = \pm 1} \sum_{\sigma_N = \pm 1} T_{\sigma_1 \sigma_2} T_{\sigma_2 \sigma_3} \ldots T_{\sigma_{N-1} \sigma_N}  T_{\sigma_N \sigma_1} =
\end{split}
\end{equation}\begin{equation*}
\begin{split}
\begin{align*}
= \sum_{\sigma_1 = \pm 1} \sum_{\sigma_2 = \pm 1} \ldots \sum_{\sigma_{N-1} = \pm 1} T_{\sigma_1 \sigma_2} T_{\sigma_2 \sigma_3} \ldots T_{\sigma_{N-2} \sigma_{N-1}} \sum_{\sigma_N = \pm 1} T_{\sigma_{N-1} \sigma_N}  T_{\sigma_N \sigma_1}
\end{align*}
\end{split}
\end{equation*}
\sphinxAtStartPar
Теперь, поскольку \(T_{\sigma \sigma'}\) являются матричными элементами матрицы \(T\), заметим, что сумма
\begin{equation*}
\begin{split}
\sum_{\sigma_N = \pm 1} T_{\sigma_{N-1} \sigma_N} T_{\sigma_N \sigma_1}
\end{split}
\end{equation*}
\sphinxAtStartPar
равна \(T_{\sigma_{N-1} \sigma_1}^2\), то есть матричному элементу матрицы \(T^2\), которая получается в результате (матричного) умножения двух матриц \(T\) (является квадратом матрицы \(T\)). Тогда сумма в правой части равенства \eqref{equation:book/problems/ru/advising:eqn:7} равна
\begin{equation}\label{equation:book/problems/ru/advising:eqn:8}
\begin{split}
\sum_{\sigma_1 = \pm 1}\sum_{\sigma_2 = \pm 1} \ldots \sum_{\sigma_{N-1}} T_{\sigma_1 \sigma_2} T_{\sigma_2 \sigma_3} \ldots T_{\sigma_{N-2} \sigma_{N-1}} T^2_{\sigma_{N-1} \sigma_1}.
\end{split}
\end{equation}
\sphinxAtStartPar
Дальше используем равенство
\begin{equation*}
\begin{split}
\sum_{\sigma_{N-1}} T_{\sigma_{N-2} \sigma_{N-1}} T^2_{\sigma_{N-1} \sigma_1} = T^3_{\sigma_{N-2} \sigma_1},
\end{split}
\end{equation*}
\sphinxAtStartPar
где \(T^3 = T\cdot T^2\) – куб матрицы \(T\), и перепишем выражение \eqref{equation:book/problems/ru/advising:eqn:8} в виде
\begin{equation*}
\begin{split}
\sum_{\sigma_1 = \pm 1}\sum_{\sigma_2 = \pm 1} \ldots \sum_{\sigma_{N-2}} T_{\sigma_1 \sigma_2} T_{\sigma_2 \sigma_3} \ldots T_{\sigma_{N-3} \sigma_{N-2}} T^3_{\sigma_{N-2} \sigma_1}.
\end{split}
\end{equation*}
\sphinxAtStartPar
Продолжим этот процесс и просуммируем последовательно по всем \(\sigma_i\), \(i = 2, \dots , N\), кроме \(\sigma_1\), тогда равенство \eqref{equation:book/problems/ru/advising:eqn:6} преобразуется к виду
\begin{equation*}
\begin{split}
Z(\theta, H, N) = \sum_{\sigma_1 = \pm 1} T^N_{\sigma_1 \sigma_1}
\end{split}
\end{equation*}
\sphinxAtStartPar
В последнем равенстве суммируются диагональные элементы матрицы \(T^N\), которая есть матрица \(T\) в степени \(N\). Сумма диагональных элементов матрицы – это след данной матрицы. Таким образом, окончательно получаем для статистической суммы одномерной модели Изинга с взаимодействием ближайших соседей и внешним полем, при периодических граничных условиях, следующую формулу:
\begin{equation}\label{equation:book/problems/ru/advising:eqn:9}
\begin{split}
Z(\theta, H, N) = \mbox{Tr}\, T^N.
\end{split}
\end{equation}
\sphinxAtStartPar
Отметим несколько обстоятельств, связанных с полученным выражением для статистической суммы:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
формула \eqref{equation:book/problems/ru/advising:eqn:9} является следствием трансляционной инвариантности рассматриваемой системы. Трансляционная инвариантность в данном случае означает, что энергия системы спинов не изменяется при пространственном сдвиге, то есть спиновые конфигурации \(\{\sigma\}\) и \(\{\sigma'\}\), где \(\sigma_i' = \sigma_{i+1}\), имеют одинаковые энергии;

\item {} 
\sphinxAtStartPar
представление гиббсовской экспоненты в виде произведения \eqref{equation:book/problems/ru/advising:eqn:3}, где множители \(T_{\sigma \sigma'}\) имеют вид \eqref{equation:book/problems/ru/advising:eqn:4}, не является единственным возможным. Можно выбрать трансфер\sphinxhyphen{}матрицу по\sphinxhyphen{}другому. Например, если взять \(\tilde{T}_{\sigma \sigma'} = e^{t\sigma\sigma' + h\sigma}\), то тогда: \(e^{-\frac{E(\{\sigma\})}{\theta}} = \prod^{N}_{j=1} \tilde{T}_{\sigma_{j} \sigma_{j+1}}.\) Таким образом, в выборе трансфер\sphinxhyphen{}матрицы существует некоторый произвол. Значение статистической суммы не зависит от этого произвола, поэтому им естественно распорядиться исходя из каких\sphinxhyphen{}то дополнительных соображений, например так, чтобы матрица обладала какой\sphinxhyphen{}то симметрией, что упрощает вычисления. Для рассмотренной выше одномерной модели Изинга трансфер\sphinxhyphen{}матрица была выбрана вещественной симметричной (то есть эрмитовой);

\item {} 
\sphinxAtStartPar
если выбранная нами трансфер\sphinxhyphen{}матрица \(T\) является эрмитовой, то с помощью унитарного преобразования \(U\) ее можно преобразовать к диагональной форме:
\begin{equation*}
\begin{split}
    \grave{T} = U^{-1}TU = dgn\{\lambda_1, \lambda_2, . . . , \lambda_r\},
    \end{split}
\end{equation*}
\sphinxAtStartPar
где символом \(dgn\) обозначена диагональная матрица, на главной диагонали которой расположены ее собственные значения. В общем случае размерность такой матрицы равна величине \(r=s^n\), где \(s\) – число состояний спина в вершине, а \(n\) – число обменных взаимодействий спинов цепочки (в рассматриваемой нами одномерной модели Изинга \(s=2\) и \(n=1\)). В этом случае статистическая сумма \eqref{equation:book/problems/ru/advising:eqn:9} переписывается к следующему виду:
\begin{equation}\label{equation:book/problems/ru/advising:eqn:10}
\begin{split}
    Z(\theta, H, N) = \mbox{Tr}\, \grave{T}^N = \sum_{i}^{r} \lambda_{i}^{N},
    \end{split}
\end{equation}
\sphinxAtStartPar
При этом величина статистической суммы не меняется, поскольку след матрицы является ее инвариантом. Отметим, что процедуру диагонализации трансфер\sphinxhyphen{}матрицы можно провести множеством способов. В зависимости от подбора диагонализирующей матрицы \(U\) её можно провести таким образом, что на первом месте в матрице \(\grave{T}\) будет стоять её главное (единственное максимальное вещественное) собственное значение, которое всегда существует по теореме Фробениуса–Перрона. Если на первое место в спектре трансфер\sphinxhyphen{}матрицы поставить ее главное собственное значение, то статистическую сумму \eqref{equation:book/problems/ru/advising:eqn:10} можно переписать как:
\begin{equation}\label{equation:book/problems/ru/advising:eqn:11}
\begin{split}
    Z(\theta, H, N) = \lambda_1^N \left[ 1 + \left(\frac{\lambda_2}{\lambda_{1}}\right)^N + ... + \left(\frac{\lambda_r}{\lambda_{1}}\right)^N \right]
    \end{split}
\end{equation}
\sphinxAtStartPar
Тогда при переходе к термодинамическому пределу \((N \to \infty)\) в выражении \eqref{equation:book/problems/ru/advising:eqn:11} все слагаемые, кроме первого, стремятся к нулю,
\begin{equation}\label{equation:book/problems/ru/advising:eq:lim}
\begin{split}
    &\lim_{N \to \infty} \left(\frac{\lambda_i}{\lambda_{1}}\right)^N =0, \\
    &\hspace{0.5cm} i=2,3,..,r
    \end{split}
\end{equation}
\sphinxAtStartPar
и выражение для статистической суммы преобразуется к виду \(Z = \lambda^{N}_{1}\).

\sphinxAtStartPar
В результате все термодинамические и магнитные функции системы – свободная энергия системы, приходящаяся на один спин,
\begin{equation}\label{equation:book/problems/ru/advising:eq:fren}
\begin{split}
    F = -\frac{\theta}{N} \mbox{ln} Z = -\theta \mbox{ln} \lambda_1,
    \end{split}
\end{equation}
\sphinxAtStartPar
энтропия
\begin{equation}\label{equation:book/problems/ru/advising:eq:entropy}
\begin{split}
    S = -\frac{\partial F}{\partial \theta} = \mbox{ln} \lambda_1 + \frac{\theta}{\lambda_1} \frac{\partial \lambda_1}{\partial \theta},
    \end{split}
\end{equation}
\sphinxAtStartPar
теплоемкость
\begin{equation}\label{equation:book/problems/ru/advising:eq:c}
\begin{split}
    C = - \theta \frac{\partial^2 F}{\partial \theta^2} =
    2 \frac{\theta}{\lambda_1}\frac{\partial \lambda_1}{\partial \theta} +
    \frac{\theta^2}{\lambda_1}
    \frac{\partial^2 \lambda_1}{\partial \theta^2} -
    \frac{\theta^2}{\lambda^{2}_{1}} \left( \frac{\partial \lambda_1}{\partial \theta} \right)^2,
    \end{split}
\end{equation}
\sphinxAtStartPar
намагниченность
\begin{equation}\label{equation:book/problems/ru/advising:eq:mag}
\begin{split}
    M= -\frac{\partial F}{\partial H} =  \frac{\theta}{\lambda_1} \frac{\partial \lambda_1}{\partial H},
    \end{split}
\end{equation}
\sphinxAtStartPar
и магнитная восприимчивость
\begin{equation}\label{equation:book/problems/ru/advising:eq:chi}
\begin{split}
    \chi = -\frac{\partial^2 F}{\partial H^2} =
    \frac{\partial M}{\partial H} =
    -\frac{\theta}{\lambda_{1}^{2}} \left( \frac{\partial \lambda_1}{\partial H} \right)^2 +
    \frac{\theta}{\lambda_1}\frac{\partial^2 \lambda_1}{\partial H^2}
    \end{split}
\end{equation}
\sphinxAtStartPar
определяются только через главное собственное значение трансфер\sphinxhyphen{}матрицы.

\end{enumerate}


\section{Решение одномерной модели}
\label{\detokenize{book/problems/ru/advising:id5}}
\sphinxAtStartPar
Теперь вернемся к аналитическому решению рассматриваемой нами классической одномерной модели Изинга (\(s=2\) и \(n=1\)). Как показали выше, задача сводится к сведению трансфер\sphinxhyphen{}матрицы \eqref{equation:book/problems/ru/advising:eqn:5} диагональному виду. Для этого воспользуемся правилами линейной алгебры и решим характеристическое уравнение для трансфер\sphinxhyphen{}матрицы и найдем её собственные значения:
\begin{equation}\label{equation:book/problems/ru/advising:eq:determ}
\begin{split}
det \left( T - \lambda I \right) = det \left( T - \lambda \left(\begin{pmatrix}
    1 & 0 \\
    0 & 1
\end{pmatrix} \right) \right) = 0,
\end{split}
\end{equation}
\sphinxAtStartPar
где \(I\) – единичная матрица, \(\lambda\) – действительная переменная. Раскрывая определитель \eqref{equation:book/problems/ru/advising:eq:determ}, находим искомое характеристическое уравнение:
\begin{equation}\label{equation:book/problems/ru/advising:eq:cheq}
\begin{split}
\lambda^{2} - \lambda \left( e^{t+h} + e^{t-h} \right) + e^{2t} - e^{-2t} = 0
\end{split}
\end{equation}
\sphinxAtStartPar
решением которого являются два собственных значения:
\begin{equation}\label{equation:book/problems/ru/advising:eq:eigen}
\begin{split}
\lambda_{\pm} = \frac{1}{2} e^{t} \left( e^{h} + e^{-h} \right) \pm  \frac{1}{2} \sqrt{ e^{2t} \left( e^{h} + e^{-h} \right)^{2} - 4e^{2t} + 4e^{-2t} } = e^{t} \cosh(h) \pm \sqrt{e^{2t} \sinh^{2}(h) + e^{-2t}},
\end{split}
\end{equation}
\sphinxAtStartPar
где \(\cosh(h) = \frac{e^{h} + e^{-h}}{2}\) – гиперболический косинус и \(\sinh(h) = \frac{e^{h} - e^{-h}}{2}\) – гиперболический синус. Следовательно статистическая сумма рассматриваемой модели записывается в следующем виде:
\begin{equation*}
\begin{split}
Z = Tr T^{N} = \lambda_{+}^{N} + \lambda_{-}^{N}.
\end{split}
\end{equation*}
\sphinxAtStartPar
Здесь следует отметить, что для всех физических значений параметров \(t\) и \(h\) (\(\in \mathbb{R}\), \(< \infty\)) выполняется условие: \(|\lambda_{+}| > |\lambda_{-}|\). Тогда в термодинамическом пределе (\(N \rightarrow \infty\)) значение \(\lambda_{+}\) преобладает над \(\lambda_{-}\) и удовлетворяет \eqref{equation:book/problems/ru/advising:eq:lim}, а статистическая сумма преобразуется к виду: \(Z =\lambda_{+}^{N} + \lambda_{-}^{N} \sim \lambda_{+}^{N}\). Отсюда можно получить выражение  для удельной свободной энергии системы, приходящейся на один спин \eqref{equation:book/problems/ru/advising:eq:fren} (с точностью до множителя (\(- \theta\))):
\begin{equation*}
\begin{split}
f (t,h)= \lim_{N \rightarrow \infty} \frac{\mbox{ln}Z}{N}= \mbox{ln} \lambda_{+} = t + \mbox{ln} \left( \cosh(h) + \sqrt{\sinh^{2}(h) + e^{-4t}} \right)
\end{split}
\end{equation*}
\sphinxAtStartPar
и для намагниченности \eqref{equation:book/problems/ru/advising:eq:mag}:
\begin{equation*}
\begin{split}
m = -\frac{\partial f(t,h)}{\partial h} = \frac{\cosh(h) + \frac{\sinh(h)\cosh(h)} {\sqrt{\sinh^{2}(h) + e^{-4t}}}} {\cosh(h) + \sqrt{\sinh^{2}(h) + e^{-4t}}}= \frac{\sinh(h)}{\sqrt{\sinh^{2}(h) + e^{-4t}}},
\end{split}
\end{equation*}
\sphinxAtStartPar
которая является аналитической функцией \(h\) и исчезает при \(h \rightarrow 0\) (так как \(\sinh(h) \rightarrow 0\)). Таким образом рассматриваемая модель не допускает фазового перехода при любой положительной температуре (\(\theta > 0\)). Она претерпевает \sphinxstyleemphasis{парамагнитный\sphinxhyphen{}ферромагнитный} фазовый переход только при \(\theta = 0\), в этом случае спонтанная намагниченность равна \(|m| = 1\).


\section{Заключение}
\label{\detokenize{book/problems/ru/advising:id6}}
\sphinxAtStartPar
В этой лекции ознакомились с аналитическим решением одномерной модели Изинга методом \sphinxstyleemphasis{трансфер\sphinxhyphen{}матрицы}. В заключении хотелось бы сказать, что модель Изинга поддается многим обобщениям, будь то более высокие измерения, различные решетки или модифицированные взаимодействия.

\sphinxstepscope


\chapter{Задачи комбинаторной оптимизации}
\label{\detokenize{book/problems/ru/copt:copt}}\label{\detokenize{book/problems/ru/copt:id1}}\label{\detokenize{book/problems/ru/copt::doc}}
\sphinxAtStartPar
Автор(ы):
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/SemyonSinchenko}{Синченко Семен}

\end{itemize}

\sphinxAtStartPar
В \sphinxhref{../../qcalgo/ru/quantum\_algorithms\_overview.html\#id2}{обзоре квантовых алгоритмов} мы уже касались темы задач, для которых не существует эффективных классических алгоритмов, а сегодня разберем еще больше примеров. В конце кратко обсудим пару способов, как решать такие задачи на классических компьютерах, а также в чем их принципиальные проблемы и ограничения.

\sphinxAtStartPar
Лекция будет построена так:
\begin{itemize}
\item {} 
\sphinxAtStartPar
задача о максимальном разрезе в графе;

\item {} 
\sphinxAtStartPar
задача о выделении сообществ в графе;

\item {} 
\sphinxAtStartPar
задача о Гамильтоновых циклах и коммивояжере;

\item {} 
\sphinxAtStartPar
задача о рюкзаке;

\item {} 
\sphinxAtStartPar
жадные алгоритмы;

\item {} 
\sphinxAtStartPar
метод имитации отжига.

\end{itemize}

\sphinxAtStartPar
Какого\sphinxhyphen{}то сложного кода или больших формул с дираковскими значками из квантовой механики тут не будет, так что можно немного передохнуть, расслабиться и насладиться чтением. Для тех, кто хорошо знаком с задачами целочисленной оптимизации, в этой лекции точно не будет ничего нового, и ее можно будет пропускать, ну или пролистать по диагонали.


\section{Задача о максимальном разрезе в графе}
\label{\detokenize{book/problems/ru/copt:id2}}
\sphinxAtStartPar
Мы уже немного говорили об этой задаче в лекции про \sphinxhref{../../problems/ru/ising.html\#id3}{модель Изинга} из\sphinxhyphen{}за их очень большого сходства. Но давайте еще раз вспомним, что это за модель такая. Ну и сразу рассмотрим ее максимально общий случай. Итак, у нас есть граф на множестве вершин \(V\), связанных множеством ребер \(E\). Каждое ребро имеет две инцидентных вершины \(u,v\); в общем случае порядок \(u,v\) важен, тогда мы говорим о направленном (\sphinxstyleemphasis{directed}) графе. Каждому ребру можно также сопоставить действительное число \(w\), тогда у нас будет так называемый \sphinxstyleemphasis{взвешенный} граф. Наша цель – разбить множество вершин \(V\) на два непересекающихся сообщества \(V_1, V_2\). Давайте сформулируем функцию стоимости:
\begin{equation*}
\begin{split}
C = \sum_{u,v,w \in E} w (\mathbf{1}(u \in V_1, v \in V_2) + \mathbf{1}(u \in V_2, v \in V_1))
\end{split}
\end{equation*}
\sphinxAtStartPar
То есть в общем случае это просто сумма всех весов ребер между двумя сообществами. В общем случае эта задача является \(NP\)\sphinxhyphen{}полной. В теории к этой задаче можно также свести любую другую \(NP\) задачу за полиномиальное время.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{Max-cut}.png}
\caption{Иллюстрация задачи о максимальном разрезе в графе}\label{\detokenize{book/problems/ru/copt:maxcut2}}\end{figure}


\section{Задача о выделении сообществ в графах}
\label{\detokenize{book/problems/ru/copt:id3}}
\sphinxAtStartPar
Задача о выделении сообщества в графах это уже более практическая и понятная задача. Она находит применение во многих областях, но одно из самых очевидных применений – это социология (в том числе анализ социальных сетей), когда мы хотим, анализируя контакты людей, выделить из них сообщества для дальнейшего анализа. Эта задача также является \(NP\)\sphinxhyphen{}трудной, так как существует экспоненциально много способов разбить вершины на множества и при этом для общего случая не существует полиномиального алгоритма решения. Ну и даже если мы найдем какое\sphinxhyphen{}то решение, то проверка того, что оно лучшее возможна также лишь за экспоненциальное время. Хотя для этой задачи и известны относительно быстрые приближенные алгоритмы, нам очень трудно понять, насколько хорошее решение они дают для действительно больших графов.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Для работы с графами мы будем пользоваться библиотекой \sphinxcode{\sphinxupquote{NetworkX}}. Она написана на чистом \sphinxcode{\sphinxupquote{Python}} и плохо подходит для работы с большими графами, зато имеет простой интерфейс и легко устанавливается на любую систему. Ее можно установить из репозитория \sphinxcode{\sphinxupquote{PyPI}}, используя команду

\begin{sphinxVerbatim}[commandchars=\\\{\}]
pip install networkx
\end{sphinxVerbatim}
\end{sphinxadmonition}

\sphinxAtStartPar
Одним из первых известных наборов данных для задачи выделения сообществ является “Клуб каратэ Захари” (Zachary’s Karate Club) {[}\hyperlink{cite.book/bibliography:id75}{Zac77}{]}. Для этого набора данных точно известно, к какому из двух сообществ принадлежит каждая из вершин. В этом клубе карате был внутренний конфликт, и одна часть людей была в группе одного из инструкторов (Mr. Hi), а другая – в группе администратора (Officer).

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{networkx} \PYG{k}{as} \PYG{n+nn}{nx}
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{o}{\PYGZpc{}}\PYG{k}{config} InlineBackend.figure\PYGZus{}format = \PYGZsq{}retina\PYGZsq{}

\PYG{n}{zachary} \PYG{o}{=} \PYG{n}{nx}\PYG{o}{.}\PYG{n}{generators}\PYG{o}{.}\PYG{n}{social}\PYG{o}{.}\PYG{n}{karate\PYGZus{}club\PYGZus{}graph}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{nx}\PYG{o}{.}\PYG{n}{draw}\PYG{p}{(}
    \PYG{n}{zachary}\PYG{p}{,}
    \PYG{n}{node\PYGZus{}color}\PYG{o}{=}\PYG{p}{[}
        \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Officer}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{r}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Mr. Hi}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{b}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{n}{dt}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{club}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{)} \PYG{k}{for} \PYG{n}{\PYGZus{}}\PYG{p}{,} \PYG{n}{dt}
        \PYG{o+ow}{in} \PYG{n}{zachary}\PYG{o}{.}\PYG{n}{nodes}\PYG{p}{(}\PYG{n}{data}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
    \PYG{p}{]}\PYG{p}{,}
\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{copt_1_0}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Задачу о выделении сообществ в тривиальном случае разбиения графа на два подмножества можно свести к знакомой нам задаче о максимальном разрезе. Правда, в отличие от задачи о максимальном разрезе, в случае с сообществами мы хотим иметь минимальное число ребер между ними. Но это можно сделать просто поменяв пару символов в выражении для стоимости:
\begin{equation*}
\begin{split}
C = \sum_{u,v,w \in E} w (\mathbf{1}(u \in V_1, v \in V_1) + \mathbf{1}(u \in V_2, v \in V_2))
\end{split}
\end{equation*}
\sphinxAtStartPar
Но на самом деле мы только что свели более простую задачу о минимальном разрезе с неотрицательными весами к более сложной задаче Max\sphinxhyphen{}Cut. А еще выбранная нами метрика (количество ребер) – не самый лучший вариант для этой задачи. Гораздо лучше подойдет модулярность (modularity), предложенная физиком Марком Ньюманом {[}\hyperlink{cite.book/bibliography:id54}{New06}{]}:
\begin{equation*}
\begin{split}
Q(C) = \frac{1}{2 |E|}\sum_{e \in E} B_{e_{src}, e_{dst}}\delta (c_{e_{src}}, c_{e_{dst}})
\end{split}
\end{equation*}
\sphinxAtStartPar
Тут \(B\) – это матрица модулярности (modularity matrix). Ее элементы определяются через степени \(d_i\) соответствующих вершин графа (степень вершины – это число ребер, связанных с данной вершиной) и матрицу смежности \(A\) графа:
\begin{equation*}
\begin{split}
B_{ij} = A_{ij} - \frac{d_i d_j}{2 |E|}
\end{split}
\end{equation*}
\sphinxAtStartPar
Условно, модулярность – это разница между числом ребер внутри сообществ в нашем графе и числом ребер внутри сообществ в графе с таким же числом ребер, но сгенерированным случайным образом. Это довольно сложное понятие, которое выходит за рамки нашего курса, но все равно потребуется нам, чтобы показать, что задача оптимизации модулярности может быть сформулирована как задача Изинга.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Это интересно, но одним из первых алгоритмов для решения задачи о выделении сообществ в графах был алгоритм имитации отжига, который изначально был создан именно для решения проблемы гамильтонианов типа Изинга. Причина заключается в том, что модулярность очень схожа по виду с выражением энергии для магнетиков.
\end{sphinxadmonition}

\sphinxAtStartPar
Мы тут пока описали лишь простой случай модулярности для не взвешенного и ненаправленного графа. Но даже в таком случае для задачи точной оптимизации модулярности не известно полиномиального алгоритма решения. Поэтому обычно применяют приближенные или жадные алгоритмы, и они вроде даже неплохо работают. Но мы почти не знаем, насколько действительно далеко они от самых оптимальных решений, особенно для больших графов.


\section{Задача о Гамильтоновых циклах}
\label{\detokenize{book/problems/ru/copt:id6}}
\sphinxAtStartPar
Перед тем как перейти к интересной и важной задаче поиска Гамильтоновых циклов, мы вспомним задачу о мостах Кенигсберга (Калининграда). Ведь именно гуляя по этому городу и пытаясь решить эту задачу, Леонард Эйлер изобрел теорию графов. Суть задачи: нужно обойти все острова города, пройдя по каждому мосту лишь один раз, и вернуться на тот остров, откуда стартовал. Эйлер, создав математический аппарат теории графов, сумел доказать, что это невозможно, ну а дальше завертелось, и вот мы с вами тут.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=300\sphinxpxdimen]{{bridges}.png}
\caption{Мосты Кеннингсберга, думая о которых, Эйлер изобрел теорию графов}\label{\detokenize{book/problems/ru/copt:id16}}\end{figure}

\sphinxAtStartPar
Такой путь в графе, когда мы проходим по каждому ребру лишь один раз, называется Эйлеров цикл. Но нам будет более интересен схожий класс циклов – Гамильтоновы циклы. Это такие циклы, которые проходят через каждую вершину графа ровно один раз.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=350\sphinxpxdimen]{{Hamilton}.jpg}
\caption{Сер Уильям Роуэн Гамильтон, 1805 \sphinxhyphen{} 1865}\label{\detokenize{book/problems/ru/copt:id17}}\end{figure}

\sphinxAtStartPar
Для Гамильтонова цикла мы можем ввести \(N^2\) бинарных переменных \(x_{i,p}\). Каждая переменная \(x_{i,p}\) равна \(1\), если \(i\)\sphinxhyphen{}я вершина находится на \(p\)\sphinxhyphen{}м шаге пути и \(0\) если нет. Тогда легко ввести условия существования такого цикла:
\begin{equation*}
\begin{split}
\begin{cases}
\sum_p x_{i,p} = 1 \quad \forall i \\
\sum_i x_{i,p} = 1 \quad \forall p \\
(x_{i, p} = 1) \land (x_{j, p + 1} = 0) \quad \forall i,j \notin E
\end{cases}
\end{split}
\end{equation*}
\sphinxAtStartPar
Тут первое условие говорит нам о том, что каждая вершина должна попасть в путь. Второе условие – каждый шаг пути содержит строго одну вершину. Ну а третий шаг – просто утверждение о том, что между вершинами соседних шагов пути должно быть ребро. На самом деле, эти три условия можно переписать в единую функцию стоимости:
\begin{equation*}
\begin{split}
C = (1 - \sum_i x_{i,p})^2 + (1 - \sum_p x_{i,p})^2 + \sum_{u,v \notin E} x_{u,p} x_{v,p+1}
\end{split}
\end{equation*}
\sphinxAtStartPar
Правда, в этом случае мы должны минимизировать, а не максимизировать эту величину.


\section{Задача коммивояжера}
\label{\detokenize{book/problems/ru/copt:id7}}
\sphinxAtStartPar
Задачу коммивояжера мы (а точнее наш смартфон) решаем каждый раз, когда строим в \sphinxcode{\sphinxupquote{Google Maps}} маршрут, включающий несколько точек. Зная, как формулируется задача о гамильтоновых циклах, сформулировать задачу коммивояжера очень легко.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{Salesman}.png}
\caption{Иллюстрация задачи коммивояжера}\label{\detokenize{book/problems/ru/copt:id18}}\end{figure}

\sphinxAtStartPar
По сути нам требуется взять все Гамильтоновы циклы и выбрать из них тот, для которого сумма весов по содержащимся в нем ребрам будет минимальной. Но надо помнить, что цикл обязательно должен быть в первую очередь Гамильтоновым, поэтому мы добавим веса слагаемых в выражение для стоимости, причем веса, отвечающие за сам цикл, будут больше:
\begin{equation*}
\begin{split}
C = A (1 - \sum_i x_{i,p})^2 + A (1 - \sum_p x_{i,p})^2 + A \sum_{u,v \notin E} x_{u,p} x_{v,p+1} + B \sum_{u,v,w \in E} w x_{u,p} x_{v,p+1}
\end{split}
\end{equation*}
\sphinxAtStartPar
Тут \(A,B\) это веса, которые лучше выбирать так, что \(0 < Bw < A \quad \forall u,v,w \in E\).

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Функции стоимости для задач и Гамильтоновых циклах и задачи коммивояжера являются все же приближением исходной формулировки, так как формально мы переходим от задачи с ограничениями к задаче без ограничений. В общем случае нет гарантии, что решение задачи без ограничений будет эквивалентно решению задачи с ограничениям. Но для целей нашей лекции и курса в целом мы опустим сложный момент исследования эквивалентности этих задач, потому что обычно оно работает вполне корректно.
\end{sphinxadmonition}


\section{Задача о рюкзаке}
\label{\detokenize{book/problems/ru/copt:id8}}
\sphinxAtStartPar
Довольно простая для понимания задача, к которой, однако, сводится огромное число куда более сложных задач. Например, именно задачей о рюкзаке является проблема оптимизации портфеля биржевых акций, или, например, оптимизации графиков работы сотрудников McDonald’s, учитывая ожидаемое число посетителей и т.д.

\sphinxAtStartPar
Суть задачи заключается в том, что у нас есть рюкзак ограниченного объема. А еще есть набор разных предметов – каждый из них имеет свой объем и стоимость. Наша цель в данном случае заключается в том, чтобы найти оптимальный набор предметов так, чтобы они влезали в наш рюкзак, при этом их стоимость была бы максимально возможной.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=450\sphinxpxdimen]{{Knapsack}.png}
\caption{Иллюстрация задачи о рюкзаке.}\label{\detokenize{book/problems/ru/copt:knapsack}}\end{figure}

\sphinxAtStartPar
Формально это можно записать следующим образом. Пускай у нас есть рюкзак объема \(V\). Давайте обозначим количество экземпляров \(i\)\sphinxhyphen{}й вещи в рюкзаке переменной \(x_i\), а ее объем \(v_i\). Ценность \(i\)\sphinxhyphen{}го предмета обозначим как \(s_i\). Решением задачи будет вектор \(X\) из целых чисел \(x_i\), которые при этом могут быть равны нулю – это будет значить, что \(i\)\sphinxhyphen{}я вещь не входит в оптимальный набор. Тогда нам необходимо решить следующую задачу:
\begin{equation*}
\begin{split}
\begin{cases}
X = \text{argmax} \{ \sum_i x_i \cdot s_i \} \\
\sum_i x_i \cdot w_i \leq W
\end{cases}
\end{split}
\end{equation*}

\section{Классические алгоритмы}
\label{\detokenize{book/problems/ru/copt:id9}}
\sphinxAtStartPar
Самый простой и очевидный вариант решения таких проблем – это просто перебор всех возможных комбинаций. Но так как сложность задач растет экспоненциально (\(O(N) \sim e^{N}\)), то очень быстро прямое решение (еще иногда говорят \sphinxstyleemphasis{brute force} решение, или \sphinxstyleemphasis{brute force} алгоритм) становится невозможным. Понятно, что можно воспользоваться какими\sphinxhyphen{}то эвристиками для конкретной задачи. Это приводит нас к алгоритмам типа \sphinxstyleemphasis{ветвей и границ} (\sphinxstyleemphasis{branch and bound}) {[}\hyperlink{cite.book/bibliography:id47}{LD10}{]}, в которых мы обычно строим дерево возможных решений и пытаемся перебирать не все подряд, а лишь “перспективные” ветви этого дерева, отсекая те ветки, где хороших решений точно не будет. Но сложность таких алгоритмов все равно остается экспоненциальной. Другой вариант – это искать не обязательно самое лучше решение, а хотя бы какое\sphinxhyphen{}то подходящее решение (\sphinxstyleemphasis{feasible solution}, решение, которое удовлетворяет ограничениям). Это приводит нас к аппроксимационным алгоритмам, которые каким\sphinxhyphen{}то образом пытаются свести экспоненциальную задачу к полиномиальной, пусть и теряя в гарантированном качестве итогового решения.

\begin{sphinxadmonition}{note}{Важное замечание}

\sphinxAtStartPar
Задачи комбинаторной оптимизации нельзя точно решить на квантовом компьютере! Квантовые компьютеры лишь дают нам потенциально очень эффективные \sphinxstyleemphasis{аппроксимационные} алгоритмы. Причем в основе этих алгоритмов лежит обычно как раз квантовое машинное обучение!
\end{sphinxadmonition}


\subsection{Общий вид алгоритма ветвей и границ}
\label{\detokenize{book/problems/ru/copt:id11}}
\sphinxAtStartPar
Давайте запишем как в общем виде выглядит алгоритм ветвей и границ (\sphinxhref{https://en.wikipedia.org/wiki/Branch\_and\_bound\#Generic\_version}{источник}).
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Найти любое решение \(xh\) проблемы, которое бы удовлетворяло ограничениям. Сохраним значение целевой функции для этого решения: \(B = f(xh)\). Оно будет определять лучшее из известных на данный момент решений.

\item {} 
\sphinxAtStartPar
Инициализировать очередь для хранения частных решений. В этом случае разбиваем пространство возможных решений на маленькие подпространства и строим дерево потенциальных решений. Эта часть индивидуальная для каждой задачи. Например, в случае задачи о рюкзаке, можно взять начальное решение и построить две его ветви: одна будет содержать все решения, где больше одного предмета, а другая – где его будет меньше.

\item {} 
\sphinxAtStartPar
Выполняем итерации, пока наша очередь не пустая.
\begin{itemize}
\item {} 
\sphinxAtStartPar
взять узел \(N\) из очереди;

\item {} 
\sphinxAtStartPar
если узел \(N\) представляет собой терминальный узел \(x\) дерева и \(f(x) < B\), то это новое лучшее известное решение; сохраняем его \(B = f(x)\);

\item {} 
\sphinxAtStartPar
если нет, то разбиваем \(N\) для создания новых узлов \(N_i\):
\begin{itemize}
\item {} 
\sphinxAtStartPar
если верхняя оценочная граница решений для этой ветки \(bound(N_i)\) больше \(B\), то ничего не делаем;

\item {} 
\sphinxAtStartPar
в противном случае добавляем \(N_i\) в очередь.

\end{itemize}

\end{itemize}

\end{enumerate}

\sphinxAtStartPar
В данном случае нам необходимо реализовать для конкретной задачи следующие процедуры:
\begin{itemize}
\item {} 
\sphinxAtStartPar
построения дерева решения

\item {} 
\sphinxAtStartPar
оценки верхней границы для ветви

\end{itemize}

\sphinxAtStartPar
В целом, данный алгоритм сегодня это, пожалуй, лучшее, что можем использовать, если нам необходимо точное решение. Также всегда есть опция остановить поиск до того, как мы достигнем оптимума – в этом варианте алгоритм становится аппроксимационным.


\subsection{Жадные алгоритмы}
\label{\detokenize{book/problems/ru/copt:id12}}
\sphinxAtStartPar
Теперь давайте вернемся к аппроксимационным алгоритмам, которые работают относительно быстро, но, к сожалению, часто дают довольное плохие результаты. Ну и самым простым вариантом таких алгоритмов будет жадный алгоритм. Рассматривать его будем на примере задачи о рюкзаке. Пусть у нас есть рюкзак объема \(30\) и набор предметов с их стоимостью и объемом:
\begin{equation*}
\begin{split}
items = \{(4, 370), (9, 1950), (10, 3500), (21, 6700), (17, 6100), (3, 800), (27, 8300)\}
\end{split}
\end{equation*}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{capacity} \PYG{o}{=} \PYG{l+m+mi}{30}
\PYG{n}{items} \PYG{o}{=} \PYG{p}{[}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{370}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{9}\PYG{p}{,} \PYG{l+m+mi}{1950}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{3500}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{21}\PYG{p}{,} \PYG{l+m+mi}{6700}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{17}\PYG{p}{,} \PYG{l+m+mi}{6100}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{800}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{27}\PYG{p}{,} \PYG{l+m+mi}{8300}\PYG{p}{)}\PYG{p}{,}\PYG{p}{]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Наше решение будет максимально простым:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
считаем удельную стоимость предметов, то есть стоимость единицы их массы;

\item {} 
\sphinxAtStartPar
набираем сначала самых дорогих предметов;

\item {} 
\sphinxAtStartPar
по остаточному принципу набираем остальные предметы, отдавая предпочтения тем, которые дороже по удельной стоимости.

\end{enumerate}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{items\PYGZus{}and\PYGZus{}score} \PYG{o}{=} \PYG{n+nb}{sorted}\PYG{p}{(}
    \PYG{p}{[}\PYG{p}{(}\PYG{n}{it}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{it}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{it}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{/} \PYG{n}{it}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)} \PYG{k}{for} \PYG{n}{it} \PYG{o+ow}{in} \PYG{n}{items}\PYG{p}{]}\PYG{p}{,}
    \PYG{n}{key}\PYG{o}{=}\PYG{k}{lambda} \PYG{n}{x}\PYG{p}{:} \PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}
    \PYG{n}{reverse}\PYG{o}{=}\PYG{k+kc}{True}
\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Items, sorted by relative cost:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{it} \PYG{o+ow}{in} \PYG{n}{items\PYGZus{}and\PYGZus{}score}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Weight: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{it}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s2}{Cost: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{it}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s2}{Relative Cost: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{it}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Items, sorted by relative cost:
Weight: 17	Cost: 6100	Relative Cost: 358.8235294117647
Weight: 10	Cost: 3500	Relative Cost: 350.0
Weight: 21	Cost: 6700	Relative Cost: 319.04761904761904
Weight: 27	Cost: 8300	Relative Cost: 307.4074074074074
Weight: 3	Cost: 800	Relative Cost: 266.6666666666667
Weight: 9	Cost: 1950	Relative Cost: 216.66666666666666
Weight: 4	Cost: 370	Relative Cost: 92.5
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
“Заполняем” рюкзак:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{solution} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{w} \PYG{o}{=} \PYG{n}{capacity}
\PYG{n}{min\PYGZus{}weight} \PYG{o}{=} \PYG{n+nb}{min}\PYG{p}{(}\PYG{p}{[}\PYG{n}{it}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{k}{for} \PYG{n}{it} \PYG{o+ow}{in} \PYG{n}{items\PYGZus{}and\PYGZus{}score}\PYG{p}{]}\PYG{p}{)}

\PYG{k}{while} \PYG{k+kc}{True}\PYG{p}{:}
    \PYG{k}{if} \PYG{n}{w} \PYG{o}{\PYGZlt{}} \PYG{n}{min\PYGZus{}weight}\PYG{p}{:}
        \PYG{k}{break}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{n}{cand} \PYG{o}{=} \PYG{p}{[}\PYG{n}{it} \PYG{k}{for} \PYG{n}{it} \PYG{o+ow}{in} \PYG{n}{items\PYGZus{}and\PYGZus{}score} \PYG{k}{if} \PYG{n}{it}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{w}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
        \PYG{n}{solution}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{cand}\PYG{p}{)}
        \PYG{n}{w} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{cand}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}

\PYG{n}{final\PYGZus{}score} \PYG{o}{=} \PYG{n+nb}{sum}\PYG{p}{(}\PYG{p}{[}\PYG{n}{it}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{k}{for} \PYG{n}{it} \PYG{o+ow}{in} \PYG{n}{solution}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{final\PYGZus{}weight} \PYG{o}{=} \PYG{n+nb}{sum}\PYG{p}{(}\PYG{p}{[}\PYG{n}{it}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{k}{for} \PYG{n}{it} \PYG{o+ow}{in} \PYG{n}{solution}\PYG{p}{]}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Final score: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{final\PYGZus{}score}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Total weight of items: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{final\PYGZus{}weight}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Final score: 10400
Total weight of items: 30
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
В данном случае это сработало неплохо – мы нашли действительно хорошее решение. Однако можно заметить, что решение из трех элементов \sphinxcode{\sphinxupquote{(10, 3500)}} было бы более выгодным, так как итоговая ценность была бы \(10500\), что на \(100\) единиц больше жадного решения. Но в силу своей \sphinxstyleemphasis{жадности} наш алгоритм не смог найти это решение, хотя найденное им и лежит довольно близко к лучшему. Так что очень часто жадные алгоритмы находят очень плохие решения, причем качество решений сильно падает с ростом размерности проблемы.


\subsection{Метод имитации отжига}
\label{\detokenize{book/problems/ru/copt:id13}}
\sphinxAtStartPar
Это итеративный алгоритм, который очень часто способен найти действительно неплохое решение. Причем, в отличие от жадных алгоритмов, отжиг специально сделан так, чтобы не “застревать” в каких\sphinxhyphen{}то локально\sphinxhyphen{}хороших точках пространства решений, а наоборот, искать самое лучшее. Мы разберем работу отжига на примере задачи о максимальном разрезе в графе, а именно, реализуем подобие алгоритма Метрополиса\sphinxhyphen{}Гастингса {[}\hyperlink{cite.book/bibliography:id34}{Has70}{]}. Но для начала давайте сгенерируем случайный граф:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{from} \PYG{n+nn}{typing} \PYG{k+kn}{import} \PYG{n}{List}
\PYG{k+kn}{from} \PYG{n+nn}{typing} \PYG{k+kn}{import} \PYG{n}{Union}


\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{seed}\PYG{p}{(}\PYG{l+m+mi}{42}\PYG{p}{)}
\PYG{n}{rand\PYGZus{}mat} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{rand}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}
\PYG{n}{rand\PYGZus{}adj} \PYG{o}{=} \PYG{p}{(}\PYG{n}{rand\PYGZus{}mat} \PYG{o}{+} \PYG{n}{rand\PYGZus{}mat}\PYG{o}{.}\PYG{n}{T}\PYG{p}{)} \PYG{o}{/} \PYG{l+m+mi}{2}
\PYG{n}{rand\PYGZus{}adj}\PYG{p}{[}\PYG{n}{rand\PYGZus{}adj} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{0.35}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{0.0}
\PYG{n}{np}\PYG{o}{.}\PYG{n}{fill\PYGZus{}diagonal}\PYG{p}{(}\PYG{n}{rand\PYGZus{}adj}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}

\PYG{n}{g} \PYG{o}{=} \PYG{n}{nx}\PYG{o}{.}\PYG{n}{Graph}\PYG{p}{(}\PYG{n}{rand\PYGZus{}adj}\PYG{p}{)}
\PYG{n}{nx}\PYG{o}{.}\PYG{n}{draw}\PYG{p}{(}\PYG{n}{g}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{copt_9_0}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Напомню, что цель состоит в том, чтобы разбить множество вершин на два подмножества так, чтобы сумма весов ребер между двумя подмножествами была максимальной. Для этого понадобится функция, которая считает целевое значение для любого разбиения на два подмножества.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{score}\PYG{p}{(}\PYG{n}{g}\PYG{p}{:} \PYG{n}{nx}\PYG{o}{.}\PYG{n}{classes}\PYG{o}{.}\PYG{n}{graph}\PYG{o}{.}\PYG{n}{Graph}\PYG{p}{,} \PYG{n}{x}\PYG{p}{:} \PYG{n}{List}\PYG{p}{[}\PYG{n+nb}{int}\PYG{p}{]}\PYG{p}{)} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n+nb}{float}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{score} \PYG{o}{=} \PYG{l+m+mi}{0}
    \PYG{k}{for} \PYG{n}{e} \PYG{o+ow}{in} \PYG{n}{g}\PYG{o}{.}\PYG{n}{edges}\PYG{p}{(}\PYG{n}{data}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{if} \PYG{n}{x}\PYG{p}{[}\PYG{n}{e}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]} \PYG{o}{!=} \PYG{n}{x}\PYG{p}{[}\PYG{n}{e}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]}\PYG{p}{:}
            \PYG{n}{score} \PYG{o}{+}\PYG{o}{=} \PYG{n}{e}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{weight}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}
    \PYG{k}{return} \PYG{n}{score}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Разобьем вершины на две группы случайным образом несколько раз и проверим, что функция работает корректно:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{split\PYGZus{}random\PYGZus{}node}\PYG{p}{(}\PYG{n}{random\PYGZus{}seed}\PYG{p}{:} \PYG{n+nb}{int}\PYG{p}{)} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{List}\PYG{p}{[}\PYG{n+nb}{int}\PYG{p}{]}\PYG{p}{)}\PYG{p}{:}

    \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{seed}\PYG{p}{(}\PYG{n}{random\PYGZus{}seed}\PYG{p}{)}
    \PYG{n}{random\PYGZus{}x} \PYG{o}{=} \PYG{p}{[}
        \PYG{l+m+mi}{1} \PYG{k}{if} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{random}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mf}{0.5} \PYG{k}{else} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}
        \PYG{k}{for} \PYG{n}{\PYGZus{}} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{g}\PYG{o}{.}\PYG{n}{number\PYGZus{}of\PYGZus{}nodes}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{]}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Random seed }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{random\PYGZus{}seed}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s2}{Score: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{score}\PYG{p}{(}\PYG{n}{g}\PYG{p}{,} \PYG{n}{random\PYGZus{}x}\PYG{p}{)}\PYG{l+s+si}{:}\PYG{l+s+s2}{.2f}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

    \PYG{k}{return} \PYG{n}{random\PYGZus{}x}

\PYG{k}{for} \PYG{n}{random\PYGZus{}seed} \PYG{o+ow}{in} \PYG{p}{[}\PYG{l+m+mi}{2019}\PYG{p}{,} \PYG{l+m+mi}{2020}\PYG{p}{,} \PYG{l+m+mi}{2021}\PYG{p}{]}\PYG{p}{:}
    \PYG{n}{random\PYGZus{}x} \PYG{o}{=} \PYG{n}{split\PYGZus{}random\PYGZus{}node}\PYG{p}{(}\PYG{n}{random\PYGZus{}seed}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Random seed 2019	Score: 7.78
Random seed 2020	Score: 7.23
Random seed 2021	Score: 9.38
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Суть процесса отжига заключается в следующем:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
генерируем начальное случайное решение (или получаем \sphinxstyleemphasis{feasible} при помощи эвристик);

\item {} 
\sphinxAtStartPar
задаем начальную “температуру” – некий глобальный метапараметр, суть которого станет ясна далее;

\item {} 
\sphinxAtStartPar
выполняем отжиг заданное число итераций;
\begin{itemize}
\item {} 
\sphinxAtStartPar
выполняем случайую модификацию решения;

\item {} 
\sphinxAtStartPar
если значение функции стоимости для нового решения лучше, чем для старого, то принимаем его;

\item {} 
\sphinxAtStartPar
если нет, то все равно можем принять новое решение, но лишь с некоторой вероятностью, которая тем больше, чем выше температура и чем ближе друг к другу по оценке старое и новое решение.

\end{itemize}

\end{enumerate}

\sphinxAtStartPar
Давайте реализуем это. В качестве функции, которая дает нам вероятность принять/отклонить новое решение, будем использовать \sphinxhref{https://en.wikipedia.org/wiki/Boltzmann\_distribution}{распределение Больцмана}:
\begin{equation*}
\begin{split}
P_{acceptance} = e^{\frac{E_{new} - E_{old}}{T}}
\end{split}
\end{equation*}
\sphinxAtStartPar
Видно, что эта величина может быть больше единицы в случае, когда новое решение лучше старого, но для нас это не проблема – это просто будет значить, что мы точно принимаем новое решение!

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{copy} \PYG{k+kn}{import} \PYG{n}{copy}

\PYG{n}{e\PYGZus{}history} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{x} \PYG{o}{=} \PYG{n}{random\PYGZus{}x}
\PYG{n}{T} \PYG{o}{=} \PYG{n}{T\PYGZus{}0} \PYG{o}{=} \PYG{l+m+mi}{100}
\PYG{n}{e} \PYG{o}{=} \PYG{n}{score}\PYG{p}{(}\PYG{n}{g}\PYG{p}{,} \PYG{n}{x}\PYG{p}{)}
\PYG{n}{e\PYGZus{}history}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{e}\PYG{p}{)}

\PYG{k}{def} \PYG{n+nf}{bolzman}\PYG{p}{(}\PYG{n}{e\PYGZus{}old}\PYG{p}{:} \PYG{n+nb}{float}\PYG{p}{,} \PYG{n}{e\PYGZus{}new}\PYG{p}{:} \PYG{n+nb}{float}\PYG{p}{,} \PYG{n}{T}\PYG{p}{:} \PYG{n}{Union}\PYG{p}{[}\PYG{n+nb}{int}\PYG{p}{,} \PYG{n+nb}{float}\PYG{p}{]}\PYG{p}{)} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n+nb}{float}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{p}{(}\PYG{n}{e\PYGZus{}new} \PYG{o}{\PYGZhy{}} \PYG{n}{e\PYGZus{}old}\PYG{p}{)} \PYG{o}{/} \PYG{n}{T}\PYG{p}{)}

\PYG{k}{def} \PYG{n+nf}{permute}\PYG{p}{(}\PYG{n}{x}\PYG{p}{:} \PYG{n}{List}\PYG{p}{[}\PYG{n+nb}{int}\PYG{p}{]}\PYG{p}{)} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{List}\PYG{p}{[}\PYG{n+nb}{int}\PYG{p}{]}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{i} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{randint}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{n}{x\PYGZus{}new} \PYG{o}{=} \PYG{n}{copy}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
    \PYG{n}{x\PYGZus{}new}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{*}\PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}

    \PYG{k}{return} \PYG{n}{x\PYGZus{}new}

\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1500}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{new\PYGZus{}state} \PYG{o}{=} \PYG{n}{permute}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
    \PYG{n}{new\PYGZus{}e} \PYG{o}{=} \PYG{n}{score}\PYG{p}{(}\PYG{n}{g}\PYG{p}{,} \PYG{n}{new\PYGZus{}state}\PYG{p}{)}

    \PYG{k}{if} \PYG{n}{new\PYGZus{}e} \PYG{o}{\PYGZgt{}} \PYG{n}{e}\PYG{p}{:}
        \PYG{n}{e} \PYG{o}{=} \PYG{n}{new\PYGZus{}e}
        \PYG{n}{x} \PYG{o}{=} \PYG{n}{new\PYGZus{}state}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{n}{prob} \PYG{o}{=} \PYG{n}{bolzman}\PYG{p}{(}\PYG{n}{e}\PYG{p}{,} \PYG{n}{new\PYGZus{}e}\PYG{p}{,} \PYG{n}{T}\PYG{p}{)}
        \PYG{k}{if} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{rand}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{prob}\PYG{p}{:}
            \PYG{n}{e} \PYG{o}{=} \PYG{n}{new\PYGZus{}e}
            \PYG{n}{x} \PYG{o}{=} \PYG{n}{new\PYGZus{}state}

    \PYG{n}{e\PYGZus{}history}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{e}\PYG{p}{)}
    \PYG{n}{T} \PYG{o}{=} \PYG{n}{T\PYGZus{}0} \PYG{o}{/} \PYG{p}{(}\PYG{n}{i} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Final energy: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{e}\PYG{l+s+si}{:}\PYG{l+s+s2}{.2f}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Final energy: 12.62
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
И посмотрим, как оно сходилось:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{e\PYGZus{}history}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{n}{e\PYGZus{}history}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{.\PYGZhy{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Step}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Cost}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{copt_17_0}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Видим, что в начале у нас был активный поиск решения, а ближе к концу переходы становились возможны, лишь если новое решение лучше. Этот процесс чем\sphinxhyphen{}то похож на кристаллизацию расплавов, когда изначально все частицы плавают в жидкости, но с уменьшением температуры они все более точно становится в те позиции, которые обеспечивают минимум свободной энергии кристалла. Именно поэтому данный алгоритм называется \sphinxstyleemphasis{имитацией отжига} (\sphinxstyleemphasis{simulated annealing}).

\sphinxAtStartPar
Этот алгоритм неплохо находит оптимальные решение, но с ростом размерности задачи, а также пространства решений процесс “отжига” должен длиться все дольше и дольше, а температура уменьшаться все медленней.


\section{Заключение}
\label{\detokenize{book/problems/ru/copt:id15}}
\sphinxAtStartPar
В этой лекции мы узнали, что же это за такие \sphinxstyleemphasis{NP}\sphinxhyphen{}задачи, а также познакомились с примерами некоторых из них. Посмотрели, как эти задачи можно решать на классическом компьютере, и какие при этом есть ограничения. В следующих лекциях мы узнаем:
\begin{itemize}
\item {} 
\sphinxAtStartPar
как задачи комбинаторной оптимизации можно свести к решению модели Изинга (подробнее об этой модели – в {\hyperref[\detokenize{book/problems/ru/ising::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{отдельной лекции}}}})

\item {} 
\sphinxAtStartPar
как задача Изинга переходит в задачу об основном состоянии квантовой системы

\item {} 
\sphinxAtStartPar
как задачу об основном состоянии можно решать на квантовом компьютере разными способами:
\begin{itemize}
\item {} 
\sphinxAtStartPar
через алгоритм \sphinxstyleemphasis{VQE}, основанном на {\hyperref[\detokenize{book/vqc/ru/vqc::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{вариационных квантовых схемах}}}}

\item {} 
\sphinxAtStartPar
через алгоритм \sphinxstyleemphasis{QAOA}, который является квантовым аналогом алгоритма имитации отжига

\item {} 
\sphinxAtStartPar
на специальных квантовых компьютерах – {\hyperref[\detokenize{book/dwave/ru/dwave::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{квантовых аннилерах}}}}

\end{itemize}

\end{itemize}

\sphinxstepscope


\part{От проблем к обучению}

\sphinxstepscope


\chapter{О блоке “От задач к квантовым алгоритмам”}
\label{\detokenize{book/problems2qml/ru/problems2qml_intro:problems2qml-intro}}\label{\detokenize{book/problems2qml/ru/problems2qml_intro:id1}}\label{\detokenize{book/problems2qml/ru/problems2qml_intro::doc}}
\sphinxAtStartPar
Этот блок посвящен тому, как перейти от задач оптимизации или квантовой химии к квантовым алгоритмам. Блок содержит лекции о:
\begin{itemize}
\item {} 
\sphinxAtStartPar
преобразовании Жордана\sphinxhyphen{}Вигнера, где показывается, как перейти от фермионных операторов из квантовой химии к спиновым операторам и модели Изинга;

\item {} 
\sphinxAtStartPar
формулировке задач комбинаторной оптимизации в терминах спиновых операторов и модели Изинга.

\end{itemize}

\sphinxAtStartPar
В заключении блока кратко затрагивается тема классических алгоритмов для решения задачи об основном состоянии модели Изинга и квантовых гамильтонианах – алгоритмы Арнольди/Ланкзоша, а также вариационный Монте\sphinxhyphen{}Карло и его модификации.

\sphinxstepscope


\chapter{Формулировка задач оптимизации в терминах модели Изинга}
\label{\detokenize{book/problems2qml/ru/np2ising:np2ising}}\label{\detokenize{book/problems2qml/ru/np2ising:id1}}\label{\detokenize{book/problems2qml/ru/np2ising::doc}}
\sphinxAtStartPar
Автор(ы):
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/SemyonSinchenko}{Синченко Семен}

\end{itemize}

\sphinxAtStartPar
Не зря мы так глубоко изучали {\hyperref[\detokenize{book/problems/ru/ising::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{модель Изинга}}}} и {\hyperref[\detokenize{book/problems/ru/advising::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{анализировали}}}} ее решения – сегодня увидим, как в терминах этой модели можно сформулировать большинство важных задач {\hyperref[\detokenize{book/problems/ru/copt::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{комбинаторной оптимизации}}}}.


\section{QUBO матрица}
\label{\detokenize{book/problems2qml/ru/np2ising:qubo}}
\sphinxAtStartPar
Но сначала кратко обсудим так называемую \sphinxcode{\sphinxupquote{QUBO}} матрицу {[}\hyperlink{cite.book/bibliography:id32}{GKD19}{]} – это еще один способ записать задачу модели Изинга, и дальше по курсу иногда будем этим пользоваться.

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{QUBO}} – это сокращение от \sphinxstylestrong{Quadratic Unconstrained Binary Optimization}, или, если переводить, то это \sphinxstyleemphasis{задача квадратичной оптимизации без ограничений}. То есть это такие задачи, для которых нет отдельных ограничений, например, равенств или неравенств, а функция стоимости представима в виде многочлена второй степени от входных переменных. Решением такой задачи является бинарный вектор \(X = \{x_1, x_2, ..., x_n\}\) такой, что \(x_1, ..., x_n \in \{0, 1\}\). В этом случае функцию стоимости \(C\) можно записать в виде:
\begin{equation*}
\begin{split}
C = a_1 x_1^2 + a_2 x_2^2 + ... + a_n x_n^2 + b_1 x_1 + ... + b_n x_n + c_{1, 2} x_1 x_2 + c_{1, 3} x_1 x_3 + ... + c_{n, n - 1} x_n x_{n -1}
\end{split}
\end{equation*}
\sphinxAtStartPar
Но так как переменные бинарные, то разницы между \(x_i^2\) и \(x_i\) нет – дальше будем использовать \(a_i\) как единственные коэффициенты, считая, что \(b_i\) уже и так включены в \(a_i\). В этом случае можно представить функцию стоимости как матрицу размера \(|X| \times |X|\), на диагонали которой стоят коэффициенты \(a_1, ..., a_n\), а вне диагонали стоят коэффициенты, с которыми в стоимость входят пары элементов:
\begin{equation*}
\begin{split}
Q = \begin{pmatrix}
    a_1 & c_{1, 2} & ... & c_{1, n} \\
    ... & ... & ... & ...\\
    c_{n, 1} & ... & ... & a_{n}
\end{pmatrix}
\end{split}
\end{equation*}
\sphinxAtStartPar
Сама оптимизационная задача в этом случае формулируется следующим образом:
\begin{equation*}
\begin{split}
\arg\min_{X} {X^T Q X}
\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Тут рассматриваем именно минимизацию функции стоимости. Но если исходная задача формулировалась в терминах максимизации чего\sphinxhyphen{}то, например, как задача о рюкзаке или максимальном разрезе в графе, то очевидно, что просто домножив стоимость на \sphinxhyphen{}1, перейдем от максимизации к минимизации. Далее это будет важно, так как будем рассматривать задачу поиска \sphinxstyleemphasis{основного состояния} квантомеханической системы, а такое состояние – это по определению состояние именно с \sphinxstyleemphasis{минимальной} энергией.
\end{sphinxadmonition}


\section{QUBO как квантовый гамильтониан}
\label{\detokenize{book/problems2qml/ru/np2ising:id3}}
\sphinxAtStartPar
Если вспомнить, как \sphinxhref{../../problems/ru/advising.html\#id2}{выглядит} модель Изинга, то легко заметить, что там, как и в \sphinxcode{\sphinxupquote{QUBO}}\sphinxhyphen{}проблемах, есть лишь члены первой и второй степени. Вот только \sphinxhref{../../qc/ru/qubit.html\#hat-sigma-z}{спиновые операторы (матрицы Паули) имеют собственные значения} \(\pm 1\), а не \(\{0, 1\}\), которые фигурируют в \sphinxcode{\sphinxupquote{QUBO}}. Это проблема, так как квадраты этих значений не равны им самим. Но это легко можно исправить введя “бинарный” оператор \(\hat{x}\):
\begin{equation*}
\begin{split}
\hat{x} = \frac{1 + \hat{\sigma}^z}{2} = \begin{pmatrix} 1 & 0 \\ 0 & 0 \end{pmatrix}
\end{split}
\end{equation*}
\sphinxAtStartPar
Введя “промежуточные” переменные \(sz_i\) которые связаны с \(x_i\) через это выражение (\(x_i = \frac{1 + sz}{2})\), всегда можно свести выражение для \(C\) к следующему виду:
\begin{equation*}
\begin{split}
C = \sum_{i, j \in \{1, ..., |X|\}} J_{i, j} sz_i sz_j + \sum_{i \in {\{1, ..., |X|\}}} h_i sz_i
\end{split}
\end{equation*}
\sphinxAtStartPar
А это уже почти модель Изинга! Заменяем \(sz\) на операторы \(\sigma^z\) и получаем гамильтониан системы. Причем такой, что минимум его энергии будет совпадать с минимальным значением функции стоимости \(C\):
\begin{equation*}
\begin{split}
\begin{align*}
    & \hat{H} = \sum_{i, j \in \{1, ..., |X|\}} J_{i, j} \sigma^z_i \sigma^z_j + \sum_{i \in {\{1, ..., |X|\}}} h_i \sigma^z_i \\
    & \braket{\Psi | \hat{H} | \Psi} = \min {X^T Q X} = \min {C,} \quad \text{если }\Psi\text{ -- это основное состояние системы}
\end{align*}
\end{split}
\end{equation*}
\sphinxAtStartPar
Причем в силу того, что у в выражении для \(\hat{H}\) фигурируют лишь \(\sigma^z\), основное состояние гамильтониана является “классическим”, то есть все спины “ориентированы” либо вверх, либо вниз, но не находятся в суперпозиции. Другими словами, гамильтониан диагонализируется в \(\mathbf{Z}\)\sphinxhyphen{}базисе.


\section{Поиск основного состояния}
\label{\detokenize{book/problems2qml/ru/np2ising:id4}}
\sphinxAtStartPar
Как увидели, задачи, сформулированные в терминах \sphinxcode{\sphinxupquote{QUBO}}, можно свести к задаче нахождения основного состояния квантовой системы, которая описывается некоторым оператором. Но что это вообще значит? И что это за гамильтониан такой, о котором все время говорим? Вообще говоря, гамильтониан – это оператор энергии:
\begin{equation*}
\begin{split}
\hat{H} = \hat{T} + \hat{U},
\end{split}
\end{equation*}
\sphinxAtStartPar
где \(T\) – это кинетическая энергия системы, а \(U\) – потенциальная энергия. Именно этот оператор определяет квантовую динамику в уравнении Шредингера. То есть это оператор, зная который (а также начальное состояние системы), можно посчитать волновую функцию системы (\(\ket{\Psi}(t)\)) в любой момент времени в будущем. Правда, это лишь в теории, так как сложность интегрирования уравнения Шредингера очень быстро растет с ростом размера системы. Этой темы немного уже касались в \sphinxhref{../../qmlkinds/ru/qmlkinds.html\#id3}{лекции про виды квантового машинного обучения}, когда рассматривали, как нейросети помогают решать это самое уравнение.

\sphinxAtStartPar
Еще коснемся этой темы в следующих лекциях, но пока достаточно понимания того, что гамильтониан полностью описывает квантовую систему. С другой стороны, зная гамильтониан, всегда можем построить “в железе” квантовую систему, которую он описывает. Например, конфигурируя магнитные поля и двухчастичные обменные взаимодействия.

\sphinxAtStartPar
Таким образом, решение проблемы \sphinxcode{\sphinxupquote{QUBO}} сводится к поиску \(\ket{\Psi}_{GS}\) – волновой функции, отвечающей основному состоянию:
\begin{equation*}
\begin{split}
\arg\min_{\ket{\Psi}} {\hat{H}}
\end{split}
\end{equation*}
\sphinxAtStartPar
А финальное решение получается просто как наиболее вероятная конфигурация спинов в состоянии \(\ket{\Psi}_{GS}\). Ну и останется лишь перейти от полученных собственных значений операторов \(\sigma^z_i\) к собственным значениям операторов \(\hat{x}_i\).

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Кстати, справедлив и обратный переход, то есть решив проблему \sphinxcode{\sphinxupquote{QUBO}} каким\sphinxhyphen{}нибудь из \sphinxhref{../../problems/ru/copt.html\#id9}{классических алгоритмов} для решения комбинаторных задач, автоматически получим конфигурацию основного состояния соответствуеющей физической системы! Этот подход впервые был предложен аж в 1988\sphinxhyphen{}м году в работе {[}\hyperlink{cite.book/bibliography:id19}{BGrotschelJungerR88}{]}. Таким образом, приходим к пониманию \sphinxstylestrong{тесной связи задач квантовой физики и комбинаторной оптимизации}. Именно на этом и строится огромное число перспективных квантовых алгоритмов для решения задач реального мира. Особенно в \sphinxstyleemphasis{NISQ} эпоху!
\end{sphinxadmonition}

\sphinxAtStartPar
Важное преимущество квантового представления \sphinxcode{\sphinxupquote{QUBO}}\sphinxhyphen{}задач – в том, что наш мир устроен таким образом, что любая квантовая система всегда стремится в состояние с минимальной энергией, то есть основное. На этом построен даже целый класс квантовых аннилеров. Но и для вариационных квантовых алгоритмов это также дает свои преимущества.


\section{Статья “Ising formulations of many NP problems”}
\label{\detokenize{book/problems2qml/ru/np2ising:ising-formulations-of-many-np-problems}}
\sphinxAtStartPar
Основным источником информации для нас будет статья \sphinxstyleemphasis{“Ising formulations of many NP problems”} {[}\hyperlink{cite.book/bibliography:id25}{Luc14}{]}, вышедшая в 2014\sphinxhyphen{}м году (версия 3). В данной лекции рассмотрим лишь часть примеров из этой работы, хотя наше рассмотрение будет чуть более подробным. В целом эта статья может быть использована как прекрасный справочник.


\section{Задача о максимальном разрезе в графе (повторение)}
\label{\detokenize{book/problems2qml/ru/np2ising:id7}}
\sphinxAtStartPar
Уже рассматривали эту задачу в {\hyperref[\detokenize{book/problems/ru/ising::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{лекции о модели Изинга}}}} и в {\hyperref[\detokenize{book/problems/ru/copt::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{лекции про задачи комбинаторной оптимизации}}}}, но теперь повторим еще раз. Итак, есть граф на множестве вершин \(V\), связанных множеством ребер \(E\). Каждое ребро соединяет вершины \(u,v\). Для простоты будем рассматривать случай ненаправленного графа. Каждое ребро имеет вес \(w\). Цель – разбить множество вершин \(V\) на два непересекающихся сообщества \(V_1, V_2\) таким образом, чтобы суммарный вес ребер, соединяющих вершины из разных сообществ, был максимален:
\begin{equation*}
\begin{split}
\arg\max{V_1, V_2} {\sum_{u,v,w \in E} w (\mathbf{1}(u \in V_1, v \in V_2) + \mathbf{1}(u \in V_2, v \in V_1))}
\end{split}
\end{equation*}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{Max-cut}.png}
\caption{Иллюстрация задачи о максимальном разрезе в графе}\label{\detokenize{book/problems2qml/ru/np2ising:maxcut3}}\end{figure}

\sphinxAtStartPar
Эта задача уже является задачей без ограничений и может быть сразу сформулирована в терминах \sphinxcode{\sphinxupquote{QUBO}} и модели Изинга.


\subsection{\sphinxstyleliteralintitle{\sphinxupquote{QUBO}} матрица}
\label{\detokenize{book/problems2qml/ru/np2ising:id8}}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{QUBO}} матрица для этой задачи имеет размер \(|V| \times |V|\), а вектор решения \(X\) это, соответственно, будет бинарный вектор длины \(|V|\). Для простоты обозначим сообщество \(V_1\) как вершины, для которых \(x_i = 0\), а \(V_2\) это будут вершины с \(x_i = 1\). Еще хотим решать задачу минимизации вместо задачи максимизации. Запишем новую целевую функцию:
\begin{equation*}
\begin{split}
C = - \sum_{i,j \in \{1, .., |V|\}} w_{i,j} (x_i + x_j - 2 x_i x_j)
\end{split}
\end{equation*}
\sphinxAtStartPar
Чтобы записать \sphinxcode{\sphinxupquote{QUBO}} матрицу, будет удобнее работать с матрицей смежности графа, а не списком его ребер. Матрица смежности \(A\) (\sphinxstyleemphasis{adjacency matrix}) – это матрица размера \(|V| \times |V|\), элементы которой это веса \(w_{i, j}\), если в графе есть ребро между вершинами \(i\) и \(j\), и \(0\), если ребра нет. Тогда матрица \sphinxcode{\sphinxupquote{QUBO}} будет иметь следующий вид:
\begin{equation*}
\begin{split}
QUBO = \begin{pmatrix}
    \sum_{j = 0}^{|V| - 1} A_{0,j} & -2 A_{0, 1} & ... & -2 A_{0, |V|} \\
    ... & ... & ... & ... \\
    -2 A_{|V|, 0} & ... & ... & \sum_{j = 0}^{|V| - 1} A{|V|, j}
\end{pmatrix}
\end{split}
\end{equation*}

\subsection{Гамильтониан Изинга}
\label{\detokenize{book/problems2qml/ru/np2ising:id9}}
\sphinxAtStartPar
В случае этой задачи можно сказать, что она изначально имеет вид модели Изинга. И действительно, наиболее вероятная конфигурация спинов для основного состояния системы с гамильтонианом такого вида:
\begin{equation*}
\begin{split}
\hat{H} = \sum_{i,j \in \{1, ..., |V|\}} (1 - \sigma^z_i \sigma^z_j)
\end{split}
\end{equation*}
\sphinxAtStartPar
будет в точности соответствовать решению задачи о максимальном разрезе. При этом численное значение энергии будет отличаться ровно на величину \(|E|\), то есть на число ребер, так как величина \((1 - \sigma^z_i \sigma^z_j)\) будет равна нулю, если вершины находятся в разных сообществах, или единице, если они находятся в одном.


\section{Задача коммивояжера}
\label{\detokenize{book/problems2qml/ru/np2ising:id10}}
\sphinxAtStartPar
Задача коммивояжера обсуждалась в \sphinxhref{../../problems/ru/copt.html\#id7}{лекции по комбинаторной оптимизации}, где были получены выражения для представления данной задачи в виде “без ограничений”. Напомним, что удалось добиться этого, “внеся” ограничения в выражения для целевой функции в виде штрафа за отклонение от ограничений. А также добавили соответствующие коэффициенты. Полученное в той лекции выражение имеет вид:
\begin{equation*}
\begin{split}
C = A (1 - \sum_i x_{i,p})^2 + A (1 - \sum_p x_{i,p})^2 + A \sum_{u,v \notin E} x_{u,p} x_{v,p+1} + B \sum_{u,v,w \in E} w x_{u,p} x_{v,p+1}
\end{split}
\end{equation*}
\sphinxAtStartPar
Для нас удобно, что это уже задача минимизации. В данном случае \sphinxcode{\sphinxupquote{QUBO}}\sphinxhyphen{}матрица получается при помощи явного раскрытия скобок в выражении для стоимости. Можно заметить, что в этом случае получаем также элементы 0\sphinxhyphen{}й степени, но формат \sphinxcode{\sphinxupquote{QUBO}}\sphinxhyphen{}матрицы такого не предусматривает. Но во\sphinxhyphen{}первых, в данном случае легко можем определить разницу между \(X^T Q X\) и минимумом \(C\), а во\sphinxhyphen{}вторых, для нас это не столь важно – нам нужно решение, а значение энергии/функции стоимости получается без каких\sphinxhyphen{}либо проблем за полиномиальное время.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Это довольно важное замечание, так как часто можно найти относительно простое представлениие задачи в виде \sphinxcode{\sphinxupquote{QUBO}}, а вот учет всех констант может сильно усложнить ее вид. Более того, как увидим далее, не все представления \sphinxcode{\sphinxupquote{QUBO}} одинаково эффективны, особенно когда переходят к решению на квантовом компьютере: для каких\sphinxhyphen{}то видов \sphinxcode{\sphinxupquote{QUBO}} будет одна величина энергетической щели между основным и возбужденным состоянием в процессе решения, а для других \sphinxcode{\sphinxupquote{QUBO}}\sphinxhyphen{}представлений той же задачи оно уже может стать больше!
\end{sphinxadmonition}


\section{Задача о выделении сообществ в графе}
\label{\detokenize{book/problems2qml/ru/np2ising:id11}}
\sphinxAtStartPar
Уже \sphinxhref{../../problems/ru/copt.html\#id3}{говорили об этой задаче} в лекции про комбинаторную оптимизацию. Для этой задачи было разработано немало эвристических алгоритмов поиска {[}\hyperlink{cite.book/bibliography:id64}{SCBR14}{]}, а в этой части сосредоточимся на формулировке как задачи \sphinxcode{\sphinxupquote{QUBO}}.


\subsection{\protect\(k = 2\protect\) сообществ}
\label{\detokenize{book/problems2qml/ru/np2ising:k-2}}
\sphinxAtStartPar
В случае всего двух сообществ будем использовать двоичные спиновые переменные \(s_i \in \{-1,1\}\) для кодирования того, к какому именно сообществу принадлежит вершина \(i\). \(\frac{1 + s_is_j}{2}\) будет равняться \(1\), если \(i\) и \(j\) принадлежат одному сообществу, и \(0\) – в противном случае. Модулярность при этом будет следующей
\begin{equation}\label{equation:book/problems2qml/ru/np2ising:eqn:comdet_2}
\begin{split}
M = \frac{1}{4m} s^T B s \\
\end{split}
\end{equation}\begin{equation}\label{equation:book/problems2qml/ru/np2ising:eqn:comdet_3}
\begin{split}
B_{ij} = (A_{ij} - \frac{g_i g_j}{2m})
\end{split}
\end{equation}
\sphinxAtStartPar
При \(s_i = 2 x_i - 1\) между спиновыми \(s_i \in \{-1,1\}\) и битовыми \(x_i \in \{0, 1\}\) переменными соответственно, а также \(\sum_{i,j} B_{i,j} = 0\), максимизация модулярности \eqref{equation:book/problems2qml/ru/np2ising:eqn:comdet_3} может быть эквивалентна выражению задачи минимизации в форме \sphinxcode{\sphinxupquote{QUBO}} с гамильтонианом \(H = - \frac{1}{m} x^T B x\) и с \sphinxcode{\sphinxupquote{QUBO}} матрицей \(Q = - \frac{B}{m}\).


\subsection{Множественные сообщества (\protect\(k > 2\protect\))}
\label{\detokenize{book/problems2qml/ru/np2ising:id13}}
\sphinxAtStartPar
Чтобы сформулировать задачу выделения \(k\) сообществ в канонической форме \sphinxcode{\sphinxupquote{QUBO}}, сначала одновременно кодируем двоичные переменные \(x_i\), а затем строим \sphinxcode{\sphinxupquote{QUBO}}\sphinxhyphen{}гамильтониан.

\sphinxAtStartPar
Используем схему однократного кодирования (one\sphinxhyphen{}hot encoding), в которой задаем \(x_{i,c} = 1\), если вершина \(i \in c\), и \(x_{i,c} = 0\) в противном случае, то есть,
\begin{equation}\label{equation:book/problems2qml/ru/np2ising:eqn:comdet_4}
\begin{split}
x_{i,c} = \begin{cases}
    1, если \ i \in c \\
    0, иначе
\end{cases}
\end{split}
\end{equation}
\sphinxAtStartPar
Тогда потребуется \(k\) переменных на логическую вершину, и размер двоичного вектора решений \(x\) увеличится с вектора длины \(N\) для случая \(k = 2\) до \(k \times N\) для \(k\)\sphinxhyphen{}сообществ. В частности, задаем \(x = (x_{1,1}, x_{2,1}, ... , x_{N,1}, ... , x_{1,k}, x_{2,k}, ... , x_{N,k})\).

\sphinxAtStartPar
\(k > 2\) формулирует проблему как бинарную задачу минимизации, тогда возможно построить гамильтониан \sphinxcode{\sphinxupquote{QUBO}} для \(k\)\sphinxhyphen{}сообществ с \(H_M = - \frac{1}{m} \sum_{c = 1}^k x_c^T B x_c\), в котором каждый член в сумме описывает бинарную задачу обнаружения сообщества для данного сообщества \(c\).

\sphinxAtStartPar
Представляя обобщенную матрицу модулярности \(Β\) размером \(kN \times kN\) и блочно\sphinxhyphen{}диагональной формы с \(B\) вдоль диагонали \eqref{equation:book/problems2qml/ru/np2ising:eqn:comdet_5}, можем переписать задачу обнаружения \(k\)\sphinxhyphen{}сообщества как задачу двоичной минимизации в каноническом формате \sphinxcode{\sphinxupquote{QUBO}} (где исходные многоклассовые переменные вложены в большее число двоичных переменных):
\begin{equation*}
\begin{split}
H_M = - \frac{1}{m} x^T B x
\end{split}
\end{equation*}\begin{equation}\label{equation:book/problems2qml/ru/np2ising:eqn:comdet_5}
\begin{split}
B = \begin{bmatrix}
    B & ... & 0 \\
    \vdots & \ddots & \vdots \\
    0 & ... & B
\end{bmatrix}
\end{split}
\end{equation}
\sphinxAtStartPar
Поскольку каждый узел \(i = 1, ... , N\) должен находиться ровно в одном сообществе \(c = 1, ... , k\), необходимо добавить штрафной член, чтобы ограничить решение для распределения сообществ. Формально это ограничение можно записать как \(\sum_{c = 1}^k x_{i,c} = 1\) при \(i = 1, ... , N\).

\sphinxAtStartPar
Это линейное ограничение можно добавить в задачу \sphinxcode{\sphinxupquote{QUBO}} в виде квадратичного штрафного члена:
\begin{equation}\label{equation:book/problems2qml/ru/np2ising:eqn:comdet_6}
\begin{split}
H_P = P \sum_{i=1}^{N} (\sum_{c=1}^{k} x_{i,c} -1)^2
\end{split}
\end{equation}
\sphinxAtStartPar
с положительным предварительным коэффициентом \(P > 0\), обеспечивающим выполнение ограничений. Чтобы сформулировать штрафной член в \eqref{equation:book/problems2qml/ru/np2ising:eqn:comdet_6} в \sphinxcode{\sphinxupquote{QUBO}}\sphinxhyphen{}гамильтониан \(H_P = x^T Q_P x\), перенумеруем двоичный вектор решений, используя один подстрочный индекс от \(1\) до \(kN\), то есть \(x = (x_{1,1}, x_{2,1}, ... , x_{N,1}, ... , x_{N,k}) = (x_1, x_2, ... , x_N , ... , x_{kN} )\). Тогда штрафной член \eqref{equation:book/problems2qml/ru/np2ising:eqn:comdet_6} может быть переписан как
\begin{equation}\label{equation:book/problems2qml/ru/np2ising:eqn:comdet_7}
\begin{split}
H_P = P (V x - b)^T (V x - b)
\end{split}
\end{equation}
\sphinxAtStartPar
где \(b\) – вектор всех единиц, а \(V = [I_N, ... , I_N]\) – высокоструктурированная матрица размера \(N \times k_N\) с \(N \times N\) матрицами тождества, сложенными горизонтально рядом друг с другом. Если вес \(P\) достаточно велик, например, находится в диапазоне от \(1/N\) до \(10/N\), то штрафной гамильтониан \(H_P\) будет стремиться к решению, в котором все ограничения удовлетворены \(V_x = b\). Поскольку гамильтониан \(H_P\) квадратичен с точностью до константы, его можно переписать в канонической форме \sphinxcode{\sphinxupquote{QUBO}} как \(H_P = x^T Q_P x\), с \(Q_P = P(V^TV - 2 \ \text{diag}(V^Tb))\).

\sphinxAtStartPar
Объединив модульности в уравнении \eqref{equation:book/problems2qml/ru/np2ising:eqn:comdet_5} и штрафной гамильтониан в уравнении \eqref{equation:book/problems2qml/ru/np2ising:eqn:comdet_7}, получаем окончательный \sphinxcode{\sphinxupquote{QUBO}}\sphinxhyphen{}гамильтониан для общего решения задачи о выделении \(k\) сообществ в графе
\begin{equation*}
\begin{split}
H = H_M + H_p
\end{split}
\end{equation*}

\section{Заключение}
\label{\detokenize{book/problems2qml/ru/np2ising:id14}}
\sphinxAtStartPar
Из этой лекции узнали, что такое \sphinxcode{\sphinxupquote{QUBO}} матрица, а также как от такой формулировки оптимизационных задач можно перейти к задаче поиска основного состояния квантомеханической системы. В будущих лекциях познакомимся уже непосредственно с тремя основными методами решения этой задачи:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
квантовый отжиг
В этом случае реализуем модель Изинга буквально в железе. Это сразу дает ряд ограничений и особенностей, но с другой стороны мы получаем возможность хорошо масштабировать систему. И действительно, сегодня компьютеры фирмы D\sphinxhyphen{}Wave имеют порядка нескольких тысяч кубитов. Многие специалисты считают, что до появления универсальных квантовых компьютеров именно аналоговые машины D\sphinxhyphen{}Wave, решающие задачу Изинга, станут основным коммерческим инструментов в квантовых вычислениях.

\item {} 
\sphinxAtStartPar
вариационно\sphinxhyphen{}градиентные методы
В этом подходе попытаемся закодировать волновую функцию основного состояния системы при помощи {\hyperref[\detokenize{book/vqc/ru/vqc::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{вариационной квантовой схемы}}}}, а дальше найти такие параметры, которые минимизируют результат измерения гамильтониана в таком состоянии. Этот метод называется {\hyperref[\detokenize{book/vqe/ru/vqe_intro::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{\sphinxstylestrong{V}ariational \sphinxstylestrong{Q}uantum \sphinxstylestrong{E}igensolver}}}}.

\item {} 
\sphinxAtStartPar
третий популярный подход соединяет идеи первых двух
В этом случае также делаем квантовый отжиг, но для этого не строим целевую систему в железе, а производим симуляцию квантовой динамики на кубитах при помощи специальных приближений из области квантовой механики. А параметры “отжига”, как и в \sphinxstylestrong{VQE}, подбираем при помощи градиентных методов. Такой подход носит название {\hyperref[\detokenize{book/qaoa/ru/qaoa::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{\sphinxstylestrong{Q}uantum \sphinxstylestrong{A}pproximate \sphinxstylestrong{O}ptimization \sphinxstylestrong{A}lgorithm}}}}.

\end{enumerate}

\sphinxAtStartPar
Именно этим темам будет посвящена бОльшая часть оставшихся лекций.

\sphinxstepscope


\chapter{QUBO\sphinxhyphen{}формулировки для линейной регрессии, SVM и метода k\sphinxhyphen{}средних}
\label{\detokenize{book/problems2qml/ru/qubo_linreg_svm_kmeans:qubo-svm-k}}\label{\detokenize{book/problems2qml/ru/qubo_linreg_svm_kmeans:qubo-linreg-svm-kmeans}}\label{\detokenize{book/problems2qml/ru/qubo_linreg_svm_kmeans::doc}}
\sphinxAtStartPar
Автор(ы):
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/dmburd}{Бурдейный Дмитрий}

\end{itemize}


\section{Описание лекции}
\label{\detokenize{book/problems2qml/ru/qubo_linreg_svm_kmeans:id1}}
\sphinxAtStartPar
Здесь рассмотрим QUBO\sphinxhyphen{}формулировки трех задач ML (линейная регрессия, SVM, сбалансированная кластеризация методом k\sphinxhyphen{}средних) аналогично тому, как в {\hyperref[\detokenize{book/problems2qml/ru/np2ising::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{предыдущей лекции}}}} было продемонстрировано сведение к QUBO задач о максимальном разрезе в графе, о коммивояжере и о выделении сообществ в графе. Изложение полностью основывается на статье {[}\hyperlink{cite.book/bibliography:id60}{DAPN21}{]}.

\sphinxAtStartPar
Некоторые обозначения, которые будут использоваться в дальнейшем:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\(\mathbb{R}\) – множество действительных чисел;

\item {} 
\sphinxAtStartPar
\(N\) – количество объектов в обучающем наборе, \(N \in \{1, 2, \dotsc\}\);

\item {} 
\sphinxAtStartPar
\(d\) – количество признаков (\sphinxstyleemphasis{features}) для объектов в обучающем наборе, \(d \in \{1, 2, \dotsc\}\);

\item {} 
\sphinxAtStartPar
\(X\) – тренировочный набор, содержит по одному объекту в каждой из \(N\) строк, каждая строка содержит \(d\) значений признаков, \(X \in \mathbb{R}^{N \times d}\);

\item {} 
\sphinxAtStartPar
\(Y\) – набор истинных “ответов” (\sphinxstyleemphasis{ground truth}), соответствующих тренировочным объектам из \(X\) (\(Y \in \mathbb{R}^{N}\) в случае регрессии, \(Y \in \{0,1\}^{N}\) в случае бинарной классификации);

\item {} 
\sphinxAtStartPar
\(\otimes\) – произведение Кронекера (тензорное произведение);

\item {} 
\sphinxAtStartPar
\(\odot\) – произведение Адамара (поэлементное произведение).

\end{itemize}

\sphinxAtStartPar
Общая формулировка QUBO\sphinxhyphen{}задачи, которая используется в статье {[}\hyperlink{cite.book/bibliography:id60}{DAPN21}{]} и к которой всё сводится, выглядит так:
\begin{equation}\label{equation:book/problems2qml/ru/qubo_linreg_svm_kmeans:eqn:general_qubo_in_paper}
\begin{split}
z^T A z + z^T b
    \to \min_{z \in \{0,1\}^M}
\end{split}
\end{equation}
\sphinxAtStartPar
где \(M\) – натуральное число, \(z\) – бинарный вектор решения, \(A \in \mathbb{R}^{M \times M}\) – QUBO\sphinxhyphen{}матрица с действительными элементами, \(b \in \mathbb{R}^{M}\) – QUBO\sphinxhyphen{}вектор. Как отмечалось в предыдущей лекции, при \(z_i \in \{0,1\}\) выполняется равенство \(z_i^2 = z_i\), так что линейные члены в \eqref{equation:book/problems2qml/ru/qubo_linreg_svm_kmeans:eqn:general_qubo_in_paper} можно включить в квадратичные, но этого делать не будем, т.к. для целей этой лекции и для лучшего понимания удобнее сохранить минимизируемую квадратичную форму именно в виде \eqref{equation:book/problems2qml/ru/qubo_linreg_svm_kmeans:eqn:general_qubo_in_paper}.


\section{Линейная регрессия}
\label{\detokenize{book/problems2qml/ru/qubo_linreg_svm_kmeans:id4}}
\sphinxAtStartPar
В задаче линейной регрессии предполагается, что зависимость истинных ответов от признаков тренировочных объектов приближенно линейная:
\begin{equation*}
\begin{split}
y_i^{(pred)} = \braket{w, x_i} + b, \quad y_i^{(pred)} \approx y_i,
\end{split}
\end{equation*}
\sphinxAtStartPar
где \(y_i^{(pred)}\) – предсказываемое значение, \(y_i\) – истинное значение (из разметки), \(\braket{\cdot, \cdot}\) – скалярное произведение. Удобно сразу избавиться от слагаемого \(b\) (\sphinxstyleemphasis{bias}), добавив единицу к набору признаков. Тогда bias окажется включенным в веса \(w\), а тренировочный набор будет иметь по \((d+1)\) признаков на объект: \(X \in \mathbb{R}^{N \times (d+1)}\). Требуется найти веса \(w\), при которых квадрат евклидовой нормы невязки минимален:
\begin{equation}\label{equation:book/problems2qml/ru/qubo_linreg_svm_kmeans:eqn:lin_reg_orig}
\begin{split}
E(w) = || Xw - Y ||^2
    \to \min_{w \in \mathbb{R}^{d+1}}
\end{split}
\end{equation}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=500\sphinxpxdimen]{{fig_12}.png}
\caption{Иллюстрация к задаче линейной регрессии.}\label{\detokenize{book/problems2qml/ru/qubo_linreg_svm_kmeans:lin-reg-example}}\end{figure}

\sphinxAtStartPar
Известно аналитическое решение задачи \eqref{equation:book/problems2qml/ru/qubo_linreg_svm_kmeans:eqn:lin_reg_orig}:
\begin{equation*}
\begin{split}
w = \left( X^T X \right)^{-1} X^T Y
\end{split}
\end{equation*}
\sphinxAtStartPar
Если \(\left( X^T X \right)^{-1}\) не существует, нужно вычислить \sphinxhref{https://ru.wikipedia.org/wiki/\%D0\%9F\%D1\%81\%D0\%B5\%D0\%B2\%D0\%B4\%D0\%BE\%D0\%BE\%D0\%B1\%D1\%80\%D0\%B0\%D1\%82\%D0\%BD\%D0\%B0\%D1\%8F\_\%D0\%BC\%D0\%B0\%D1\%82\%D1\%80\%D0\%B8\%D1\%86\%D0\%B0}{псевдообратную} матрицу. ВременнАя сложность решения задачи линейной регрессии равна \(\mathcal{O}(N d^2)\), т.к. нужно \(\mathcal{O}(N d^2)\) для вычисления матрицы \(X^T X\) и \(\mathcal{O}(d^3)\) для вычисления обратной к ней (предполагаем, что \(N \gg d\)).


\subsection{QUBO\sphinxhyphen{}формулировка}
\label{\detokenize{book/problems2qml/ru/qubo_linreg_svm_kmeans:qubo}}
\sphinxAtStartPar
Перепишем выражение \eqref{equation:book/problems2qml/ru/qubo_linreg_svm_kmeans:eqn:lin_reg_orig}:
\begin{equation}\label{equation:book/problems2qml/ru/qubo_linreg_svm_kmeans:eqn:lin_reg_qubo_1}
\begin{split}
E(w) =  w^T X^T X w - 2 w^T X^T Y + Y^T Y
        \to \min_{w \in \mathbb{R}^{d+1}}
\end{split}
\end{equation}
\sphinxAtStartPar
Наша цель – найти вектор \(w\), компоненты которого – действительные числа. Но в QUBO\sphinxhyphen{}формулировке необходимо представить решение в виде вектора с бинарными компонентами. Как это сделать? Конечно, напрашивается идея использовать бинарное представление действительного числа \(w_i\) (будем отдельно записывать в бинарном виде целую часть, отдельно – дробную). Нужно помнить о том, что знак \(w_i\) может быть как положительным, так и отрицательным. Формат представления придется выбрать фиксированным (т.е. с \sphinxhref{https://ru.wikipedia.org/wiki/\%D0\%A7\%D0\%B8\%D1\%81\%D0\%BB\%D0\%BE\_\%D1\%81\_\%D1\%84\%D0\%B8\%D0\%BA\%D1\%81\%D0\%B8\%D1\%80\%D0\%BE\%D0\%B2\%D0\%B0\%D0\%BD\%D0\%BD\%D0\%BE\%D0\%B9\_\%D0\%B7\%D0\%B0\%D0\%BF\%D1\%8F\%D1\%82\%D0\%BE\%D0\%B9}{фиксированной запятой}, не с плавающей запятой). Пример:
\begin{equation*}
\begin{split}
\begin{align}
  \pm 110.101   &= \pm
                    \underbrace{
                        \left( 0 \cdot 2^0 + 1 \cdot 2^1 + 1 \cdot 2^2 \right)
                    }_{\text{идем влево от разд. точки}}
                   \pm
                    \underbrace{
                        \left( 1 \cdot 2^{-1} + 0 \cdot 2^{-2} + 1 \cdot 2^{-3} \right)
                    }_{\text{идем вправо от разд. точки}}  \\
                &= \pm \left( 2 + 4 + \frac{1}{2} + \frac{1}{8} \right) \\
                &= \pm 6.625
\end{align}
\end{split}
\end{equation*}
\sphinxAtStartPar
Бинарные компоненты логично рассматривать как индикаторы наличия или отсутствия соответствующих степеней двойки в бинарном представлении каждого действительного числа. Введем вектор\sphinxhyphen{}столбец \(P\), который отвечает за точность представления (\sphinxstyleemphasis{\sphinxstylestrong{P}recision vector}) и состоит из степеней двойки со знаками:
\begin{equation*}
\begin{split}
P = \left[ -2^l, -2^{l-1}, \dotsc, -2^{-m+1}, -2^{-m}, 2^{-m}, 2^{-m+1}, \dotsc, 2^{l-1}, 2^l \right]^T,
\end{split}
\end{equation*}
\sphinxAtStartPar
этот вектор отсортирован по возрастанию элементов. Отводится \(l\) двоичных разрядов для целой части числа, \(m\) разрядов для дробной. \(l\) определяется максимальным по модулю действительным числом, которое хотим представлять; \(m\) определяется желаемой точностью представления. Число элементов вектора \(P\) равно \((m + 1 + l) \cdot2 = K\).

\sphinxAtStartPar
Вводим вектор \(\tilde{w}_i \in \{0,1\}^K\) такой, что
\begin{equation*}
\begin{split}
\tilde{w}_i^T P
= \sum_{k=1}^{K} p_k \tilde{w}_{i k}
\approx w_i \in \mathbb{R}
\end{split}
\end{equation*}
\sphinxAtStartPar
Чтобы не было неоднозначности, нужно договориться о том, что для представления \(w_i > 0\) используем только положительные элементы вектора \(P\), а для \(w_i < 0\) – только отрицательные.

\sphinxAtStartPar
Составляем бинарный вектор \(\tilde{w} \in \{0,1\}^{K(d+1)}\)
\begin{equation*}
\begin{split}
\tilde{w} = [
                \underbrace{ \tilde{w}_{11} \dots \tilde{w}_{1K} }_{\text{предст. } w_1}
                \underbrace{ \tilde{w}_{21} \dots \tilde{w}_{2K} }_{\text{предст. } w_2}
                \dots
                \underbrace{ \tilde{w}_{(d+1)1} \dots \tilde{w}_{(d+1)K} }_{\text{предст. } w_{d+1}}
            ]^T
\end{split}
\end{equation*}
\sphinxAtStartPar
и матрицу точности \(\mathcal{P}\) (\sphinxstyleemphasis{\sphinxstylestrong{P}recision matrix}), которая задает переход к бинарному представлению векторов:
\begin{equation*}
\begin{split}
\mathcal{P} = I_{d+1} \otimes P^T,
\end{split}
\end{equation*}
\sphinxAtStartPar
где \(I_{d+1}\) – единичная матрица размера \((d+1)\). Матрица \(\mathcal{P}\) имеет размерность \((d+1) \times K(d+1)\). Исходный вектор весов можно записать как
\begin{equation}\label{equation:book/problems2qml/ru/qubo_linreg_svm_kmeans:eqn:w_by_tilde_w}
\begin{split}
w = \mathcal{P} \tilde{w},
\end{split}
\end{equation}
\sphinxAtStartPar
где знак “=” на самом деле означает приближенное равенство (наше fixed\sphinxhyphen{}point представление имеет конечную точность).

\sphinxAtStartPar
Всё готово для того, чтобы переписать исходную задачу \eqref{equation:book/problems2qml/ru/qubo_linreg_svm_kmeans:eqn:lin_reg_qubo_1} в QUBO\sphinxhyphen{}формулировке. Подставляем \eqref{equation:book/problems2qml/ru/qubo_linreg_svm_kmeans:eqn:w_by_tilde_w} в \eqref{equation:book/problems2qml/ru/qubo_linreg_svm_kmeans:eqn:lin_reg_qubo_1} и получаем
\begin{equation}\label{equation:book/problems2qml/ru/qubo_linreg_svm_kmeans:eqn:lin_reg_qubo_2}
\begin{split}
E(\tilde{w}) =
    \tilde{w}^T \mathcal{P}^T X^T X \mathcal{P} \tilde{w}
    - 2 \tilde{w}^T \mathcal{P}^T X^T Y
\to \min_{\tilde{w} \in \{0,1\}^{(d+1)K}}
\end{split}
\end{equation}
\sphinxAtStartPar
слагаемое \(Y^T Y\) отброшено, т.к. это константа, никак не влияющая на решение задачи оптимизации без ограничений.


\subsection{Оценка вычислительной сложности}
\label{\detokenize{book/problems2qml/ru/qubo_linreg_svm_kmeans:id5}}
\sphinxAtStartPar
Для исходной задачи регрессии \eqref{equation:book/problems2qml/ru/qubo_linreg_svm_kmeans:eqn:lin_reg_orig} количество значений в датасете \(X\) равно \(\mathcal{O}(N d)\). Мы ввели \(K\) бинарных переменных для каждого из \((d+1)\) весов. Значит, получилось \(\mathcal{O}(K d)\) переменных в QUBO\sphinxhyphen{}формулировке \eqref{equation:book/problems2qml/ru/qubo_linreg_svm_kmeans:eqn:lin_reg_qubo_2}. Для решения задачи требуется \(\mathcal{O}(K^2 d^2)\) кубитов (см. {[}\hyperlink{cite.book/bibliography:id29}{DPP19}{]}), это пространственная сложность в рассматриваемом подходе.

\sphinxAtStartPar
ВременнАя сложность в классической задаче \(\mathcal{O}(N d^2)\). В случае QUBO\sphinxhyphen{}задачи для временнОй оценки нужно рассмотреть три части:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Затраты времени для конвертации задачи регрессии в QUBO\sphinxhyphen{}формулировку. Здесь получаем \(\mathcal{O}(N K^2 d^2)\) (проверьте это, оценив число умножений, необходимых для вычисления \(\mathcal{P}^T X^T X \mathcal{P}\)).

\item {} 
\sphinxAtStartPar
Время для реализации QUBO\sphinxhyphen{}задачи в квантовом “железе”. Здесь потребуется \(\mathcal{O}(K^2 d^2)\), если использовать алгоритм из {[}\hyperlink{cite.book/bibliography:id29}{DPP19}{]}.

\item {} 
\sphinxAtStartPar
Время для выполнения квантового отжига. Существуют теоретические оценки времени для получения точного решения, но более практично рассматривать случай, когда можно просто довольствоваться достаточно высокой вероятностью (скажем, 99\%) получения оптимального решения. Для современных квантовых компьютеров D\sphinxhyphen{}Wave с ограниченным числом кубитов на практике получается, что время отжига и число повторений можно считать константами.

\end{enumerate}

\sphinxAtStartPar
В итоге полная временнАя сложность решения QUBO\sphinxhyphen{}задачи на адиабатическом квантовом компьютере \(\mathcal{O}(N K^2 d^2)\). Может показаться, что это хуже, чем временнАя сложность классического решения, если считать \(K\) переменной. Но величина \(K\) определяется только шириной диапазона числовых значений и желаемой точностью представления, \(K\) не зависит от основных параметров задачи типа \(N\) и \(d\). Поэтому можно считать \(K\) константой. Тогда число требуемых кубитов \(\mathcal{O}(d^2)\), временнАя сложность \(\mathcal{O}(N d^2)\), это эквивалентно классическому случаю.


\section{SVM}
\label{\detokenize{book/problems2qml/ru/qubo_linreg_svm_kmeans:svm}}
\sphinxAtStartPar
Классический SVM подробно описан в соответствующей {\hyperref[\detokenize{book/qsvm/ru/classic_svm::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{лекции}}}}. Рассматривается тренировочный набор \(X \in \mathbb{R}^{N \times d}\) и набор истинных меток \(Y \in \{-1, +1\}^{N}\). Нужно решить задачу бинарной классификации, найдя веса \(w \in \mathbb{R}^{d}\) и константу \(b \in \mathbb{R}\), при которых классификатор \(a(x_i) = \text{sign} \left( w^T x_i + b \right)\) допускает как можно меньше ошибок на обучающей выборке.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=500\sphinxpxdimen]{{fig_22}.png}
\caption{Иллюстрация к задаче бинарной классификации с помощью SVM.}\label{\detokenize{book/problems2qml/ru/qubo_linreg_svm_kmeans:svm-example}}\end{figure}

\sphinxAtStartPar
Двойственная задача \eqref{equation:book/qsvm/ru/classic_svm:svmDual} в текущих обозначениях принимает вид
\begin{equation}\label{equation:book/problems2qml/ru/qubo_linreg_svm_kmeans:eqn:svm_dual_1}
\begin{split}
\left\{
    \begin{aligned}
        & \mathcal{L}(\lambda) =
            \sum_{i = 1}^{N} \lambda_i
            -\frac{1}{2} \sum_{i, j = 1}^{N}
                \lambda_i \lambda_j y_i y_j
                \langle x_i, x_j \rangle
          \to \max_{\lambda}, \\
        & 0 \leq \lambda_i \leq C \quad \forall i \in \{1, 2, \dotsc, N\}, \\
        & \sum_{i = 1}^{N} \lambda_i y_i = 0.
    \end{aligned}
\right.
\end{split}
\end{equation}

\subsection{QUBO\sphinxhyphen{}формулировка}
\label{\detokenize{book/problems2qml/ru/qubo_linreg_svm_kmeans:id8}}
\sphinxAtStartPar
Перепишем \eqref{equation:book/problems2qml/ru/qubo_linreg_svm_kmeans:eqn:svm_dual_1} как задачу минимизации:
\begin{equation}\label{equation:book/problems2qml/ru/qubo_linreg_svm_kmeans:eqn:svm_dual_2}
\begin{split}
\left\{
    \begin{aligned}
        & \mathcal{L}_{neg}(\lambda) =
            \frac{1}{2} \sum_{i, j = 1}^{N}
                \lambda_i \lambda_j y_i y_j
                \langle x_i, x_j \rangle
            -\sum_{i = 1}^{N} \lambda_i
          \to \min_{\lambda}, \\
        & 0 \leq \lambda_i \leq C \quad \forall i \in \{1, 2, \dotsc, N\}, \\
        & \sum_{i = 1}^{N} \lambda_i y_i = 0.
    \end{aligned}
\right.
\end{split}
\end{equation}
\sphinxAtStartPar
Тренировочные объекты \(x_i\), соответствующие \(\lambda_i = 0\), называются \sphinxstyleemphasis{периферийными}, от них решение
\begin{equation*}
\begin{split}
w = \sum_{i = 1}^{N} \lambda_i y_i x_i
\end{split}
\end{equation*}
\sphinxAtStartPar
не зависит. Объекты, соответствующие \(\lambda_i > 0\), называются \sphinxstyleemphasis{опорными}.

\sphinxAtStartPar
Задача минимизации переписывается в виде
\begin{equation}\label{equation:book/problems2qml/ru/qubo_linreg_svm_kmeans:eqn:svm_dual_3}
\begin{split}
\left\{
    \begin{aligned}
        & \mathcal{L}_{neg}(\lambda) =
            \frac{1}{2} \lambda^T \left( X X^T \odot Y Y^T \right) \lambda
            -\lambda^T 1_{N}
          \to \min_{\lambda}, \\
        & 0_{N} \leq \lambda \leq C_{N}, \\
        & \lambda^T Y = 0,
    \end{aligned}
\right.
\end{split}
\end{equation}
\sphinxAtStartPar
где \(1_N\) – вектор, состоящий из \(N\) единиц (аналогичный смысл имеют \(0_N\) и \(C_N\)), \(\lambda \in \mathbb{R}^{N}\).

\sphinxAtStartPar
Как в задаче линейной регрессии, будем представлять каждую \(\lambda_i \in \mathbb{R}\) бинарным вектором \(\tilde{\lambda}_i \in \{0,1\}^K\). Поскольку \(\lambda_i \geq 0\), в \sphinxstyleemphasis{precision vector} \(P\) нужно включить только положительные значения:
\begin{equation*}
\begin{split}
P = \left[2^{-m}, 2^{-m+1}, \dotsc, 2^{l-1}, 2^l \right]^T
\end{split}
\end{equation*}
\sphinxAtStartPar
Вектор \(P\) содержит \(m + 1 + l = K\) элементов (здесь \(K\) никак не связано с \(K\) из раздела про линейную регрессию, просто было решено не вводить новое обозначение для длины нового вектора \(P\)). При подходящем выборе \(m\) и \(l\) достаточно точно выполняется равенство
\begin{equation}\label{equation:book/problems2qml/ru/qubo_linreg_svm_kmeans:eqn:real_lambda_by_binary}
\begin{split}
\lambda_i \approx \sum_{k=1}^{K} p_k \tilde{\lambda}_{i k}
\quad \forall i \in \{1, 2, \dotsc, N\}
\end{split}
\end{equation}
\sphinxAtStartPar
Выполняем конкатенацию всех \(\tilde{\lambda}_{i k}\) по вертикали
\begin{equation*}
\begin{split}
\tilde{\lambda} = [
                \underbrace{ \tilde{\lambda}_{11} \dots \tilde{\lambda}_{1K} }_{\text{предст. } \lambda_1}
                \underbrace{ \tilde{\lambda}_{21} \dots \tilde{\lambda}_{2K} }_{\text{предст. } \lambda_2}
                \dots
                \underbrace{ \tilde{\lambda}_{N1} \dots \tilde{\lambda}_{NK} }_{\text{предст. } \lambda_{N}}
            ]^T
\end{split}
\end{equation*}
\sphinxAtStartPar
и вводим матрицу \(\mathcal{P}\) (\sphinxstyleemphasis{precision matrix})
\begin{equation*}
\begin{split}
\mathcal{P} = I_{N} \otimes P^T
\end{split}
\end{equation*}
\sphinxAtStartPar
таким образом, что (приближенно)
\begin{equation*}
\begin{split}
\lambda = \mathcal{P} \tilde{\lambda}
\end{split}
\end{equation*}
\sphinxAtStartPar
Подставляя из этого выражения \(\lambda\) в \eqref{equation:book/problems2qml/ru/qubo_linreg_svm_kmeans:eqn:svm_dual_3}, получаем:
\begin{equation}\label{equation:book/problems2qml/ru/qubo_linreg_svm_kmeans:eqn:svm_qubo_1}
\begin{split}
\left\{
    \begin{aligned}
    & \mathcal{L}_{neg}(\tilde{\lambda}) =
                \frac{1}{2}
                \tilde{\lambda}^T \mathcal{P}^T \left( X X^T \odot Y Y^T \right) \mathcal{P} \tilde{\lambda}
                -\tilde{\lambda}^T \mathcal{P}^T 1_{N}
            \to \min_{\tilde{\lambda} \in \{0,1\}^{N K}} \\
    & \left( \mathcal{P} \tilde{\lambda} \right)^T Y = 0
    \end{aligned}
\right.
\end{split}
\end{equation}
\sphinxAtStartPar
Остается избавиться от ограничения в виде равенства в \eqref{equation:book/problems2qml/ru/qubo_linreg_svm_kmeans:eqn:svm_qubo_1}. Как обычно делается в таких случаях, вместо ограничения вводим соответствующий штраф за его нарушение:
\begin{equation*}
\begin{split}
Penalty^{(hp)} = \frac{\gamma}{2}
    \left(
        \left( \mathcal{P} \tilde{\lambda} \right)^T Y
    \right)^2
    = \frac{\gamma}{2} \left(
        \left( \tilde{\lambda}^T \mathcal{P}^T \right) Y
    \right)^2
    = \frac{\gamma}{2} \tilde{\lambda}^T \mathcal{P}^T \left( Y Y^T \right) \mathcal{P} \tilde{\lambda},
\end{split}
\end{equation*}
\sphinxAtStartPar
где \(\gamma\) – достаточно большая константа, \sphinxstyleemphasis{hp} означает \sphinxstyleemphasis{hyperplane} (гиперплоскость).

\sphinxAtStartPar
Добавляем \(Penalty^{(hp)}\) к \(\mathcal{L}_{neg}(\tilde{\lambda})\) и получаем итоговую QUBO\sphinxhyphen{}формулировку:
\begin{equation}\label{equation:book/problems2qml/ru/qubo_linreg_svm_kmeans:eqn:svm_qubo_2}
\begin{split}
    \frac{1}{2}
        \tilde{\lambda}^T \mathcal{P}^T
        \left(
            X X^T \odot Y Y^T + \gamma Y Y^T
        \right)
        \mathcal{P} \tilde{\lambda}
        -\tilde{\lambda}^T \mathcal{P}^T 1_{N}
    \to \min_{\tilde{\lambda} \in \{0,1\}^{N K}}
\end{split}
\end{equation}

\subsection{Оценка вычислительной сложности}
\label{\detokenize{book/problems2qml/ru/qubo_linreg_svm_kmeans:id9}}
\sphinxAtStartPar
Задача \eqref{equation:book/problems2qml/ru/qubo_linreg_svm_kmeans:eqn:svm_dual_3} содержит \(\mathcal{O}(N d)\) значений в данных и \(\mathcal{O}(N)\) параметров (\(\lambda\)). QUBO\sphinxhyphen{}формулировка \eqref{equation:book/problems2qml/ru/qubo_linreg_svm_kmeans:eqn:svm_qubo_2} содержит то же количество данных, а число параметров в \(K\) раз больше, т.е. \(\mathcal{O}(K N)\). Значит, потребуется \(\mathcal{O}(N^2 K^2)\) кубитов.

\sphinxAtStartPar
ВременнАя сложность классического SVM в типичных реализациях (например, \sphinxhref{https://en.wikipedia.org/wiki/LIBSVM}{LIBSVM}) равна \(\mathcal{O}(N^3)\). Для оценки временнОй сложности QUBO рассматриваем три составляющие (как в задаче линейной регрессии):
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Затраты времени для конвертации в QUBO\sphinxhyphen{}формулировку. Из \eqref{equation:book/problems2qml/ru/qubo_linreg_svm_kmeans:eqn:svm_dual_2} и \eqref{equation:book/problems2qml/ru/qubo_linreg_svm_kmeans:eqn:real_lambda_by_binary} следует, что оценка времени \(\mathcal{O}(N^2 K^2)\).

\item {} 
\sphinxAtStartPar
Для реализации QUBO\sphinxhyphen{}задачи в квантовом “железе” потребуется \(\mathcal{O}(N^2 K^2)\).

\item {} 
\sphinxAtStartPar
Время для выполнения квантового отжига и число повторений можно считать константами (см. комментарии к тому же пункту в обсуждении линейной регрессии).

\end{enumerate}

\sphinxAtStartPar
В итоге временнАя сложность \(\mathcal{O}(N^2 K^2)\). \(K\) можно считать константой, т.к. она зависит только от диапазона и желаемой точности представления \(\lambda\) и не зависит от параметров самой задачи классификации. Тогда получается временная сложность \(\mathcal{O}(N^2)\), что гораздо лучше оценки \(\mathcal{O}(N^3)\) в классическом случае.


\section{Сбалансированная кластеризация методом k\sphinxhyphen{}средних}
\label{\detokenize{book/problems2qml/ru/qubo_linreg_svm_kmeans:k}}
\sphinxAtStartPar
Кластеризация методом k\sphinxhyphen{}средних – ML\sphinxhyphen{}задача обучения без учителя (\sphinxstyleemphasis{unsupervised}). Требуется распределить тренировочные объекты по \(k\) кластерам так, чтобы суммарное отклонение тренировочных объектов, принадлежащих кластерам, от центроидов (центров масс) соответствующих кластеров было минимальным. Сбалансированная кластеризация методом k\sphinxhyphen{}средних – частный случай, в котором каждый кластер содержит примерно одно и то же количество объектов \(N/k\), как показано на \hyperref[\detokenize{book/problems2qml/ru/qubo_linreg_svm_kmeans:kmeans-clustering-example}]{Fig.\@ \ref{\detokenize{book/problems2qml/ru/qubo_linreg_svm_kmeans:kmeans-clustering-example}}}.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=500\sphinxpxdimen]{{fig_32}.png}
\caption{Иллюстрация к задаче сбалансированной кластеризации методом k\sphinxhyphen{}средних.}\label{\detokenize{book/problems2qml/ru/qubo_linreg_svm_kmeans:kmeans-clustering-example}}\end{figure}

\sphinxAtStartPar
Нужно распределить \(N\) объектов из тренировочного набора \(X \in \mathbb{R}^{N \times d}\) по \(k\) кластерам \(\Phi = \{\phi_1, \dotsc, \phi_k\}\). Пусть \(\mu_i\) – центроид кластера \(\phi_i\). В общем случае задача кластеризации методом k\sphinxhyphen{}средних формулируется так:
\begin{equation}\label{equation:book/problems2qml/ru/qubo_linreg_svm_kmeans:eqn:general_kmeans}
\begin{split}
\sum_{i=1}^{k} \frac{1}{2 |\phi_i|}
    \sum_{x,y \in \phi_i} || x - y ||^2
    \to \min_{\Phi}
\end{split}
\end{equation}
\sphinxAtStartPar
Если размеры \(|\phi_i|\) всех кластеров одинаковые, то формулировка переписывается так:
\begin{equation}\label{equation:book/problems2qml/ru/qubo_linreg_svm_kmeans:eqn:kmeans_equal_clusters}
\begin{split}
\sum_{i=1}^{k} \sum_{x,y \in \phi_i} || x - y ||^2
    \to \min_{\Phi}
\end{split}
\end{equation}
\sphinxAtStartPar
В прикладных задачах кластеризации размеры кластеров только приближенно равны друг другу, поэтому решение задачи \eqref{equation:book/problems2qml/ru/qubo_linreg_svm_kmeans:eqn:kmeans_equal_clusters} не является точным решением задачи \eqref{equation:book/problems2qml/ru/qubo_linreg_svm_kmeans:eqn:general_kmeans}. Для решения задачи кластеризации методом k\sphinxhyphen{}средних можно использовать, например, \sphinxhref{https://en.wikipedia.org/wiki/Lloyd\%27s\_algorithm}{алгоритм Ллойда}. Существует модификация алгоритма Ллойда для случая сбалансированной кластеризации.


\subsection{QUBO\sphinxhyphen{}формулировка}
\label{\detokenize{book/problems2qml/ru/qubo_linreg_svm_kmeans:id10}}
\sphinxAtStartPar
Вводим матрицу \(D \in \mathbb{R}^{N \times N}\), элементы которой равны квадратам попарных расстояний между тренировочными объектами:
\begin{equation*}
\begin{split}
d_{i j} = || x_i - x_j ||^2
\end{split}
\end{equation*}
\sphinxAtStartPar
Также вводим бинарную матрицу \(\tilde{W} \in \{0,1\}^{N \times k}\), каждый элемент которой \(\tilde{w}_{ij} = 1\) в том и только в том случае, когда объект \(x_i\) принадлежит кластеру \(\phi_j\). Очевидно, есть два ограничения на \(\tilde{W}\):
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Поскольку мы предполагаем, что все кластеры содержат примерно одно и тоже количество объектов, каждый столбец \(\tilde{W}\) должен содержать примерно \(N/k\) единиц.

\item {} 
\sphinxAtStartPar
Каждый объект принадлежит ровно одному кластеру, поэтому каждая строка \(\tilde{W}\) должна содержать ровно одну единицу.

\end{enumerate}

\sphinxAtStartPar
Для получения QUBO\sphinxhyphen{}формулировки задачи нам потребуется избавиться от этих ограничений. Для этого, как обычно, введем в минимизируемую квадратичную форму штрафы за нарушение ограничений. Вернемся к этому через пару абзацев.

\sphinxAtStartPar
Используя \(D\) и \(\tilde{W}\), мы можем переписать внутреннюю сумму в \eqref{equation:book/problems2qml/ru/qubo_linreg_svm_kmeans:eqn:kmeans_equal_clusters} в виде
\begin{equation*}
\begin{split}
\sum_{x,y \in \phi_i} || x - y ||^2 =
    {\tilde{w}_{j}^{'}}^T D \tilde{w}_{j}^{'},
\end{split}
\end{equation*}
\sphinxAtStartPar
где \(\tilde{w}_{j}^{'}\) – столбец номер j в \(\tilde{W}\). Чтобы переписать в бинарных переменных полную (двойную) сумму в \eqref{equation:book/problems2qml/ru/qubo_linreg_svm_kmeans:eqn:kmeans_equal_clusters}, составим вектор\sphinxhyphen{}столбец из всех \(N k\) элементов матрицы \(\tilde{W}\):
\begin{equation*}
\begin{split}
\tilde{w} = [
                \tilde{w}_{11} \dots \tilde{w}_{N1}
                \tilde{w}_{12} \dots \tilde{w}_{N2}
                \dots
                \tilde{w}_{1k} \dots \tilde{w}_{Nk}
            ]^T
\end{split}
\end{equation*}
\sphinxAtStartPar
При условии, что ограничения на \(\tilde{w}\) выполнены, запишем задачу \eqref{equation:book/problems2qml/ru/qubo_linreg_svm_kmeans:eqn:kmeans_equal_clusters} в эквивалентном виде
\begin{equation}\label{equation:book/problems2qml/ru/qubo_linreg_svm_kmeans:eqn:sqr_form_without_constraints}
\begin{split}
\tilde{w}^T \left( I_k \otimes D \right) \tilde{w}
    \to \min_{\tilde{w}}
\end{split}
\end{equation}
\sphinxAtStartPar
Теперь разбираемся с ограничениями на \(\tilde{w}\).

\sphinxAtStartPar
Во\sphinxhyphen{}первых, каждый столбец \(\tilde{W}\) должен содержать примерно \(N/k\) единиц. Введем штраф, непосредственно отражающий это требование:
\begin{equation*}
\begin{split}
Penalty_{j}^{(col)} =
    \alpha
    \left(
        {\tilde{w}_{j}^{'}}^T \tilde{w}_{j}^{'} - \frac{N}{k}
    \right)^2,
\end{split}
\end{equation*}
\sphinxAtStartPar
где \(\alpha\) – достаточно большая константа. Раскрыв скобки в предыдущем выражении, можно убедиться, что
\begin{equation*}
\begin{split}
Penalty_{j}^{(col)}
    =
    {\tilde{w}_{j}^{'}}^T
        \alpha
        \underbrace{
            \left( 1_N - \frac{2N}{k} I_N \right)
        }_{\text{обозначим как } F}
    \tilde{w}_{j}^{'}
    + \text{const}
\end{split}
\end{equation*}
\sphinxAtStartPar
Сумма всех штрафов для столбцов равна
\begin{equation*}
\begin{split}
Penalty^{(col)} = \sum_j Penalty_{j}^{(col)} =
    \tilde{w}^T
        \left( I_k \otimes \alpha F \right)
    \tilde{w}
\end{split}
\end{equation*}
\sphinxAtStartPar
Во\sphinxhyphen{}вторых, каждая строка \(\tilde{W}\) должна содержать ровно одну единицу. Соответствующий штраф
\begin{equation*}
\begin{split}
Penalty_{i}^{(row)} =
    \beta
    \left(
        \tilde{w}_{i}^T \tilde{w}_{i} - 1
    \right)^2,
\end{split}
\end{equation*}
\sphinxAtStartPar
где \(\beta\) – достаточно большая константа. Раскрыв скобки в предыдущем выражении, получаем
\begin{equation*}
\begin{split}
Penalty_{i}^{(row)}
    =
    \tilde{w}_{i}^T
        \beta
        \underbrace{
            \left( 1_k - 2 I_k \right)
        }_{\text{обозначим как } G}
    \tilde{w}_{i}
    + \text{const}
\end{split}
\end{equation*}
\sphinxAtStartPar
Чтобы найти сумму \(Penalty^{(row)} = \sum_i Penalty_{i}^{(row)}\), преобразуем бинарный вектор \(\tilde{w}\) в другой бинарный вектор \(\tilde{v}\), получающийся из \(\tilde{w}\) определенной перестановкой элементов:
\begin{equation*}
\begin{split}
\tilde{v} = [
                \tilde{w}_{11} \dots \tilde{w}_{1k}
                \tilde{w}_{21} \dots \tilde{w}_{2k}
                \dots
                \tilde{w}_{N1} \dots \tilde{w}_{Nk}
            ]^T
\end{split}
\end{equation*}
\sphinxAtStartPar
Переход от \(\tilde{w}\) к \(\tilde{v}\) можно представить как линейное преобразование
\begin{equation*}
\begin{split}
\tilde{v} = Q \tilde{w}
\end{split}
\end{equation*}
\sphinxAtStartPar
с некоторой матрицей \(Q \in \{0,1\}^{Nk \times Nk}\) (матрица \(Q\) в свою очередь получается из единичной матрицы \(I_{Nk}\) определенной перестановкой элементов).

\sphinxAtStartPar
Сумма штрафов для строк равна
\begin{equation*}
\begin{split}
Penalty^{(row)} = \sum_i Penalty_{i}^{(row)} =
    \tilde{v}^T
        \left( I_N \otimes \beta G \right)
    \tilde{v}
    =
    \tilde{w}^T Q^T
        \left( I_N \otimes \beta G \right)
    Q \tilde{w}
\end{split}
\end{equation*}
\sphinxAtStartPar
Соберем вместе квадратичную форму \eqref{equation:book/problems2qml/ru/qubo_linreg_svm_kmeans:eqn:sqr_form_without_constraints} (записанную без учета ограничений) и штрафы \(Penalty^{(col)}\), \(Penalty^{(row)}\) в одно финальное выражение, которое и является QUBO\sphinxhyphen{}формулировкой задачи о сбалансированной кластеризации методом k\sphinxhyphen{}средних:
\begin{equation}\label{equation:book/problems2qml/ru/qubo_linreg_svm_kmeans:eqn:final_qubo_kmeans}
\begin{split}
\tilde{w}^T
    \left(
        I_k \otimes (D + \alpha F)
        + Q^T (I_N \otimes \beta G) Q
    \right)
\tilde{w}
    \to \min_{\tilde{w}}
\end{split}
\end{equation}

\subsection{Оценка вычислительной сложности}
\label{\detokenize{book/problems2qml/ru/qubo_linreg_svm_kmeans:id11}}
\sphinxAtStartPar
Задача \eqref{equation:book/problems2qml/ru/qubo_linreg_svm_kmeans:eqn:kmeans_equal_clusters} содержит \(\mathcal{O}(N d)\) значений в данных и \(\mathcal{O}(N)\) переменных. В QUBO\sphinxhyphen{}формулировке вводим по \(k\) бинарных переменных для каждой исходной. Получается \(\mathcal{O}(N k)\) переменных, а значит, требуется \(\mathcal{O}(N^2 k^2)\) кубитов.

\sphinxAtStartPar
Известно, что классический алгоритм сбалансированной кластеризации методом k\sphinxhyphen{}средних сходится за время \(\mathcal{O}(N^{3.5} k^{3.5})\) в худшем случае (см. ссылки в статье {[}\hyperlink{cite.book/bibliography:id60}{DAPN21}{]}). Для оценки временнОй сложности QUBO рассматриваем три составляющие:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Затраты времени для конвертации в QUBO\sphinxhyphen{}формулировку. В выражении \eqref{equation:book/problems2qml/ru/qubo_linreg_svm_kmeans:eqn:final_qubo_kmeans} по вычислительной сложности доминирует слагаемое, содержащее \(I_k \otimes D\). Соответствующая вычислительная сложность \(\mathcal{O}(N^2 k d)\).

\item {} 
\sphinxAtStartPar
Для реализации QUBO\sphinxhyphen{}задачи в квантовом “железе” потребуется \(\mathcal{O}(N^2 k^2)\).

\item {} 
\sphinxAtStartPar
Время для выполнения квантового отжига и число повторений можно считать константами (см. комментарии к тому же пункту в обсуждении линейной регрессии).

\end{enumerate}

\sphinxAtStartPar
В итоге получаем полную вычислительную сложность \(\mathcal{O}(N^2 k (d+k))\). Это лучше, чем результат классического алгоритма в худшем случае. Но количество итераций в классическом алгоритме сильно зависит от “удачности” начального приближения для центроидов кластеров. Классический алгоритм может оказаться и быстрее квантового.


\section{Заключение}
\label{\detokenize{book/problems2qml/ru/qubo_linreg_svm_kmeans:id13}}
\sphinxAtStartPar
В этой лекции были рассмотрены три важные задачи машинного обучения, которые можно переформулировать в виде QUBO (\sphinxstyleemphasis{Quadratic Unconstrained Binary Optimization}) для решения на квантовом аннилере путем сведения к задаче нахождения основного состояния квантовой системы. Общий подход заключается в том, что минимизируемый в классической формулировке функционал переписывается в виде квадратичной формы относительно бинарных переменных, а вместо условий\sphinxhyphen{}ограничений в финальную квадратичную форму QUBO\sphinxhyphen{}задачи вводятся штрафы за нарушение этих ограничений. Есть надежда на то, что при некотором количестве кубитов квантовые алгоритмы будут иметь преимущество перед классическими по времени выполнения.

\sphinxstepscope


\chapter{Преобразование Жордана\sphinxhyphen{}Вигнера}
\label{\detokenize{book/problems2qml/ru/jordanwigner:jordanwigner}}\label{\detokenize{book/problems2qml/ru/jordanwigner:id1}}\label{\detokenize{book/problems2qml/ru/jordanwigner::doc}}
\sphinxAtStartPar
Автор(ы):
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/Randl}{Желтоножский Евгений}

\end{itemize}


\section{Описание лекции}
\label{\detokenize{book/problems2qml/ru/jordanwigner:id2}}
\sphinxAtStartPar
В этой лекции мы узнаем как реально существующей системе (например, электронам на решетке) сопоставить систему состоящую из спинов (кубитов), для того чтобы просимулировать ее на квантовом компьютере. Для этого мы сначала изучим альтернативный, зачастую более удобный подход к описанию многочастичных квантовых систем, который называется “вторичное квантование”.


\section{Введение}
\label{\detokenize{book/problems2qml/ru/jordanwigner:id3}}
\sphinxAtStartPar
Для того чтобы просимулировать квантовую систему на квантовом же компьютере (например, посчитать энергию основного состояния какого\sphinxhyphen{}нибудь атома), нам необходимо закодировать состояние системы и действующие на нее операторы: найти соответствие между состояниями системы и состояниями нашего компьютера (т.е., кубитов).

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{encoding}.png}
\caption{Общая схема симуляции квантовой системы на квантовом компьютере (взято из {[}\hyperlink{cite.book/bibliography:id61}{SRL12}{]}).}\label{\detokenize{book/problems2qml/ru/jordanwigner:a-simulation-scheme}}\end{figure}


\section{Спины, фермионы и бозоны}
\label{\detokenize{book/problems2qml/ru/jordanwigner:id5}}
\sphinxAtStartPar
Как мы помним из {\hyperref[\detokenize{book/problems/ru/quantchemadvancedscf::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{лекции по квантовой химии}}}}, квантовые частицы могут быть либо бозонами, либо фермионами. Одно из различий между ними состоит в том, что при перестановки двух бозонов волновая функция не меняется, а при перестановке двух фермионов – меняет знак. Эта классификация следует из того, что квантовые частицы неотличимы.

\sphinxAtStartPar
Несмотря на то, что наши кубиты состоят из каких\sphinxhyphen{}то частиц (бозонов или фермионов), обычно они отличимы (например, зафиксированы на своих позициях) и, следовательно, не являются ни бозонами, ни фермионами. Так как мы используем два состояния кубита (\(| 0 \rangle\) и \(| 1 \rangle\)), каждый кубит может быть описан как система со спином 1/2.


\section{Вторичное квантование}
\label{\detokenize{book/problems2qml/ru/jordanwigner:id6}}
\sphinxAtStartPar
В квантовой механике мы \sphinxhref{../../qc/ru/gates.html\#id11}{можем описать} состояние нескольких частиц как тензорное произведение состояний каждой из частиц. Например, если у нас есть две частицы, и их квантовое состояние описывается положением частицы в пространстве, \(r_i\), мы можем записать состояние частиц как
\begin{equation*}
\begin{split}
| \psi \rangle = | r_1 \rangle \otimes |r_2 \rangle.
\end{split}
\end{equation*}
\sphinxAtStartPar
У этого подхода есть два главных недостатка – во первых, работать с системами в которых разное количество частиц, или где это количество может меняться, не очень удобно. Во\sphinxhyphen{}вторых, не учитывается неразличимость квантовых частиц.

\sphinxAtStartPar
Обе эти проблемы решаются вторичным квантованием, где вместо использования состояния каждой частицы мы описываем систему количеством частиц в каждом из возможных состояний. Так как частицы неразличимы, такое описание достаточно для полного описания системы. Вместо Гильбертова пространства фиксированной размерности наши состояния теперь являются элементами пространства Фока (суммы Гильбертовых пространств для всех возможных значений количества частиц). Основное состояние, или вакуум, теперь это состояние с 0 частиц.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Несмотря на название, мы не квантуем систему повторно, а просто избавляемся от избыточности в описании.
\end{sphinxadmonition}

\sphinxAtStartPar
Мы так же можем определить операторы, которые добавляют или убирают частицу в определенном состоянии из системы. На языке первой квантизации:
\begin{equation*}
\begin{split}
b^\dagger_\alpha | \Psi \rangle =\frac{1}{\sqrt{N+1}} | \psi_\alpha \rangle \otimes | \Psi \rangle \\
b_\alpha \left(| \psi_\alpha \rangle \otimes | \Psi \rangle \right) =\frac{1}{\sqrt{N}}| \Psi \rangle.
\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
До сих пор операторы которые мы видели действовали из гильбертова пространства с определенным количеством частиц в него самого. Оператор создания действует из гильбертова пространства с \(n\) частиц в гильбертово пространства с \(n+1\) частиц (оба этих пространства являются частью пространства Фока).
\end{sphinxadmonition}

\sphinxAtStartPar
Тут \(b^\dagger_\alpha\) называется оператором создания (creation), а \(b_\alpha\) – уничтожения (annihilation). Заметим, что эти операторы не эрмитовы, т.е., \(b^\dagger_\alpha \neq b_\alpha\). Нормализация операторов выбрана таким образом, что собственные значения (эрмитова) оператора \(b^\dagger_\alpha b_\alpha\) – количество частиц в состоянии \(\alpha\).

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Наблюдаемые величины соответсвуют эрмитовым операторам, следовательно \(b_\alpha\) не соответсвует никакой наблюдаемой величине. В частности, такой член сам по себе не может быть частью гамильтониана (но может быть частью эрмитова члена, например \(b_\alpha+b^\dagger_\alpha\).
\end{sphinxadmonition}

\sphinxAtStartPar
Если в системе нет ни одной частицы в состоянии \(\alpha\), то оператор уничтожения уничтожает состояние:
\begin{equation*}
\begin{split}
b_\alpha | \Psi \rangle=0.  
\end{split}
\end{equation*}
\sphinxAtStartPar
\(0\) тут это нулевой вектор, в отличии от \(| 0 \rangle\), вакуума. Так как \(0\) это не физическое состояние (например, если бы мы захотели измерить какую\sphinxhyphen{}нибудь величину \(X\), то вероятность найти систему в любом собственном состоянии \(| x \rangle\) будет равно нулю), мы можем интерпретировать это как тот факт, что нельзя уничтожить частицу которой нет.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Хотя стандартная конвенция говорит о том, что векторы состояния нормализованы (\(\langle \psi | \psi \rangle = 1\)), после применения оператора (эрмитова или нет) мы не обязаны получить нормализованное состяние. Можно считать что после каждого применения оператора мы нормализуем состояние, либо, чуть более математически, что мы рассматриваем проективное гильбертово пространство, которое задается классом эквивалентности \(v \sim kv\) для комплексного числа \(k \in \mathbb{C}\) и любого вектора \(v \in \mathcal{H}\) т.е. все параллельные векторы эквивалентны.
\end{sphinxadmonition}

\sphinxAtStartPar
В зависимости от типа частиц, операторы создания и уничтожения подчиняются определенным отношениям. В случае бозонов,
разные операторы коммутируют:
\begin{equation*}
\begin{split}
[b^\dagger_i, b_j ] = \delta_{ij} \\
[b^\dagger_i, b^\dagger_j ] = [b_i, b_j ] = 0.  
\end{split}
\end{equation*}
\sphinxAtStartPar
В случае фермионов, операторы антикоммутируют:
\begin{equation*}
\begin{split}
\{с^\dagger_i, с_j \} = \delta_{ij} \\
\{c^\dagger_i, c^\dagger_j \} = \{c_i, c_j \} = 0.  
\end{split}
\end{equation*}
\sphinxAtStartPar
В частности,
\begin{equation*}
\begin{split}
\{c^\dagger_j, c^\dagger_j \} = 2\left(c^\dagger_j\right)^2 = 0,
\end{split}
\end{equation*}
\sphinxAtStartPar
и, следовательно, в системе не может быть больше одного фермиона в одном состоянии (в соответствии с принципом запрета Паули). Из этого так же следует что \(c_j^2=0\), так как независимо от состояния системы, после первого оператора в ней не останется фермиона который можно было бы уничтожить.


\section{Переход от спинов к фермионам}
\label{\detokenize{book/problems2qml/ru/jordanwigner:id7}}
\sphinxAtStartPar
Пронумеруем возможные состояния частиц индексом \(i\): например, это могут быть электроны в состояниях, отвечающих гауссианам из \sphinxcode{\sphinxupquote{STO\sphinxhyphen{}3g}} или находящиеся в разных узлах цепочки атомов. Мы можем попробовать сопоставить спину фермион: если спин с индексом \(i\) направлен вниз то фермион c индексом \(i\) существует, а если спин направлен вверх – то фермион не существует (количество фермионов с определенным индексом может быть только \(1\) или \(0\)). Другими словами, используя оператор количества частиц \(\hat{n}_i = c^\dagger_i c_i\), где \(c^\dagger_i\) и \(c_i\) это операторы создания и уничтожения соответственно, мы хотели бы сопоставить
\begin{equation*}
\begin{split}
\hat{\sigma}_i^z = 1 - 2\hat{n}_i
\end{split}
\end{equation*}
\sphinxAtStartPar
Тогда лестничные (ladder) операторы \(\sigma^- = (\hat{\sigma}_i^x-i\hat{\sigma}_i^y)/2 = \begin{pmatrix} 0 & 0 \\ 1 & 0 \end{pmatrix}\) и \(\sigma^+= (\hat{\sigma}_i^x+i\hat{\sigma}_i^y)/2 = \begin{pmatrix} 0 & 1 \\ 0 & 0 \end{pmatrix}\), соответствуют операторам создания и уничтожения.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Заметим что оператор \(\sigma^-\) переводит состояние “спин вверх” в состоянии “спин вниз”, а состяние “спин вниз” уничтожает. \(\sigma^+\) переводит состояние “спин вниз” в состоянии “спин вверх” (а состяние “спин вверх” уничтожает). Оба этих оператора неэрмитовы.
\end{sphinxadmonition}

\sphinxAtStartPar
Действительно, в одном состоянии (если индексы двух операторов равны) эти операторы выполняют фермионное антикоммутационное отношение
\begin{equation*}
\begin{split}
\{ \sigma^+_j, \sigma^-_j \} = 1.
\end{split}
\end{equation*}
\sphinxAtStartPar
К сожалению, на разных узлах эти операторы коммутируют, а не антикоммутируют. Чтобы это исправить, мы “прикрепляем” к каждому фермиону “нить” (string):
\begin{equation*}
\begin{split}
\sigma^+_i = \left[ \prod_{j< i} (1-2c^\dagger_j c_j) \right] c_i \\
\sigma^-_i = \left[ \prod_{j< i} (1-2c^\dagger_j c_j) \right] c^\dagger_i.
\end{split}
\end{equation*}
\sphinxAtStartPar
Oператор \(\prod_{j_i} (1-2c^\dagger_j c_j)\) равен \(\pm 1\) в зависимости от четности количества фермионов слева от узла \(i\).

\sphinxAtStartPar
Заметим, что \(c_k\) антикоммутирует с \((1-2c^\dagger_k c_k)\):
\begin{equation*}
\begin{split}
\{ c_j, (1-2c^\dagger_j c_j) \} = c_j (1-2c^\dagger_j c_j) + c_j (1-2c^\dagger_j c_j)c_j = \\
c_j -2\underbrace{c_jc^\dagger_j}_{1-c^\dagger_j c_j} c_j + c_j -2c^\dagger_j \underbrace{c_jc_j}_{0} = \\
c_j - 2c_j + 2 c^\dagger_j \underbrace{c_jc_j}_{0} + c_j = 0,
\end{split}
\end{equation*}
\sphinxAtStartPar
и, следовательно, с нитью \(\prod_{j_i} (1-2c^\dagger_j c_j) \) (интуитивно, если сначала разрушить фермион, то четность изменится).

\sphinxAtStartPar
Пусть, без ограничения общности, \(\ell>k\):
\begin{equation*}
\begin{split}
\sigma^+_k \sigma^-_\ell = \left[ \prod_{j<k} (1-2c^\dagger_j c_j) \right] c_k \left[ \prod_{m< \ell} (1-2c^\dagger_m c_m) \right] c^\dagger_\ell.
\end{split}
\end{equation*}
\sphinxAtStartPar
Если мы перенесем \(c_k\) вправо, то выражение умножится на \(-1\) дважды (один раз из\sphinxhyphen{}за изменения четности \(\ell\)\sphinxhyphen{}нити, и один раз из\sphinxhyphen{}за обмена с \(c^\dagger_\ell\)). В то же время, \(i\)\sphinxhyphen{}нить коммутирует со всем, поэтому ее мы можем перенести вправо без изменений:
\begin{equation*}
\begin{split}
\sigma^+_k \sigma^-_\ell = \left[ \prod_{j<k} (1-2c^\dagger_j c_j) \right] c_k
\left[ \prod_{m< \ell} (1-2c^\dagger_m c_m) \right] c^\dagger_\ell = \left[ \prod_{m< \ell} (1-2c^\dagger_m c_m) \right]
c^\dagger_\ell \left[ \prod_{j<k} (1-2c^\dagger_j c_j) \right] c_k = \sigma^-_\ell \sigma^+_k,
\end{split}
\end{equation*}
\sphinxAtStartPar
как и требовалось. Мы так же можем записать обратное отношение:
\begin{equation*}
\begin{split}
c_i = \prod_{j< i} \sigma^z_j \sigma^+_i \\
c^\dagger_i = \prod_{j< i} \sigma^z_j \sigma^-_i.
\end{split}
\end{equation*}
\sphinxAtStartPar
Проверка антикоммутаторов оставляется читателю в качестве упражнения.

\sphinxAtStartPar
Таким образом мы установили соответствие между фермионной и спиновой системами, но операторы в обоих случаях очень нелокальны. В частности, один фермионный оператор соответствует произведению \(\mathcal{O}(N)\) спиновых операторов (и наоборот).

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Существуют и другие способы сопоставления фермионной и спиновой систем, например, Bravyi–Kitaev transform {[}\hyperlink{cite.book/bibliography:id21}{BK02}{]}. Также существует способ сопоставить бозоны и фермионы – бозонизация {[}\hyperlink{cite.book/bibliography:id72}{VDS98}{]}.
\end{sphinxadmonition}


\subsection{Пример. Модель Хаббарда}
\label{\detokenize{book/problems2qml/ru/jordanwigner:id10}}
\sphinxAtStartPar
Одной из важных моделей в физике твёрдого тела является модель Хаббарда, описывающая взаимодействие электронов на решетке. В соответствии с принципом Паули, на каждом узле может быть максимум два электрона (один со спином вверх и один со спином вниз).

\sphinxAtStartPar
Гамильтониан модели Хаббарда состоит из двух членов. Первый, кинетический, описывает движение электрона по решетке:
\begin{equation*}
\begin{split}
H_k = -t \sum_{\langle i,j \rangle, \sigma} c^\dagger_{i, \sigma}c_{j, \sigma} + \text{h.c.},
\end{split}
\end{equation*}
\sphinxAtStartPar
где \(\langle i,j \rangle\) означает что \(i\) и \(j\) индексы соседних узлов решетки, \(\sigma\) обозначает спин электрона, а \(h.c.\) (hermtian conjugate) обозначает слагаемое, эрмитово сопряжённое написанному.

\sphinxAtStartPar
Оператор \(c^\dagger_{i, \sigma}c_{j, \sigma}\) уничтожает электрон на узле \(j\) и создает электрон с таким же спином на узле \(i\), то есть, фактически, перемещает электрон с узла \(j\) на узел \(i\).

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Эрмитово сопряжённый оператор \(\left(c^\dagger_{i, \sigma}c_{j, \sigma}\right)^\dagger = c^\dagger_{j, \sigma}c_{i, \sigma}\) перемещает электрон с узла \(i\) на узел \(j\).
\end{sphinxadmonition}

\sphinxAtStartPar
Так как этот член квадратичный, мы можем точно решить гамильтониан содержащий только его.

\sphinxAtStartPar
Второй член содержит отталкивающее взаимодействие двух электронов на одном узле, соответствующее отталкиванию двух зарядов:
\begin{equation*}
\begin{split}
H_U =U \sum_{i} n_{i, \uparrow} n_{i, \downarrow}=U \sum_{i} c^\dagger_{i, \uparrow}c_{i, \uparrow}c^\dagger_{i, \downarrow}c_{i, \downarrow}
\end{split}
\end{equation*}
\sphinxAtStartPar
Полный гамильтониан
\begin{equation*}
\begin{split}
H = -t \sum_{\langle i,j \rangle, \sigma} c^\dagger_{i, \sigma}c_{j, \sigma} + \text{h.c.}+U \sum_
{i} n_{i, \uparrow} n_{i, \downarrow}.
\end{split}
\end{equation*}
\sphinxAtStartPar
Для того чтобы описать соответствующий спиновый Гамильтониан, каждому узлу мы сопоставим два кубита (один для каждого фермиона). Для простоты, рассмотрим одномерную цепочку:
\begin{equation*}
\begin{split}
c_{i, \downarrow} = \prod_{k< 2 i} \sigma^z_k \sigma^+_{2i} \\
c_{i, \uparrow} = \prod_{k< 2 i+1} \sigma^z_k \sigma^+_{2i+1}
\end{split}
\end{equation*}
\sphinxAtStartPar
Следовательно, кинетическая часть равна
\begin{equation*}
\begin{split}
H_k = -t \sum_{\langle i,j \rangle, \sigma} c^\dagger_{i, \sigma}c_{j, \sigma} + \text{h.c.} = -t\sum_{\langle i,j \rangle} \prod_{\ell< 2 j} \sigma^z_j \sigma^-_{2j} \prod_{k< 2 i} \sigma^z_k \sigma^+_{2i} + \text{h.c.}
\end{split}
\end{equation*}
\sphinxAtStartPar
Заметим, что хоть каждый оператор создания/уничтожения сильно не локален, в их произведении большая часть произведения отменяется (так как \(\left( \sigma^z_j \right)^2=1\):
\begin{equation*}
\begin{split}
H_k = -t\sum_{j} \sigma^-_{2j} \sigma^z_{2j} \sigma^z_{2j+1}\sigma^+_{2j+2} + \sigma^+_{2j} \sigma^z_{2j} \sigma^z_{2j+1}\sigma^-_{2j+2} = \\
-t\sum_{j}(\sigma^-_{2j}\sigma^+_{2j+2}+ \sigma^+_{2j}\sigma^-_{2j+2}) \sigma^z_{2j}\sigma^z_{2j+1} = \\
-t\sum_{j}(\sigma^x_{2j}\sigma^x_{2j+2}+ \sigma^y_{2j}\sigma^y_{2j+2}) \sigma^z_{2j}\sigma^z_{2j+1}
\end{split}
\end{equation*}
\sphinxAtStartPar
Второй член дает нам (используя \( \hat{\sigma}_i^z = 1 - 2\hat{n}_i \))
\begin{equation*}
\begin{split}
H_U =\frac{U}{4} \sum_{j} (1 - \sigma^z_{2j})(1 - \sigma^z_{2j+1})
\end{split}
\end{equation*}
\sphinxAtStartPar
Таким образом, мы получили спиновый гамильтониан:
\begin{equation*}
\begin{split}
H_k -t\sum_{j}(\sigma^x_{2j}\sigma^x_{2j+2}+ \sigma^y_{2j}\sigma^y_{2j+2}) \sigma^z_{2j} \sigma^z_
{2j+1} + \frac{U}{4} \sum_{j} (1 - \sigma^z_{2j} )(1 - \sigma^z_{2j+1})
\end{split}
\end{equation*}
\sphinxstepscope


\chapter{Проблема собственных значений}
\label{\detokenize{book/problems2qml/ru/eigenvals:eigenvals}}\label{\detokenize{book/problems2qml/ru/eigenvals:id1}}\label{\detokenize{book/problems2qml/ru/eigenvals::doc}}
\sphinxAtStartPar
Автор(ы):
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/SemyonSinchenko}{Синченко Семен}

\end{itemize}


\section{Введение}
\label{\detokenize{book/problems2qml/ru/eigenvals:id2}}
\sphinxAtStartPar
Мы с вами узнали, что задачи комбинаторной оптимизации и квантовой химии могут быть сведены к решению проблемы поиска минимального собственного значения большого эрмитова оператора – гамильтониана. Для оптимизационных задач это {\hyperref[\detokenize{book/problems2qml/ru/np2ising::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{осуществляется}}}} при помощи сведения к \sphinxstyleemphasis{QUBO}\sphinxhyphen{}матрице и гамильтониану типа Изинга. А для электронных орбиталей из квантовой химии можно {\hyperref[\detokenize{book/problems2qml/ru/jordanwigner::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{применить}}}} преобразование Жордана\sphinxhyphen{}Вигнера и также перейти к спиновому гамильтониану.

\sphinxAtStartPar
Теперь перед нами встает вопрос, а как же искать основное состояние этого гамильтониана? В этой лекции рассмотрим \sphinxstylestrong{классические} методы решения этой проблемы, то есть без квантовых компьютеров. Рассмотрение этих методов и их недостатков покажет то, зачем тут так нужен будет квантовый компьютер.


\section{О проблеме (повторение)}
\label{\detokenize{book/problems2qml/ru/eigenvals:id3}}
\sphinxAtStartPar
Эта тема обсуждалась во вводных лекциях по линейной алгебре, в \sphinxhref{../../linalg/ru/matrices.html\#id9}{части про собственные вектора и собственные значения}.

\sphinxAtStartPar
Итак, пусть у имеется диагонализируемая матрица \(A\) размерности \(n \times n\), она же является линейным оператором \(\hat{A}\). Из линейной алгебры знаем, что у этой матрицы есть \(n\) таких чисел \(e_i\) и векторов \(\Psi_i\), что для них выполняется условие:
\begin{equation*}
\begin{split}
A \Psi_i = e_i \Psi_i
\end{split}
\end{equation*}
\sphinxAtStartPar
или в нотации Дирака, которая используется в области квантовых вычислений:
\begin{equation*}
\begin{split}
\hat{A} \ket{\Psi_i} = e_i\ket{\Psi_i}
\end{split}
\end{equation*}
\sphinxAtStartPar
Таким образом, собственные вектора – это такие вектора, которые при применении оператора не меняют свое направление. Например, в примере ниже собственный вектор – это ось симметрии оператора:

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=450\sphinxpxdimen]{{Mona_Lisa}.png}
\caption{Синий вектор, в отличии от красного, при применении оператора не меняет направление так как является его собственным вектором.}\label{\detokenize{book/problems2qml/ru/eigenvals:mona-lisa-eigen}}\end{figure}


\section{Итеративные алгоритмы}
\label{\detokenize{book/problems2qml/ru/eigenvals:id4}}
\sphinxAtStartPar
В целом, задача нахождения собственных значений является очень трудной с вычислительной точки зрения, особенно для больших матриц. Для матриц размера более, чем \(3 \times 3\) в общем случае не существует алгоритма нахождения собственных значений и собственных векторов. Однако существует несколько итеративных алгоритмов. Рассмотрим лишь два из них, причем без особых деталей, так как эти алгоритмы, а также доказательство их сходимости являются достаточно сложными.


\subsection{Степенной метод}
\label{\detokenize{book/problems2qml/ru/eigenvals:id5}}
\sphinxAtStartPar
Один из самых простых для понимания алгоритмов, который, тем не менее находит интересные применения. Суть его в том, что берем некоторый случайный вектор \(\ket{\Psi}\) и начинаем последовательно действовать на него оператором \(\hat{A}\) (другими словами умножать, на нашу матрицу), при этом нормируя:
\begin{equation*}
\begin{split}
\ket{\Psi_{i+1}} = \frac{\hat{A}\ket{\Psi_i}}{||\hat{A}||}
\end{split}
\end{equation*}
\sphinxAtStartPar
И так повторяем до тех пор, пока изменение вектора не будет меньше, чем некоторое заданное маленькое значение \(\epsilon\). Когда достигли этого условия, это значит что нашли первый собственный вектор, который соответствует наибольшему собственному значению. В частном случае интересных нам эрмитовых операторов, можно так же последовательно находить все собственные вектора и собственные значения.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
На самом деле, сеть интернета является графом – множеством связанных между собой вершин. А любой граф можно представить в виде большой\sphinxhyphen{}большой, но очень разреженной матрицы, каждый элемент которой это 1 если между соответствующими вершинами есть ребро и 0, если нет. Например, элемент \(L_{ij}\) будет 1, если между вершинами \(i\) и \(j\) есть ребро.иВ 1998\sphinxhyphen{}м году, Ларри Пейдж и Сергей Брин нашли очень эффективный способ подсчета первого собственного вектора этой матрицы, используя именно модификацию степенного метода. Этот алгоритм получил название \sphinxcode{\sphinxupquote{PageRank}}, причем \sphinxstyleemphasis{Page} это фамилия автора, а не отсылка к веб\sphinxhyphen{}страницам, как можно было бы подумать. Этот алгоритм лег в основу поисковика \sphinxstyleemphasis{Google}, который в дальнейшем вырос в транснациональную корпорацию!
\end{sphinxadmonition}


\subsection{Итерация Арнольди}
\label{\detokenize{book/problems2qml/ru/eigenvals:id6}}
\sphinxAtStartPar
Это гораздо более сложный метод, который, однако, является одним из самых эффективных применительно к разреженным матрицам {[}\hyperlink{cite.book/bibliography:id18}{Arn51}{]}. Объяснить его легко, к сожалению, не получится, так как алгоритм требует понимания Крыловских подпространств и других концептов из области линейной алгебры разреженных систем. Но пока достаточно лишь того, что этот алгоритм имеет очень эффективную реализацию – \sphinxhref{https://www.caam.rice.edu/software/ARPACK/}{ARPACK}, написанную в середине 90\sphinxhyphen{}х годов на языке \sphinxcode{\sphinxupquote{FORTRAN77}}. Именно эта библиотека используется “под капотом” у \sphinxcode{\sphinxupquote{SciPy}}, а также во многих других научных пакетах. Давайте посмотрим, как она работает.

\sphinxAtStartPar
Сгенерируем большую разреженную матрицу.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{from} \PYG{n+nn}{scipy} \PYG{k+kn}{import} \PYG{n}{sparse}

\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{seed}\PYG{p}{(}\PYG{l+m+mi}{42}\PYG{p}{)}
\PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{random}\PYG{p}{(}\PYG{l+m+mi}{10000}\PYG{p}{)}
\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{seed}\PYG{p}{(}\PYG{l+m+mi}{42}\PYG{p}{)}
\PYG{n}{y} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{random}\PYG{p}{(}\PYG{l+m+mi}{10000}\PYG{p}{)}
\PYG{n}{px} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{where}\PYG{p}{(}\PYG{n}{x} \PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{0.2}\PYG{p}{)}
\PYG{n}{py} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{where}\PYG{p}{(}\PYG{n}{y} \PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{0.2}\PYG{p}{)}
\PYG{n}{num\PYGZus{}elements} \PYG{o}{=} \PYG{n+nb}{max}\PYG{p}{(}\PYG{p}{[}\PYG{n}{px}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{py}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{spmat} \PYG{o}{=} \PYG{n}{sparse}\PYG{o}{.}\PYG{n}{coo\PYGZus{}matrix}\PYG{p}{(}
    \PYG{p}{(}
        \PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{ones}\PYG{p}{(}\PYG{n}{num\PYGZus{}elements}\PYG{p}{)}\PYG{p}{,}
        \PYG{p}{(}\PYG{n}{px}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{p}{:}\PYG{n}{num\PYGZus{}elements}\PYG{p}{]}\PYG{p}{,} \PYG{n}{py}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{p}{:}\PYG{n}{num\PYGZus{}elements}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{)}
\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{spmat}\PYG{o}{.}\PYG{n+nf+fm}{\PYGZus{}\PYGZus{}repr\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}10000x10000 sparse matrix of type \PYGZsq{}\PYGZlt{}class \PYGZsq{}numpy.float64\PYGZsq{}\PYGZgt{}\PYGZsq{}
	with 7957 stored elements in COOrdinate format\PYGZgt{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Матрица размера \(10000 \times 10000\) это большая матрица и работать с ней в “плотном” (dense) представлении было бы очень трудно. Но \sphinxcode{\sphinxupquote{ARPACK}} позволяет найти минимальное собственное значение за доли секунд, используя разреженность матрицы:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{scipy}\PYG{n+nn}{.}\PYG{n+nn}{sparse} \PYG{k+kn}{import} \PYG{n}{linalg} \PYG{k}{as} \PYG{n}{sl}

\PYG{n}{max\PYGZus{}eigval} \PYG{o}{=} \PYG{n}{sl}\PYG{o}{.}\PYG{n}{eigs}\PYG{p}{(}\PYG{n}{spmat}\PYG{p}{,} \PYG{n}{k}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{which}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{LR}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{return\PYGZus{}eigenvectors}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{min\PYGZus{}eigval} \PYG{o}{=} \PYG{n}{sl}\PYG{o}{.}\PYG{n}{eigs}\PYG{p}{(}\PYG{n}{spmat}\PYG{p}{,} \PYG{n}{k}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{which}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{SR}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{return\PYGZus{}eigenvectors}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Min E: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{min\PYGZus{}eigval}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{Max E: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{max\PYGZus{}eigval}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Min E: (\PYGZhy{}2.7755575615628914e\PYGZhy{}17+0j)
Max E: (1.0000000000000004+0j)
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Для тех кто забыл, какие параметры принимает функция \sphinxcode{\sphinxupquote{eigs}} из \sphinxcode{\sphinxupquote{scipy.linalg.spare}} напомним, что первый параметр это разреженная матрица, \sphinxcode{\sphinxupquote{k}} – сколько именно собственных значений хотим получить, \sphinxcode{\sphinxupquote{which}} указывает на собственные значения:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SM}} – \sphinxstyleemphasis{smallest magnitude} – наименьшие по модулю числа

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{LM}} – \sphinxstyleemphasis{largest magnitude} – наибольшие по модулю числа

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SR}} – \sphinxstyleemphasis{smallers real} – числа с наименьшей действительной частью

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{LR}} – \sphinxstyleemphasis{largest real} – числа с наибольшей действительной частью

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SI}} – \sphinxstyleemphasis{smallest image} – числа с наименьшей мнимой частью

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{LI}} – \sphinxstyleemphasis{largest image} – числа с наибольшей мнимой частью

\end{itemize}

\sphinxAtStartPar
Наконец, параметр \sphinxcode{\sphinxupquote{return\_eigenvectors}} – хотим ли получить только собственные значения, или еще и собственные вектора.

\sphinxAtStartPar
Более подробна работа с \sphinxcode{\sphinxupquote{scipy.sparse}}, а также с \sphinxcode{\sphinxupquote{scipy.sparse.linalg}} разбирается в {[}вводном блоке по линейной алгебре{]}(пока пусто).

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Не у всех матриц все собственные значения являются действительными, поэтому \sphinxcode{\sphinxupquote{ARPACK}} по умолчанию считает комплексные значения, хотя в этом конкретном случае видим, что мнимая часть равна нулю.
\end{sphinxadmonition}


\subsection{Алгоритм Ланкзоша}
\label{\detokenize{book/problems2qml/ru/eigenvals:id8}}
\sphinxAtStartPar
Итерация Ланкзоша (\sphinxstyleemphasis{англ.} Lanzos) {[}\hyperlink{cite.book/bibliography:id46}{Lan50}{]} – это модификация итерации Арнольди, которая работает с эрмитовыми матрицами и находит максимально широкое применение в том числе для квантовых гамильтонианов. Этот алгоритм по умолчанию включен в большинство математических пакетов, включая \sphinxcode{\sphinxupquote{ARPACK}} и, соответственно, \sphinxcode{\sphinxupquote{SciPy}}:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{max\PYGZus{}eigval} \PYG{o}{=} \PYG{n}{sl}\PYG{o}{.}\PYG{n}{eigsh}\PYG{p}{(}\PYG{n}{spmat}\PYG{p}{,} \PYG{n}{k}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{which}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{LM}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{return\PYGZus{}eigenvectors}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{min\PYGZus{}eigval} \PYG{o}{=} \PYG{n}{sl}\PYG{o}{.}\PYG{n}{eigsh}\PYG{p}{(}\PYG{n}{spmat}\PYG{p}{,} \PYG{n}{k}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{which}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{SM}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{return\PYGZus{}eigenvectors}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Min E: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{min\PYGZus{}eigval}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{Max E: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{max\PYGZus{}eigval}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Min E: \PYGZhy{}1.074893821039778e\PYGZhy{}25
Max E: 1.0000000000000004
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
У этой процедуры из \sphinxcode{\sphinxupquote{ARPACK}} немного другие варианты параметра \sphinxcode{\sphinxupquote{which}}, так как мы помним, что у эрмитовых матриц собственные значения вещественны:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{LM}} – \sphinxstyleemphasis{largest magnitude} – наибольшие по модулю

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SM}} – \sphinxstyleemphasis{smallest magnitude} – наименьшие по модулю

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{LA}} – \sphinxstyleemphasis{largest algebraic} – алгебраически наибольшие, т.е. с учетом знака

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SA}} – \sphinxstyleemphasis{smallest algebraic} – алгебраически наименьшие, т.е. с учетом знака

\end{itemize}


\section{Вариационные алгоритмы}
\label{\detokenize{book/problems2qml/ru/eigenvals:id10}}
\sphinxAtStartPar
В этом разделе поговорим о существующих алгоритмах решения задачи об основном состоянии уже в контексте квантовой механики. Хотя, как помним, задачи оптимизации и квантовой физики \sphinxhref{../../problems2qml/ru/np2ising.html\#id4}{тесно связаны}. В каком\sphinxhyphen{}то смысле, вариационные алгоритмы, а в особенности, квантовый Монте\sphinxhyphen{}Карло и различные его модификации в чем\sphinxhyphen{}то сильно похожи на классический \sphinxhref{../../problems/ru/copt.html\#id13}{алгоритм имитации отжига}.


\subsection{Вариационный Монте\sphinxhyphen{}Карло}
\label{\detokenize{book/problems2qml/ru/eigenvals:id11}}
\sphinxAtStartPar
\sphinxstylestrong{V}ariational \sphinxstylestrong{M}onte\sphinxhyphen{}\sphinxstylestrong{C}arlo, или просто \sphinxstylestrong{VMC} это очень простой и в тоже время эффективный алгоритм нахождения основного состояния квантомеханической системы.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Замечание – в классическом \sphinxstylestrong{VMC} обычно работают при нулевой температуре. Хотя в общем случае, температура оказывает значительное влияние на то, в каком состоянии находится физическая система.
\end{sphinxadmonition}

\sphinxAtStartPar
Давайте еще раз запишем ожидаемое значение энергии гамильтониана в состоянии \(\ket{\Psi}\):
\begin{equation*}
\begin{split}
E = \frac{\braket{\Psi | \hat{H} | \Psi}}{\braket{\Psi | \Psi}}
\end{split}
\end{equation*}
\sphinxAtStartPar
Если ввести вектор \(X\), который описывает конфигурацию системы (например, ориентации спинов), то выражение для энергии можно переписать в интегральной форме:
\begin{equation*}
\begin{split}
E = \frac{\int |\Psi(X)|^2 \frac{\hat{H}\Psi(X)}{\Psi(X)} dX}{\int |\Psi(X)|^2 dX}
\end{split}
\end{equation*}
\sphinxAtStartPar
В данном случае, выражение
\begin{equation*}
\begin{split}
\frac{|\Psi(X)|^2}{\int |\Psi(X)|^2 dX}
\end{split}
\end{equation*}
\sphinxAtStartPar
дает распределение вероятностей, а значит можно из него семплировать, используя методы Монте\sphinxhyphen{}Карло. Это очень похоже на то, как ранее семплировали из распределения Больцмана в \sphinxhref{../../problems/ru/copt.html\#id13}{классическом методе Монте\sphinxhyphen{}Карло}. Вопрос лишь в том, как представить волновую функцию \(\ket{\Psi}\)? В этом помогут так называемые \sphinxstyleemphasis{trial wave functions} – параметризированные функции от \(X\). В этом случае меняем или \sphinxstyleemphasis{варьируем} параметры \sphinxstyleemphasis{trial wave function} в процессе:
\begin{itemize}
\item {} 
\sphinxAtStartPar
семплируем из \(\frac{|\Psi(X)|^2}{\int |\Psi(X)|^2 dX}\) конфигурации;

\item {} 
\sphinxAtStartPar
обновляем параметризацию \sphinxstyleemphasis{trial function} так, чтобы минимизировать энергию.

\end{itemize}

\sphinxAtStartPar
Повторяем до сходимости. Ну а дальше посмотрим на некоторые примеры \sphinxstyleemphasis{trial wave functions}.


\subsubsection{Jastrow Function}
\label{\detokenize{book/problems2qml/ru/eigenvals:jastrow-function}}
\sphinxAtStartPar
Когда есть задача из \(N\) квантовых частиц, каждая из которых описывается координатой или радиус вектором, то можно построить \sphinxstyleemphasis{trial wave function} в виде суммы попарных функций двухчастичных взаимодействий:
\begin{equation*}
\begin{split}
\Psi(X) = e^{-\sum_{i,j} u(r_i, r_j)},
\end{split}
\end{equation*}
\sphinxAtStartPar
где \(r_i, r_j\) – это радиус\sphinxhyphen{}векторы частиц, а \(u(r_i, r_j)\) – симметричная функция, описывающая двухчастичное взаимодействия. Такая функция называется \sphinxstylestrong{Jastrow function} {[}\hyperlink{cite.book/bibliography:id44}{Jas55}{]}. В этом случае, в процессе работы \sphinxstylestrong{VMC} будем просто варьировать радиус\sphinxhyphen{}векторы частиц также, как варьировали вершины графа в \sphinxhref{../../problems/ru/copt.html\#id13}{обычном отжиге}, когда решали задачу комбинаторной оптимизации. Только теперь есть еще и параметризация обменных взаимодействий, которую “варьируем”.


\subsubsection{Hartree\sphinxhyphen{}Fock (SCF)}
\label{\detokenize{book/problems2qml/ru/eigenvals:hartree-fock-scf}}
\sphinxAtStartPar
Для задач квантовой химии, когда работаем с фермионами, существует вид \sphinxstyleemphasis{trial wave function} на основе Слэтеровского детерминанта, о котором  писали в \sphinxhref{../../problems/ru/quantchemadvancedscf.html\#id13}{продвинутой лекции по квантовой химии}:
\begin{equation*}
\begin{split}
\Psi(R) = D^{\uparrow}D^{\downarrow},
\end{split}
\end{equation*}
\sphinxAtStartPar
где \(D\) это матрица из одноэлектронных орбиталей:
\begin{equation*}
\begin{split}
D = \begin{bmatrix}
  \psi_1(r_1) & \psi_1(r_2) & ... & \psi_1(r_{N / 2}) \\
  ... & ... & ... & ... \\
  \psi_{N / 2}(r_1) & \psi_{N / 2}(r_2) & ... & \psi_{N / 2}(r_{N / 2}) \\
\end{bmatrix}
\end{split}
\end{equation*}

\subsubsection{Jastrow Function для спинов}
\label{\detokenize{book/problems2qml/ru/eigenvals:id13}}
\sphinxAtStartPar
Дальше нас будут интересовать как раз модели Изинга и спины, а не частицы в пространстве или орбитали из вторичного квантования. Для спинов можем записать Jastrow function следующим образом:
\begin{equation*}
\begin{split}
\Psi(s) = e^{\sum_{i,j}s_i W_{i,j} s_j},
\end{split}
\end{equation*}
\sphinxAtStartPar
где матрица \(W\) будет играть роль параметризации и отражать парные спиновые корреляции. Давайте посмотрим это на практике при помощи библиотеки \sphinxcode{\sphinxupquote{NetKet}} {[}\hyperlink{cite.book/bibliography:id24}{CCH+19}{]}.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{netket} \PYG{k}{as} \PYG{n+nn}{nk}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Моделировать будем простую {\hyperref[\detokenize{book/problems/ru/ising::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{модель Изинга}}}} для цепочки из 10 спинов (чтобы быстро считалось):
\begin{equation*}
\begin{split}
\hat{H} = -h \sum_i \sigma^x_i + J \sum_{i,j}\sigma^z_i \sigma^z_j
\end{split}
\end{equation*}
\sphinxAtStartPar
Параметры возьмем такими:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\(J=0.5\)

\item {} 
\sphinxAtStartPar
\(h=1.321\)

\end{itemize}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{g} \PYG{o}{=} \PYG{n}{nk}\PYG{o}{.}\PYG{n}{graph}\PYG{o}{.}\PYG{n}{Hypercube}\PYG{p}{(}\PYG{n}{length}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{n\PYGZus{}dim}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{pbc}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\PYG{n}{hi} \PYG{o}{=} \PYG{n}{nk}\PYG{o}{.}\PYG{n}{hilbert}\PYG{o}{.}\PYG{n}{Spin}\PYG{p}{(}\PYG{n}{s}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{n}{N}\PYG{o}{=}\PYG{n}{g}\PYG{o}{.}\PYG{n}{n\PYGZus{}nodes}\PYG{p}{)}
\PYG{n}{op} \PYG{o}{=} \PYG{n}{nk}\PYG{o}{.}\PYG{n}{operator}\PYG{o}{.}\PYG{n}{Ising}\PYG{p}{(}\PYG{n}{h}\PYG{o}{=}\PYG{l+m+mf}{1.321}\PYG{p}{,} \PYG{n}{hilbert}\PYG{o}{=}\PYG{n}{hi}\PYG{p}{,} \PYG{n}{J}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{n}{graph}\PYG{o}{=}\PYG{n}{g}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Поскольку модель относительно небольшая по числу частиц, то сразу можем получить точное решение методом Ланкзоша.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{exact} \PYG{o}{=} \PYG{n}{nk}\PYG{o}{.}\PYG{n}{exact}\PYG{o}{.}\PYG{n}{lanczos\PYGZus{}ed}\PYG{p}{(}\PYG{n}{op}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Создадим модель на основе Jastrow и \sphinxstylestrong{VMC}:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sampler} \PYG{o}{=} \PYG{n}{nk}\PYG{o}{.}\PYG{n}{sampler}\PYG{o}{.}\PYG{n}{MetropolisLocal}\PYG{p}{(}\PYG{n}{hi}\PYG{p}{)}
\PYG{n}{model} \PYG{o}{=} \PYG{n}{nk}\PYG{o}{.}\PYG{n}{models}\PYG{o}{.}\PYG{n}{Jastrow}\PYG{p}{(}\PYG{n}{dtype}\PYG{o}{=}\PYG{n+nb}{complex}\PYG{p}{)}
\PYG{n}{optimizer} \PYG{o}{=} \PYG{n}{nk}\PYG{o}{.}\PYG{n}{optimizer}\PYG{o}{.}\PYG{n}{Sgd}\PYG{p}{(}\PYG{n}{learning\PYGZus{}rate}\PYG{o}{=}\PYG{l+m+mf}{0.05}\PYG{p}{)}
\PYG{n}{sr} \PYG{o}{=} \PYG{n}{nk}\PYG{o}{.}\PYG{n}{optimizer}\PYG{o}{.}\PYG{n}{SR}\PYG{p}{(}\PYG{n}{diag\PYGZus{}shift}\PYG{o}{=}\PYG{l+m+mf}{0.01}\PYG{p}{)}
\PYG{n}{vmc} \PYG{o}{=} \PYG{n}{nk}\PYG{o}{.}\PYG{n}{driver}\PYG{o}{.}\PYG{n}{VMC}\PYG{p}{(}\PYG{n}{op}\PYG{p}{,} \PYG{n}{optimizer}\PYG{p}{,} \PYG{n}{sampler}\PYG{p}{,} \PYG{n}{model}\PYG{p}{,} \PYG{n}{n\PYGZus{}samples}\PYG{o}{=}\PYG{l+m+mi}{1008}\PYG{p}{,} \PYG{n}{preconditioner}\PYG{o}{=}\PYG{n}{sr}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
/home/runner/work/qmlcourse/qmlcourse/.venv/lib/python3.8/site\PYGZhy{}packages/netket/utils/deprecation.py:126: FutureWarning: 

**DEPRECATION\PYGZus{}WARNING:**
    The `dtype` argument to neural\PYGZhy{}network layers and models is deprecated
    throughout NetKet to maintain consistency with new releases of flax.
    Please use `param\PYGZus{}dtype` instead.

    This warning will become an error in a future version of NetKet.


  warn\PYGZus{}deprecation(\PYGZus{}dep\PYGZus{}msg)
WARNING:absl:No GPU/TPU found, falling back to CPU. (Set TF\PYGZus{}CPP\PYGZus{}MIN\PYGZus{}LOG\PYGZus{}LEVEL=0 and rerun for more info.)
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Изучение документации библиотеки \sphinxcode{\sphinxupquote{NetKet}} оставляем вам самим, так как объяснение абстракций графа и гильбертова пространства, а также использование метода \sphinxcode{\sphinxupquote{stochastic reconfiguration}} для вычисления градиентов выходит за рамки лекции. Документаци представлена на \sphinxhref{https://www.netket.org}{сайте NetKet}.
\end{sphinxadmonition}

\sphinxAtStartPar
Запустим оптимизацию:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{logger} \PYG{o}{=} \PYG{n}{nk}\PYG{o}{.}\PYG{n}{logging}\PYG{o}{.}\PYG{n}{RuntimeLog}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{vmc}\PYG{o}{.}\PYG{n}{run}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{n}{out}\PYG{o}{=}\PYG{n}{logger}\PYG{p}{,} \PYG{n}{show\PYGZus{}progress}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
(RuntimeLog():
  keys = [\PYGZsq{}Energy\PYGZsq{}],)
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Посмотрим на результат:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n+nb}{list}\PYG{p}{(}\PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{real}\PYG{p}{(}\PYG{n}{logger}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Energy}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Mean}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{.\PYGZhy{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{VMC mean energy}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Epoch}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Energy}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{hlines}\PYG{p}{(}\PYG{n}{exact}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{50}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Exact solution}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{red}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{eigenvals_17_0}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsubsection{Neural Network Quantum States}
\label{\detokenize{book/problems2qml/ru/eigenvals:neural-network-quantum-states}}
\sphinxAtStartPar
Еще более интересный подход к выбору \sphinxstyleemphasis{trial wave function} – это использование в качестве \(\Psi(X)\) нейронной сети {[}\hyperlink{cite.book/bibliography:id23}{CT17}{]}. Уже немного \sphinxhref{../../qmlkinds/ru/qmlkinds.html\#nqs}{касались этой темы}, когда речь шла о видах квантового машинного обучения. Хороший вариант, это использовать, например, полносвязную сеть – ограниченную машину Больцмана:

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=450\sphinxpxdimen]{{NQS}.png}
\caption{Нейронная сеть в качестве \sphinxstyleemphasis{trial wave function} из работы {[}\hyperlink{cite.book/bibliography:id23}{CT17}{]}.}\label{\detokenize{book/problems2qml/ru/eigenvals:nqs2}}\end{figure}

\sphinxAtStartPar
Это также легко может быть реализовано с использованием библиотеки \sphinxcode{\sphinxupquote{NetKet}}:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{model} \PYG{o}{=} \PYG{n}{nk}\PYG{o}{.}\PYG{n}{models}\PYG{o}{.}\PYG{n}{RBM}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{optimizer} \PYG{o}{=} \PYG{n}{nk}\PYG{o}{.}\PYG{n}{optimizer}\PYG{o}{.}\PYG{n}{Sgd}\PYG{p}{(}\PYG{n}{learning\PYGZus{}rate}\PYG{o}{=}\PYG{l+m+mf}{0.05}\PYG{p}{)}
\PYG{n}{sr} \PYG{o}{=} \PYG{n}{nk}\PYG{o}{.}\PYG{n}{optimizer}\PYG{o}{.}\PYG{n}{SR}\PYG{p}{(}\PYG{n}{diag\PYGZus{}shift}\PYG{o}{=}\PYG{l+m+mf}{0.01}\PYG{p}{)}
\PYG{n}{vmc} \PYG{o}{=} \PYG{n}{nk}\PYG{o}{.}\PYG{n}{driver}\PYG{o}{.}\PYG{n}{VMC}\PYG{p}{(}\PYG{n}{op}\PYG{p}{,} \PYG{n}{optimizer}\PYG{p}{,} \PYG{n}{sampler}\PYG{p}{,} \PYG{n}{model}\PYG{p}{,} \PYG{n}{n\PYGZus{}samples}\PYG{o}{=}\PYG{l+m+mi}{1000}\PYG{p}{,} \PYG{n}{preconditioner}\PYG{o}{=}\PYG{n}{sr}\PYG{p}{)}

\PYG{n}{logger} \PYG{o}{=} \PYG{n}{nk}\PYG{o}{.}\PYG{n}{logging}\PYG{o}{.}\PYG{n}{RuntimeLog}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{vmc}\PYG{o}{.}\PYG{n}{run}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{n}{out}\PYG{o}{=}\PYG{n}{logger}\PYG{p}{,} \PYG{n}{show\PYGZus{}progress}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n+nb}{list}\PYG{p}{(}\PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{real}\PYG{p}{(}\PYG{n}{logger}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Energy}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Mean}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{.\PYGZhy{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{VMC mean energy}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Epoch}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Energy}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{hlines}\PYG{p}{(}\PYG{n}{exact}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{50}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Exact solution}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{red}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
/home/runner/work/qmlcourse/qmlcourse/.venv/lib/python3.8/site\PYGZhy{}packages/netket/vqs/mc/mc\PYGZus{}state/state.py:59: UserWarning: n\PYGZus{}samples=1000 (1000 per MPI rank) does not divide n\PYGZus{}chains=16, increased to 1008 (1008 per MPI rank)
  warnings.warn(
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{eigenvals_19_1}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Преимущества использования нейронной сети трудно показать на таком небольшом примере с моделью Изинга и 10\sphinxhyphen{}ю спинами, но они полностью раскрываются, если нужно анализировать более сложные модели.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Это интересно, но при помощи библиотеки \sphinxcode{\sphinxupquote{NetKet}} можно по сути решать проблемы комбинаторной оптимизации {[}\hyperlink{cite.book/bibliography:id63}{SB19}{]} с помощью методов \sphinxstyleemphasis{deep learning}.
\end{sphinxadmonition}


\subsection{Проблемы с VMC}
\label{\detokenize{book/problems2qml/ru/eigenvals:vmc}}
\sphinxAtStartPar
К сожалению, у метода \sphinxstylestrong{VMC} есть свои проблемы. Это относительно плохая масштабируемость – при росте размерности проблемы для того, чтобы подобрать реально хорошую аппроксимацию потребуется все больше итераций и семплов на каждой из них. Также у \sphinxstylestrong{VMC} есть ряд фундаментальных проблем, например, так называемая \sphinxstyleemphasis{sign problem} {[}\hyperlink{cite.book/bibliography:id50}{LJGS+90}{]}.


\section{Заключение}
\label{\detokenize{book/problems2qml/ru/eigenvals:id19}}
\sphinxAtStartPar
В этой лекции рассмотрены известные подходы к решению задачи о минимальном собственном значении на классическом компьютере. Как увидели, все эти методы не могут быть масштабированы на реально большие операторы. Так что для решения этих проблем действительно нужен квантовый компьютер.

\sphinxstepscope


\part{VQE}

\sphinxstepscope


\chapter{О блоке “VQE”}
\label{\detokenize{book/vqe/ru/vqe_intro:vqe}}\label{\detokenize{book/vqe/ru/vqe_intro:vqe-intro}}\label{\detokenize{book/vqe/ru/vqe_intro::doc}}
\sphinxAtStartPar
Этот блок будет полностью посвящен вариационному алгоритму нахождения собственных значений операторов – \sphinxcode{\sphinxupquote{Variational Quantum Eigensolver}}.

\sphinxAtStartPar
Базовая лекция расскажет верхнеуровневую интуицию алгоритма и в ней будет пример решения простой задачи Изинга. В продвинутой лекции будет практика решения на квантовом компьютере реальной комбинаторной задачи от начала и до конца.

\sphinxstepscope


\chapter{Variational Quantum Eigensolver}
\label{\detokenize{book/vqe/ru/vqe:variational-quantum-eigensolver}}\label{\detokenize{book/vqe/ru/vqe:vqe}}\label{\detokenize{book/vqe/ru/vqe::doc}}
\sphinxAtStartPar
Автор(ы):
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/SemyonSinchenko}{Синченко Семен}

\end{itemize}

\sphinxAtStartPar
В этой лекции рассмотрим такой классный и очень перспективный алгоритм как \sphinxcode{\sphinxupquote{Variational Quantum Eigensolver}}. Это алгоритм создан для аппроксимационного решения задачи о собственных значениях матриц. Но, как помним, к этой задаче {\hyperref[\detokenize{book/problems2qml/ru/np2ising::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{можно свести}}}} большое число реально интересных задач, например, \sphinxstyleemphasis{NP}\sphinxhyphen{}трудные {\hyperref[\detokenize{book/problems/ru/copt::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{задачи комбинаторной оптимизации}}}}. Также к решению проблемы о собственных значениях спиновых систем {\hyperref[\detokenize{book/problems2qml/ru/jordanwigner::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{сводятся}}}} задачи квантовой химии, которые {\hyperref[\detokenize{book/problems/ru/quantchembasic::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{обсуждались}}}} в отдельной лекции.

\sphinxAtStartPar
Задача о собственных значениях, на решение которой направлен рассматриваемый алгоритм {\hyperref[\detokenize{book/problems2qml/ru/eigenvals::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{обсуждалась}}}} ранее, поэтому не будем на ней останавливаться подробно.


\section{VQE}
\label{\detokenize{book/vqe/ru/vqe:id1}}
\sphinxAtStartPar
Теперь давайте посмотрим, как эта задача связана с квантовым компьютером, а также как ее можно свести к градиентному спуску в пространстве параметров \sphinxcode{\sphinxupquote{VQE}}, содержащей лишь гейты вращения. Напомню, что наличие лишь гейтов вращения {\hyperref[\detokenize{book/grads/ru/gradients::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{позволяет эффективно считать градиенты}}}}.


\subsection{Собственные значения как результат измерения}
\label{\detokenize{book/vqe/ru/vqe:id2}}
\sphinxAtStartPar
Итак, есть эрмитова матрица, для которой хотим найти минимальное собственное значение. То есть сделать примерно то, что делает \sphinxcode{\sphinxupquote{ARPACK}} или \sphinxstylestrong{VMC}, но на квантовом компьютере.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Если матрица \(A\) не эрмитова, то всегда можно ее дополнить до эрмитовой. Поэтому далее, без потери общности, будем считать эту матрицу именно эрмитовой. Меж тем не будем рассматривать как именно это делать, пока достаточно знать что это возможно.
\end{sphinxadmonition}

\sphinxAtStartPar
Из первых лекций помним, что любое измерение квантового оператора в каком\sphinxhyphen{}то состоянии \sphinxhref{../../qc/ru/qubit.html\#id31}{есть проекция этого состояния на пространство его собственных векторов}, а результатом измерения \sphinxhref{../../qc/ru/qubit.html\#id25}{является одно из его собственных значений}. При этом распределение вероятностей получения этих собственных значений определяется волновой функцией \(\ket{\Psi}\) измеряемого состояния. А значит, то, какое собственное значение получим, будет определяться тем, какое состояние приготовим! Более того, минимальное значение энергии, или минимальное собственное значение в терминах этой задачи является наиболее вероятным результатом измерения основного состояния. Напомним, что результат измерения оператора \(\hat{A}\) в состоянии \(\ket{\Psi}\) записывается так:
\begin{equation*}
\begin{split}
e = \bra{\Psi}\hat{A}\ket{\Psi}
\end{split}
\end{equation*}
\sphinxAtStartPar
А, как помним из {\hyperref[\detokenize{book/vqc/ru/vqc::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{лекции по параметризованным квантовым схемам}}}}, приготовленное состояние задается собственно самой схемой (еще говорят \sphinxstyleemphasis{ansatz}), а также набором ее классических параметров, которые варьируются в процессе обучения.

\sphinxAtStartPar
Так приходим к алгоритму \sphinxcode{\sphinxupquote{VQE}} – \sphinxstylestrong{V}ariational \sphinxstylestrong{Q}uantum \sphinxstylestrong{E}igensolver:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
выбираем \sphinxstyleemphasis{ansatz} – параметризованный оператор \(\hat{B}(q)\), который представляет из себя последовательность гейтов вращения; вектор \(q\) – это вектор из действительных чисел – параметров;

\item {} 
\sphinxAtStartPar
генерируем случайные начальные параметры \(q_0\);

\item {} 
\sphinxAtStartPar
цикл обучения, повторяем \(n\) раз:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumii}{enumiii}{}{.}%
\item {} 
\sphinxAtStartPar
готовим состояние \(\ket{\Psi} = \hat{B}(q_n)\ket{0}\);

\item {} 
\sphinxAtStartPar
измеряем \(e = \bra{\Psi}\hat{A}\ket{\Psi}\);

\item {} 
\sphinxAtStartPar
вычисляем градиент \(g = \frac{\partial{e}}{\partial{q}}\);

\item {} 
\sphinxAtStartPar
обновляем параметры \(q_{n+1} = q_n - \alpha g\);

\end{enumerate}

\item {} 
\sphinxAtStartPar
результатом обучения являются:
\begin{itemize}
\item {} 
\sphinxAtStartPar
набор параметров \(q\) такой, что \(\hat{B}(q)\ket{0}\) является вектором, близким к первому собственному вектору \(\hat{A}\);

\item {} 
\sphinxAtStartPar
результат измерения \(e\), близкий к первому собственному значению \(\hat{A}\).

\end{itemize}

\end{enumerate}


\section{Интуиция алгоритма}
\label{\detokenize{book/vqe/ru/vqe:id3}}
\sphinxAtStartPar
Если вспомнить подход \sphinxhref{../../problems2qml/ru/eigenvals.html\#id11}{\sphinxstylestrong{VMC}} для решения задачи о собственных значениях, то там использовался \sphinxstyleemphasis{trial wave function} – некоторое, параметризированное кодирование состояния в его вероятность. С некоторой долей условности можно рассматривать \sphinxstyleemphasis{ansatz} в \sphinxstylestrong{VQE} как квантовый аналог классических \sphinxstyleemphasis{trial wave functions}. Только вместо семплирования при помощи методов Монте\sphinxhyphen{}Карло, условно говоря, сэмплируем из реальной волновой функции, когда считаем математическое ожидание результата измерения. Как \sphinxhref{../../qc/ru/qubit.html\#id31}{помним из первой лекции} измерение есть проекция на один из собственных векторов, то есть можно рассматривать это как выбор сэмпла из пространства всех собственных векторов. Причем для определения вероятности используется состояние после применения параметризированного \sphinxstyleemphasis{ansatz}.


\section{Пример}
\label{\detokenize{book/vqe/ru/vqe:id4}}
\sphinxAtStartPar
Решим простую задачку с тривиальной моделью Изинга, который \sphinxhref{../../problems/ru/ising.html\#numpy}{рассматривали} в посвященной этому лекции. Будем использовать тот же код:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{from} \PYG{n+nn}{scipy} \PYG{k+kn}{import} \PYG{n}{sparse}
\PYG{k+kn}{from} \PYG{n+nn}{scipy}\PYG{n+nn}{.}\PYG{n+nn}{sparse} \PYG{k+kn}{import} \PYG{n}{linalg} \PYG{k}{as} \PYG{n}{sl}

\PYG{k}{def} \PYG{n+nf}{sigmaz\PYGZus{}k}\PYG{p}{(}\PYG{n}{k}\PYG{p}{:} \PYG{n+nb}{int}\PYG{p}{,} \PYG{n}{n}\PYG{p}{:} \PYG{n+nb}{int}\PYG{p}{)} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{sparse}\PYG{o}{.}\PYG{n}{csr\PYGZus{}matrix}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{left\PYGZus{}part} \PYG{o}{=} \PYG{n}{sparse}\PYG{o}{.}\PYG{n}{eye}\PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*}\PYG{o}{*} \PYG{n}{k}\PYG{p}{)}
    \PYG{n}{right\PYGZus{}part} \PYG{o}{=} \PYG{n}{sparse}\PYG{o}{.}\PYG{n}{eye}\PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*}\PYG{o}{*} \PYG{p}{(}\PYG{n}{n} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}} \PYG{n}{k}\PYG{p}{)}\PYG{p}{)}

    \PYG{k}{return} \PYG{n}{sparse}\PYG{o}{.}\PYG{n}{kron}\PYG{p}{(}
        \PYG{n}{sparse}\PYG{o}{.}\PYG{n}{kron}\PYG{p}{(}
            \PYG{n}{left\PYGZus{}part}\PYG{p}{,}
            \PYG{n}{sparse}\PYG{o}{.}\PYG{n}{csr\PYGZus{}matrix}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{p}{]}\PYG{p}{,}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{)}\PYG{p}{,}
        \PYG{n}{right\PYGZus{}part}
    \PYG{p}{)}

\PYG{k}{def} \PYG{n+nf}{ising}\PYG{p}{(}\PYG{n}{j}\PYG{p}{:} \PYG{n+nb}{float}\PYG{p}{,} \PYG{n}{h}\PYG{p}{:} \PYG{n+nb}{float}\PYG{p}{,} \PYG{n}{n}\PYG{p}{:} \PYG{n+nb}{int}\PYG{p}{)} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{n}{sparse}\PYG{o}{.}\PYG{n}{csr\PYGZus{}matrix}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{res} \PYG{o}{=} \PYG{n}{sparse}\PYG{o}{.}\PYG{n}{csr\PYGZus{}matrix}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*}\PYG{o}{*} \PYG{n}{n}\PYG{p}{,} \PYG{l+m+mi}{2} \PYG{o}{*}\PYG{o}{*} \PYG{n}{n}\PYG{p}{)}\PYG{p}{,} \PYG{n}{dtype}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{complex64}\PYG{p}{)}

    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{res} \PYG{o}{+}\PYG{o}{=} \PYG{n}{j} \PYG{o}{*} \PYG{n}{sigmaz\PYGZus{}k}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{n}\PYG{p}{)} \PYG{o}{*} \PYG{n}{sigmaz\PYGZus{}k}\PYG{p}{(}\PYG{n}{i} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{n}\PYG{p}{)}
        \PYG{n}{res} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{h} \PYG{o}{*} \PYG{n}{sigmaz\PYGZus{}k}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{n}\PYG{p}{)}

    \PYG{n}{res} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{h} \PYG{o}{*} \PYG{n}{sigmaz\PYGZus{}k}\PYG{p}{(}\PYG{n}{n} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{n}\PYG{p}{)}

    \PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Создадим оператор со значениями \(j=1.0, h=2.0\):

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{op} \PYG{o}{=} \PYG{n}{sparse}\PYG{o}{.}\PYG{n}{coo\PYGZus{}matrix}\PYG{p}{(}\PYG{n}{ising}\PYG{p}{(}\PYG{n}{j}\PYG{o}{=}\PYG{l+m+mf}{1.0}\PYG{p}{,} \PYG{n}{h}\PYG{o}{=}\PYG{l+m+mf}{2.0}\PYG{p}{,} \PYG{n}{n}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\subsection{Ansatz}
\label{\detokenize{book/vqe/ru/vqe:ansatz}}
\sphinxAtStartPar
Воспользуемся относительно простым вариантом кодирования с использование \(CNOT\) и нескольких слоев.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Более подробно причина выбора именно такого кодирования, а также подробности внутренней реализации на \sphinxcode{\sphinxupquote{PennyLane}} рассматривается в практической лекции по \sphinxstylestrong{VQE}.
\end{sphinxadmonition}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{pennylane} \PYG{k}{as} \PYG{n+nn}{qml}

\PYG{n}{N\PYGZus{}SPINS} \PYG{o}{=} \PYG{l+m+mi}{10}
\PYG{n}{N\PYGZus{}LAYERS} \PYG{o}{=} \PYG{l+m+mi}{2}

\PYG{n}{device} \PYG{o}{=} \PYG{n}{qml}\PYG{o}{.}\PYG{n}{device}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{default.qubit}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{wires}\PYG{o}{=}\PYG{n}{N\PYGZus{}SPINS}\PYG{p}{)}
\PYG{n}{ham} \PYG{o}{=} \PYG{n}{qml}\PYG{o}{.}\PYG{n}{SparseHamiltonian}\PYG{p}{(}\PYG{n}{op}\PYG{p}{,} \PYG{n}{wires}\PYG{o}{=}\PYG{n+nb}{list}\PYG{p}{(}\PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N\PYGZus{}SPINS}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Hamiltonian}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{k}{def} \PYG{n+nf}{layer}\PYG{p}{(}\PYG{n}{params}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N\PYGZus{}SPINS}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{qml}\PYG{o}{.}\PYG{n}{RY}\PYG{p}{(}\PYG{n}{params}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{wires}\PYG{o}{=}\PYG{n}{i}\PYG{p}{)}
        \PYG{n}{qml}\PYG{o}{.}\PYG{n}{RZ}\PYG{p}{(}\PYG{n}{params}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{wires}\PYG{o}{=}\PYG{n}{i}\PYG{p}{)}

    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N\PYGZus{}SPINS} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{qml}\PYG{o}{.}\PYG{n}{CZ}\PYG{p}{(}\PYG{n}{wires}\PYG{o}{=}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{n}{i} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}

\PYG{n+nd}{@qml}\PYG{o}{.}\PYG{n}{qnode}\PYG{p}{(}\PYG{n}{device}\PYG{p}{,} \PYG{n}{diff\PYGZus{}method}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{parameter\PYGZhy{}shift}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{k}{def} \PYG{n+nf}{feed\PYGZus{}forward}\PYG{p}{(}\PYG{n}{params}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N\PYGZus{}LAYERS}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{layer}\PYG{p}{(}\PYG{n}{params}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{)}

    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N\PYGZus{}SPINS}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{qml}\PYG{o}{.}\PYG{n}{RY}\PYG{p}{(}\PYG{n}{params}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{wires}\PYG{o}{=}\PYG{n}{i}\PYG{p}{)}
        \PYG{n}{qml}\PYG{o}{.}\PYG{n}{RZ}\PYG{p}{(}\PYG{n}{params}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{wires}\PYG{o}{=}\PYG{n}{i}\PYG{p}{)}

    \PYG{k}{return} \PYG{n}{qml}\PYG{o}{.}\PYG{n}{expval}\PYG{p}{(}\PYG{n}{ham}\PYG{p}{)}

\PYG{n}{params} \PYG{o}{=} \PYG{n+nb}{tuple}\PYG{p}{(}
    \PYG{n+nb}{tuple}\PYG{p}{(}
        \PYG{p}{(}
            \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{rand}\PYG{p}{(}\PYG{p}{)} \PYG{o}{*} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{p}{,}
            \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{rand}\PYG{p}{(}\PYG{p}{)} \PYG{o}{*} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{p}{,}
        \PYG{p}{)}
        \PYG{k}{for} \PYG{n}{\PYGZus{}} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N\PYGZus{}SPINS}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{k}{for} \PYG{n}{\PYGZus{}} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N\PYGZus{}LAYERS}\PYG{p}{)}
\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Result for random weights: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{feed\PYGZus{}forward}\PYG{p}{(}\PYG{n}{params}\PYG{p}{)}\PYG{l+s+si}{:}\PYG{l+s+s2}{.4f}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Result for random weights: 3.0699
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Обучение}
\label{\detokenize{book/vqe/ru/vqe:id5}}
\sphinxAtStartPar
Возьмем точное решение из \sphinxhref{../../problems/ru/ising.html\#numpy}{лекции по модели Изинга}:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{exact} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{11.0}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Запустим обучение и посмотрим, как оно сходится:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{o}{\PYGZpc{}}\PYG{k}{config} InlineBackend.figure\PYGZus{}format = \PYGZdq{}retina\PYGZdq{}

\PYG{n}{opt} \PYG{o}{=} \PYG{n}{qml}\PYG{o}{.}\PYG{n}{MomentumOptimizer}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{energy} \PYG{o}{=} \PYG{p}{[}
    \PYG{n}{feed\PYGZus{}forward}\PYG{p}{(}\PYG{n}{params}\PYG{p}{)}\PYG{p}{,}
\PYG{p}{]}

\PYG{k}{for} \PYG{n}{epoch} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{60}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{params}\PYG{p}{,} \PYG{n}{e} \PYG{o}{=} \PYG{n}{opt}\PYG{o}{.}\PYG{n}{step\PYGZus{}and\PYGZus{}cost}\PYG{p}{(}\PYG{n}{feed\PYGZus{}forward}\PYG{p}{,} \PYG{n}{params}\PYG{p}{)}
    \PYG{n}{energy}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{e}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{energy}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{n}{energy}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{.\PYGZhy{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Energy by epochs}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{hlines}\PYG{p}{(}
    \PYG{n}{exact}\PYG{p}{,}
    \PYG{l+m+mi}{0}\PYG{p}{,}
    \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{energy}\PYG{p}{)}\PYG{p}{,}
    \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{red}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
    \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Exact solution}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Epoch}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Energy}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
/home/runner/work/qmlcourse/qmlcourse/.venv/lib/python3.8/site\PYGZhy{}packages/pennylane/\PYGZus{}grad.py:95: UserWarning: Starting with PennyLane v0.21.0, when using Autograd, inputs have to explicitly specify requires\PYGZus{}grad=True (or the argnum argument must be passed) in order for trainable parameters to be identified.
  warnings.warn(
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{vqe_9_1}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Заключение}
\label{\detokenize{book/vqe/ru/vqe:id6}}
\sphinxAtStartPar
В этой лекции познакомились в \sphinxstylestrong{VQE} – очень перспективным, красивым и мощным алгоритмом для решения задач о собственных значениях на квантовых компьютерах. В следующей лекции более детально посмотрим на реализацию этого алгоритма в коде, а также обсудим выбранный \sphinxstyleemphasis{ansatz}.

\sphinxstepscope


\chapter{Практика VQE}
\label{\detokenize{book/vqe/ru/tspvqe:vqe}}\label{\detokenize{book/vqe/ru/tspvqe:tsp2vqe}}\label{\detokenize{book/vqe/ru/tspvqe::doc}}
\sphinxAtStartPar
Автор(ы):
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/SemyonSinchenko}{Синченко Семен}

\end{itemize}

\sphinxAtStartPar
Эта лекция будет посвящена практике с \sphinxstylestrong{VQE}, а именно решению задачи коммивояжера. Будет много кода и мало теории. Рекомендуется заранее повторить следующие лекции:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{../../problems/ru/copt.html\#id7}{Описание задачи коммивояжера} в лекции про задачи комбинаторной оптимизации.

\item {} 
\sphinxAtStartPar
\sphinxhref{../../problems2qml/ru/np2ising.html\#id10}{Сведение этой задачи к модели Изинга} в лекции о переходе от комбинаторных задач к квантовым алгоритмам.

\end{itemize}

\sphinxAtStartPar
Нам потребуется определить бинарный оператор \(\sigma^{z_{mod}}\), который активно \sphinxhref{../../problems2qml/ru/np2ising.html\#id3}{использовали} при определении гамильтониана. Нужно будет расписать полный оператор, отвечающий данной задаче и нужен случайный взвешенный граф, по которому будет “путешествовать” коммивояжер. Начнем с импорта библиотек и генерации графа.


\section{Импорт библиотек}
\label{\detokenize{book/vqe/ru/tspvqe:id1}}
\sphinxAtStartPar
Для графов будем использовать структуры данных из уже знакомой нам библиотеки \sphinxcode{\sphinxupquote{NetwrokX}}, а для работы с разреженными операторами \sphinxcode{\sphinxupquote{SciPy}}.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{o}{\PYGZpc{}}\PYG{k}{config} InlineBackend.figure\PYGZus{}format = \PYGZdq{}retina\PYGZdq{}

\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{networkx} \PYG{k}{as} \PYG{n+nn}{nx}
\PYG{k+kn}{from} \PYG{n+nn}{scipy} \PYG{k+kn}{import} \PYG{n}{sparse}
\PYG{k+kn}{from} \PYG{n+nn}{scipy}\PYG{n+nn}{.}\PYG{n+nn}{sparse} \PYG{k+kn}{import} \PYG{n}{linalg} \PYG{k}{as} \PYG{n}{sl}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\section{Случайный взвешенный граф}
\label{\detokenize{book/vqe/ru/tspvqe:id2}}
\sphinxAtStartPar
Случайный взвешенный граф проще всего сгенерировать из случайной матрицы весов. Давайте сделаем такую:

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Тут будем работать с матрицей полного графа, то есть такого, в котором каждая вершина связана с каждой. Это вполне корректное допущение для задачи коммивояжера, так как, например, из каждого города РФ обычно можно попасть во все другие, пусть и за разное время в пути.
\end{sphinxadmonition}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{seed}\PYG{p}{(}\PYG{l+m+mi}{42}\PYG{p}{)}
\PYG{n}{rand\PYGZus{}mat} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{randint}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{100}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Только эта матрица не является симметричной и имеет ненулевые элементы на диагонали. Элементы на диагонали означают петли (loop или self\sphinxhyphen{}loop), что не очень разумно в терминах задачи коммивояжера: не ясно, что значит, например, путь из Москвы в Москву. Аналогично и про то, что матрица не симметричная: если путь из Москвы в Санкт\sphinxhyphen{}Петербург займет 6 часов, то и путь обратно тоже займет столько же. Так что хотим симметричную матрицу. Давайте это исправим:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{rand\PYGZus{}adj} \PYG{o}{=} \PYG{p}{(}\PYG{n}{rand\PYGZus{}mat} \PYG{o}{+} \PYG{n}{rand\PYGZus{}mat}\PYG{o}{.}\PYG{n}{T}\PYG{p}{)} \PYG{o}{/} \PYG{l+m+mi}{2}
\PYG{n}{np}\PYG{o}{.}\PYG{n}{fill\PYGZus{}diagonal}\PYG{p}{(}\PYG{n}{rand\PYGZus{}adj}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Наконец, сделаем из этого граф и визуализируем его:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{g} \PYG{o}{=} \PYG{n}{nx}\PYG{o}{.}\PYG{n}{Graph}\PYG{p}{(}\PYG{n}{rand\PYGZus{}adj}\PYG{p}{)}

\PYG{n}{pos} \PYG{o}{=} \PYG{n}{nx}\PYG{o}{.}\PYG{n}{drawing}\PYG{o}{.}\PYG{n}{layout}\PYG{o}{.}\PYG{n}{random\PYGZus{}layout}\PYG{p}{(}\PYG{n}{g}\PYG{p}{,} \PYG{n}{seed}\PYG{o}{=}\PYG{l+m+mi}{42}\PYG{p}{)}
\PYG{n}{nx}\PYG{o}{.}\PYG{n}{draw}\PYG{p}{(}\PYG{n}{g}\PYG{p}{,} \PYG{n}{pos}\PYG{o}{=}\PYG{n}{pos}\PYG{p}{)}
\PYG{n}{edge\PYGZus{}weights} \PYG{o}{=} \PYG{n}{nx}\PYG{o}{.}\PYG{n}{get\PYGZus{}edge\PYGZus{}attributes}\PYG{p}{(}\PYG{n}{g}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{weight}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{nx}\PYG{o}{.}\PYG{n}{draw\PYGZus{}networkx\PYGZus{}edge\PYGZus{}labels}\PYG{p}{(}\PYG{n}{g}\PYG{p}{,} \PYG{n}{pos}\PYG{o}{=}\PYG{n}{pos}\PYG{p}{,} \PYG{n}{edge\PYGZus{}labels}\PYG{o}{=}\PYG{n}{edge\PYGZus{}weights}\PYG{p}{)}
\PYG{n}{nx}\PYG{o}{.}\PYG{n}{draw\PYGZus{}networkx\PYGZus{}labels}\PYG{p}{(}\PYG{n}{g}\PYG{p}{,} \PYG{n}{pos}\PYG{o}{=}\PYG{n}{pos}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{tspvqe_7_0}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Решение задачи TSP в NetworkX}
\label{\detokenize{book/vqe/ru/tspvqe:tsp-networkx}}
\sphinxAtStartPar
Для того, чтобы потом понять, что все правильно сделали, давайте найдем приближенное решение задачи средствами \sphinxcode{\sphinxupquote{NetworkX}}.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{nx\PYGZus{}solution} \PYG{o}{=} \PYG{n}{nx}\PYG{o}{.}\PYG{n}{algorithms}\PYG{o}{.}\PYG{n}{approximation}\PYG{o}{.}\PYG{n}{traveling\PYGZus{}salesman\PYGZus{}problem}\PYG{p}{(}\PYG{n}{g}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{NetworkX solution (nodes order): }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{nx\PYGZus{}solution}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{n}{nx\PYGZus{}solution\PYGZus{}cost} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{nx\PYGZus{}solution}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{nx\PYGZus{}solution\PYGZus{}cost} \PYG{o}{+}\PYG{o}{=} \PYG{n}{g}\PYG{o}{.}\PYG{n}{get\PYGZus{}edge\PYGZus{}data}\PYG{p}{(}\PYG{n}{nx\PYGZus{}solution}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{nx\PYGZus{}solution}\PYG{p}{[}\PYG{n}{i} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{weight}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{NetworkX solution (total cost): }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{nx\PYGZus{}solution\PYGZus{}cost}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
NetworkX solution (nodes order): [0, 3, 1, 2, 0]
NetworkX solution (total cost): 213.0
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Матрица \protect\(\sigma^z_{mod}\protect\)}
\label{\detokenize{book/vqe/ru/tspvqe:sigma-z-mod}}
\sphinxAtStartPar
Это бинарный оператор, который \sphinxhref{../../problems2qml/ru/np2ising.html\#id3}{ранее вводили} в лекции о представлении комбинаторных задач в виде моделей Изинга.
Соотношение между \(\sigma^z_{mod}\) и \(\sigma^z\) таково:
\begin{equation*}
\begin{split}
\hat{\sigma}^z_{mod} = \frac{1 + \hat{\sigma}^z}{2}
\end{split}
\end{equation*}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{sigma\PYGZus{}z\PYGZus{}mod}\PYG{p}{(}\PYG{n}{k}\PYG{p}{:} \PYG{n+nb}{int}\PYG{p}{,} \PYG{n}{size}\PYG{p}{:} \PYG{n+nb}{int}\PYG{p}{)} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{sparse}\PYG{o}{.}\PYG{n}{csr\PYGZus{}matrix}\PYG{p}{:}
    \PYG{n}{sz\PYGZus{}mod} \PYG{o}{=} \PYG{n}{sparse}\PYG{o}{.}\PYG{n}{coo\PYGZus{}matrix}\PYG{p}{(}
        \PYG{p}{[}
            \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,}\PYG{p}{]}\PYG{p}{,}
            \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{]}
    \PYG{p}{)}

    \PYG{n}{left\PYGZus{}ith} \PYG{o}{=} \PYG{n}{sparse}\PYG{o}{.}\PYG{n}{eye}\PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*}\PYG{o}{*} \PYG{n}{k}\PYG{p}{,} \PYG{n+nb}{format}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{coo}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n}{right\PYGZus{}ith} \PYG{o}{=} \PYG{n}{sparse}\PYG{o}{.}\PYG{n}{eye}\PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*}\PYG{o}{*} \PYG{p}{(}\PYG{n}{size} \PYG{o}{\PYGZhy{}} \PYG{n}{k} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n+nb}{format}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{coo}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

    \PYG{k}{return} \PYG{n}{sparse}\PYG{o}{.}\PYG{n}{kron}\PYG{p}{(}
        \PYG{n}{sparse}\PYG{o}{.}\PYG{n}{kron}\PYG{p}{(}\PYG{n}{left\PYGZus{}ith}\PYG{p}{,} \PYG{n}{sz\PYGZus{}mod}\PYG{p}{)}\PYG{p}{,}
        \PYG{n}{right\PYGZus{}ith}\PYG{p}{,}
    \PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Для произвольного состояния \(\ket{\psi}\) справедливо
\begin{equation*}
\begin{split}
\hat{\sigma}^z_{mod} \ket{\psi} = \frac{1}{2} \ket{\psi} + \frac{1}{2} \hat{\sigma}^z \ket{\psi}
\end{split}
\end{equation*}
\sphinxAtStartPar
Пусть \(\ket{\phi}\) – собственный вектор (собственное состояние) оператора \(\hat{\sigma}^z\), соответствующий собственному значению \(\lambda\):
\begin{equation*}
\begin{split}
\hat{\sigma}^z \ket{\phi} = \lambda \ket{\phi}
\end{split}
\end{equation*}
\sphinxAtStartPar
Отсюда следует, что
\begin{equation*}
\begin{split}
\hat{\sigma}^z_{mod} \ket{\phi} = \frac{1}{2} \ket{\phi} + \frac{1}{2} \lambda \ket{\phi} = \frac{1 + \lambda}{2} \ket{\phi}
\end{split}
\end{equation*}
\sphinxAtStartPar
Значит,
\begin{itemize}
\item {} 
\sphinxAtStartPar
собственные векторы \(\hat{\sigma}^z_{mod}\) и \(\hat{\sigma}^z\) совпадают;

\item {} 
\sphinxAtStartPar
соответствующие собственные значения связаны соотношением \(\lambda_{mod} = \frac{1 + \lambda}{2}\).

\end{itemize}

\sphinxAtStartPar
Поскольку \(\lambda \in \{-1, +1\}\), получаем \(\lambda_{mod} \in \{0, 1\}\). На всякий случай проверим это, создав оператор маленькой размерности и вычислив его собственные значения:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{eigs} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linalg}\PYG{o}{.}\PYG{n}{eig}\PYG{p}{(}\PYG{n}{sigma\PYGZus{}z\PYGZus{}mod}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{o}{.}\PYG{n}{toarray}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{unique}\PYG{p}{(}\PYG{n}{eigs}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
[0. 1.]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Напомню, что у нас zero\sphinxhyphen{}based индексация, поэтому \sphinxcode{\sphinxupquote{sigma\_z\_mod(1, 3)}} значит что\sphinxhyphen{}то типа “построй мне матрицу \(\hat{\sigma}^z_{mod}\), действующую на второй спин (ну или второй кубит)”.

\sphinxAtStartPar
Легко убедиться, что
\begin{itemize}
\item {} 
\sphinxAtStartPar
для \(\lambda_{mod} = 1\) собственный вектор представляется битовой строкой, в которой спин с индексом 1 имеет значение 0;

\item {} 
\sphinxAtStartPar
для \(\lambda_{mod} = 0\) собственный вектор представляется битовой строкой, в которой спин с индексом 1 имеет значение 1.

\end{itemize}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{sigmaz\PYGZus{}k}\PYG{p}{(}\PYG{n}{k}\PYG{p}{:} \PYG{n+nb}{int}\PYG{p}{,} \PYG{n}{n}\PYG{p}{:} \PYG{n+nb}{int}\PYG{p}{)} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{sparse}\PYG{o}{.}\PYG{n}{csr\PYGZus{}matrix}\PYG{p}{:}
    \PYG{n}{left\PYGZus{}part} \PYG{o}{=} \PYG{n}{sparse}\PYG{o}{.}\PYG{n}{eye}\PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*}\PYG{o}{*} \PYG{n}{k}\PYG{p}{)}
    \PYG{n}{right\PYGZus{}part} \PYG{o}{=} \PYG{n}{sparse}\PYG{o}{.}\PYG{n}{eye}\PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*}\PYG{o}{*} \PYG{p}{(}\PYG{n}{n} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}} \PYG{n}{k}\PYG{p}{)}\PYG{p}{)}

    \PYG{k}{return} \PYG{n}{sparse}\PYG{o}{.}\PYG{n}{kron}\PYG{p}{(}
        \PYG{n}{sparse}\PYG{o}{.}\PYG{n}{kron}\PYG{p}{(}
            \PYG{n}{left\PYGZus{}part}\PYG{p}{,}
            \PYG{n}{sparse}\PYG{o}{.}\PYG{n}{csr\PYGZus{}matrix}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{p}{]}\PYG{p}{,}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{)}\PYG{p}{,}
        \PYG{n}{right\PYGZus{}part}
    \PYG{p}{)}

\PYG{k}{def} \PYG{n+nf}{probs2bit\PYGZus{}str}\PYG{p}{(}\PYG{n}{probs}\PYG{p}{:} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{)} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n+nb}{str}\PYG{p}{:}
    \PYG{n}{size} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{log2}\PYG{p}{(}\PYG{n}{probs}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{bit\PYGZus{}s\PYGZus{}num} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{where}\PYG{p}{(}\PYG{n}{probs} \PYG{o}{==} \PYG{n}{probs}\PYG{o}{.}\PYG{n}{max}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
    \PYG{n}{s} \PYG{o}{=} \PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{bit\PYGZus{}s\PYGZus{}num}\PYG{l+s+si}{:}\PYG{l+s+s2}{b}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}
    \PYG{n}{s} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{*} \PYG{p}{(}\PYG{n}{size} \PYG{o}{\PYGZhy{}} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}\PYG{p}{)} \PYG{o}{+} \PYG{n}{s}

    \PYG{k}{return} \PYG{n}{s}

\PYG{k}{for} \PYG{n}{i}\PYG{p}{,} \PYG{n}{psi} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{eigs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{probs} \PYG{o}{=} \PYG{n}{psi} \PYG{o}{*} \PYG{n}{psi}\PYG{o}{.}\PYG{n}{conj}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{bit\PYGZus{}s} \PYG{o}{=} \PYG{n}{probs2bit\PYGZus{}str}\PYG{p}{(}\PYG{n}{probs}\PYG{p}{)}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Eigenvalue: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{eigs}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s2}{Bit string: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{bit\PYGZus{}s}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Eigenvalue: 1.0	Bit string: 000
Eigenvalue: 1.0	Bit string: 001
Eigenvalue: 0.0	Bit string: 010
Eigenvalue: 0.0	Bit string: 011
Eigenvalue: 1.0	Bit string: 100
Eigenvalue: 1.0	Bit string: 101
Eigenvalue: 0.0	Bit string: 110
Eigenvalue: 0.0	Bit string: 111
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Убедимся также в совпадении собственных векторов с матрицей \(\sigma^z\):

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Для чистых состояний без запутывания матрицы собственных векторов могут быть приведены к виду единичных матриц. И действительно, каждый собственный вектор отвечает строго одной конфигурации спинов, а значит его волновая функция имеет вид \(\ket{\Psi} = \ket{0, 0, ..., 1, ..., 0, 0}\), где 1 соответствует как раз номеру той битовой строки, которая отвечает этой конфигурации.
\end{sphinxadmonition}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Sigma z\PYGZus{}mod:}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{eigs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{Sigma z:}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{np}\PYG{o}{.}\PYG{n}{linalg}\PYG{o}{.}\PYG{n}{eig}\PYG{p}{(}\PYG{n}{sigmaz\PYGZus{}k}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{o}{.}\PYG{n}{toarray}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Sigma z\PYGZus{}mod:
[[1. 0. 0. 0. 0. 0. 0. 0.]
 [0. 1. 0. 0. 0. 0. 0. 0.]
 [0. 0. 1. 0. 0. 0. 0. 0.]
 [0. 0. 0. 1. 0. 0. 0. 0.]
 [0. 0. 0. 0. 1. 0. 0. 0.]
 [0. 0. 0. 0. 0. 1. 0. 0.]
 [0. 0. 0. 0. 0. 0. 1. 0.]
 [0. 0. 0. 0. 0. 0. 0. 1.]]

Sigma z:
[[1. 0. 0. 0. 0. 0. 0. 0.]
 [0. 1. 0. 0. 0. 0. 0. 0.]
 [0. 0. 1. 0. 0. 0. 0. 0.]
 [0. 0. 0. 1. 0. 0. 0. 0.]
 [0. 0. 0. 0. 1. 0. 0. 0.]
 [0. 0. 0. 0. 0. 1. 0. 0.]
 [0. 0. 0. 0. 0. 0. 1. 0.]
 [0. 0. 0. 0. 0. 0. 0. 1.]]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
В общем случае, даже если у двух операторов совпадают собственные вектора, то их порядок (по возрастанию собственных значений) совпадать совсем не обязан. В этом легко убедиться, например, если поменять местами \(\hat{1}\) и \(\hat{\sigma^z}\) в \(\sigma^{z_{mod}}\). Поэтому, чтобы избежать ошибок в будущем, лучше не привыкать сравнивать матрицы собственных векторов при помощи \sphinxcode{\sphinxupquote{np.allclose}}, а сравнивать их глазами построчно.
\end{sphinxadmonition}


\section{Гамильтониан задачи TSP}
\label{\detokenize{book/vqe/ru/tspvqe:tsp}}
\sphinxAtStartPar
Давайте еще раз выпишем полный гамильтониан системы. Напомню, что задача будет параметризована при помощи \(N^2\) кубит, которые для удобства выстроены в виде матрицы, где \(i\)\sphinxhyphen{}я строка соответствует \(i\)\sphinxhyphen{}му шагу в цикле по графу, а \(j\)\sphinxhyphen{}й элемент строки соответствует номеру вершины и является бинарным оператором:
\begin{equation*}
\begin{split}
\hat{H} = a\sum_{i=1}^N (1 - \sum_{j=1}^N \sigma^{z_{mod}}_{i,j})^2 + a\sum_{j=1}^N (1 - \sum_{i=1}^N \sigma^{z_{mod}}_{i,j})^2 + a \sum_{u,v \not\in E}\sum_{j=1}^{N-1}\sigma^{z_{mod}}_{u,j}\sigma^{z_{mod}}_{v,j+1} + b \sum_{u,v \in E}\sum_{j=1}^{N-1}\sigma^{z_{mod}}_{u,j}\sigma^{z_{mod}}_{v,j+1}
\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Еще раз вспомним, что первые два слагаемых “говорят”: каждая вершина должна входить только в один столбец, а каждая строка должна содержать только одну вершину. Третье слагаемое представляет собой штраф за соединение вершин, между которыми нет ребра, а четвертое дает стоимость всего пути. Первые три слагаемых идут с бОльшим коэффициентом, чем последнее, так как нам важно в первую очередь получить реальное решение, а не получить самое дешевое.
\end{sphinxadmonition}

\sphinxAtStartPar
Сделаем финт ушами: будем всегда считать, что путь коммивояжера начинается в вершине с индексом 0. Так как путь коммивояжера это гамильтонов цикл, то делаем это упрощение без какой\sphinxhyphen{}либо потери общности, так как вершина с индексом 0 все равно должна будет войти в путь. При этом такой хитрый трюк позволит снизить число необходимых кубит с \(N^2\) до \((N - 1)^2\), что довольно существенно (хотя асимптотическая сложность остается такой же). Работать с графом будем при помощи уже знакомой библиотеки \sphinxcode{\sphinxupquote{NetworkX}}:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{convert\PYGZus{}tsp\PYGZus{}to\PYGZus{}ising}\PYG{p}{(}\PYG{n}{g}\PYG{p}{:} \PYG{n}{nx}\PYG{o}{.}\PYG{n}{Graph}\PYG{p}{)} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{sparse}\PYG{o}{.}\PYG{n}{coo\PYGZus{}matrix}\PYG{p}{:}
    \PYG{c+c1}{\PYGZsh{} Имеется два элемента гамильтониана:}
    \PYG{c+c1}{\PYGZsh{}  \PYGZhy{} часть, дающая нам Гамилтонов цикл}
    \PYG{c+c1}{\PYGZsh{}  \PYGZhy{} часть, считающая стоимость пути}
    \PYG{c+c1}{\PYGZsh{} Для нас важно, чтобы вес первой части превалирвал.}
    \PYG{c+c1}{\PYGZsh{} Поэтому, в качестве коэффициента берем}
    \PYG{c+c1}{\PYGZsh{} пятикратное значение максимального веса ребер в графе.}

    \PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{5} \PYG{o}{*} \PYG{n+nb}{max}\PYG{p}{(}\PYG{p}{[}\PYG{n}{e}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{weight}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]} \PYG{k}{for} \PYG{n}{e} \PYG{o+ow}{in} \PYG{n}{g}\PYG{o}{.}\PYG{n}{edges}\PYG{p}{(}\PYG{n}{data}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{size} \PYG{o}{=} \PYG{n}{g}\PYG{o}{.}\PYG{n}{number\PYGZus{}of\PYGZus{}nodes}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}

    \PYG{n}{H} \PYG{o}{=} \PYG{n}{sparse}\PYG{o}{.}\PYG{n}{coo\PYGZus{}matrix}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*}\PYG{o}{*} \PYG{p}{(}\PYG{n}{size} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{2} \PYG{o}{*}\PYG{o}{*} \PYG{p}{(}\PYG{n}{size} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{n}{dtype}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{complex128}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} Вычисляем сумму по колонкам:}
    \PYG{c+c1}{\PYGZsh{}   \PYGZhy{} каждая вершина должна быть в каждой колонке строго один раз}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{size}\PYG{p}{)}\PYG{p}{:}
        \PYG{c+c1}{\PYGZsh{} Считаем выражение 1 \PYGZhy{} sum}
        \PYG{n}{col\PYGZus{}sum} \PYG{o}{=} \PYG{n}{sparse}\PYG{o}{.}\PYG{n}{eye}\PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*}\PYG{o}{*} \PYG{p}{(}\PYG{n}{size} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{n+nb}{format}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{coo}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{size}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{col\PYGZus{}sum} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{sigma\PYGZus{}z\PYGZus{}mod}\PYG{p}{(}\PYG{n}{i} \PYG{o}{+} \PYG{n}{j} \PYG{o}{*} \PYG{n}{size}\PYG{p}{,} \PYG{n}{size} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2}\PYG{p}{)}

        \PYG{c+c1}{\PYGZsh{} Возводим в квадрат и добавляем к гамилтониану}
        \PYG{n}{H} \PYG{o}{+}\PYG{o}{=} \PYG{n}{a} \PYG{o}{*} \PYG{n}{col\PYGZus{}sum} \PYG{o}{*} \PYG{n}{col\PYGZus{}sum}

    \PYG{c+c1}{\PYGZsh{} Вычисляем сумму по строкам:}
    \PYG{c+c1}{\PYGZsh{}   \PYGZhy{} каждая вершина должна быть в каждой строке строго один раз}
    \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{size}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{row\PYGZus{}sum} \PYG{o}{=} \PYG{n}{sparse}\PYG{o}{.}\PYG{n}{eye}\PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*}\PYG{o}{*} \PYG{p}{(}\PYG{n}{size} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{n+nb}{format}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{coo}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{size}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{row\PYGZus{}sum} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{sigma\PYGZus{}z\PYGZus{}mod}\PYG{p}{(}\PYG{n}{i} \PYG{o}{+} \PYG{n}{j} \PYG{o}{*} \PYG{n}{size}\PYG{p}{,} \PYG{n}{size} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2}\PYG{p}{)}

        \PYG{c+c1}{\PYGZsh{} Аналогично, в квадрат и добавляем}
        \PYG{n}{H} \PYG{o}{+}\PYG{o}{=} \PYG{n}{a} \PYG{o}{*} \PYG{n}{row\PYGZus{}sum} \PYG{o}{*} \PYG{n}{row\PYGZus{}sum}

    \PYG{c+c1}{\PYGZsh{} Считаем сумму по тем ребрам, которых в графе нет и тем, которые есть.}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{size}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{size}\PYG{p}{)}\PYG{p}{:}
            \PYG{k}{if} \PYG{n}{g}\PYG{o}{.}\PYG{n}{has\PYGZus{}edge}\PYG{p}{(}\PYG{n}{i} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{j} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
                \PYG{c+c1}{\PYGZsh{} Сумма по всем ребрам графа}
                \PYG{n}{coef} \PYG{o}{=} \PYG{n}{g}\PYG{o}{.}\PYG{n}{get\PYGZus{}edge\PYGZus{}data}\PYG{p}{(}\PYG{n}{i} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{j} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{weight}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}
            \PYG{k}{else}\PYG{p}{:}
                \PYG{c+c1}{\PYGZsh{} Сумма по всем отсутствующим ребрам графа}
                \PYG{n}{coef} \PYG{o}{=} \PYG{n}{a}

            \PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{size} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
                \PYG{c+c1}{\PYGZsh{} Дальше просто используем полученный коэффициент и считаем сумму}
                \PYG{n}{H} \PYG{o}{+}\PYG{o}{=} \PYG{p}{(}
                    \PYG{n}{coef}
                    \PYG{o}{*} \PYG{n}{sigma\PYGZus{}z\PYGZus{}mod}\PYG{p}{(}\PYG{n}{i} \PYG{o}{+} \PYG{n}{k} \PYG{o}{*} \PYG{n}{size}\PYG{p}{,} \PYG{n}{size} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2}\PYG{p}{)}
                    \PYG{o}{*} \PYG{n}{sigma\PYGZus{}z\PYGZus{}mod}\PYG{p}{(}\PYG{n}{j} \PYG{o}{+} \PYG{p}{(}\PYG{n}{k} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{*} \PYG{n}{size}\PYG{p}{,} \PYG{n}{size} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2}\PYG{p}{)}
                \PYG{p}{)}

            \PYG{n}{H} \PYG{o}{+}\PYG{o}{=} \PYG{p}{(}
                \PYG{n}{coef}
                \PYG{o}{*} \PYG{n}{sigma\PYGZus{}z\PYGZus{}mod}\PYG{p}{(}\PYG{n}{i} \PYG{o}{+} \PYG{p}{(}\PYG{n}{size} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{*} \PYG{n}{size}\PYG{p}{,} \PYG{n}{size} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2}\PYG{p}{)}
                \PYG{o}{*} \PYG{n}{sigma\PYGZus{}z\PYGZus{}mod}\PYG{p}{(}\PYG{n}{j}\PYG{p}{,} \PYG{n}{size} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2}\PYG{p}{)}
            \PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} Начинаем всегда из нулевой вершины, это позволяет снизить число необходимых кубитов.}
    \PYG{c+c1}{\PYGZsh{} Теперь должны добавить в гамильтониан слагаемое, отвечающее за нулевую вершину в пути.}
    \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{size}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{if} \PYG{n}{g}\PYG{o}{.}\PYG{n}{has\PYGZus{}edge}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{j} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{coef} \PYG{o}{=} \PYG{n}{g}\PYG{o}{.}\PYG{n}{get\PYGZus{}edge\PYGZus{}data}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{j} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{weight}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}
        \PYG{k}{else}\PYG{p}{:}
            \PYG{n}{coef} \PYG{o}{=} \PYG{n}{a}

        \PYG{n}{H} \PYG{o}{+}\PYG{o}{=} \PYG{n}{coef} \PYG{o}{*} \PYG{n}{sigma\PYGZus{}z\PYGZus{}mod}\PYG{p}{(}\PYG{n}{j}\PYG{p}{,} \PYG{n}{size} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2}\PYG{p}{)}
        \PYG{n}{H} \PYG{o}{+}\PYG{o}{=} \PYG{n}{coef} \PYG{o}{*} \PYG{n}{sigma\PYGZus{}z\PYGZus{}mod}\PYG{p}{(}\PYG{n}{j} \PYG{o}{+} \PYG{p}{(}\PYG{n}{size} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{*} \PYG{n}{size}\PYG{p}{,} \PYG{n}{size} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} PennyLane работает с матрицами только в координатном формате, поэтому сразу делаем приведение.}
    \PYG{k}{return} \PYG{n}{sparse}\PYG{o}{.}\PYG{n}{coo\PYGZus{}matrix}\PYG{p}{(}\PYG{n}{H}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Убедимся, что точное решение даст тот же путь (с той же стоимостью), что и решение из \sphinxcode{\sphinxupquote{NetworkX}}:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{op} \PYG{o}{=} \PYG{n}{convert\PYGZus{}tsp\PYGZus{}to\PYGZus{}ising}\PYG{p}{(}\PYG{n}{g}\PYG{p}{)}
\PYG{n}{scipy\PYGZus{}solution} \PYG{o}{=} \PYG{n}{sl}\PYG{o}{.}\PYG{n}{eigs}\PYG{p}{(}\PYG{n}{op}\PYG{p}{,} \PYG{n}{k}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{which}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{SR}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{return\PYGZus{}eigenvectors}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Ground state energy: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{scipy\PYGZus{}solution}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{l+s+si}{:}\PYG{l+s+s2}{.4f}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{n}{probs} \PYG{o}{=} \PYG{n}{scipy\PYGZus{}solution}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{*} \PYG{n}{scipy\PYGZus{}solution}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{conj}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{bit\PYGZus{}s} \PYG{o}{=} \PYG{n}{probs2bit\PYGZus{}str}\PYG{p}{(}\PYG{n}{probs}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Нулевая вершина всегда первая}
\PYG{n}{scipy\PYGZus{}path} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{p}{]}

\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{k} \PYG{o}{=} \PYG{l+m+mi}{0}
    \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{if} \PYG{n}{bit\PYGZus{}s}\PYG{p}{[}\PYG{n}{j} \PYG{o}{+} \PYG{n}{i} \PYG{o}{*} \PYG{l+m+mi}{3}\PYG{p}{]} \PYG{o}{==} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}
            \PYG{n}{k} \PYG{o}{=} \PYG{n}{j} \PYG{o}{+} \PYG{l+m+mi}{1}
    \PYG{n}{scipy\PYGZus{}path}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{k}\PYG{p}{)}
\PYG{n}{scipy\PYGZus{}path}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}

\PYG{n}{scipy\PYGZus{}solution\PYGZus{}cost} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{scipy\PYGZus{}path}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{scipy\PYGZus{}solution\PYGZus{}cost} \PYG{o}{+}\PYG{o}{=} \PYG{n}{g}\PYG{o}{.}\PYG{n}{get\PYGZus{}edge\PYGZus{}data}\PYG{p}{(}\PYG{n}{scipy\PYGZus{}path}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{scipy\PYGZus{}path}\PYG{p}{[}\PYG{n}{i} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{weight}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{SciPy solution (nodes order): }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{scipy\PYGZus{}path}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{SciPy solution (total cost): }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{scipy\PYGZus{}solution\PYGZus{}cost}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Ground state energy: 273.0000\PYGZhy{}0.0000j
SciPy solution (nodes order): [0, 2, 1, 3, 0]
SciPy solution (total cost): 213.0
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Видим, что решение через матрицу совпадает с тем, что выдал \sphinxcode{\sphinxupquote{NetworkX}} (с точностью до инверсии: \sphinxcode{\sphinxupquote{{[}0, 2, 1, 3, 0{]}}} и \sphinxcode{\sphinxupquote{{[}0, 3, 1, 2, 0{]}}}), как и общая стоимость пути. Энергия основного состояния отличается по причине того, что использовали оптимизацию и магию с коэффициентами. Но это не так важно: по энергиям важно лишь отношение порядка, потому что зная битовую строку всегда можем проверить стоимость пути за линейное время!

\sphinxAtStartPar
Теперь можно наконец\sphinxhyphen{}то, приступать к симуляции квантовых вычислений!


\section{VQE на Pennylane}
\label{\detokenize{book/vqe/ru/tspvqe:vqe-pennylane}}
\sphinxAtStartPar
Для начала давайте преобразуем матрицу к тому объекту, с которым умеет работать квантовый фреймворк.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Pennylane}} поддерживает также работу с представлением гамильтонианов в виде так называемых Паули\sphinxhyphen{}строк, но тут не будем еще раз определять весь гамильтониан, а просто перериспользуем разреженную матрицу.
\end{sphinxadmonition}

\sphinxAtStartPar
Веса графа имеют разброс значений от 0 до 100. Из\sphinxhyphen{}за этого, при некоторых конфигурациях можем получать очень большое собственное значение гамильтониана, вплоть до нескольких тысяч. Это не очень хорошо для градиентного спуска методом \sphinxcode{\sphinxupquote{paramter\sphinxhyphen{}shift}}, поэтому для численной устойчивости давайте умножим все значения весов на \(0.1\). Это сделает градиенты не слишком большими и улучшит численную устойчивость. Делать это можно совершенно спокойно, так как не критична численная величина минимального собственного, а важно лишь отношение порядка собственных значений.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{pennylane} \PYG{k}{as} \PYG{n+nn}{qml}

\PYG{n}{numer\PYGZus{}stability\PYGZus{}const} \PYG{o}{=} \PYG{l+m+mf}{0.1}
\PYG{n}{ham} \PYG{o}{=} \PYG{n}{qml}\PYG{o}{.}\PYG{n}{SparseHamiltonian}\PYG{p}{(}\PYG{n}{op} \PYG{o}{*} \PYG{n}{numer\PYGZus{}stability\PYGZus{}const}\PYG{p}{,} \PYG{n}{wires}\PYG{o}{=}\PYG{n+nb}{list}\PYG{p}{(}\PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{9}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Далее необходимо выбрать \sphinxstyleemphasis{ansatz}. Современные квантовые процессоры обычно имеют вид решетки, типа такого:

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=350\sphinxpxdimen]{{sycamore}.png}
\caption{Схематичное изображение квантового компьютера \sphinxstyleemphasis{Sycamore} от компании \sphinxstyleemphasis{Google} {[}\hyperlink{cite.book/bibliography:id68}{AAB+19}{]}}\label{\detokenize{book/vqe/ru/tspvqe:sycamore-lattice2}}\end{figure}

\sphinxAtStartPar
Поэтому, в идеале, хотелось бы делать либо однокубитные операции, либо двухкубитные операции, но над “соседними” кубитами. Так появилась идея \sphinxstyleemphasis{hardware efficient ansatz} {[}\hyperlink{cite.book/bibliography:id33}{KMT+17}{]}. Он заключается в том, что формируется несколько “слоев” \sphinxstylestrong{VQC}, где каждый такой слой содержит несколько операций вращений, а также попарные “запутывающие” операции (например, \sphinxhref{../../qc/ru/gates.html\#cy-cz}{\sphinxstyleemphasis{CZ}}, или гейт \sphinxhref{../../qc/ru/gates.html\#cnot-cx}{\sphinxstyleemphasis{CNOT}}). Выглядит это примерно так:

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{HWA}.png}
\caption{Иллюстрация \sphinxstyleemphasis{hardware efficient ansatz} (\sphinxstyleemphasis{HWEA}) из {[}\hyperlink{cite.book/bibliography:id33}{KMT+17}{]}}\label{\detokenize{book/vqe/ru/tspvqe:id8}}\end{figure}

\sphinxAtStartPar
Давайте реализуем такой слой:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{size} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{ham}\PYG{o}{.}\PYG{n}{wires}\PYG{p}{)}

\PYG{k}{def} \PYG{n+nf}{layer}\PYG{p}{(}\PYG{n}{params}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{size}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{qml}\PYG{o}{.}\PYG{n}{RY}\PYG{p}{(}\PYG{n}{params}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{wires}\PYG{o}{=}\PYG{n}{i}\PYG{p}{)}
        \PYG{n}{qml}\PYG{o}{.}\PYG{n}{RZ}\PYG{p}{(}\PYG{n}{params}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{wires}\PYG{o}{=}\PYG{n}{i}\PYG{p}{)}

    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{size} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{qml}\PYG{o}{.}\PYG{n}{CZ}\PYG{p}{(}\PYG{n}{wires}\PYG{o}{=}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{n}{i} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Здесь специально не повторяем основ параметризированных квантовых схем. Для тех, кто забыл, что это такое, рекомендуем вернуться к {\hyperref[\detokenize{book/vqc/ru/vqc::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{отдельной лекции}}}} по этой теме.

\sphinxAtStartPar
Теперь создадим устройство, которое будет квантовым симулятором, а также напишем код, который будет на этом устройстве запускаться. Такой код должен последовательно применить несколько \sphinxstyleemphasis{HWEA} слоев, после чего измерить ожидаемое значение гамильтониана в полученном состоянии.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{device} \PYG{o}{=} \PYG{n}{qml}\PYG{o}{.}\PYG{n}{device}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{default.qubit}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{wires}\PYG{o}{=}\PYG{n}{size}\PYG{p}{)}
\PYG{n}{num\PYGZus{}layers} \PYG{o}{=} \PYG{l+m+mi}{3}

\PYG{n+nd}{@qml}\PYG{o}{.}\PYG{n}{qnode}\PYG{p}{(}\PYG{n}{device}\PYG{p}{,} \PYG{n}{diff\PYGZus{}method}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{parameter\PYGZhy{}shift}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{k}{def} \PYG{n+nf}{feed\PYGZus{}forward}\PYG{p}{(}\PYG{n}{params}\PYG{p}{,} \PYG{n}{wires}\PYG{o}{=}\PYG{n}{size}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{layer}\PYG{p}{(}\PYG{n}{params}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{)}

    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{size}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{qml}\PYG{o}{.}\PYG{n}{RY}\PYG{p}{(}\PYG{n}{params}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{wires}\PYG{o}{=}\PYG{n}{i}\PYG{p}{)}
        \PYG{n}{qml}\PYG{o}{.}\PYG{n}{RZ}\PYG{p}{(}\PYG{n}{params}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{wires}\PYG{o}{=}\PYG{n}{i}\PYG{p}{)}

    \PYG{k}{return} \PYG{n}{qml}\PYG{o}{.}\PYG{n}{expval}\PYG{p}{(}\PYG{n}{ham}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Теперь надо сгенерировать параметры и выбрать метод их оптимизации. В этот раз давайте воспользуемся алгоритмом \sphinxcode{\sphinxupquote{Momentum}}, так называемым “ускоренным” градиентным спуском:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{opt} \PYG{o}{=} \PYG{n}{qml}\PYG{o}{.}\PYG{n}{MomentumOptimizer}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{params} \PYG{o}{=} \PYG{n+nb}{tuple}\PYG{p}{(}
    \PYG{n+nb}{tuple}\PYG{p}{(}
        \PYG{p}{(}
            \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{rand}\PYG{p}{(}\PYG{p}{)} \PYG{o}{*} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{p}{,}
            \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{rand}\PYG{p}{(}\PYG{p}{)} \PYG{o}{*} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{p}{,}
        \PYG{p}{)}
        \PYG{k}{for} \PYG{n}{\PYGZus{}} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{size}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{k}{for} \PYG{n}{\PYGZus{}} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{num\PYGZus{}layers} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Ну и наконец можно приступать к оптимизации параметров. Все примерно также, как в {\hyperref[\detokenize{book/grads/ru/gradients::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{базовой лекции про градиенты}}}}. То есть ничего нового тут по сути не делается.


\section{Симуляция}
\label{\detokenize{book/vqe/ru/tspvqe:id6}}
\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
Осторожно, следующий код работает несколько минут, так как обучаем довольно тяжелую схему на 9\sphinxhyphen{}и кубитах! Кстати, при желании можно добиться гораздо больше точности по энергии относительно точного решения. Для этого достаточно установить число эпох \(\sim 150\). Но поскольку этот код исполняется при сборке данных лекций, то мы не можем себе позволить считать отдельные страницы по 7\sphinxhyphen{}10 минут. Читателю рекомендуется самостоятельно определить то число эпох, которого достаточно, чтобы получить точность в 3\sphinxhyphen{}м знаке после запятой.
\end{sphinxadmonition}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{energy} \PYG{o}{=} \PYG{p}{[}
    \PYG{n}{feed\PYGZus{}forward}\PYG{p}{(}\PYG{n}{params}\PYG{p}{)}\PYG{p}{,}
\PYG{p}{]}

\PYG{k}{for} \PYG{n}{epoch} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{85}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{params}\PYG{p}{,} \PYG{n}{e} \PYG{o}{=} \PYG{n}{opt}\PYG{o}{.}\PYG{n}{step\PYGZus{}and\PYGZus{}cost}\PYG{p}{(}\PYG{n}{feed\PYGZus{}forward}\PYG{p}{,} \PYG{n}{params}\PYG{p}{)}
    \PYG{n}{energy}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{e}\PYG{p}{)}

    \PYG{k}{if} \PYG{n}{epoch} \PYG{o}{\PYGZpc{}} \PYG{l+m+mi}{5} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{:}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{epoch: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{epoch}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s2}{energy: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{e}\PYG{l+s+si}{:}\PYG{l+s+s2}{.6f}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
/home/runner/work/qmlcourse/qmlcourse/.venv/lib/python3.8/site\PYGZhy{}packages/pennylane/\PYGZus{}grad.py:95: UserWarning: Starting with PennyLane v0.21.0, when using Autograd, inputs have to explicitly specify requires\PYGZus{}grad=True (or the argnum argument must be passed) in order for trainable parameters to be identified.
  warnings.warn(
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
epoch: 0	energy: 360.638506
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
epoch: 5	energy: 163.172963
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
epoch: 10	energy: 96.375950
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
epoch: 15	energy: 56.524352
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
epoch: 20	energy: 43.497589
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
epoch: 25	energy: 35.938162
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
epoch: 30	energy: 31.882151
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
epoch: 35	energy: 29.457526
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
epoch: 40	energy: 29.232270
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
epoch: 45	energy: 28.058306
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
epoch: 50	energy: 27.814023
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
epoch: 55	energy: 27.495886
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
epoch: 60	energy: 27.479515
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
epoch: 65	energy: 27.411348
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
epoch: 70	energy: 27.348231
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
epoch: 75	energy: 27.329692
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
epoch: 80	energy: 27.324815
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{energy}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{n}{energy}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{.\PYGZhy{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Energy by epochs}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{hlines}\PYG{p}{(}
    \PYG{n}{np}\PYG{o}{.}\PYG{n}{real}\PYG{p}{(}\PYG{n}{scipy\PYGZus{}solution}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)} \PYG{o}{*} \PYG{n}{numer\PYGZus{}stability\PYGZus{}const}\PYG{p}{,}
    \PYG{l+m+mi}{0}\PYG{p}{,}
    \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{energy}\PYG{p}{)}\PYG{p}{,}
    \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{red}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
    \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Exact solution}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Epoch}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Energy}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{tspvqe_32_0}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Видим, что \sphinxstylestrong{VQE} отлично сходится к основному состоянию, которое знаем из \sphinxcode{\sphinxupquote{SciPy}} и \sphinxcode{\sphinxupquote{ARPACK}}. Теперь давайте убедимся, что квантовый путь совпадет с тем, что получили из \sphinxcode{\sphinxupquote{NetworkX}}. Для этого нужно получить распределение вероятностей битовых строк. На реальном компьютере это можно сделать просто измеряя много раз, но на симуляторе есть возможность получить его сразу одной командой.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nd}{@qml}\PYG{o}{.}\PYG{n}{qnode}\PYG{p}{(}\PYG{n}{device}\PYG{p}{,} \PYG{n}{diff\PYGZus{}method}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{parameter\PYGZhy{}shift}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{k}{def} \PYG{n+nf}{answer}\PYG{p}{(}\PYG{n}{params}\PYG{p}{,} \PYG{n}{wires}\PYG{o}{=}\PYG{n}{size}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{num\PYGZus{}layers}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{layer}\PYG{p}{(}\PYG{n}{params}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{)}

    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{size}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{qml}\PYG{o}{.}\PYG{n}{RY}\PYG{p}{(}\PYG{n}{params}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{wires}\PYG{o}{=}\PYG{n}{i}\PYG{p}{)}
        \PYG{n}{qml}\PYG{o}{.}\PYG{n}{RZ}\PYG{p}{(}\PYG{n}{params}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{wires}\PYG{o}{=}\PYG{n}{i}\PYG{p}{)}

    \PYG{k}{return} \PYG{n}{qml}\PYG{o}{.}\PYG{n}{probs}\PYG{p}{(}\PYG{n}{wires}\PYG{o}{=}\PYG{n+nb}{list}\PYG{p}{(}\PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{size}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{probs} \PYG{o}{=} \PYG{n}{answer}\PYG{p}{(}\PYG{n}{params}\PYG{p}{)}
\PYG{n}{bit\PYGZus{}s} \PYG{o}{=} \PYG{n}{probs2bit\PYGZus{}str}\PYG{p}{(}\PYG{n}{probs}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Нулевая вершина всегда первая}
\PYG{n}{q\PYGZus{}path} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{p}{]}

\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{k} \PYG{o}{=} \PYG{l+m+mi}{0}
    \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{if} \PYG{n}{bit\PYGZus{}s}\PYG{p}{[}\PYG{n}{j} \PYG{o}{+} \PYG{n}{i} \PYG{o}{*} \PYG{l+m+mi}{3}\PYG{p}{]} \PYG{o}{==} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}
            \PYG{n}{k} \PYG{o}{=} \PYG{n}{j} \PYG{o}{+} \PYG{l+m+mi}{1}
    \PYG{n}{q\PYGZus{}path}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{k}\PYG{p}{)}
\PYG{n}{q\PYGZus{}path}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}

\PYG{n}{q\PYGZus{}solution\PYGZus{}cost} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{q\PYGZus{}path}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{q\PYGZus{}solution\PYGZus{}cost} \PYG{o}{+}\PYG{o}{=} \PYG{n}{g}\PYG{o}{.}\PYG{n}{get\PYGZus{}edge\PYGZus{}data}\PYG{p}{(}\PYG{n}{q\PYGZus{}path}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q\PYGZus{}path}\PYG{p}{[}\PYG{n}{i} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{weight}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Quantum solution (nodes order): }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{q\PYGZus{}path}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Quantum solution (total cost): }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{q\PYGZus{}solution\PYGZus{}cost}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Quantum solution (nodes order): [0, 2, 1, 3, 0]
Quantum solution (total cost): 213.0
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Ура, получился тот же ответ, что и в \sphinxcode{\sphinxupquote{SciPy}}/\sphinxcode{\sphinxupquote{NetworkX}}. Значит самописный \sphinxstylestrong{VQE} работает правильно.


\section{Заключение}
\label{\detokenize{book/vqe/ru/tspvqe:id7}}
\sphinxAtStartPar
В этой лекции попрактиковались в решение реальных задач при помощи алгоритма \sphinxstylestrong{VQE}.

\sphinxstepscope


\part{D\sphinxhyphen{}Wave – квантовый отжиг и семплирование}

\sphinxstepscope


\chapter{О блоке “D\sphinxhyphen{}Wave – квантовый отжиг и семплирование”}
\label{\detokenize{book/dwave/ru/dwave_intro:d-wave}}\label{\detokenize{book/dwave/ru/dwave_intro:dwave-intro}}\label{\detokenize{book/dwave/ru/dwave_intro::doc}}
\sphinxAtStartPar
Этот блок посвящен квантовому отжигателю компании D\sphinxhyphen{}Wave и задачам, которые можно решать с его помощью.

\sphinxstepscope


\chapter{D\sphinxhyphen{}Wave: квантовый отжиг, оптимизация и семплинг}
\label{\detokenize{book/dwave/ru/dwave:d-wave}}\label{\detokenize{book/dwave/ru/dwave:dwave}}\label{\detokenize{book/dwave/ru/dwave::doc}}
\sphinxAtStartPar
Автор(ы):
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/meandmytram}{Березутский Александр}

\end{itemize}


\section{Описание лекции}
\label{\detokenize{book/dwave/ru/dwave:id1}}
\sphinxAtStartPar
В этой лекции рассмотрим квантовый отжигатель компании \sphinxcode{\sphinxupquote{D\sphinxhyphen{}Wave}} и задачи, которые можно решать с его помощью. Заострим основное внимание на физике и алгоритмах, нежели на hardware\sphinxhyphen{}реализации этого устройства. Эта лекция основана на \sphinxhref{https://docs.dwavesys.com/}{официальной документации \sphinxcode{\sphinxupquote{D\sphinxhyphen{}Wave}}}.


\section{Введение в квантовый отжиг}
\label{\detokenize{book/dwave/ru/dwave:id2}}
\sphinxAtStartPar
На сегодняшний день, квантовый отжиг представляет собой отдельную модель квантовых вычислений, не связанную с так называемыми \sphinxcode{\sphinxupquote{Gate\sphinxhyphen{}Model}} квантовыми вычислениями. Эта парадигма позволяет эффективно решать задачи комбинаторной оптимизации больших масштабов, представляющие большой интерес для многих областей науки и индустрии. Вкратце, в модели квантового отжига на физическую модель (коей является массив кубитов) отображаются параметры решаемой задачи, после чего кубиты адиабатически (достаточно медленно) переводятся в основное состояние, которое и кодирует в себе искомое решение. Давайте теперь разберем подробнее данный подход.


\section{Задачи оптимизации и семплирования}
\label{\detokenize{book/dwave/ru/dwave:id3}}
\sphinxAtStartPar
Квантовый отжигатель (\sphinxcode{\sphinxupquote{Quantum Annealing Processor}}) в силу своей физической реализации приводит к решениям, соответствующим низкоэнергетическим состояниям физической системы. В то время как задачи оптимизации (\sphinxcode{\sphinxupquote{Optimization Problems}}) требуют глобального минимума энергии, иногда хватает и семплов из состояний, близких к основным. Такие задачи называются задачами семплирования (\sphinxcode{\sphinxupquote{Probabilistic Sampling Problems}}).

\sphinxAtStartPar
Классическим примером задачи оптимизации в контексте квантового отжига является, например, \sphinxhref{../../problems/ru/copt.html\#id7}{задача коммивояжера}. Квантовая физика, в силу своей природы, может помогать решать такого рода задачи, так как они могут быть переформулированы в задачи дискретной минимизации энергии. Одно из основных правил физики состоит в том, что все физические системы стремятся к состояниям с минимальной энергией. Например, объекты скользят с холмов, горячие вещи со временем остывают и так далее. Этот принцип соблюдается и в мире квантовой физики. Квантовый отжиг просто использует квантовую физику для поиска низкоэнергетических состояний системы и, как следствие, оптимального или почти оптимального решения.

\sphinxAtStartPar
В свою очередь, задачи семплирования, часто являющиеся вычислительно сложными (например, задача семплирования из ограниченной машины Больцмана), идеально подходят к квантовым отжигателям в случае когда необходимо построить вероятностную модель, а доступ к полному вероятностному распределению состояний не представляется возможным. Такая постановка задачи подходит например, чтобы обучить модель генерировать изображения рукописных цифр из знаменитого датасета \sphinxcode{\sphinxupquote{MNIST}}. По этой теме можно послушать \sphinxhref{https://ods.ai/tracks/quantum-computing-df2021/blocks/67a583ab-0dc6-4b4f-93c8-209aa1d352e1}{доклад} Никиты Щуцкого “Quantum\sphinxhyphen{}Classical Neural Networks in Computational Drug Design”, сделанный в рамках трека ODS по квантовым вычислениям.


\section{Квантовая физика под капотом}
\label{\detokenize{book/dwave/ru/dwave:id4}}
\sphinxAtStartPar
Как помним, квантовый гамильтониан является оператором, ставящим в соответствие собственным состояниям системы ее энергии. Множество собственных чисел гамильтониана называется его спектром. В квантовом отжигателе \sphinxcode{\sphinxupquote{D\sphinxhyphen{}Wave}} гамильтониан имеет следующую форму:
\begin{equation*}
\begin{split}
\mathcal{H}_{Ising} =
    A(t) \cdot
    \underbrace{
        \left( -\sum_{i} \hat{\sigma}_{x}^{(i)} \right)
    }_{
        \text{Initial Hamiltonian}
    }
    + B(t) \cdot
    \underbrace{
        \left(
            \sum_{i} h_{i} \hat{\sigma}_{z}^{(i)}
            +\sum_{i,j} J_{i, j} \hat{\sigma}_{z}^{(i)} \hat{\sigma}_{z}^{(j)}
        \right)
    }_{
        \text{Final Hamiltonian}
    },
\end{split}
\end{equation*}
\sphinxAtStartPar
где \(A(t)\), \(B(t)\) являются функциями от времени \(t \in [0, T]\), \(\hat{\sigma}_{x, z}^{(i)}\) – операторами Паули, действующими на кубиты, а \(h_i\) и \(J_{i,j}\) – локальными полями и взаимодействиями кубитов соответственно. Физически, вектор \(h\) соответствует внешнему магнитному полю, применимому к каждому кубиту. В свою очередь, матрица \(J\) отвечает за попарные \(ZZ\) взаимодействия кубитов. Функции \(A(t)\), \(B(t)\) должны быть такими, что \(A(0)=B(T)=1\), \(A(T)=B(0)=0\), то есть гамильтониан со временем полностью переходит из \(\mathcal{H}_{Initial}\) в \(\mathcal{H}_{Final}\). Вид этих функций называется расписанием отжига или \sphinxcode{\sphinxupquote{annealing schedule}}.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=444\sphinxpxdimen]{{fig_31}.png}
\caption{Пример расписания отжига: функций \(A(t)\), \(B(t)\).}\label{\detokenize{book/dwave/ru/dwave:id8}}\end{figure}

\sphinxAtStartPar
Отметим также, что матрица взаимодействий кубитов \(J_{i,j}\) ограничена графом взаимодействий кубитов, который обычно фиксирован. Для практического применения в коде детальное представление этого графа знать не нужно, но ознакомиться с ним можно на специально посвященной этому \sphinxhref{https://docs.dwavesys.com/docs/latest/c\_gs\_4.html\#getting-started-topologies}{странице документации \sphinxcode{\sphinxupquote{D\sphinxhyphen{}Wave}}}.

\sphinxAtStartPar
Разберем подробно, что же представляет собой данный гамильтониан. Начальный гамильтониан \(\mathcal{H}_{Initial}\) представляет собой гамильтониан с основным состоянием состоящим из суперпозиции \(0\) и \(1\). Этот гамильтониан в литературе также называется \sphinxcode{\sphinxupquote{tunneling Hamiltonian}}. Финальный гамильтониан \(\mathcal{H}_{Final}\), в свою очередь, является гамильтонианом задачи (его называют также \sphinxcode{\sphinxupquote{Problem Hamiltonian}}), чье основное состояние и представляет собой решение, параметры которого находятся в матрице взаимодействий кубитов \(J_{i,j}\) и векторе локальных полей \(h_i\). Обратим внимание на тот факт, что \(\mathcal{H}_{Final}\) – полностью классический гамильтониан, он диагонален в вычислительном базисе (\(\sigma_z\)). Каждое собственное (классическое) состояние этого гамильтониана соответствует классической функции потерь для решаемой задачи.

\sphinxAtStartPar
Таким образом, в квантовом отжиге система инициализируется в основном состоянии начального гамильтониана – такое состояние легко приготовить экспериментально, то есть система легко переходит в основное состояние начального гамильтониана в силу его простоты. По мере самого отжига, исходя из \sphinxhref{https://ru.wikipedia.org/wiki/\%D0\%90\%D0\%B4\%D0\%B8\%D0\%B0\%D0\%B1\%D0\%B0\%D1\%82\%D0\%B8\%D1\%87\%D0\%B5\%D1\%81\%D0\%BA\%D0\%B0\%D1\%8F\_\%D1\%82\%D0\%B5\%D0\%BE\%D1\%80\%D0\%B5\%D0\%BC\%D0\%B0}{адиабатической теоремы}, основное состояние начального гамильтониана переходит в основное состояние финального гамильтониана. Для наглядности, на графике ниже (взят из \sphinxhref{https://arxiv.org/pdf/1903.06559.pdf}{этой} статьи) показано типичное поведение первых энергетических уровней гамильтониана. Основному состоянию соответствует кривая с наименьшей энергией.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=444\sphinxpxdimen]{{fig_11}.png}
\caption{Типичная зависимость от времени энергетических уровней гамильтонианов, используемых в квантовом отжиге}\label{\detokenize{book/dwave/ru/dwave:id9}}\end{figure}

\sphinxAtStartPar
Очень важно отметить, что для успеха данного алгоритма необходимо выполнение условий адиабатической теоремы:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
минимальная энергетическая щель \(\Delta_{\text{min}}\) (разница энергий основного и первого возбужденного состояний) не должна обращаться в \(0\) в любой момент времени;

\item {} 
\sphinxAtStartPar
функции \(A(t)\) и \(B(t)\) должны меняться достаточно медленно.

\end{enumerate}

\sphinxAtStartPar
Можно показать, что второе условие может быть переформулировано в виде \(T \gg \frac{1}{\Delta^2_{\text{min}}}\). Именно это неравенство ответственно за наибольшую проблему, с которой можно столкнуться при практической реализации данного алгоритма. В частности, из него видно, что время алгоритма зависит от минимальной (за все время алгоритма) энергетической щели, которая не должна быть слишком маленькой, иначе время алгоритма станет слишком большим. Если же щель будет слишком большой (что соответствует быстрому отжигу), то система может перейти в возбужденное состояние. Однако, основные состояний начального и финального гамильтонианов являются, качественно, сильно разными. Основное состояние начального гамильтониана является тривиальным, в то время как основное состояние финального гамильтониана кодирует в себе решение сложной задачи оптимизации. Это наталкивает нас на мысль, что в течение процесса квантового отжига, система может пережить квантовый фазовый переход.

\sphinxAtStartPar
Для квантовых фазовых переходов первого рода известно, что \(\Delta_{\text{min}} \propto e^{-N}\), где \(N\) – количество кубитов, что приводит к \(T \propto e^{2N}\), то есть экспоненциально большому времени алгоритма. В этом случае задача считается “сложной”, так как алгоритм не масштабируется.

\sphinxAtStartPar
В свою очередь, для квантовых фазовых переходов второго рода верно, что \(\Delta_{\text{min}} \propto N^{-l}\) (\(l>0\)), что приводит к \(T \propto N^{2l}\), то есть полиномиальному времени алгоритма и задача считается “простой”.


\section{Пример: задача раскраски графа}
\label{\detokenize{book/dwave/ru/dwave:id5}}
\sphinxAtStartPar
Давайте теперь попробуем решить с помощью квантового отжига следующую задачу комбинаторной оптимизации – \sphinxhref{https://ru.wikipedia.org/wiki/\%D0\%A0\%D0\%B0\%D1\%81\%D0\%BA\%D1\%80\%D0\%B0\%D1\%81\%D0\%BA\%D0\%B0\_\%D0\%B3\%D1\%80\%D0\%B0\%D1\%84\%D0\%BE\%D0\%B2}{задачу раскраски графа}, или, как она называется в англоязычной литературе – \sphinxcode{\sphinxupquote{graph coloring problem}}. В этой задаче необходимо с помощью заданного числа цветов присвоить цвет каждой вершине графа так, чтобы любые две вершины, имеющие общее ребро, имели разные цвета. Назовем граф \(G = (E,V)\), где \(E\) – множество ребер, а \(V\) – множество вершин. Для наглядности, рассмотрим эту задачу в виде раскраски карты Канады четырьмя цветами – необходимо каждой канадской провинции (аналогу штата в США) присвоить цвет так, чтобы все граничащие провинции имели разные цвета. Этот пример находится также в \sphinxhref{https://docs.ocean.dwavesys.com/en/latest/examples/map\_coloring.html\#map-coloring}{документации} \sphinxcode{\sphinxupquote{D\sphinxhyphen{}Wave}}. Визуально, решение этой задачи будет выглядеть как на следующем графике.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=444\sphinxpxdimen]{{fig_21}.png}
\caption{Раскрас карты Канады с помощью четырех цветов.}\label{\detokenize{book/dwave/ru/dwave:id10}}\end{figure}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{D\sphinxhyphen{}Wave}} предоставляют доступ к трем видам бэкендов: квантовому, классическому и гибридному. Так как курс посвящен квантовому машинному обучению, воспользуемся непосредственно квантовым отжигателем. Для этого необходимо получить токен, который генерируется в личном кабинете пользователя при регистрации в \sphinxhref{https://cloud.dwavesys.com/leap/}{облачном сервисе D\sphinxhyphen{}Wave}.

\sphinxAtStartPar
Импортируем нужные библиотеки.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{dwavebinarycsp}
\PYG{k+kn}{from} \PYG{n+nn}{dwave}\PYG{n+nn}{.}\PYG{n+nn}{system} \PYG{k+kn}{import} \PYG{n}{DWaveSampler}\PYG{p}{,} \PYG{n}{EmbeddingComposite}
\PYG{k+kn}{import} \PYG{n+nn}{networkx} \PYG{k}{as} \PYG{n+nn}{nx}
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Отобразим задачу на граф, где провинции будут вершинами графа, а границы – его ребрами. Например \sphinxcode{\sphinxupquote{(AB, BC)}} – ребро, соответствующее границе между провинциями Альберта и Британская Колумбия. Обозначения провинций представлены в таблице ниже.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
код
&\sphinxstyletheadfamily 
\sphinxAtStartPar
провинция
&\sphinxstyletheadfamily 
\sphinxAtStartPar
код
&\sphinxstyletheadfamily 
\sphinxAtStartPar
провинция
&\sphinxstyletheadfamily 
\sphinxAtStartPar
код
&\sphinxstyletheadfamily 
\sphinxAtStartPar
провинция
\\
\hline
\sphinxAtStartPar
AB
&
\sphinxAtStartPar
Alberta
&
\sphinxAtStartPar
BC
&
\sphinxAtStartPar
British Columbia
&
\sphinxAtStartPar
MB
&
\sphinxAtStartPar
Manitoba
\\
\hline
\sphinxAtStartPar
NB
&
\sphinxAtStartPar
New Brunswick
&
\sphinxAtStartPar
NL
&
\sphinxAtStartPar
Newfoundland and Labrador
&
\sphinxAtStartPar
NS
&
\sphinxAtStartPar
Nova Scotia
\\
\hline
\sphinxAtStartPar
NT
&
\sphinxAtStartPar
Northwest Territories
&
\sphinxAtStartPar
NU
&
\sphinxAtStartPar
Nunavut
&
\sphinxAtStartPar
ON
&
\sphinxAtStartPar
Ontario
\\
\hline
\sphinxAtStartPar
PE
&
\sphinxAtStartPar
Prince Edward Island
&
\sphinxAtStartPar
QC
&
\sphinxAtStartPar
Quebec
&
\sphinxAtStartPar
SK
&
\sphinxAtStartPar
Saskatchewan
\\
\hline
\sphinxAtStartPar
YT
&
\sphinxAtStartPar
Yukon
&
\sphinxAtStartPar

&
\sphinxAtStartPar

&
\sphinxAtStartPar

&
\sphinxAtStartPar

\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{provinces} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{AB}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{BC}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{MB}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{NB}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{NL}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{NS}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{NT}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{NU}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ON}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{PE}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{QC}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{SK}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{YT}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}
\PYG{n}{neighbors} \PYG{o}{=} \PYG{p}{[}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{AB}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{BC}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{AB}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{NT}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{AB}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{SK}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{BC}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{NT}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{BC}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{YT}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,}
             \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{MB}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{NU}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{MB}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ON}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{MB}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{SK}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{NB}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{NS}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{NB}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{QC}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,}
             \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{NL}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{QC}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{NT}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{NU}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{NT}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{SK}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{NT}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{YT}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ON}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{QC}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Чтобы “объяснить” отжигателю эту задачу, необходимо сформулировать ее в виде \sphinxhref{https://ru.wikipedia.org/wiki/\%D0\%A3\%D0\%B4\%D0\%BE\%D0\%B2\%D0\%BB\%D0\%B5\%D1\%82\%D0\%B2\%D0\%BE\%D1\%80\%D0\%B5\%D0\%BD\%D0\%B8\%D0\%B5\_\%D0\%BE\%D0\%B3\%D1\%80\%D0\%B0\%D0\%BD\%D0\%B8\%D1\%87\%D0\%B5\%D0\%BD\%D0\%B8\%D0\%B9}{задачи удовлетворения ограничений} (\sphinxcode{\sphinxupquote{Constraint Satisfaction Problem (CSP)}}). В свою очередь, библиотеки \sphinxcode{\sphinxupquote{D\sphinxhyphen{}Wave}} умеют отображать ее на модель Изинга. Математически, это выглядит следующим образом: каждой провинции (вершине графа) сопоставляется 4 бинарные переменные (каждая отвечает за один из четырех цветов) \(x_i \in \{0,1\}\), где одна из переменных “выбирает” цвет и переключается в состояние \(x_i = 1\), как и остальные три переменные остаются в состоянии \(0\).

\sphinxAtStartPar
Теперь займемся ограничениями. Следующая функция выражает ограничение того, что соседние вершины в графе не могут быть одного и того же цвета. Область ее определения и значения – булевы переменные.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{not\PYGZus{}both\PYGZus{}1}\PYG{p}{(}\PYG{n}{v}\PYG{p}{:} \PYG{n+nb}{bool}\PYG{p}{,} \PYG{n}{u}\PYG{p}{:} \PYG{n+nb}{bool}\PYG{p}{)} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n+nb}{bool}\PYG{p}{:}
    \PYG{k}{return} \PYG{o+ow}{not} \PYG{p}{(}\PYG{n}{v} \PYG{o+ow}{and} \PYG{n}{u}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Зададим конфигурации цветов.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{one\PYGZus{}color\PYGZus{}configurations} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZcb{}}
\PYG{n}{colors} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{one\PYGZus{}color\PYGZus{}configurations}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Создадим объект класса \sphinxcode{\sphinxupquote{CSP}} и зададим следующие ограничения:
\begin{itemize}
\item {} 
\sphinxAtStartPar
каждая провинция имеет лишь один цвет;

\item {} 
\sphinxAtStartPar
каждая ей соседняя не может иметь такой же цвет.

\end{itemize}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{csp} \PYG{o}{=} \PYG{n}{dwavebinarycsp}\PYG{o}{.}\PYG{n}{ConstraintSatisfactionProblem}\PYG{p}{(}\PYG{n}{dwavebinarycsp}\PYG{o}{.}\PYG{n}{BINARY}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{province} \PYG{o+ow}{in} \PYG{n}{provinces}\PYG{p}{:}
    \PYG{n}{variables} \PYG{o}{=} \PYG{p}{[}\PYG{n}{province}\PYG{o}{+}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{colors}\PYG{p}{)}\PYG{p}{]}
    \PYG{n}{csp}\PYG{o}{.}\PYG{n}{add\PYGZus{}constraint}\PYG{p}{(}\PYG{n}{one\PYGZus{}color\PYGZus{}configurations}\PYG{p}{,} \PYG{n}{variables}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{neighbor} \PYG{o+ow}{in} \PYG{n}{neighbors}\PYG{p}{:}
    \PYG{n}{v}\PYG{p}{,} \PYG{n}{u} \PYG{o}{=} \PYG{n}{neighbor}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{colors}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{variables} \PYG{o}{=} \PYG{p}{[}\PYG{n}{v}\PYG{o}{+}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{,} \PYG{n}{u}\PYG{o}{+}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{]}
        \PYG{n}{csp}\PYG{o}{.}\PYG{n}{add\PYGZus{}constraint}\PYG{p}{(}\PYG{n}{not\PYGZus{}both\PYGZus{}1}\PYG{p}{,} \PYG{n}{variables}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Конвертируем модель из \sphinxcode{\sphinxupquote{CSP}} в \sphinxcode{\sphinxupquote{BQM}} (\sphinxcode{\sphinxupquote{Binary Quadratic Model}}) – бинарную квадратичную модель. Это модель Изинга, в которой значения спинов \(\sigma_i = 0.5 * (x_i + 1)\). Таким образом, каждая провинция Канады и ее цвет будет кодироваться четырьмя спинами, один из которых направлен вверх (вниз), пока остальные направлены вниз (вверх).

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{bqm} \PYG{o}{=} \PYG{n}{dwavebinarycsp}\PYG{o}{.}\PYG{n}{stitch}\PYG{p}{(}\PYG{n}{csp}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Создадим семплер, передав в него \sphinxcode{\sphinxupquote{API Token}}, создав прежде переменное окружение \sphinxcode{\sphinxupquote{DWAVE\_TOKEN}}, к примеру, в терминале посредством \sphinxcode{\sphinxupquote{export DWAVE\_TOKEN=insert\_api\_token}}:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{os}

\PYG{n}{base\PYGZus{}sampler} \PYG{o}{=} \PYG{n}{DWaveSampler}\PYG{p}{(}\PYG{n}{token}\PYG{o}{=}\PYG{n}{os}\PYG{o}{.}\PYG{n}{environ}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{DWAVE\PYGZus{}TOKEN}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Дадим задание квантовому семплеру на \(1000\).

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sampler} \PYG{o}{=} \PYG{n}{EmbeddingComposite}\PYG{p}{(}\PYG{n}{base\PYGZus{}sampler}\PYG{p}{)}
\PYG{n}{sampleset} \PYG{o}{=} \PYG{n}{sampler}\PYG{o}{.}\PYG{n}{sample}\PYG{p}{(}\PYG{n}{bqm}\PYG{p}{,} \PYG{n}{num\PYGZus{}reads}\PYG{o}{=}\PYG{l+m+mi}{1000}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Canada Map Coloring}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Проверим, что было найдено решение задачи,

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sample} \PYG{o}{=} \PYG{n}{sampleset}\PYG{o}{.}\PYG{n}{first}\PYG{o}{.}\PYG{n}{sample}
\PYG{k}{if} \PYG{o+ow}{not} \PYG{n}{csp}\PYG{o}{.}\PYG{n}{check}\PYG{p}{(}\PYG{n}{sample}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Failed to color map. Try sampling again.}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{k}{else}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{sample}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZob{}\PYGZsq{}AB0\PYGZsq{}: 0, \PYGZsq{}AB1\PYGZsq{}: 0, \PYGZsq{}AB2\PYGZsq{}: 0, \PYGZsq{}AB3\PYGZsq{}: 1, \PYGZsq{}BC0\PYGZsq{}: 1, \PYGZsq{}BC1\PYGZsq{}: 0, \PYGZsq{}BC2\PYGZsq{}: 0, \PYGZsq{}BC3\PYGZsq{}: 0, \PYGZsq{}MB0\PYGZsq{}: 0, \PYGZsq{}MB1\PYGZsq{}: 0, \PYGZsq{}MB2\PYGZsq{}: 0, \PYGZsq{}MB3\PYGZsq{}: 1, \PYGZsq{}NB0\PYGZsq{}: 1, \PYGZsq{}NB1\PYGZsq{}: 0, \PYGZsq{}NB2\PYGZsq{}: 0, \PYGZsq{}NB3\PYGZsq{}: 0, \PYGZsq{}NL0\PYGZsq{}: 1, \PYGZsq{}NL1\PYGZsq{}: 0, \PYGZsq{}NL2\PYGZsq{}: 0, \PYGZsq{}NL3\PYGZsq{}: 0, \PYGZsq{}NS0\PYGZsq{}: 0, \PYGZsq{}NS1\PYGZsq{}: 0, \PYGZsq{}NS2\PYGZsq{}: 0, \PYGZsq{}NS3\PYGZsq{}: 1, \PYGZsq{}NT0\PYGZsq{}: 0, \PYGZsq{}NT1\PYGZsq{}: 0, \PYGZsq{}NT2\PYGZsq{}: 1, \PYGZsq{}NT3\PYGZsq{}: 0, \PYGZsq{}NU0\PYGZsq{}: 1, \PYGZsq{}NU1\PYGZsq{}: 0, \PYGZsq{}NU2\PYGZsq{}: 0, \PYGZsq{}NU3\PYGZsq{}: 0, \PYGZsq{}ON0\PYGZsq{}: 0, \PYGZsq{}ON1\PYGZsq{}: 1, \PYGZsq{}ON2\PYGZsq{}: 0, \PYGZsq{}ON3\PYGZsq{}: 0, \PYGZsq{}PE0\PYGZsq{}: 0, \PYGZsq{}PE1\PYGZsq{}: 1, \PYGZsq{}PE2\PYGZsq{}: 0, \PYGZsq{}PE3\PYGZsq{}: 0, \PYGZsq{}QC0\PYGZsq{}: 0, \PYGZsq{}QC1\PYGZsq{}: 0, \PYGZsq{}QC2\PYGZsq{}: 1, \PYGZsq{}QC3\PYGZsq{}: 0, \PYGZsq{}SK0\PYGZsq{}: 0, \PYGZsq{}SK1\PYGZsq{}: 1, \PYGZsq{}SK2\PYGZsq{}: 0, \PYGZsq{}SK3\PYGZsq{}: 0, \PYGZsq{}YT0\PYGZsq{}: 0, \PYGZsq{}YT1\PYGZsq{}: 1, \PYGZsq{}YT2\PYGZsq{}: 0, \PYGZsq{}YT3\PYGZsq{}: 0\PYGZcb{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Мы получили словарь \sphinxcode{\sphinxupquote{sample}}, который будет выглядеть следующим образом: его ключи будут кодировать провинцию и цвет, а значения – бинарные переменные, означающие раскрашена ли провинция этим цветом. Этот словарь – семпл из состояния, полученного при решении данной задачи методом квантового отжига. Построим визуализацию решения в виде графа с раскрашенными вершинами.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{typing} \PYG{k+kn}{import} \PYG{n}{List}
\PYG{k+kn}{from} \PYG{n+nn}{typing} \PYG{k+kn}{import} \PYG{n}{Tuple}
\PYG{k+kn}{from} \PYG{n+nn}{typing} \PYG{k+kn}{import} \PYG{n}{Dict}


\PYG{k}{def} \PYG{n+nf}{plot\PYGZus{}map}\PYG{p}{(}\PYG{n}{sample}\PYG{p}{:} \PYG{n}{Dict}\PYG{p}{[}\PYG{n+nb}{str}\PYG{p}{,} \PYG{n+nb}{bool}\PYG{p}{]}\PYG{p}{,} \PYG{n}{provinces}\PYG{p}{:} \PYG{n}{List}\PYG{p}{[}\PYG{n+nb}{str}\PYG{p}{]}\PYG{p}{,} \PYG{n}{neighbors}\PYG{p}{:} \PYG{n}{List}\PYG{p}{[}\PYG{n}{Tuple}\PYG{p}{[}\PYG{n+nb}{str}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{k+kc}{None}\PYG{p}{:}
    \PYG{n}{G} \PYG{o}{=} \PYG{n}{nx}\PYG{o}{.}\PYG{n}{Graph}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{G}\PYG{o}{.}\PYG{n}{add\PYGZus{}nodes\PYGZus{}from}\PYG{p}{(}\PYG{n}{provinces}\PYG{p}{)}
    \PYG{n}{G}\PYG{o}{.}\PYG{n}{add\PYGZus{}edges\PYGZus{}from}\PYG{p}{(}\PYG{n}{neighbors}\PYG{p}{)}
    \PYG{n}{color\PYGZus{}map} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
    \PYG{k}{for} \PYG{n}{province} \PYG{o+ow}{in} \PYG{n}{provinces}\PYG{p}{:}
          \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{colors}\PYG{p}{)}\PYG{p}{:}
            \PYG{k}{if} \PYG{n}{sample}\PYG{p}{[}\PYG{n}{province}\PYG{o}{+}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{]}\PYG{p}{:}
                \PYG{n}{color\PYGZus{}map}\PYG{p}{[}\PYG{n}{province}\PYG{p}{]} \PYG{o}{=} \PYG{n}{i}
    \PYG{n}{node\PYGZus{}colors} \PYG{o}{=} \PYG{p}{[}\PYG{n}{color\PYGZus{}map}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{n}{node}\PYG{p}{)} \PYG{k}{for} \PYG{n}{node} \PYG{o+ow}{in} \PYG{n}{G}\PYG{o}{.}\PYG{n}{nodes}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}
    \PYG{n}{nx}\PYG{o}{.}\PYG{n}{draw\PYGZus{}circular}\PYG{p}{(}\PYG{n}{G}\PYG{p}{,} \PYG{n}{with\PYGZus{}labels}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{node\PYGZus{}color}\PYG{o}{=}\PYG{n}{node\PYGZus{}colors}\PYG{p}{,} \PYG{n}{node\PYGZus{}size}\PYG{o}{=}\PYG{l+m+mi}{3000}\PYG{p}{,} \PYG{n}{cmap}\PYG{o}{=}\PYG{n}{plt}\PYG{o}{.}\PYG{n}{cm}\PYG{o}{.}\PYG{n}{rainbow}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{plot\PYGZus{}map}\PYG{p}{(}\PYG{n}{sample}\PYG{p}{,} \PYG{n}{provinces}\PYG{p}{,} \PYG{n}{neighbors}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{dwave_19_0}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
После запуска функции \sphinxcode{\sphinxupquote{plot\_map}}, получим изображение графа, в котором вершины будут соответствовать провинциям и цветам, а ребра – границам между провинциями. Вы можете сами убедиться, что ни одна провинция не будет иметь такой же цвет, как и ее сосед. Также отметим, что такая задача может иметь не одно решение, поэтому не нужно ожидать, что граф будет получаться всегда одним и тем же.

\sphinxAtStartPar
Таким образом, сумели решить задачу раскраски графа с помощью квантового отжигателя.


\section{Пример: задача электронной структуры молекулы}
\label{\detokenize{book/dwave/ru/dwave:id6}}
\sphinxAtStartPar
Поскольку в курсе также имеем дело с задачами квантовой химии, давайте разберем соответствующий пример из {[}\hyperlink{cite.book/bibliography:id69}{TKTD20}{]}. В данной статье авторы осуществляют точную диагонализацию физического гамильтониана с помощью квантового отжигателя \sphinxcode{\sphinxupquote{D\sphinxhyphen{}Wave}}. Этот подход они называют \sphinxcode{\sphinxupquote{QAE}} – \sphinxcode{\sphinxupquote{Quantum Annealing Eigensolver}}. Разберем эту статью гораздо менее подробно, чем предыдущую задачу.

\sphinxAtStartPar
Основная проблема применения квантового отжига в квантовой химии – найти отображение гамильтониана электронной структуры молекулы на гамильтониан Изинга (вспомним \(\mathcal{H}_{Final}\) из теории квантового отжига, описанной в начале этой лекции). Обычно такие отображения начинаются с записи электронного гамильтониана в \sphinxhref{https://en.wikipedia.org/wiki/Second\_quantization}{формализме вторичного квантования}, а затем используют преобразования \sphinxhref{../../problems2qml/ru/jordanwigner.html\#id6}{Жордана\sphinxhyphen{}Вигнера} (\sphinxcode{\sphinxupquote{Jordan\sphinxhyphen{}Wigner transformation}}) или Бравого\sphinxhyphen{}Китаева (\sphinxcode{\sphinxupquote{Bravyi\sphinxhyphen{}Kitaev transformation}}). Минусы такого подхода заключаются в том, что:
\begin{itemize}
\item {} 
\sphinxAtStartPar
растет число кубитов, необходимое для описания системы на языке (напомним, классического, а значит – диагонального) гамильтониана Изинга

\item {} 
\sphinxAtStartPar
в гамильтониане появляются элементы вне диагонали (благодаря членам содержащим \(\sigma^x\), \(\sigma^y\)).

\end{itemize}

\sphinxAtStartPar
Подход авторов к задаче состоит из двух частей. Первый шаг состоит из составления электронного гамильтониана в базисе \sphinxhref{https://en.wikipedia.org/wiki/Slater\_determinant}{слетеровских детерминантов}, которые в свою очередь составлены из одноэлектронных самосогласованных \sphinxhref{https://en.wikipedia.org/wiki/Hartree\%E2\%80\%93Fock\_method}{орбиталей Хартри\sphinxhyphen{}Фока}.

\sphinxAtStartPar
В свою очередь, второй этап состоит из нахождения первых нескольких собственных векторов (волновых функций) и собственных значений (соответствующих энергий) этого гамильтониана. Под капотом, задача нахождения собственных значений и собственных векторов отображается на задачу квантового отжига. Это самая хитрая часть алгоритма. Это отображение построено на минимизации отношения Рэлея (\sphinxcode{\sphinxupquote{Rayleigh\sphinxhyphen{}Ritz quotient}}, \sphinxcode{\sphinxupquote{RRQ}}) \(R_{\mathcal{H}}=\langle \psi | \mathcal{H} | \psi \rangle / \langle \psi | \psi \rangle \), где \(\mathcal{H}\) – электронный гамильтониан, а \(\psi\) – волновая функция. Соответствующая минимальному \(R\) волновая функция кодируется в бинарный вектор с помощью \sphinxcode{\sphinxupquote{power\sphinxhyphen{}of\sphinxhyphen{}two scheme}}. Подробней про это можно почитать в статьях, на которые ссылается оригинальная работа. Примечательно, что метод минимизации отношения Рэлея соответствует вариационному методу в квантовой химии.

\sphinxAtStartPar
На следующей схеме (взята из оригинальной работы) изображен алгоритм \sphinxcode{\sphinxupquote{QAE}} в общем виде. В нашей терминологии, \(A\) соответствует \(\mathcal{H}\), \(v\) – \(\psi\). \(F(v)=\langle v, A v \rangle + \lambda \cdot \langle v, v \rangle \) – функция потерь в формате \sphinxcode{\sphinxupquote{QUBO}} – \sphinxcode{\sphinxupquote{Quantum Unconstrained Binary Optimization}} (функция потерь на языке \sphinxcode{\sphinxupquote{QUBO}} получается, если в функции потерь на языке модели Изинга, каждую спиновую переменную \(\sigma_i \ \in \ \{-1,1\}\) преобразовать по закону \(x_i = (\sigma_i + 1)/2\), \(\sigma_i \ \in \ \{0,1\}\)), с классическим множителем лагранжа \(\lambda\).

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=444\sphinxpxdimen]{{fig_41}.png}
\caption{Схема алгоритма \sphinxcode{\sphinxupquote{QAE}}.}\label{\detokenize{book/dwave/ru/dwave:id11}}\end{figure}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=444\sphinxpxdimen]{{fig_51}.png}
\caption{Результаты алгоритма на примере молекулы \(H_3^{+}\).}\label{\detokenize{book/dwave/ru/dwave:id12}}\end{figure}

\sphinxstepscope


\chapter{Сравнение квантовой и классической имитации отжига}
\label{\detokenize{book/dwave/ru/annealing_paper_1998:annealing-paper-1998}}\label{\detokenize{book/dwave/ru/annealing_paper_1998:id1}}\label{\detokenize{book/dwave/ru/annealing_paper_1998::doc}}
\sphinxAtStartPar
Автор(ы):
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/dmburd}{Бурдейный Дмитрий}

\end{itemize}


\section{Описание лекции}
\label{\detokenize{book/dwave/ru/annealing_paper_1998:id2}}
\sphinxAtStartPar
В этой лекции рассмотрим каноническую работу \sphinxstylestrong{Quantum annealing in the transverse Ising model}, опубликованную в 1998 году {[}\hyperlink{cite.book/bibliography:id45}{KN98}{]}. В ней двумя способами численно решается задача о нахождении основного состояния системы взаимодействующих спинов. Первый способ – обычная классическая имитация отжига, второй – имитация квантового отжига. Результаты применения этих подходов анализируются и сравниваются между собой.


\section{Постановка задачи}
\label{\detokenize{book/dwave/ru/annealing_paper_1998:id4}}
\sphinxAtStartPar
Итак, рассматривается одномерная система взаимодействующих спинов, которая описывается гамильтонианом Изинга (полностью аналогичным тому, который был представлен в {\hyperref[\detokenize{book/problems/ru/ising::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{базовой лекции}}}} о модели Изинга):
\begin{equation*}
\begin{split}
\hat{H}_{0} =
    -\sum_{i,j} J_{ij} \hat{\sigma}^{z}_i \hat{\sigma}^{z}_{j}
    - h \sum_{i} \hat{\sigma}^{z}_i,
\end{split}
\end{equation*}
\sphinxAtStartPar
где \(J_{ij}\) – величины обменного взаимодействия для пар спинов, \(h\) – внешнее поле (оно направлено вдоль оси \(z\) и потому называется продольным – \sphinxstyleemphasis{longitudinal}). Требуется найти основное состояние гамильтониана \(\hat{H}_{0}\), т.е. его собственное состояние, соответствующее его минимальному собственному значению.

\sphinxAtStartPar
Далее разберем численное решение этой задачи с помощью обычной классической имитации отжига (\sphinxstyleemphasis{simulated annealing}, SA для краткости) и с помощью квантовой имитации отжига (\sphinxstyleemphasis{quantum annealing} – QA).


\section{Имитация квантового отжига (QA)}
\label{\detokenize{book/dwave/ru/annealing_paper_1998:qa}}
\sphinxAtStartPar
Как в {\hyperref[\detokenize{book/dwave/ru/dwave::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{предыдущей лекции}}}} об аннилере D\sphinxhyphen{}Wave, добавляем к “целевому”  гамильтониану \(\hat{H}_{0}\) (\sphinxstyleemphasis{problem Hamiltonian}) слагаемое, которое называется \sphinxstyleemphasis{tunneling Hamiltonian}:
\begin{equation}\label{equation:book/dwave/ru/annealing_paper_1998:eqn:QA_Hamilt}
\begin{split}
\hat{H}(t) =
    \hat{H}_{0} - \Gamma(t) \sum_{i} \hat{\sigma}^{x}_i
    = \hat{H}_{0} + \hat{H}_{tun}(t),
\end{split}
\end{equation}
\sphinxAtStartPar
где \(\hat{H}_{tun}(t)\) зависит от времени и отвечает за квантовомеханическое туннелирование между различными собственными состояниями гамильтониана \(\hat{H}_{0}\). Оператор \(\hat{H}_{tun}(t)\) соответствует приложенному внешнему магнитному полю вдоль оси \(x\) (т.е. поперечному, \sphinxstyleemphasis{transverse}). Когда величина \(\Gamma(t)\) очень велика по сравнению с \(J_{i j}\) и \(h\), собственное состояние гамильтониана \(\hat{H}(t)\), соответствующее его минимальному собственному значению, представляет собой линейную комбинацию всевозможных состояний системы с приблизительно равными амплитудами вероятностей ориентации каждого спина вверх и вниз. Если достаточно медленно уменьшать \(\Gamma(t)\) с очень большой величины до нуля, можно надеяться (в соответствии с адиабатической теоремой), что приведем систему в основное состояние гамильтониана \(\hat{H}_{0}\).

\sphinxAtStartPar
В обсуждаемой статье в качестве примеров рассматриваются три различных закона изменения \(\Gamma(t)\):
\begin{itemize}
\item {} 
\sphinxAtStartPar
\(\Gamma(t) = \frac{c}{\ln(t+1)},\)

\item {} 
\sphinxAtStartPar
\(\Gamma(t) = \frac{c}{\sqrt{t}},\)

\item {} 
\sphinxAtStartPar
\(\Gamma(t) = \frac{c}{t},\)

\end{itemize}

\sphinxAtStartPar
везде \(t \in (0, +\infty)\) и \(c = \textrm{const}\).

\sphinxAtStartPar
Квантовая динамика системы описывается нестационарным уравнением Шредингера
\begin{equation}\label{equation:book/dwave/ru/annealing_paper_1998:eqn:Schrodinger_timedep}
\begin{split}
i \frac{\partial}{\partial t} \ket{\psi(t)} =
    \hat{H}(t) \ket{\psi(t)}
\end{split}
\end{equation}
\sphinxAtStartPar
Это уравнение решается численно (с помощью дискретизации по времени и применения конечно\sphinxhyphen{}разностной схемы) для небольшой системы (число спинов \(N=8\)). Измерить близость состояния \(\ket{\psi(t)}\) к основному состоянию \(\ket{g}\) гамильтониана \(\hat{H}_{0}\) можно путем вычисления вероятности
\begin{equation*}
\begin{split}
P_{QA}(t) = {\left| \braket{g | \psi(t)} \right|}^2
\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Note}

\sphinxAtStartPar
Основное состояние \(\ket{g}\) для небольшого числа спинов можно найти точно, например, путем полного перебора.
\end{sphinxadmonition}

\sphinxAtStartPar
Кроме того, можно рассмотреть так называемое \sphinxhref{https://en.wikipedia.org/wiki/Quasistatic\_approximation}{\sphinxstyleemphasis{квазистатическое приближение}}. Выберем какое\sphinxhyphen{}нибудь значение \(\Gamma = \textrm{const}\) и решим задачу об основном состоянии \(\ket{\psi_{\Gamma}}\) независящего от времени гамильтониана
\begin{equation*}
\begin{split}
\hat{H}_{0} - \Gamma \sum_{i} \hat{\sigma}^{x}_i
\end{split}
\end{equation*}
\sphinxAtStartPar
Следует ожидать, что при очень медленном изменении \(\Gamma(t)\) вероятность
\begin{equation*}
\begin{split}
P_{QA}^{st}(\Gamma) = {\left| \braket{g | \psi_{\Gamma}} \right|}^2
\end{split}
\end{equation*}
\sphinxAtStartPar
будет близка к \(P_{QA}(t)\) (имеется в виду, что значение \(\Gamma\) соответствует значению \(\Gamma(t)\)). Отличие \(P_{QA}(t)\) от \(P_{QA}^{st}(\Gamma)\) говорит о том, насколько близко состояния системы при динамическом процессе отжига следуют за соответствующими “квазистатическими” состояниями.


\section{Классическая имитация отжига (SA)}
\label{\detokenize{book/dwave/ru/annealing_paper_1998:sa}}
\sphinxAtStartPar
В {\hyperref[\detokenize{book/problems/ru/copt::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{лекции}}}}, посвященной комбинаторной оптимизации, процесс имитации отжига описывался таким образом: выбиралось случайное начальное состояние, затем оно в цикле подвергалось случайной модификации, и новое состояние принималось или отклонялось в соответствии с некоторым критерием. В статье {[}\hyperlink{cite.book/bibliography:id45}{KN98}{]} принят другой подход к SA. Рассматривается так называемое \sphinxhref{https://ru.wikipedia.org/wiki/\%D0\%9E\%D1\%81\%D0\%BD\%D0\%BE\%D0\%B2\%D0\%BD\%D0\%BE\%D0\%B5\_\%D0\%BA\%D0\%B8\%D0\%BD\%D0\%B5\%D1\%82\%D0\%B8\%D1\%87\%D0\%B5\%D1\%81\%D0\%BA\%D0\%BE\%D0\%B5\_\%D1\%83\%D1\%80\%D0\%B0\%D0\%B2\%D0\%BD\%D0\%B5\%D0\%BD\%D0\%B8\%D0\%B5}{\sphinxstyleemphasis{основное кинетическое уравнение}} (англ. \sphinxstyleemphasis{master equation}). Оно описывает классический SA процесс, соответствующий нестационарному уравнению Шредингера \eqref{equation:book/dwave/ru/annealing_paper_1998:eqn:Schrodinger_timedep}. В нашем случае это система обыкновенных дифференциальных уравнений для вероятностей нахождения системы в различных состояниях \(i\) в момент времени \(t\):
\begin{equation}\label{equation:book/dwave/ru/annealing_paper_1998:eqn:SA_master_eqn}
\begin{split}
\frac{d P_i(t)}{d t} =
    \sum_j \mathcal{L}_{i j} P_j(t),
\end{split}
\end{equation}
\sphinxAtStartPar
где \(\mathcal{L}_{i j}\) – вероятность перехода системы из состояния \(j\) в состояние \(i\) (при \(j \neq i\)) в единицу времени. Рассматриваются только элементарные переходы, сопровождающиеся изменением ориентации какого\sphinxhyphen{}либо одного спина (остальные спины при данном переходе не меняют ориентацию). Элементы матрицы переходов записываются следующим образом:
\begin{equation}\label{equation:book/dwave/ru/annealing_paper_1998:eqn:L_trans_matr_elem}
\begin{split}
\mathcal{L}_{i j} =
\begin{cases}
    \frac{1}{1 + \exp \left( \frac{E_i - E_j}{T(t)} \right) } & \quad (\text{single-spin transition}, j \neq i) \\
    -\sum_{k \neq i} \mathcal{L}_{k i} & \quad (j = i) \\
    0 & \quad \text{(otherwise)}
\end{cases}
\end{split}
\end{equation}
\sphinxAtStartPar
Для первого условия правая часть в формуле \eqref{equation:book/dwave/ru/annealing_paper_1998:eqn:L_trans_matr_elem} соответствует \sphinxhref{https://ru.wikipedia.org/wiki/\%D0\%A0\%D0\%B0\%D1\%81\%D0\%BF\%D1\%80\%D0\%B5\%D0\%B4\%D0\%B5\%D0\%BB\%D0\%B5\%D0\%BD\%D0\%B8\%D0\%B5\_\%D0\%91\%D0\%BE\%D0\%BB\%D1\%8C\%D1\%86\%D0\%BC\%D0\%B0\%D0\%BD\%D0\%B0}{распределению Больцмана}. Для понимания полезно проанализировать несколько предельных случаев:
\begin{itemize}
\item {} 
\sphinxAtStartPar
если \(E_i < E_j\) и \(\left| E_i - E_j \right| \gg T(t)\), то вероятность перехода \(j \to i\) близка к 1;

\item {} 
\sphinxAtStartPar
если \(E_i > E_j\) и \(E_i - E_j \gg T(t)\), то вероятность перехода \(j \to i\) близка к 0;

\item {} 
\sphinxAtStartPar
если \(\left| E_i - E_j \right| \ll T(t)\), то вероятность перехода \(j \to i\) близка к \(1/2\).

\end{itemize}

\sphinxAtStartPar
Все случаи соответствуют интуитивным ожиданиям.

\sphinxAtStartPar
Во втором условии в \eqref{equation:book/dwave/ru/annealing_paper_1998:eqn:L_trans_matr_elem} сама сумма (без знака “минус”) равна суммарной вероятности перехода из состояния \(i\) во все остальные состояния. Так что эта сумма должна входить со знаком “минус” в выражение \(\frac{d P_i(t)}{d t}\) для темпа изменения вероятности \(P_i\) нахождения в состоянии \(i\).

\sphinxAtStartPar
Третье условие в \eqref{equation:book/dwave/ru/annealing_paper_1998:eqn:L_trans_matr_elem} означает, что рассматриваем только перевороты одиночных спинов (\sphinxstyleemphasis{single\sphinxhyphen{}spin flip}) в качестве допустимых переходов между состояниями системы.

\sphinxAtStartPar
Зависимость температуры от времени выбирается равной \(\Gamma(t)\):
\begin{equation*}
\begin{split}
T(t) = \Gamma(t)
\end{split}
\end{equation*}
\sphinxAtStartPar
Близость решения задачи SA к основному состоянию \(\ket{g}\) гамильтониана \(\hat{H}_{0}\) выражается величиной вероятности \(P_g(t)\) найти систему в основном состоянии в момент времени \(t\):
\begin{equation*}
\begin{split}
P_{SA}(t) = P_g(t)
\end{split}
\end{equation*}
\sphinxAtStartPar
Аналогично квантовому случаю, введем величину \(P_{SA}^{st}(T)\), которая в квазистатическом приближении близка к \(P_{SA}(t)\) (если величина температуры \(T = T(t)\)).


\section{Анализ и сравнение результатов}
\label{\detokenize{book/dwave/ru/annealing_paper_1998:id6}}
\sphinxAtStartPar
В статье обсуждаются численные результаты для \(P_{SA}\) и \(P_{QA}\) для различных конфигураций обменного взаимодействия и различных вариантов зависимости поперечного поля от времени. В всех случаях продольное внешнее поле выбрано постоянным: \(h = 0.1\).


\subsection{Ферромагнитная модель}
\label{\detokenize{book/dwave/ru/annealing_paper_1998:id7}}
\sphinxAtStartPar
Здесь проводится численный эксперимент для ферромагнитной модели Изинга с \(J_{i j} = \textrm{const}\) для всех пар спинов. Зависимости \(T\) и \(\Gamma\) от времени выбираются такими:
\begin{equation*}
\begin{split}
\Gamma(t) = T(t) = \frac{3}{\ln(t + 1)}
\end{split}
\end{equation*}
\sphinxAtStartPar
Результаты представлены на \hyperref[\detokenize{book/dwave/ru/annealing_paper_1998:qa-sa-fig-1}]{Fig.\@ \ref{\detokenize{book/dwave/ru/annealing_paper_1998:qa-sa-fig-1}}}.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=500\sphinxpxdimen]{{fig_1}.png}
\caption{Зависимости \(P_{SA}(t)\), \(P_{QA}(t)\), \(P_{SA}^{st}(T(t))\) и \(P_{QA}^{st}(\Gamma(t))\) для ферромагнитной модели при \(\Gamma(t) = T(t) = 3 / \ln(t+1)\).}\label{\detokenize{book/dwave/ru/annealing_paper_1998:qa-sa-fig-1}}\end{figure}

\sphinxAtStartPar
Видно, что квазистатическое приближение работает очень хорошо, интересующие нас величины в динамическом процессе очень близки к вычисленным в равновесных условиях. Когда расписание отжига имеет вид \(T(t) = c / \ln(t+1)\), гарантируется сходимость \(P_{SA} \to 1\) при подходящем выборе константы \(c\) (в статье {[}\hyperlink{cite.book/bibliography:id45}{KN98}{]} есть ссылка на соответствующую теорему). Выбор константы \(c = 3\) достаточно произволен, но высокая точность приближенного равенства \(P_{SA}(t) \approx P_{SA}^{st}(T(t))\) свидетельствует о том, что в рассматриваемом случае действительно \(P_{SA} \to 1\) при \(t \to +\infty\).

\sphinxAtStartPar
Для QA нет аналогичного точного утверждения о сходимости \(P_{QA} \to 1\), но численные результаты для данного ферромагнитного случая при \(\Gamma(t) = 3 / \ln(t+1)\) позволяют предположить такую сходимость.

\sphinxAtStartPar
Тот факт, что QA\sphinxhyphen{}кривая на \hyperref[\detokenize{book/dwave/ru/annealing_paper_1998:qa-sa-fig-1}]{Fig.\@ \ref{\detokenize{book/dwave/ru/annealing_paper_1998:qa-sa-fig-1}}} всегда ниже SA\sphinxhyphen{}кривой, никакого значения не имеет, потому что в обеих задачах у нас все величины обезразмерены (\(\hbar = 1\) в \eqref{equation:book/dwave/ru/annealing_paper_1998:eqn:Schrodinger_timedep} и единица времени \(\tau = 1\) в \eqref{equation:book/dwave/ru/annealing_paper_1998:eqn:SA_master_eqn}) и никакого согласования при обезразмеривании в двух задачах нет.

\sphinxAtStartPar
Если уменьшать поперечное поле и температуру быстрее,
\begin{equation*}
\begin{split}
\Gamma(t) = T(t) = \frac{3}{\sqrt{t}},
\end{split}
\end{equation*}
\sphinxAtStartPar
то возникает качественное отличие QA и SA решений, см. \hyperref[\detokenize{book/dwave/ru/annealing_paper_1998:qa-sa-fig-2}]{Fig.\@ \ref{\detokenize{book/dwave/ru/annealing_paper_1998:qa-sa-fig-2}}}.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=500\sphinxpxdimen]{{fig_2}.png}
\caption{Вид коэффициентов перекрытия для ферромагнитной модели при \(\Gamma(t) = T(t) = 3 / \sqrt{t}\).}\label{\detokenize{book/dwave/ru/annealing_paper_1998:qa-sa-fig-2}}\end{figure}

\sphinxAtStartPar
Видно, что решение квантовомеханической задачи лучше сходится к основному состоянию, чем решение классической задачи. Более того, SA\sphinxhyphen{}решение “застревает” в каком\sphinxhyphen{}то локальном минимуме с не очень малой вероятностью. На \hyperref[\detokenize{book/dwave/ru/annealing_paper_1998:qa-sa-fig-3}]{Fig.\@ \ref{\detokenize{book/dwave/ru/annealing_paper_1998:qa-sa-fig-3}}} виден темп приближения \(P_{QA}\) к 1 (на графике двойная логарифмическая шкала). Можно сделать вывод, что \((1 - P_{QA}) \propto 1/t\) в широком диапазоне \(t\).

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=500\sphinxpxdimen]{{fig_3}.png}
\caption{\((1 - P_{QA}(t))\) для ферромагнитной модели при \(\Gamma(t) = 3 / \sqrt{t}\).}\label{\detokenize{book/dwave/ru/annealing_paper_1998:qa-sa-fig-3}}\end{figure}

\sphinxAtStartPar
Если еще быстрее уменьшать поперечное поле и температуру,
\begin{equation*}
\begin{split}
\Gamma(t) = T(t) = \frac{3}{t},
\end{split}
\end{equation*}
\sphinxAtStartPar
то оба решения “застревают” в неосновных состояниях, как видно из \hyperref[\detokenize{book/dwave/ru/annealing_paper_1998:qa-sa-fig-4}]{Fig.\@ \ref{\detokenize{book/dwave/ru/annealing_paper_1998:qa-sa-fig-4}}}.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=500\sphinxpxdimen]{{fig_4}.png}
\caption{Вид коэффициентов перекрытия для ферромагнитной модели при \(\Gamma(t) = T(t) = 3 / t\).}\label{\detokenize{book/dwave/ru/annealing_paper_1998:qa-sa-fig-4}}\end{figure}


\subsection{Фрустрированная модель}
\label{\detokenize{book/dwave/ru/annealing_paper_1998:id9}}
\sphinxAtStartPar
Здесь анализируется так называемая фрустрированная (\sphinxstyleemphasis{frustrated}) система, она изображена на \hyperref[\detokenize{book/dwave/ru/annealing_paper_1998:qa-sa-fig-5}]{Fig.\@ \ref{\detokenize{book/dwave/ru/annealing_paper_1998:qa-sa-fig-5}}}.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=300\sphinxpxdimen]{{fig_5}.png}
\caption{Фрустрированная система спинов.}\label{\detokenize{book/dwave/ru/annealing_paper_1998:qa-sa-fig-5}}\end{figure}

\sphinxAtStartPar
Сплошные линии обозначают ферромагнитное взаимодействие между спинами, пунктирная линия – антиферромагнитное взаимодействие (сила которого по абсолютной величине равна силе ферромагнитного взаимодействия). Если в SA\sphinxhyphen{}задаче температура очень велика, то спины 4 и 5 меняют свою ориентацию с очень высокой частотой, так что взаимодействие спинов 3 и 6 посредством спинов 4 и 5 пренебрежимо мало. В этом случае прямое антиферромагнитное взаимодействие между спинами 3 и 6 оказывается доминирующим, поэтому наблюдается отрицательная корреляция между ориентациями спинов 3 и 6 (см. \hyperref[\detokenize{book/dwave/ru/annealing_paper_1998:qa-sa-fig-6}]{Fig.\@ \ref{\detokenize{book/dwave/ru/annealing_paper_1998:qa-sa-fig-6}}}).

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=500\sphinxpxdimen]{{fig_6}.png}
\caption{Величина корреляции спинов 3 и 6. Индекс \sphinxcode{\sphinxupquote{c}} означает классическое решение (SA), индекс \sphinxcode{\sphinxupquote{q}} означает квантовомеханическое решение (QA).}\label{\detokenize{book/dwave/ru/annealing_paper_1998:qa-sa-fig-6}}\end{figure}

\sphinxAtStartPar
С другой стороны, при низкой температуре спины 4 и 5 стремятся принять определенную устойчивую ориентацию. В этом случае эффективное (непрямое) ферромагнитное взаимодействие между спинами 3 и 6 посредством спинов 4 и 5 примерно вдвое сильнее, чем прямое антиферромагнитное взаимодействие. Эти рассуждения подтверждаются положительной величиной корреляции \(\braket{\sigma_3^z \sigma_6^z}_c\) при низких температурах (\hyperref[\detokenize{book/dwave/ru/annealing_paper_1998:qa-sa-fig-6}]{Fig.\@ \ref{\detokenize{book/dwave/ru/annealing_paper_1998:qa-sa-fig-6}}}). Значит, спины 3 и 6 должны поменять взаимную ориентацию при некоторой промежуточной температуре.

\sphinxAtStartPar
Если поперечное поле в QA\sphinxhyphen{}задаче играет роль, аналогичную роли температуры в SA\sphinxhyphen{}задаче, то следует ожидать схожего поведения величины корреляции \(\braket{\sigma_3^z \sigma_6^z}_q\) при изменении \(\Gamma\). Здесь наблюдаемая \(\braket{\sigma_3^z \sigma_6^z}_q\) вычисляется с использованием основного состояния гамильтониана \eqref{equation:book/dwave/ru/annealing_paper_1998:eqn:QA_Hamilt} при заданной \(\Gamma\). Так и есть (см. пунктирную кривую на \hyperref[\detokenize{book/dwave/ru/annealing_paper_1998:qa-sa-fig-6}]{Fig.\@ \ref{\detokenize{book/dwave/ru/annealing_paper_1998:qa-sa-fig-6}}}).

\sphinxAtStartPar
Если использовать расписание отжига
\begin{equation*}
\begin{split}
\Gamma(t) = T(t) = \frac{3}{\sqrt{t}},
\end{split}
\end{equation*}
\sphinxAtStartPar
то получаются результаты, изображенные на \hyperref[\detokenize{book/dwave/ru/annealing_paper_1998:qa-sa-fig-7}]{Fig.\@ \ref{\detokenize{book/dwave/ru/annealing_paper_1998:qa-sa-fig-7}}}.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=500\sphinxpxdimen]{{fig_7}.png}
\caption{Вид коэффициентов перекрытия для фрустрированной модели при \(\Gamma(t) = T(t) = 3 / \sqrt{t}\).}\label{\detokenize{book/dwave/ru/annealing_paper_1998:qa-sa-fig-7}}\end{figure}

\sphinxAtStartPar
Обезразмеренное время \(\tau = t T_c^2\) для SA\sphinxhyphen{}задачи и \(\tau = t \Gamma_c^2\) для QA\sphinxhyphen{}задачи. Здесь \(T_c\) и \(\Gamma_c\) – критические величины, при которых \(\braket{\sigma_3^z \sigma_6^z}_c\) и \(\braket{\sigma_3^z \sigma_6^z}_q\) переходят через ноль на графике \hyperref[\detokenize{book/dwave/ru/annealing_paper_1998:qa-sa-fig-6}]{Fig.\@ \ref{\detokenize{book/dwave/ru/annealing_paper_1998:qa-sa-fig-6}}}. Видно, что квантовый отжиг лучше подходит для поиска основного состояния в такой системе.


\subsection{Модель со случайными взаимодействиями}
\label{\detokenize{book/dwave/ru/annealing_paper_1998:id10}}
\sphinxAtStartPar
Последний рассмотренный пример – это модель спинового стекла, предложенная Шеррингтоном и Киркпатриком {[}\hyperlink{cite.book/bibliography:id62}{SK75}{]}. Для всех пар спинов есть взаимодействие, сила которого является случайной величиной и семплируется из гауссова распределения с нулевым средним и с дисперсией \(1/N\) (в нашем случае \(N=8\)). На \hyperref[\detokenize{book/dwave/ru/annealing_paper_1998:qa-sa-fig-8}]{Fig.\@ \ref{\detokenize{book/dwave/ru/annealing_paper_1998:qa-sa-fig-8}}} показан типичный результат для эволюции коэффициентов перекрытия во времени при расписании отжига \(\Gamma(t) = T(t) = 3 / \sqrt{t}\).

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=500\sphinxpxdimen]{{fig_8}.png}
\caption{Вид коэффициентов перекрытия для модели Шеррингтона\sphinxhyphen{}Киркпатрика при \(\Gamma(t) = T(t) = 3 / \sqrt{t}\).}\label{\detokenize{book/dwave/ru/annealing_paper_1998:qa-sa-fig-8}}\end{figure}

\sphinxAtStartPar
Было проверено несколько реализаций для коэффициентов обменного взаимодействия (семплирование выполнялось из одной и той же функции распределения), результаты оказались качественно близкими. Графики на \hyperref[\detokenize{book/dwave/ru/annealing_paper_1998:qa-sa-fig-8}]{Fig.\@ \ref{\detokenize{book/dwave/ru/annealing_paper_1998:qa-sa-fig-8}}} подтверждают, что для данной оптимизационной задачи квантовый отжиг подходит лучше, чем классический.


\section{Заключение}
\label{\detokenize{book/dwave/ru/annealing_paper_1998:id12}}
\sphinxAtStartPar
В этой лекции рассказали о канонической работе, в которой для модели Изинга рассмотрены классическая имитация отжига и квантовая имитация отжига, выполнен анализ и сравнение свойств решений в рамках этих двух подходов на нескольких примерах. Выяснилось, что:
\begin{itemize}
\item {} 
\sphinxAtStartPar
при одном и том же расписании отжига квантовый отжиг дает сходимость к основному состоянию с большей вероятностью, чем классический отжиг;

\item {} 
\sphinxAtStartPar
для квантового случая система сходится к основному состоянию при расписании отжига \(\Gamma = c / \sqrt{t}\), но не при более быстром уменьшении поперечного поля;

\item {} 
\sphinxAtStartPar
для ферромагнитной модели при квантовом отжиге вероятность получения основного состояния ведет себя приближенно как \((1 - \frac{\text{const}}{t})\) на больших временах \(t\).

\end{itemize}

\sphinxstepscope


\part{QAOA}

\sphinxstepscope


\chapter{О блоке “Quantum Approximate Optimization Algorithm”}
\label{\detokenize{book/qaoa/ru/qaoa_intro:quantum-approximate-optimization-algorithm}}\label{\detokenize{book/qaoa/ru/qaoa_intro:qaoa-intro}}\label{\detokenize{book/qaoa/ru/qaoa_intro::doc}}
\sphinxAtStartPar
В этом блоке узнаете об алгоритме квантовой приближенной оптимизации.

\sphinxstepscope


\chapter{Quantum Approximate Optimization Algorithm}
\label{\detokenize{book/qaoa/ru/qaoa:quantum-approximate-optimization-algorithm}}\label{\detokenize{book/qaoa/ru/qaoa:qaoa}}\label{\detokenize{book/qaoa/ru/qaoa::doc}}
\sphinxAtStartPar
Автор(ы):
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/Carinetta}{Решетова Карина}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/SemyonSinchenko}{Синченко Семен}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/meandmytram}{Березутский Александр}

\end{itemize}


\section{Введение}
\label{\detokenize{book/qaoa/ru/qaoa:id1}}
\sphinxAtStartPar
В лекции рассматривается еще один алгоритм для приближенного решения {\hyperref[\detokenize{book/problems/ru/copt::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{\(NP\)\sphinxhyphen{}задач комбинаторный оптимизации}}}}, который называется \sphinxstylestrong{Q}auntum \sphinxstylestrong{A}pproximate \sphinxstylestrong{O}ptimization \sphinxstylestrong{A}lgorithm (далее \sphinxstylestrong{QAOA}) {[}\hyperlink{cite.book/bibliography:id31}{FGG14}{]}.


\subsection{Квантовый отжиг (повторение)}
\label{\detokenize{book/qaoa/ru/qaoa:id3}}
\sphinxAtStartPar
В прошлых лекция активно {\hyperref[\detokenize{book/dwave/ru/dwave::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{рассказывалось}}}} о квантовых \sphinxstyleemphasis{аннилерах} (\sphinxstyleemphasis{отжигателях}, англ. \sphinxstyleemphasis{annealers}) – аналоговых устройствах, реализующих поиск основного состояния системы. Выпишем еще раз \sphinxhref{../../dwave/ru/dwave.html\#id4}{гамильтониан}, который там используется:
\begin{equation*}
\begin{split}
\mathcal{H}_{Ising}=\underbrace{{-A(t)}\left(\sum_{i} \hat{\sigma}_{x}^{(i)}\right)}_{\text {Initial Hamiltonian }}+\underbrace{{B(t)}\left(\sum_{i} h_{i} \hat{\sigma}_{z}^{(i)}+\sum_{i,j} J_{i, j} \hat{\sigma}_{z}^{(i)} \hat{\sigma}_{z}^{(j)}\right)}_{\text {Final Hamiltonian }},
\end{split}
\end{equation*}
\sphinxAtStartPar
В процессе квантового отжига плавно меняются параметры \(A\) и \(B\):

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=444\sphinxpxdimen]{{fig_31}.png}
\caption{Пример расписания отжига: функций \(A(t)\), \(B(t)\).}\label{\detokenize{book/qaoa/ru/qaoa:fig-1}}\end{figure}

\sphinxAtStartPar
В той же {\hyperref[\detokenize{book/dwave/ru/dwave::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{лекции}}}} о \sphinxcode{\sphinxupquote{D\sphinxhyphen{}Wave}} указывалась главная проблема – риск перехода системы из основного состояния в возбужденное при недостаточно медленном изменении параметров \(A\) и \(B\):

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=444\sphinxpxdimen]{{fig_11}.png}
\caption{Типичная зависимость от времени энергетических уровней гамильтонианов, используемых в квантовом отжиге}\label{\detokenize{book/qaoa/ru/qaoa:fig-2}}\end{figure}

\sphinxAtStartPar
Таким образом, большой проблемой для нас является выбор правильного “расписания” отжига, то есть зависимостей \(A(t)\) и \(B(t)\).


\subsection{От железа к симуляции}
\label{\detokenize{book/qaoa/ru/qaoa:id4}}
\sphinxAtStartPar
У отжига “в железе” есть существенная проблема – трудно правильным образом подбирать расписание отжига. Но есть и другая идея! Изначально квантовые компьютеры создавались для симуляции квантовой динамики. Воспользуемся техникой симуляции, которая называется \sphinxstyleemphasis{trotterization}.


\subsection{Trotterization и симуляция аннилера}
\label{\detokenize{book/qaoa/ru/qaoa:trotterization}}
\sphinxAtStartPar
В данном случае наша цель – получить выражение для финального состояния \(\ket{\Psi}\), которое будет отвечать решению квантового отжигателя. Финальное состояние есть решение уравнения Шредингера:
\begin{equation*}
\begin{split}
\ket{\Psi(t)} = e^{-i\mathcal{H}_{Ising}(t)t}\ket{\Psi(0)} = e^{-i(A(t) \mathcal{H}_{initial} + B(t)\mathcal{H}_{cost})t}\ket{\Psi(0)},
\end{split}
\end{equation*}
\sphinxAtStartPar
где \(\mathcal{H}_{initial}\) – это \sphinxstyleemphasis{tunneling} или начальный гамильтониан, а \(\mathcal{H}_{cost}\) – это так называемый \sphinxstyleemphasis{problem} или \sphinxstyleemphasis{cost} гамильтониан, который отвечает задаче. Подробно эти темы обсуждались в {\hyperref[\detokenize{book/dwave/ru/dwave::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{лекции о D\sphinxhyphen{}Wave}}}}. Для тех, кто сейчас ничего не понял, рекомендуется также вернуться к лекции {\hyperref[\detokenize{book/problems2qml/ru/np2ising::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{о переходе от комбинаторных задач к гамильтонианам}}}}, чтобы понять, как получается \sphinxstyleemphasis{cost} гамильтониан.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Уравнение Шредингера практически не решается численно для сколько\sphinxhyphen{}нибудь больших задач, поэтому мы примем как факт то, что точно посчитать квантовую динамику аннилера у нас не выйдет, тем более не выйдет как\sphinxhyphen{}то пытаться оптимизировать
\end{sphinxadmonition}

\sphinxAtStartPar
Для решения проблемы “нерешаемости” уравнения Шредингера перейдем от непрерывного времени \(t\) и зависимостей \(A(t)\) и \(B(t)\) к \(N\) дискретных моментов времени \(t_1, t_2, ..., t_n\). Тогда можно заменить расписание отжига в виде непрерывных коэффициентов на набор дискретных коэффициентов, каждый из которых отвечает своему моменту времени:
\begin{equation*}
\begin{split}
& A(t) \to \gamma_1, \gamma_2, ..., \gamma_N \\
& B(t) \to \beta_1, \beta_2, ..., \beta_N
\end{split}
\end{equation*}
\sphinxAtStartPar
Финальное состояние записывается так:
\begin{equation*}
\begin{split}
\ket{\Psi(t)} = e^{-i\gamma_1 \mathcal{H}_{initial}}e^{-i\beta_1\mathcal{H}_{cost}} ... e^{-i\gamma_N \mathcal{H}_{initial}}e^{-i\beta_N\mathcal{H}_{cost}} \ket{\Psi(0)}
\end{split}
\end{equation*}

\subsection{Оптимизация расписания}
\label{\detokenize{book/qaoa/ru/qaoa:id5}}
\sphinxAtStartPar
Теперь задача оптимизации расписания по своей сути сведена к следующей:
\begin{equation*}
\begin{split}
& \arg\min_{\gamma_1, ..., \gamma_N, \beta_1, ..., \beta_N} {\braket{\Psi_{final} | \mathcal{H}_{cost} | \Psi_{final}}} \\
& \ket{\Psi_{final}} = e^{-i\gamma_1 \mathcal{H}_{initial}}e^{-i\beta_1\mathcal{H}_{cost}} ... e^{-i\gamma_N \mathcal{H}_{initial}}e^{-i\beta_N\mathcal{H}_{cost}}\ket{\Psi(0)}
\end{split}
\end{equation*}
\sphinxAtStartPar
А это уже хорошо знакомая задача оптимизации результата измерения состояния, заданного при помощи некоторой {\hyperref[\detokenize{book/vqc/ru/vqc::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{\sphinxstylestrong{VQC}}}}}, которая параметризирована набором действительных чисел \(\gamma_1, ..., \gamma_N, \beta_1, ..., \beta_N\). И эта задача решается хорошо уже знакомыми {\hyperref[\detokenize{book/grads/ru/gradients::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{градиентными методами}}}}.


\section{Пример задачи оптимизации}
\label{\detokenize{book/qaoa/ru/qaoa:id6}}
\sphinxAtStartPar
Рассмотрим задачу оптимизации \(n\)\sphinxhyphen{}разрядного набора данных, для которого нужно найти некоторый минимум (или максимум). Алгоритм задается двумя гамильтонианами \(H_{p}\) и \(H_{M}\), а также \(2p\) параметрами: \(\gamma_{1}, ..., \gamma_{p}\) и \(\beta_{1}, ..., \beta_{p}\).

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{QAOA}} использует унитарный оператор \(U(\beta,\gamma)\), принимающий на вход вещественные параметры \(\beta\), \(\gamma\), и описывается уже знакомым квантовым состоянием \(\ket{\Psi}\). Цель поиска – найти те самые оптимальные \(\beta_{\text{opt}}\) и \(\gamma_{\text{opt}}\).

\sphinxAtStartPar
Оператор \(U\) состоит из двух частей:
\begin{itemize}
\item {} 
\sphinxAtStartPar
оператор, меняющий фазу \(U_{\text{phase}}\)
\begin{equation*}
\begin{split}
    U_{\text{phase}}(\gamma) = e^{ -i {\gamma} H_{\text{phase}} }
    \end{split}
\end{equation*}
\item {} 
\sphinxAtStartPar
оператор, смешивающий кубиты \(U_{\text{mixer}}\)
\begin{equation*}
\begin{split}
    U_{\text{mixer}}(\beta) = e^{ -i {\beta} H_{\text{mixer}} }
    \end{split}
\end{equation*}
\end{itemize}

\sphinxAtStartPar
Оператор \(U_{\text{phase}}\) совершает вращение относительно осей \(Z\) или \(Y\) с помощью соответствующих матриц Паули
\begin{equation*}
\begin{split}
H_{\text{phase}} = Z \ or \ Y \ \text{axis rotation}
\end{split}
\end{equation*}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=444\sphinxpxdimen]{{hamiltonian_u_phase}.png}
\caption{Оператор \(U_{\text{phase}}\)}\label{\detokenize{book/qaoa/ru/qaoa:hamiltonian-u-phase}}\end{figure}

\sphinxAtStartPar
\(U_{\text{mixed}}\) в классическом случае использует матрицу \(XNOT\).

\sphinxAtStartPar
Операторы применяются к начальному состоянию \(\ket{\Psi_{0}}\) (путем поочередного применения гамильтонианов \(H_{p}\) и \(H_{M}\)) последовательно \(р\) раз (или, иначе говоря, используются \(p\) слоев), где продолжительность \(j\)\sphinxhyphen{}й итерации определяется параметрами \(\gamma_{j}\) и \(\beta_{j}\) соответственно
\begin{equation*}
\begin{split}
\ket{\phi(\beta,\gamma)} = \underbrace{U_{\text{mixer}}(\beta) U_{\text{phase}}(\gamma) \ ... \ U_{\text{mixer}}(\beta) U_{\text{phase}}(\gamma)}_{\text {p times}}{\ket{\Psi_0}}
\end{split}
\end{equation*}
\sphinxAtStartPar
Общая схема для \(n\) кубитов выглядит следующим образом

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=444\sphinxpxdimen]{{general_scheme_for_n_qubits}.png}
\caption{Общая схема для \(n\) кубитов}\label{\detokenize{book/qaoa/ru/qaoa:general-scheme-for-n-qubits}}\end{figure}

\sphinxAtStartPar
Итак, алгоритм состоит из следующих основных этапов:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
приготовление начального состояния \(\ket{\Psi_{0}}\) из \(n\) кубитов. Начальное состояние выбирается как равное состояние суперпозиции всех возможных решений
\begin{equation*}
\begin{split}
    \ket{\Psi_{0}} = \frac{1}{\sqrt{2^n}} \sum_{x} \ket{x}
    \end{split}
\end{equation*}
\item {} 
\sphinxAtStartPar
последующее применение к каждому кубиту матриц Адамара для осуществления суперпозиции всевозможных состояний

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=222\sphinxpxdimen]{{the_1t_step_alg}.png}
\end{figure}

\item {} 
\sphinxAtStartPar
применяем оператор вращения фазы
\begin{equation*}
\begin{split}
    U_{\text{phase}} = \sum_{i \neq j}^{n-1} e^{-i \gamma Z_i Z_j}
    \end{split}
\end{equation*}
\sphinxAtStartPar
например, вот так
\begin{equation*}
\begin{split}
    H_p = (I_0 \otimes Z_1 \otimes I_2 \otimes Z_3)
    \end{split}
\end{equation*}
\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=222\sphinxpxdimen]{{the_2d_step_alg}.png}
\end{figure}

\sphinxAtStartPar
Напоминаем, как выглядит данный оператор в матричном виде: \(Z = \begin{bmatrix} 1 & 0 \\ 0 & 1\end{bmatrix}\).

\item {} 
\sphinxAtStartPar
применяем смешивающий оператор
\begin{equation*}
\begin{split}
    U_{\text{mixer}} = \sum_{i=0}^{n-1} e^{-i \beta X_i}
    \end{split}
\end{equation*}
\sphinxAtStartPar
к примеру, так
\begin{equation*}
\begin{split}
    U_{\text{mixer}} = (I \otimes I \otimes X \otimes Z)
    \end{split}
\end{equation*}
\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=222\sphinxpxdimen]{{the_3d_step_alg}.png}
\end{figure}
\begin{equation*}
\begin{split}
    X = \begin{bmatrix} 0 & 1 \\ 1 & 0\end{bmatrix}
    \end{split}
\end{equation*}
\end{enumerate}

\sphinxAtStartPar
В данном алгоритме используется адиабатический метод эволюции состояния {[}\hyperlink{cite.book/bibliography:id30}{FGGS00}{]} \(\ket{\Psi_0}\) с переменным гамильтонианом: на каждой итерации параметры \(\beta\) и \(\gamma\) понемногу изменяются.

\sphinxAtStartPar
Далее производится измерение финального состояния в \(Z\)\sphinxhyphen{}базисе и вычисление \(\bra{\Psi(\beta,\gamma)}H_{phase}\ket{\Psi(\beta,\gamma)}\). Найденный минимум будет соответствовать оптимальным \(\beta\) и \(\gamma\).

\sphinxAtStartPar
Описанные выше шаги могут быть полностью повторены с обновлёнными наборами временных параметров в рамках классического цикла оптимизации (такого как градиентный спуск или другие подходы), используемого для оптимизации параметров алгоритма.

\sphinxAtStartPar
Возвращается лучшее решение, найденное за всё время поиска.


\section{Quantum Alternating Operator Ansatz}
\label{\detokenize{book/qaoa/ru/qaoa:quantum-alternating-operator-ansatz}}
\sphinxAtStartPar
Применение “анзаца” в алгоритме квантовой приближенной оптимизации заключается в модернизации оператора смешивания \(U_{mixer}\) и предполагает использование \(CNOT\), а не \(X\).

\sphinxAtStartPar
Анзац рассматривает более общие параметризированные унитарные трансформации, а не только соответствующие эволюции фиксированного локального гамильтониана во времени. Он позволяет более эффективно реализовывать операции смешивания, особенно в задачах оптимизации с жесткими ограничениями.

\sphinxAtStartPar
На рисунках ниже представлена абстрактная визуализация “смешивания” и обозначение оператора:

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=444\sphinxpxdimen]{{ansatz_mixing}.png}
\caption{“Смешивание”}\label{\detokenize{book/qaoa/ru/qaoa:ansatz-mixing}}\end{figure}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=444\sphinxpxdimen]{{ansatz_operator_designation}.png}
\caption{Обозначение оператора}\label{\detokenize{book/qaoa/ru/qaoa:ansatz-operator-designation}}\end{figure}

\sphinxAtStartPar
Классически семейство анзацев можно поделить на три основных типа:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Hardware Efficient Ansatz (HEA) – запутывающий все кубиты;

\item {} 
\sphinxAtStartPar
Alternating Layered Ansatz (ALT) {[}\hyperlink{cite.book/bibliography:id31}{FGG14}{]};

\item {} 
\sphinxAtStartPar
Tensor Product Ansatz (TEN) {[}\hyperlink{cite.book/bibliography:id41}{HPM+19}{]}.

\end{itemize}

\sphinxAtStartPar
На рисунке ниже изображены упрощённые (без учета анзаца и фазовых гейтов) для понимания схемы описанных компоновок – по одному слою каждого типа:

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=444\sphinxpxdimen]{{ansats_types}.png}
\end{figure}

\sphinxAtStartPar
Конечно, к компоновке смешанных гейтов можно подходить сколь угодно творчески, и пример общей схемы, реализующей QAOAz, представлен ниже:

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=444\sphinxpxdimen]{{ansatz_sample}.png}
\end{figure}

\sphinxstepscope


\part{Перспективы}

\sphinxstepscope


\chapter{Академия и индустрия}
\label{\detokenize{book/perspectives/ru/academic_industrial:academic-industrial}}\label{\detokenize{book/perspectives/ru/academic_industrial:id1}}\label{\detokenize{book/perspectives/ru/academic_industrial::doc}}


\sphinxstepscope


\part{О КУРСЕ / ABOUT THE COURSE}

\sphinxstepscope


\chapter{Список литературы / Bibliography}
\label{\detokenize{book/bibliography:bibliography}}\label{\detokenize{book/bibliography::doc}}
\sphinxstepscope


\chapter{Список авторов курса / Course authors}
\label{\detokenize{book/authors:course-authors}}\label{\detokenize{book/authors:authors}}\label{\detokenize{book/authors::doc}}

\section{Создатели курса / Co\sphinxhyphen{}founders}
\label{\detokenize{book/authors:co-founders}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/SemyonSinchenko}{Синченко Семён / Sinchenko Semyon}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/Yorko}{Кашницкий Юрий / Kashnitsky Yury}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/vvssttkk}{vvssttkk}

\end{itemize}


\section{Основные авторы / The main authors}
\label{\detokenize{book/authors:the-main-authors}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/dbazhanov}{Бажанов Дмитрий / Bazhanov Dmitry}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/meandmytram}{Березутский Александр / Berezutskii Aleksandr}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/zimka}{Зимка Борис / Zimka Boris}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/ooovector}{Беседин Илья / Besedin Ilya}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/dmburd}{Бурдейный Дмитрий / Burdeiny Dmitry}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/Randl}{Желтоножский Евгений / Zheltonozhskiy Evgeniy}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/karelin}{Карелин Николай / Karelin Nikolay}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/Yorko}{Кашницкий Юрий / Kashnitsky Yury}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/Erlemar}{Лукьяненко Андрей / Lukyanenko Andrey}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/m12sl}{Озерин Алексей / Ozerin Alex}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/belgraviton}{Петров Вадим / Piatrou Vadzim}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/alexey-pronkin}{Пронькин Алексей / Pronkin Alexey}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/Carinetta}{Решетова Карина / Reshetova Carinetta}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/flatslm}{Сендерович Леонид / Senderovich Leonid}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/SemyonSinchenko}{Синченко Семен / Sinchenko Semyon}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/polyzer}{Токарев Игорь / Tokarev Igor}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/SergeiShirkin}{Ширкин Сергей / Shirkin Sergei}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/magnus-the-collectioner}{Щуцкий Никита / Shchutski Mikita}

\item {} 
\sphinxAtStartPar
\sphinxhref{http://github.com/dayyass}{Эль\sphinxhyphen{}Айясс Дани / El\sphinxhyphen{}Ayyass Dani}

\end{itemize}


\section{Основные ревьюеры / The main reviewers}
\label{\detokenize{book/authors:the-main-reviewers}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/sustxh}{Дихтяр Иван / Dikhtyar Ivan}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/Randl}{Желтоножский Евгений / Zheltonozhskiy Evgeniy}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/zimka}{Зимка Борис / Zimka Boris}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/karelin}{Карелин Николай / Karelin Nikolay}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/Yorko}{Кашницкий Юрий / Kashnitsky Yury}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/TezRomacH}{Тезиков Роман / Tezikov Roman}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/vvssttkk}{vvssttkk}

\end{itemize}


\section{Техническая поддержка / Technical support}
\label{\detokenize{book/authors:technical-support}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/dkorzhov}{Коржов Дмитрий / Korzhov Dmitry}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/alexey-pronkin}{Пронькин Алексей / Pronkin Alexey}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/vvssttkk}{vvssttkk}

\end{itemize}


\section{Редакторы / Editors}
\label{\detokenize{book/authors:editors}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/nsmarkova}{Маркова Наталья / Markova Natalya}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/patsko8a}{Пацкова Екатерина / Patskova Ekaterina}

\end{itemize}

\sphinxstepscope


\chapter{Глоссарий / Glossary}
\label{\detokenize{book/glossary:glossary}}\label{\detokenize{book/glossary:id1}}\label{\detokenize{book/glossary::doc}}
\sphinxAtStartPar
\sphinxstyleemphasis{Scroll down for English version}


\bigskip\hrule\bigskip



\section{Russian}
\label{\detokenize{book/glossary:russian}}

\subsection{А}
\label{\detokenize{book/glossary:id2}}\begin{description}
\item[{Алгоритм Гровера\index{Алгоритм Гровера@\spxentry{Алгоритм Гровера}|spxpagem}\phantomsection\label{\detokenize{book/glossary:term-0}}}] \leavevmode
\sphinxAtStartPar
Англ. Grover’s algorithm

\item[{Алгоритм квантового приближения для задачи оптимизации\index{Алгоритм квантового приближения для задачи оптимизации@\spxentry{Алгоритм квантового приближения для задачи оптимизации}|spxpagem}\phantomsection\label{\detokenize{book/glossary:term-1}}}] \leavevmode
\sphinxAtStartPar
(QAOA, quantum approximate optimization algorithm), \sphinxurl{https://www.osp.ru/os/2019/03/13055118}, \sphinxurl{https://habr.com/ru/post/513474/}

\item[{Аннилер\index{Аннилер@\spxentry{Аннилер}|spxpagem}\phantomsection\label{\detokenize{book/glossary:term-2}}}] \leavevmode
\sphinxAtStartPar
Англ. annealer. Устройство для приближенного решения задачи оптимизации \sphinxurl{https://en.wikipedia.org/wiki/Quantum\_annealing}

\end{description}


\subsection{Б}
\label{\detokenize{book/glossary:id3}}\begin{description}
\item[{Бра\sphinxhyphen{}вектор\index{Бра\sphinxhyphen{}вектор@\spxentry{Бра\sphinxhyphen{}вектор}|spxpagem}\phantomsection\label{\detokenize{book/glossary:term-3}}}] \leavevmode
\sphinxAtStartPar
Англ. bra\sphinxhyphen{}vector

\end{description}


\subsection{В}
\label{\detokenize{book/glossary:id4}}\begin{description}
\item[{Вакуумное состояние\index{Вакуумное состояние@\spxentry{Вакуумное состояние}|spxpagem}\phantomsection\label{\detokenize{book/glossary:term-4}}}] \leavevmode
\sphinxAtStartPar
Англ. Vacuum state, также используется название “основное состояние” (basic state). Так часто называется квантовое состояние с вектором \(\ket{0}\). Термин заимствован из квантовой оптики, чаще всего не имеет ничего общего с “обыденным” понятием “вакуума”.

\item[{Вариационная квантовая схема\index{Вариационная квантовая схема@\spxentry{Вариационная квантовая схема}|spxpagem}\phantomsection\label{\detokenize{book/glossary:term-5}}}] \leavevmode
\sphinxAtStartPar
Англ. Variational Quantum Circuits (VQC)

\item[{Вариационное машинное обучение\index{Вариационное машинное обучение@\spxentry{Вариационное машинное обучение}|spxpagem}\phantomsection\label{\detokenize{book/glossary:term-6}}}] \leavevmode
\sphinxAtStartPar
Англ. variational machine learning

\end{description}


\subsection{Г}
\label{\detokenize{book/glossary:id5}}\begin{description}
\item[{Гейты\index{Гейты@\spxentry{Гейты}|spxpagem}\phantomsection\label{\detokenize{book/glossary:term-7}}}] \leavevmode
\sphinxAtStartPar
Англ. Quantum gates

\item[{Гейт Адамара\index{Гейт Адамара@\spxentry{Гейт Адамара}|spxpagem}\phantomsection\label{\detokenize{book/glossary:term-8}}}] \leavevmode
\sphinxAtStartPar
Англ. Hadamard gate

\end{description}


\subsection{И}
\label{\detokenize{book/glossary:id6}}\begin{description}
\item[{Измерение\index{Измерение@\spxentry{Измерение}|spxpagem}\phantomsection\label{\detokenize{book/glossary:term-9}}}] \leavevmode
\sphinxAtStartPar
Англ. Quantum measurement

\end{description}


\subsection{К}
\label{\detokenize{book/glossary:id7}}\begin{description}
\item[{Квантовая информация\index{Квантовая информация@\spxentry{Квантовая информация}|spxpagem}\phantomsection\label{\detokenize{book/glossary:term-10}}}] \leavevmode
\sphinxAtStartPar
Также используется термин “квантовая информатика”, англ. Quantum Information

\item[{Квантовый оператор\index{Квантовый оператор@\spxentry{Квантовый оператор}|spxpagem}\phantomsection\label{\detokenize{book/glossary:term-11}}}] \leavevmode
\sphinxAtStartPar
Англ. Quantum operator

\item[{Квантово\sphinxhyphen{}классическое обучение\index{Квантово\sphinxhyphen{}классическое обучение@\spxentry{Квантово\sphinxhyphen{}классическое обучение}|spxpagem}\phantomsection\label{\detokenize{book/glossary:term-12}}}] \leavevmode
\sphinxAtStartPar
Англ. Quantum\sphinxhyphen{}classical machine learning

\item[{Квантовое состояние\index{Квантовое состояние@\spxentry{Квантовое состояние}|spxpagem}\phantomsection\label{\detokenize{book/glossary:term-13}}}] \leavevmode
\sphinxAtStartPar
Англ. Quantum state

\item[{Кет\sphinxhyphen{}вектор\index{Кет\sphinxhyphen{}вектор@\spxentry{Кет\sphinxhyphen{}вектор}|spxpagem}\phantomsection\label{\detokenize{book/glossary:term-14}}}] \leavevmode
\sphinxAtStartPar
Англ. ket\sphinxhyphen{}vector

\item[{Кот Шредингера\index{Кот Шредингера@\spxentry{Кот Шредингера}|spxpagem}\phantomsection\label{\detokenize{book/glossary:term-15}}}] \leavevmode
\sphinxAtStartPar
Англ. Schrödinger’s cat

\item[{\sphinxhref{https://ru.wikipedia.org/wiki/\%D0\%9A\%D1\%83\%D0\%B1\%D0\%B8\%D1\%82}{Кубит}\index{Кубит@\spxentry{Кубит}|spxpagem}\phantomsection\label{\detokenize{book/glossary:term-16}}}] \leavevmode
\sphinxAtStartPar
Также кюбит или q\sphinxhyphen{}бит, англ. Qubit, от quantum bit. Минимальная единица информации на квантовом компьютере. Как и (классический) бит, кубит допускает два состояния, которые обычно обозначаются кет\sphinxhyphen{}векторами \(\ket{0}\) и \(\ket{1}\), а на уровне реализации кубит – это двухуровневая квантовая система, такая как две поляризации фотона или спина электрона.

\item[{Кудит\index{Кудит@\spxentry{Кудит}|spxpagem}\phantomsection\label{\detokenize{book/glossary:term-17}}}] \leavevmode
\sphinxAtStartPar
Англ. qudit. Квантовая система с d состояниями.

\end{description}


\subsection{М}
\label{\detokenize{book/glossary:id8}}\begin{description}
\item[{Матрица плотности\index{Матрица плотности@\spxentry{Матрица плотности}|spxpagem}\phantomsection\label{\detokenize{book/glossary:term-18}}}] \leavevmode
\sphinxAtStartPar
Также используется термин “оператор плотности”, англ. Density matrix или Density operator

\item[{Матричное прямое произведение\index{Матричное прямое произведение@\spxentry{Матричное прямое произведение}|spxpagem}\phantomsection\label{\detokenize{book/glossary:term-19}}}] \leavevmode
\sphinxAtStartPar
Синоним произведение Кронекера см. Кронекер. Англ. Tensor product

\item[{Метод квантового локального подбора\index{Метод квантового локального подбора@\spxentry{Метод квантового локального подбора}|spxpagem}\phantomsection\label{\detokenize{book/glossary:term-20}}}] \leavevmode
\sphinxAtStartPar
(QLS, quantum local search), \sphinxurl{https://www.osp.ru/os/2019/03/13055118}

\item[{Многокубитные гейты\index{Многокубитные гейты@\spxentry{Многокубитные гейты}|spxpagem}\phantomsection\label{\detokenize{book/glossary:term-21}}}] \leavevmode
\sphinxAtStartPar
Англ. Multiqubit gates

\end{description}


\subsection{Н}
\label{\detokenize{book/glossary:id9}}\begin{description}
\item[{\sphinxhref{https://ru.wikipedia.org/wiki/\%D0\%91\%D1\%80\%D0\%B0\_\%D0\%B8\_\%D0\%BA\%D0\%B5\%D1\%82}{Нотация Дирака}\index{Нотация Дирака@\spxentry{Нотация Дирака}|spxpagem}\phantomsection\label{\detokenize{book/glossary:term-22}}}] \leavevmode
\sphinxAtStartPar
Англ. Dirac notation, формализм (система обозначения) для описания кантовых состояний на основе бра\sphinxhyphen{} и кет\sphinxhyphen{}векторов (англ. bra\sphinxhyphen{}ket от bracket, скобка). В этой системе обозначений \(\ket{\Psi}\) обозначает вектор состояния, \(\bra{\Psi}\) – сопряженный вектор состояния, а \(\bra{\Psi} \hat{H} \ket{\Psi}\) – среднее (математическое ожидаемое) значения наблюдаемой для оператора \(\hat{H}\) в состоянии \(\ket{\Psi}\) (также говорят о свертке оператора \(\hat{H}\) с бра\sphinxhyphen{}вектором \(\bra{\Psi}\) и кет\sphinxhyphen{}вектором \(\ket{\Psi}\)). Система обозначений Дирака позволяет отделить отделить вектора состояния \(\ket{\Psi}\) от самого состояния \(\Psi\) или конкретного математического описания (в виде волновой функции или вектора).

\end{description}


\subsection{О}
\label{\detokenize{book/glossary:id10}}\begin{description}
\item[{Операторы Паули\index{Операторы Паули@\spxentry{Операторы Паули}|spxpagem}\phantomsection\label{\detokenize{book/glossary:term-23}}}] \leavevmode
\sphinxAtStartPar
Также используется термин “матрицы Паули”, англ. Pauli operators или Pauli matrices

\end{description}


\subsection{П}
\label{\detokenize{book/glossary:id11}}\begin{description}
\item[{Правило сдвига параметров\index{Правило сдвига параметров@\spxentry{Правило сдвига параметров}|spxpagem}\phantomsection\label{\detokenize{book/glossary:term-24}}}] \leavevmode
\sphinxAtStartPar
(*) Англ. Parameter\sphinxhyphen{}shift rule

\item[{Произведение Кронекера\index{Произведение Кронекера@\spxentry{Произведение Кронекера}|spxpagem}\phantomsection\label{\detokenize{book/glossary:term-25}}}] \leavevmode
\sphinxAtStartPar
То же, что и матричное прямое произведение (тензорное произведение в случае линейных операторов). Англ. Kronecker product

\end{description}


\subsection{С}
\label{\detokenize{book/glossary:id12}}\begin{description}
\item[{Смешанные состояние\index{Смешанные состояние@\spxentry{Смешанные состояние}|spxpagem}\phantomsection\label{\detokenize{book/glossary:term-26}}}] \leavevmode
\sphinxAtStartPar
Англ. Mixed states

\item[{Собственный вектор\index{Собственный вектор@\spxentry{Собственный вектор}|spxpagem}\phantomsection\label{\detokenize{book/glossary:term-27}}}] \leavevmode
\sphinxAtStartPar
Англ. Eigenvector

\item[{Собственное значение\index{Собственное значение@\spxentry{Собственное значение}|spxpagem}\phantomsection\label{\detokenize{book/glossary:term-28}}}] \leavevmode
\sphinxAtStartPar
Англ. Eigenvalue

\item[{Соотношение неопределенности\index{Соотношение неопределенности@\spxentry{Соотношение неопределенности}|spxpagem}\phantomsection\label{\detokenize{book/glossary:term-29}}}] \leavevmode
\sphinxAtStartPar
Также используется термин “принцип неопределенности”, англ. Uncertainty relation или Uncertainty principle

\item[{Суперпозиция\index{Суперпозиция@\spxentry{Суперпозиция}|spxpagem}\phantomsection\label{\detokenize{book/glossary:term-30}}}] \leavevmode
\sphinxAtStartPar
Англ. Superposition

\item[{Сфера Блоха\index{Сфера Блоха@\spxentry{Сфера Блоха}|spxpagem}\phantomsection\label{\detokenize{book/glossary:term-31}}}] \leavevmode
\sphinxAtStartPar
Англ. Bloch sphere

\end{description}


\subsection{У}
\label{\detokenize{book/glossary:id13}}\begin{description}
\item[{Унитарный оператор\index{Унитарный оператор@\spxentry{Унитарный оператор}|spxpagem}\phantomsection\label{\detokenize{book/glossary:term-32}}}] \leavevmode
\sphinxAtStartPar
Англ. Unitary operator

\end{description}


\subsection{Ш}
\label{\detokenize{book/glossary:id14}}\begin{description}
\item[{“Шумные” квантовые компьютеры промежуточного масштаба (Noisy intermediate\sphinxhyphen{}scale quantum, NISQ, NISQ Hardware)\index{""Шумные"" квантовые компьютеры промежуточного масштаба (Noisy intermediate\sphinxhyphen{}scale quantum, NISQ, NISQ Hardware)@\spxentry{""Шумные"" квантовые компьютеры промежуточного масштаба}\spxextra{Noisy intermediate\sphinxhyphen{}scale quantum, NISQ, NISQ Hardware}|spxpagem}\phantomsection\label{\detokenize{book/glossary:term-Noisy-intermediate-scale-quantum-NISQ-NISQ-Hardware}}}] \leavevmode
\sphinxAtStartPar
Термин введен Прескиллом в работе \sphinxurl{https://arxiv.org/abs/1801.00862} для описания сегодняшнего состояния квантовых вычислений, когда “настоящие” квантовые вычисления (на миллионах кубит) еще невозможны, но совеменные квантовые компьютеры уже могут выполнять вычисления, которые невозможны на обычных, классических компьютерах. См. также краткое обсуждение в \sphinxurl{https://quantumcomputing.stackexchange.com/questions/1885/what-is-meant-by-noisy-intermediate-scale-quantum-nisq-technology}, и перевод на термина русский \sphinxurl{https://www.osp.ru/os/2019/03/13055130}

\end{description}


\subsection{Э}
\label{\detokenize{book/glossary:id15}}\begin{description}
\item[{Энтропия\index{Энтропия@\spxentry{Энтропия}|spxpagem}\phantomsection\label{\detokenize{book/glossary:term-33}}}] \leavevmode
\sphinxAtStartPar
Англ. Entropy

\end{description}


\bigskip\hrule\bigskip



\section{English}
\label{\detokenize{book/glossary:english}}

\subsection{A}
\label{\detokenize{book/glossary:a}}\begin{description}
\item[{Annealer\index{Annealer@\spxentry{Annealer}|spxpagem}\phantomsection\label{\detokenize{book/glossary:term-Annealer}}}] \leavevmode
\sphinxAtStartPar
Device for approximate solution of an optimization problem \sphinxurl{https://en.wikipedia.org/wiki/Quantum\_annealing}

\end{description}

\sphinxstepscope


\chapter{Благодарности / Acknowledgements}
\label{\detokenize{book/acknowledgments:acknowledgements}}\label{\detokenize{book/acknowledgments:acknowledgments}}\label{\detokenize{book/acknowledgments::doc}}\begin{itemize}
\item {} 
\sphinxAtStartPar
сообществу \sphinxhref{https://ods.ai}{Open Data Science} за предоставление платформы для размещения курса и техническую поддержку;

\sphinxAtStartPar
/ \sphinxhref{https://ods.ai}{Open Data Science} community for providing the course platform and technical support /

\end{itemize}

\sphinxstepscope


\chapter{Рейтинг / Leaderboard}
\label{\detokenize{book/leaderboard:leaderboard}}\label{\detokenize{book/leaderboard:id1}}\label{\detokenize{book/leaderboard::doc}}

\section{25.10.2021 – 19.12.2021}
\label{\detokenize{book/leaderboard:id2}}
\sphinxAtStartPar
Студенты, которые прошли все задания и в общей сумме имеют больше 6 баллов

\sphinxAtStartPar
/ Students who passed all assignments and have a total of more than 6 points /


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
№
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Студент / Student
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Общий балл / Total
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Блок / Block 1
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Блок / Block 2
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Блок / Block 3
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Блок / Block 4
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Блок / Block 5
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Блок / Block 6
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Блок / Block 7
\\
\hline
\sphinxAtStartPar
1
&
\sphinxAtStartPar
Dmitry Burdeiny
&
\sphinxAtStartPar
90
&
\sphinxAtStartPar
12
&
\sphinxAtStartPar
8
&
\sphinxAtStartPar
11
&
\sphinxAtStartPar
8
&
\sphinxAtStartPar
7
&
\sphinxAtStartPar
11
&
\sphinxAtStartPar
33
\\
\hline
\sphinxAtStartPar
2
&
\sphinxAtStartPar
Alexey Zherebtsov
&
\sphinxAtStartPar
54
&
\sphinxAtStartPar
10
&
\sphinxAtStartPar
8
&
\sphinxAtStartPar
9
&
\sphinxAtStartPar
8
&
\sphinxAtStartPar
7
&
\sphinxAtStartPar
7
&
\sphinxAtStartPar
5
\\
\hline
\sphinxAtStartPar
3
&
\sphinxAtStartPar
Sergei Miller
&
\sphinxAtStartPar
50
&
\sphinxAtStartPar
12
&
\sphinxAtStartPar
3
&
\sphinxAtStartPar
11
&
\sphinxAtStartPar
8
&
\sphinxAtStartPar
7
&
\sphinxAtStartPar
9
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
4
&
\sphinxAtStartPar
Mikhail Knyazev
&
\sphinxAtStartPar
50
&
\sphinxAtStartPar
12
&
\sphinxAtStartPar
8
&
\sphinxAtStartPar
11
&
\sphinxAtStartPar
6
&
\sphinxAtStartPar
7
&
\sphinxAtStartPar
6
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
5
&
\sphinxAtStartPar
Michael Afanasev
&
\sphinxAtStartPar
50
&
\sphinxAtStartPar
10
&
\sphinxAtStartPar
8
&
\sphinxAtStartPar
11
&
\sphinxAtStartPar
6
&
\sphinxAtStartPar
7
&
\sphinxAtStartPar
8
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
6
&
\sphinxAtStartPar
Ilya Simakov
&
\sphinxAtStartPar
49
&
\sphinxAtStartPar
10
&
\sphinxAtStartPar
5
&
\sphinxAtStartPar
9
&
\sphinxAtStartPar
8
&
\sphinxAtStartPar
7
&
\sphinxAtStartPar
10
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
7
&
\sphinxAtStartPar
Boris Filippov
&
\sphinxAtStartPar
48
&
\sphinxAtStartPar
10
&
\sphinxAtStartPar
3
&
\sphinxAtStartPar
11
&
\sphinxAtStartPar
8
&
\sphinxAtStartPar
7
&
\sphinxAtStartPar
9
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
8
&
\sphinxAtStartPar
Nikolay Falaleev
&
\sphinxAtStartPar
48
&
\sphinxAtStartPar
10
&
\sphinxAtStartPar
6
&
\sphinxAtStartPar
11
&
\sphinxAtStartPar
8
&
\sphinxAtStartPar
7
&
\sphinxAtStartPar
6
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
9
&
\sphinxAtStartPar
Aximon
&
\sphinxAtStartPar
47
&
\sphinxAtStartPar
11
&
\sphinxAtStartPar
5
&
\sphinxAtStartPar
8
&
\sphinxAtStartPar
6
&
\sphinxAtStartPar
7
&
\sphinxAtStartPar
10
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
10
&
\sphinxAtStartPar
Dmitrii Fastovets
&
\sphinxAtStartPar
45
&
\sphinxAtStartPar
8
&
\sphinxAtStartPar
8
&
\sphinxAtStartPar
8
&
\sphinxAtStartPar
6
&
\sphinxAtStartPar
7
&
\sphinxAtStartPar
8
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
11
&
\sphinxAtStartPar
Sergey Martynenko
&
\sphinxAtStartPar
44
&
\sphinxAtStartPar
9
&
\sphinxAtStartPar
3
&
\sphinxAtStartPar
10
&
\sphinxAtStartPar
6
&
\sphinxAtStartPar
7
&
\sphinxAtStartPar
9
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
12
&
\sphinxAtStartPar
Konstantin Sukharev
&
\sphinxAtStartPar
39
&
\sphinxAtStartPar
6
&
\sphinxAtStartPar
5
&
\sphinxAtStartPar
8
&
\sphinxAtStartPar
6
&
\sphinxAtStartPar
7
&
\sphinxAtStartPar
7
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
13
&
\sphinxAtStartPar
Ivan Cheprasov
&
\sphinxAtStartPar
39
&
\sphinxAtStartPar
5
&
\sphinxAtStartPar
3
&
\sphinxAtStartPar
9
&
\sphinxAtStartPar
6
&
\sphinxAtStartPar
7
&
\sphinxAtStartPar
9
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
14
&
\sphinxAtStartPar
Serguey Golubev
&
\sphinxAtStartPar
35
&
\sphinxAtStartPar
8
&
\sphinxAtStartPar
3
&
\sphinxAtStartPar
6
&
\sphinxAtStartPar
6
&
\sphinxAtStartPar
2
&
\sphinxAtStartPar
10
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
15
&
\sphinxAtStartPar
Aleksandr Nifontov
&
\sphinxAtStartPar
32
&
\sphinxAtStartPar
4
&
\sphinxAtStartPar
3
&
\sphinxAtStartPar
5
&
\sphinxAtStartPar
6
&
\sphinxAtStartPar
5
&
\sphinxAtStartPar
9
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
16
&
\sphinxAtStartPar
Rustam Bikmurzin
&
\sphinxAtStartPar
29
&
\sphinxAtStartPar
8
&
\sphinxAtStartPar
3
&
\sphinxAtStartPar
4
&
\sphinxAtStartPar
4
&
\sphinxAtStartPar
5
&
\sphinxAtStartPar
5
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
17
&
\sphinxAtStartPar
Ivan Gluhov
&
\sphinxAtStartPar
24
&
\sphinxAtStartPar
2
&
\sphinxAtStartPar
4
&
\sphinxAtStartPar
8
&
\sphinxAtStartPar
4
&
\sphinxAtStartPar
2
&
\sphinxAtStartPar
4
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
18
&
\sphinxAtStartPar
Maksim Kleshchenok
&
\sphinxAtStartPar
22
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
9
&
\sphinxAtStartPar
2
&
\sphinxAtStartPar
2
&
\sphinxAtStartPar
8
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
19
&
\sphinxAtStartPar
Adam Smoluakov
&
\sphinxAtStartPar
16
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
3
&
\sphinxAtStartPar
7
&
\sphinxAtStartPar
4
&
\sphinxAtStartPar
2
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
20
&
\sphinxAtStartPar
Mark Baushenko
&
\sphinxAtStartPar
15
&
\sphinxAtStartPar
4
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
8
&
\sphinxAtStartPar
3
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
21
&
\sphinxAtStartPar
Viktor Krasilnikov
&
\sphinxAtStartPar
14
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
3
&
\sphinxAtStartPar
2
&
\sphinxAtStartPar
2
&
\sphinxAtStartPar
5
&
\sphinxAtStartPar

\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxstepscope


\part{Intro}

\sphinxstepscope


\chapter{About quantum computers, bitcoin, and superiority}
\label{\detokenize{book/intro/en/intro:about-quantum-computers-bitcoin-and-superiority}}\label{\detokenize{book/intro/en/intro:intro-en}}\label{\detokenize{book/intro/en/intro::doc}}
\sphinxAtStartPar
Author(s):
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/SemyonSinchenko}{Sinchenko Semyon}

\end{itemize}

\sphinxAtStartPar
Translation:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/SemyonSinchenko}{Sinchenko Semyon}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/vvssttkk}{vvssttkk}

\end{itemize}


\section{About the lecture}
\label{\detokenize{book/intro/en/intro:about-the-lecture}}
\sphinxAtStartPar
The lecture has no learning meaning but tries to answer questions that can have anyone who faces the topic of quantum computing for the first time:
\begin{itemize}
\item {} 
\sphinxAtStartPar
what is computing this?

\item {} 
\sphinxAtStartPar
why do we need all this stuff?

\item {} 
\sphinxAtStartPar
when will one crack bitcoin?

\item {} 
\sphinxAtStartPar
what the advantage all around?

\end{itemize}


\section{What the computing is this?}
\label{\detokenize{book/intro/en/intro:what-the-computing-is-this}}

\subsection{Quantity evolution of computers}
\label{\detokenize{book/intro/en/intro:quantity-evolution-of-computers}}
\sphinxAtStartPar
Classical computers which are based on Turing, Von Neumann and Shockley ideas are an organic part of our lives. We all used to have an every year growing computational power of such computers. And today’s cheap laptops have a power that supercomputers had 15 years ago.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{Moores_Law}.png}
\caption{A Moore law illustration; a growth of the number of transistors from 1970s}\label{\detokenize{book/intro/en/intro:id1}}\end{figure}

\sphinxAtStartPar
A law that is named a Moore law was formulated by Gordon Moore in the late 60\sphinxhyphen{}s. It tells us that the number of transistors by crystal of integral circuit is adding twice every two years. And it had been holding true for the last 60 years.


\subsection{Quality evolution of computers}
\label{\detokenize{book/intro/en/intro:quality-evolution-of-computers}}
\sphinxAtStartPar
Unfortunately the Moore law holding cannot be endless because there are physical limitations: sooner or later the direct addition of twice the number of transistors could be impossible due to tunneling effects. That’s why it is said that modern computers will have a “quality” revolution. Some say about new materials for creating transistors. Another say about new principles of computers. For example about photonic computers where photons are used instead of electrons, but one can hear that the next computer revolution will be the invention of quantum computers. That is what we will talk about.


\subsection{The idea of quantum computers}
\label{\detokenize{book/intro/en/intro:the-idea-of-quantum-computers}}
\sphinxAtStartPar
There are a few versions of what the first one said about using quantum mechanics laws for creating the new computer. Like it frequently happens a few scientists independently and at one time came to the same idea. One of them was Richard Phillips Feynman.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{Feinman}.jpg}
\caption{Richard Phillips Feynman, 1918\sphinxhyphen{}1988}\label{\detokenize{book/intro/en/intro:id2}}\end{figure}

\sphinxAtStartPar
In 1981 when there was a very active development of both classical computers and computational quantum mechanics he said that for solving quantum mechanical problems we should have a quantum computer.


\subsection{What computer is this?}
\label{\detokenize{book/intro/en/intro:what-computer-is-this}}
\sphinxAtStartPar
It is a very complicated question and all the first half of our course will try to answer it. It is strange if such a complex question that is discussed in a few lectures with hard math could be explained in a few words. It would be wrong to say that classical computers are based on classical physics’ laws and quantum computers are based on quantum physics’ laws because one couldn’t explain the principles of modern transistors without such quantum things like the Fermi level and other stuff. Also, it would be wrong to say that classical computers operate with \(0\) and \(1\), but quantum have all states from \(0\) to \(1\) because there is the probability Turing machine that works with a probabilistic bit that can have all the states from \(0\) to \(1\). In particular, we do not want to rush with a lot of complex and unclear terms like quantum superposition, qubits or quantum entanglement because such terms mean nothing for anyone who is not in the loop. First let us agree that \sphinxstyleemphasis{quantum computers} are not only based on new technology like photonic or graphene computers but use a whole new principle of computation and information representation different from what Turing invented.


\section{Why do we need it?}
\label{\detokenize{book/intro/en/intro:why-do-we-need-it}}

\subsection{Factorization problem}
\label{\detokenize{book/intro/en/intro:factorization-problem}}
\sphinxAtStartPar
It seems to me that specifically the invention of the Shor algorithm for effective solving of the factorization problem was the most important step for the popularization of quantum computing. After that a lot of specialists and scientists rushed to this field, military forces and corporations pushed a fantastic sum of money to the field, reporters started to talk about the future failure of the bank system and the whole world. Probably the Shor algorithm is the most hyped quantum algorithm.

\sphinxAtStartPar
The reason is that the biggest part of modern cryptography is based on simple assuming that there is no polynomial algorithm for the factorization task. In other words, if we have a number that is the result of two big prime numbers products we can try to find those prime numbers until the death of the universe. But it is true only for the classical computer. A quantum computer has the effective polynomial algorithm invented by Peter Shor in 1994. And this algorithm can solve the factorization problem in a relatively short time.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{Shor}.png}
\caption{Peter Shor. The man who set the world on fire with his algorithm.}\label{\detokenize{book/intro/en/intro:id3}}\end{figure}

\sphinxAtStartPar
This algorithm will crack bitcoin and ruin the banking system in the future. But it’s not all that simple: the evolution of quantum computers threw scientists into creating \sphinxstyleemphasis{post\sphinxhyphen{}quantum} cryptography that is based on tasks which cannot be effectively solved on both classical and quantum computers.


\subsection{Combinatorial and NP\sphinxhyphen{}hard problems}
\label{\detokenize{book/intro/en/intro:combinatorial-and-np-hard-problems}}
\sphinxAtStartPar
Except for difficulties with Moore law, there is another problem with classical computers. There are tasks that likely won’t be solved effectively on the classical Turing computer. Even on photonic or graphene ones. A good example is the knapsack problem. When we have a knapsack of limited volume and a lot of things with different size and cost. And we want to fill our knapsack in such a manner to maximize the total cost of things inside it. The task looks very simple, but it is an example of \sphinxhref{https://en.wikipedia.org/wiki/NP-completeness}{\(NP\)\sphinxhyphen{}complete problems}. If we have a big number of different things and a relative big knapsack such a problem cannot be solved exactly in a reasonable time. Even finding a good enough \sphinxstyleemphasis{approximate} solution to such a problem is very hard today!

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
I used a word “likely” because the question about existence of the effective solution of NP\sphinxhyphen{}complete problems is one of the major unsolved problems in computer science{]}(https://en.wikipedia.org/wiki/P\_versus\_NP\_problem). Today we do not know any effective algorithm for it. But we still cannot proof that \sphinxstyleemphasis{there isn’t such an algorithm}. Highly likely there isn’t of course and \(P \neq NP\) but no one can proof it.
\end{sphinxadmonition}

\sphinxAtStartPar
The algorithms are already known for quantum computers that allow potentially effective, albeit \sphinxstyleemphasis{approximate}, solution of such problems on a quantum computer. These are the traveling salesman problem, the knapsack problem, the graph clustering problem, and many other combinatorial optimization problems. In this course there will be a whole block dedicated to such quantum algorithms as \sphinxstyleemphasis{Variational Quantum Eigensolver} and \sphinxstyleemphasis{Quantum Approximate Optimization Algorithm}.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{Salesman}.png}
\caption{Visualizing the solution of the salesman’s problem – the shortest route to get around 12 German cities – is a very important task of modern logistics}\label{\detokenize{book/intro/en/intro:id4}}\end{figure}


\subsection{Quantum mechanics simulation}
\label{\detokenize{book/intro/en/intro:quantum-mechanics-simulation}}
\sphinxAtStartPar
This is what Feynman proposed to create quantum computers for. This is a separate big topic, with a lot of quantum mechanics. Several lectures in this course will be devoted to it. But let’s try to explain this without going into too much detail.

\sphinxAtStartPar
The problems of quantum mechanics cannot be solved analytically. It would seem that what is the problem Newton’s laws for three bodies also cannot be solved analytically, but this does not prevent flying into space, because such a problem can be solved numerically. But there comes a second problem, namely, that explicitly integrates the Schrödinger equation in time, or, simply, to solve quantum mechanics numerically and also computationally almost impossible for more than two particles.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=350\sphinxpxdimen]{{Schrodinger}.jpg}
\caption{Erwin Schrödinger, 1887\sphinxhyphen{}1961, creator of the famous equation and cat meme}\label{\detokenize{book/intro/en/intro:id5}}\end{figure}

\sphinxAtStartPar
It would seem, what’s in it for us. After all, quantum mechanics is the lot of theoreticians. But here is the problem: quantum mechanics is the basis of quantum chemistry, which, in its turn, is the basis of all chemistry in general and such of its applications as creating new drugs, developing new batteries for Tesla cars and many other things. And today we are forced to use only very approximate solutions and concepts, the accuracy of which is often insufficient.

\sphinxAtStartPar
Quantum computers can make a real breakthrough in this case. After all, due to its physical nature, a quantum computer is ideal for simulating quantum mechanics, and hence for solving such important tasks as drug development and design of new materials today.


\subsection{Machine Learning and Artificial Intelligence}
\label{\detokenize{book/intro/en/intro:machine-learning-and-artificial-intelligence}}
\sphinxAtStartPar
Machine learning has reached unprecedented heights in its development over the past 10\sphinxhyphen{}15 years. Many tasks that previously seemed impossible to solve with a computer are now successfully solved with machine learning. Examples include playing Go, distinguishing Chihuahua breeds from photographs, recognizing faces in a video stream, composing relatively meaningful texts, and generating Picasso\sphinxhyphen{}style paintings from simple photographs. But it is still very far from the capabilities of the human brain. For example, the largest artificial neural networks today are roughly estimated to be the equivalent of 15 million neurons, while the human brain has about 85 billion! The learning speed of modern neural networks also raises questions. Thus, the largest language models today are trained for weeks on clusters of thousands of video cards, while a human with his relatively modest computing power learns to speak for only 2\sphinxhyphen{}3 years.

\sphinxAtStartPar
And here, too, quantum computers can come to the rescue. In this case, quantum analogues of neural networks, as well as their combinations with classical neural networks already show impressive results. For example, there are works showing that 4 quantum neurons are equivalent to a classical artificial neural network with \(\sim 250\) neurons in its expressiveness!

\sphinxAtStartPar
It is quantum machine learning, and the ways it can be applied, that will be the focus of most in this course. We will try to cover everything from the theory of how quantum machine learning algorithms can be built to how they can be programmed in modern quantum programming languages. If this topic is of interest to you, this course is definitely for you!


\section{When will bitcoin be cracked?}
\label{\detokenize{book/intro/en/intro:when-will-bitcoin-be-cracked}}
\sphinxAtStartPar
This is probably one of the main questions that arise when reading such articles. And let’s answer right away: they won’t crack soon, there is still plenty of time, 10 years for sure.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=350\sphinxpxdimen]{{Bitcoin}.jpg}
\caption{Bitcoin, like many other electronic media will be forced to switch to post\sphinxhyphen{}quantum cryptography}\label{\detokenize{book/intro/en/intro:id6}}\end{figure}


\subsection{How many qubits are needed for different tasks?}
\label{\detokenize{book/intro/en/intro:how-many-qubits-are-needed-for-different-tasks}}
\sphinxAtStartPar
Probably at once it is necessary to estimate the size that a quantum computer must have in order to effectively solve the tasks described above. Approximate figures are as follows:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Shor’s algorithm and breaking of modern cryptography (including bitcoin): \(\sim 20\cdot 10^6\) (20 million) qubits

\item {} 
\sphinxAtStartPar
optimization problems: \(\sim 100 \cdot 10^3\) (100 thousand) qubits

\item {} 
\sphinxAtStartPar
first useful problems in quantum chemistry: \(\sim 1\cdot 10^3\) (1 thousand) qubits

\item {} 
\sphinxAtStartPar
quantum machine learning: \(\sim 100-500\) qubits

\end{itemize}

\sphinxAtStartPar
This is, by the way, one of the reasons why our course is mostly about quantum machine learning.


\subsection{Logical vs Physical Qubits}
\label{\detokenize{book/intro/en/intro:logical-vs-physical-qubits}}
\sphinxAtStartPar
There is also the problem that all quantum mechanics is probabilistic. There is also the problem that quantum computers operate in the microcosm and are very sensitive to any noise from outside. This leads to a completely unacceptable level of errors in calculations and their low determinism. For example, a good level of accuracy for quantum computers today is 99\% per operation. But each algorithm includes hundreds or even thousands of operations! And then the error rate becomes quite sad.

\sphinxAtStartPar
But there is some good news. There are now many cool error\sphinxhyphen{}correcting algorithms that allow you to use several physical qubits with high error rates to create one logical qubit that has a very low error rate. That is, the programmer will write code that performs operations on one qubit, and on the physical level, it will be an operation on several qubits. All in all, the problem is solvable. Except that up to a thousand physical qubits might be needed to create one quality logical qubit! The estimates we gave above are just about logical qubits, i.e. qubits with very high precision of operations at the level of classical computers.


\subsection{How many qubits are there today?}
\label{\detokenize{book/intro/en/intro:how-many-qubits-are-there-today}}
\sphinxAtStartPar
Let’s say that quantum computers already exist today. Except that all manufacturers, when they write about a new record, mean physical qubits most often.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=350\sphinxpxdimen]{{quantum_computer}.jpg}
\caption{IBM’s quantum computer looks something like this}\label{\detokenize{book/intro/en/intro:id7}}\end{figure}

\sphinxAtStartPar
There are quantum computers with different architectures. Some have more qubits, but also a higher error rate. Others have a low error rate, but they are difficult to scale. The topic of quantum iron in this course will be a separate block of several lectures. But in brief, we can name the following figures:
\begin{itemize}
\item {} 
\sphinxAtStartPar
the record in relatively easily scalable but noisy quantum computers is \(\sim 55\) qubits

\item {} 
\sphinxAtStartPar
the record in relatively accurate but slow and poorly scalable computers is \(\sim 20\) qubits

\item {} 
\sphinxAtStartPar
the record in accurate and scalable but very difficult to program computers is \(\sim 25\) qubits

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Here we mean accordingly:
\begin{itemize}
\item {} 
\sphinxAtStartPar
superconducting qubits, which are the easiest to scale today

\item {} 
\sphinxAtStartPar
trapped ions, which have one of the highest accuracies

\item {} 
\sphinxAtStartPar
photons, which seem to be good for everything, except that the programming on them is aligning lenses and lasers on an optical table

\end{itemize}
\end{sphinxadmonition}

\sphinxAtStartPar
It is worth adding that the record in exact and scalable as well as programmable (topological) qubits today is exactly 2 qubits. Seriously, the interaction of two logical qubits was published in \sphinxcode{\sphinxupquote{Nature}} this year (2021).


\subsection{What plans do the leading players in this market have?}
\label{\detokenize{book/intro/en/intro:what-plans-do-the-leading-players-in-this-market-have}}
\sphinxAtStartPar
It would seem that with such a scale bitcoin has nothing to fear, and in general the area does not look the most promising. But there is one nuance. All the major players in the market of creating quantum computers (\sphinxstyleemphasis{Google Quantum}, \sphinxstyleemphasis{IBM Quantum}, \sphinxstyleemphasis{IonQ}, \sphinxstyleemphasis{Xanadu}) have announced plans to have about one million physical qubits by 2030, which is equivalent to about a thousand logical qubits. That’s not terrible for cryptography yet, but many useful tasks will already be able to be solved. And it is worth looking again at the graph of Moore’s Law for classical computers, which shows approximately the same progress every ten years!


\section{On Quantum Superiority}
\label{\detokenize{book/intro/en/intro:on-quantum-superiority}}
\sphinxAtStartPar
It is very common to hear talk about quantum superiority being achieved or disproved. Let’s try, near the end of the lecture, to understand what it is and why it is important (or not).


\subsection{The concept of quantum superiority}
\label{\detokenize{book/intro/en/intro:the-concept-of-quantum-superiority}}
\sphinxAtStartPar
The concept itself was formulated back in 2012 by renowned physicist theorist John Preskill.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=350\sphinxpxdimen]{{Preskill}.jpg}
\caption{John Preskill, who coined the term. He is also famous for his famous bet with another physicist, Stephen Hawking (which Hawking lost)}\label{\detokenize{book/intro/en/intro:id8}}\end{figure}

\sphinxAtStartPar
Quantum superiority is a solution on a quantum computer to a problem that cannot be solved on a classical computer in reasonable time (10 thousand years is not considered reasonable time). Achieving quantum superiority is definitely a new level in the development of quantum computing. But there is one catch. The fact is that we are talking about absolutely any task, no matter how useful or useless it is.

\sphinxAtStartPar
So when someone claims to achieve quantum superiority, it is an important reason for scientists and developers of quantum computers, but most likely it is a very unimportant fact, from the point of view of the common man.


\subsection{Timeline of events}
\label{\detokenize{book/intro/en/intro:timeline-of-events}}
\sphinxAtStartPar
Finally, here is a brief chronology of events.
\begin{itemize}
\item {} 
\sphinxAtStartPar
2019, \sphinxstyleemphasis{Google} claims to achieve quantum superiority. The task chosen is as convenient as possible for a quantum computer and completely devoid of practical sense. According to the developers from \sphinxstyleemphasis{Google}, their quantum computer in 4 minutes solved a problem that a classical supercomputer would take 10 thousand years to solve. Their quantum computer had 54 qubits

\item {} 
\sphinxAtStartPar
2019, \sphinxstyleemphasis{IBM} says that \sphinxstyleemphasis{Google} failed to consider that their problem could be solved more optimally on a classical computer, but without experiments

\item {} 
\sphinxAtStartPar
2020, \sphinxstyleemphasis{Alibaba} implements the \sphinxstyleemphasis{IBM} algorithm on its supercomputer and solves the problem in \(\sim 20\) days

\item {} 
\sphinxAtStartPar
2021, a group of Chinese scientists optimizes the classical algorithm and solves the problem on 60 \sphinxstyleemphasis{NVIDIA} video cards in 7 days

\item {} 
\sphinxAtStartPar
2021, a group of other Chinese scientists claims to have achieved a new superiority on a 56\sphinxhyphen{}qubit quantum computer

\end{itemize}

\sphinxAtStartPar
All in all, there is a rather interesting process of sword and shield warfare going on right now. While some scientists build more powerful quantum computers, others come up with more advanced algorithms to simulate them. Although, of course, all scientists say that at about 60\sphinxhyphen{}70 qubits this story will finally end in favor of quantum computers.


\section{What does it even look like? And how much does it cost?}
\label{\detokenize{book/intro/en/intro:what-does-it-even-look-like-and-how-much-does-it-cost}}
\sphinxAtStartPar
As of today, almost all known technologies for creating quantum computers require something of:
\begin{itemize}
\item {} 
\sphinxAtStartPar
ultra\sphinxhyphen{}low temperatures

\item {} 
\sphinxAtStartPar
ultrahigh vacuum

\item {} 
\sphinxAtStartPar
ultra\sphinxhyphen{}precise alignment of lasers on the optical bench

\end{itemize}

\sphinxAtStartPar
Or even all at once. That is why today almost all quantum computers are sold through cloud services. For example, relatively recently, the leading cloud technology provider \sphinxstyleemphasis{Amazon} added a new product to its \sphinxcode{\sphinxupquote{AWS}} service \sphinxhref{https://aws.amazon.com/braket/}{Amazon Braket}. This product allows you to rent a real computer, just as we are used to renting processors, video cards or hard drives. Similar products are now provided by other major players in the market of cloud services. This is all for research purposes only, though. After all, as we have already understood, today quantum computers are not yet able to solve real problems. For example, you can run your quantum program on a 32\sphinxhyphen{}bit \sphinxcode{\sphinxupquote{Aspen\sphinxhyphen{}9}} computer for only \$0.3 (per\sphinxhyphen{}task).

\sphinxAtStartPar
Some manufacturers go further and offer relatively compact solutions. For example, recently \sphinxhref{https://phys.org/news/2021-06-compact-quantum-server-centers.amp?\_\_twitter\_impression=true}{a 24\sphinxhyphen{}cube solution was introduced}, which fits in two standard server racks. But the scalability of such devices raises questions.

\sphinxAtStartPar
In any case, in the next 15\sphinxhyphen{}20 years we definitely should not wait for the appearance of a pocket quantum computer, or at least a quantum coprocessor in the home PC. And it does not make much sense, because few people at home need to hack bitcoin, solve a logistics problem or develop a high\sphinxhyphen{}temperature superconductor.


\section{Conclusion}
\label{\detokenize{book/intro/en/intro:conclusion}}
\sphinxAtStartPar
This is an introductory lecture; it will not give you any special knowledge. Rather, its purpose is to interest the reader. The most interesting part will be in the main part of the course where we will be dealing with quantum algorithms, trying to simulate quantum mechanics and training real quantum neural networks! We are waiting for you at the course!



\sphinxstepscope


\chapter{Prerequisite}
\label{\detokenize{book/intro/en/prerequisite:prerequisite}}\label{\detokenize{book/intro/en/prerequisite:prerequisite-en}}\label{\detokenize{book/intro/en/prerequisite::doc}}
\sphinxAtStartPar
Translation:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/vvssttkk}{vvssttkk}

\end{itemize}

\sphinxAtStartPar
This course combines both theory for in\sphinxhyphen{}depth understanding of the material and plenty of practice to reinforce skills and work through non\sphinxhyphen{}obvious situations/problems. Therefore, it is assumed that you already have some basic knowledge. You can check yourself with the optional \sphinxhref{https://ods.ai/tracks/qmlcourse/blocks/ee9f2a26-6234-4a72-84a6-a05de035bb1a}{Entrance Test}, which will help you understand if you need to take the introductory “blue” lectures – on Python, math and machine learning (15 questions total, 5 per block). The test is pretty simple, so if you pass it without mistakes or almost without mistakes \sphinxhyphen{} that doesn’t say much, anyway it can be difficult. But if you have a lot of mistakes, then you should turn to the introductory “blue” blocks.


\section{Python, Poetry and development environment}
\label{\detokenize{book/intro/en/prerequisite:python-poetry-and-development-environment}}
\sphinxAtStartPar
To be successful in the course you must be able to do and understand such things as
\begin{itemize}
\item {} 
\sphinxAtStartPar
copying files from GitHub;

\item {} 
\sphinxAtStartPar
installing \sphinxcode{\sphinxupquote{Poetry}} and the \sphinxcode{\sphinxupquote{Python}} libraries;

\item {} 
\sphinxAtStartPar
how to run/start the \sphinxcode{\sphinxupquote{Jupyter Notebook}};

\item {} 
\sphinxAtStartPar
the basic keyboard shortcuts in \sphinxcode{\sphinxupquote{Jupyter Notebook}};

\item {} 
\sphinxAtStartPar
how to run code in \sphinxcode{\sphinxupquote{Jupyter Notebook}};

\item {} 
\sphinxAtStartPar
what simple data types exist in \sphinxcode{\sphinxupquote{Python}};

\item {} 
\sphinxAtStartPar
how to work with complex container types (\sphinxcode{\sphinxupquote{list}}, \sphinxcode{\sphinxupquote{dict}}, \sphinxcode{\sphinxupquote{tuple}}), including the most popular methods of each;

\item {} 
\sphinxAtStartPar
how \sphinxcode{\sphinxupquote{Python arithmetic}} works and how variables of different types relate to one another;

\item {} 
\sphinxAtStartPar
what are conditional constructs and branching logic;

\item {} 
\sphinxAtStartPar
what is a block of code in \sphinxcode{\sphinxupquote{Python}} and why indents (tabs) are needed;

\item {} 
\sphinxAtStartPar
what loops are and how they can be used with complex data types;

\item {} 
\sphinxAtStartPar
how to write functions in \sphinxcode{\sphinxupquote{Python}} and what function arguments are and what they are;

\item {} 
\sphinxAtStartPar
what a decorator is and how to use it;

\item {} 
\sphinxAtStartPar
basic OOP: class declaration, the concept of a class object, the ability to write class methods.

\end{itemize}

\sphinxAtStartPar
If you don’t understand any of the topics, it is highly recommended that you refresh your knowledge (or even acquire it) by taking the corresponding lessons in Python Basics. Even if you have experience working with it and writing code, you are encouraged to learn how to install all the necessary dependencies and libraries, as well as the hotkeys and various functions in the \sphinxcode{\sphinxupquote{Jupyter Notebook}}.


\section{Linear algebra and \sphinxstyleliteralintitle{\sphinxupquote{Numpy}}}
\label{\detokenize{book/intro/en/prerequisite:linear-algebra-and-numpy}}
\sphinxAtStartPar
To understand basic quantum algorithms and quantum machine learning algorithms, just as in classical machine learning, one cannot do without linear algebra. If you have time to take mathematics seriously, we recommend \sphinxhref{https://ocw.mit.edu/courses/18-06-linear-algebra-spring-2010/}{Gilbert Strang} or \sphinxhref{https://www.litres.ru/d-v-beklemishev/kurs-analiticheskoy-geometrii-i-lineynoy-algebry-66005405/}{D.V. Beklemishev (RU)} courses, as well as \sphinxhref{https://biblio.mccme.ru/node/2192}{A.I. Kostrikin’s problem book (RU)}. And if you have ever studied linear algebra, but have forgotten it, a block of our course will help. We want you to have no problems with such concepts as
\begin{itemize}
\item {} 
\sphinxAtStartPar
vector\sphinxhyphen{}line and vector\sphinxhyphen{}column;

\item {} 
\sphinxAtStartPar
linear dependence of vectors;

\item {} 
\sphinxAtStartPar
systems of linear equations;

\item {} 
\sphinxAtStartPar
matrices, determinants and trace of a matrix;

\item {} 
\sphinxAtStartPar
linear operator;

\item {} 
\sphinxAtStartPar
complex and Hermite conjugation;

\item {} 
\sphinxAtStartPar
scalar and vector product;

\item {} 
\sphinxAtStartPar
Hilbert space.

\end{itemize}

\sphinxAtStartPar
The list is obviously not exhaustive, and it is likely that you will not list all the things that can be encountered as you study quantum algorithms.


\section{Machime Learning}
\label{\detokenize{book/intro/en/prerequisite:machime-learning}}
\sphinxAtStartPar
Finally, to talk about quantum machine learning, you need to have a good understanding of machine learning. \DUrole{xref,myst}{This course unit} describes what different machine learning tasks have in common and how the various applications of machine learning models are put together like a jigsaw puzzle. This block, however, does not replace a good book or course on machine learning (like \sphinxhref{https://www.coursera.org/learn/machine-learning}{Andrew Ng course}, \sphinxhref{https://datasciencecourse.ru/}{Yandex and MIPT specialization (RU)}, \sphinxhref{https://mlcourse.ai}{mlcourse.ai}, \sphinxhref{https://github.com/esokolov/ml-course-hse}{Machine Learning course at FKN HSE – E. A. Sokolov (RU)} or \sphinxhref{https://ml-handbook.ru/}{SHAD’s Machine Learning Tutorial (RU)}) covering topics such as:
\begin{itemize}
\item {} 
\sphinxAtStartPar
teacher\sphinxhyphen{}assisted and non\sphinxhyphen{}teacher\sphinxhyphen{}assisted learning, reinforcement learning;

\item {} 
\sphinxAtStartPar
quality metrics in learning tasks with a teacher;

\item {} 
\sphinxAtStartPar
loss functions and reduction of machine learning problems to optimization problems;

\item {} 
\sphinxAtStartPar
feature processing and construction;

\item {} 
\sphinxAtStartPar
model quality assessment and cross validation;

\item {} 
\sphinxAtStartPar
classification and regression algorithms: decision trees, forest, boosting, logistic regression, etc;

\item {} 
\sphinxAtStartPar
ranking algorithms, ranking quality metrics;

\item {} 
\sphinxAtStartPar
teacherless learning: dimensionality reduction, clustering, anomaly search;

\item {} 
\sphinxAtStartPar
bayesian view of machine learning;

\item {} 
\sphinxAtStartPar
representation learning.

\end{itemize}

\sphinxAtStartPar
Again, this is not an exhaustive list, and it covers only the “classics,” ignoring deep learning. But if any of these things are confusing or if the entry \sphinxhref{https://ods.ai/tracks/qmlcourse/blocks/ee9f2a26-6234-4a72-84a6-a05de035bb1a}{test} fails, it may be worth referring to the courses mentioned above.

\sphinxstepscope


\part{Linear Algebra and Numpy}

\sphinxstepscope


\chapter{About “Linear Algebra and Numpy”}
\label{\detokenize{book/linalg/en/linalg_intro:about-linear-algebra-and-numpy}}\label{\detokenize{book/linalg/en/linalg_intro:linalg-intro-en}}\label{\detokenize{book/linalg/en/linalg_intro::doc}}
\sphinxAtStartPar
This unit is designed to discuss the basic concepts and ideas of linear algebra and is a quick reference guide; \sphinxstylestrong{is not} a full\sphinxhyphen{}fledged textbook. For a more detailed dive into the topic we recommend the textbook \sphinxhref{https://www.inm.ras.ru/wp-content/uploads/library/Monographies/all.pdf}{“Matrix Analysis and Linear Algebra” (RU)} by Tyrtyshnikov E. Е. or \sphinxhref{http://www.cse.zju.edu.cn/eclass/attachments/2015-10/01-1446086008-145421.pdf}{“Matrix Analysis” (EN)} by Roger A. Horn, Charles R. Johnson.

\sphinxAtStartPar
Within the unit:
\begin{itemize}
\item {} 
\sphinxAtStartPar
discuss basic concepts and ideas such as \sphinxstylestrong{vectors} and \sphinxstylestrong{matrices};

\item {} 
\sphinxAtStartPar
get acquainted with tools for working with vectors and matrices;

\item {} 
\sphinxAtStartPar
let’s try to calculate something!

\end{itemize}

\sphinxAtStartPar
Descriptions:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\(a\) – a number (scalar);

\item {} 
\sphinxAtStartPar
\(\mathbf{a}\) –  vector;

\item {} 
\sphinxAtStartPar
\(\mathbf{A}\) – matrix.

\end{itemize}

\sphinxAtStartPar
Useful material:
\begin{itemize}
\item {} 
\sphinxAtStartPar
MathProfi: \sphinxhref{http://mathprofi.ru/vektory\_dlya\_chainikov.html}{Analytic geometry (RU)}.

\item {} 
\sphinxAtStartPar
3Blue1Brown: \sphinxhref{https://youtube.com/playlist?list=PLZHQObOWTQDPD3MizzM2xVFitgF8hE\_ab}{Essence of linear algebra}.

\end{itemize}

\sphinxstepscope


\chapter{Vectors}
\label{\detokenize{book/linalg/en/vectors:vectors}}\label{\detokenize{book/linalg/en/vectors:vectors-en}}\label{\detokenize{book/linalg/en/vectors::doc}}
\sphinxAtStartPar
Author(s):
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{http://github.com/dayyass}{El\sphinxhyphen{}Ayyass Dani}

\end{itemize}

\sphinxAtStartPar
Translation:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{http://github.com/alexey-pronkin}{Pronkin Alexey}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/Randl}{Zheltonozhskii Evgenii}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/vvssttkk}{vvssttkk}

\end{itemize}


\section{Definition}
\label{\detokenize{book/linalg/en/vectors:definition}}
\sphinxAtStartPar
The term \sphinxcode{\sphinxupquote{vector}} has several interpretations: mathematical, geometric, physical, etc. The exact meaning of the term depends on the context.

\sphinxAtStartPar
Formally, a vector is defined as an element of vector space – a set with \sphinxstylestrong{addition} and \sphinxstylestrong{multiplication of a vector by a number (scalar)} operations, which satisfy \sphinxhref{https://en.wikipedia.org/wiki/Vector\_space}{8 axioms}.

\sphinxAtStartPar
For simplicity, let us consider the rectangular (Cartesian) coordinate system in the plane, familiar from school days – two perpendicular to each other axes \(x\) and \(y\), selected unit vectors (orthogonal) \(\mathbf{e}_1\), \(\mathbf{e}_2\) on them and the origin of coordinates.

\sphinxAtStartPar
The vector \(\mathbf{a}\) in this coordinate system can be written as follows: \(\mathbf{a} = a_1 \mathbf{e}_1 + a_2 \mathbf{e}_2 = \begin{pmatrix} a_1 \\ a_2 \end{pmatrix}\)

\sphinxAtStartPar
\sphinxstylestrong{Note 1}: Vector coordinates do not uniquely define its position in the plane, but only the position of the vector’s end relative to its start. For example, a vector \(\begin{pmatrix} 3 \\ 4 \end{pmatrix}\) can be drawn either from the origin \(\begin{pmatrix} 0 , 0 \end{pmatrix}\) with the end at \(\begin{pmatrix} 3 , 4 \end{pmatrix}\), or from an arbitrary point, e.g. \(\begin{pmatrix} 1 , 1 \end{pmatrix}\) with the end at \(\begin{pmatrix} 4 , 5 \end{pmatrix}\). Both of these vectors correspond to 3 orthogonal unite vectors on the \(x\)\sphinxhyphen{}axis and 4 on the \(y\)\sphinxhyphen{}axis. Normally, unless otherwise stated, it is assumed that the vector is deferred from the origin.

\sphinxAtStartPar
\sphinxstylestrong{Note 2}: A vector can be represented either as a column vector \(\begin{pmatrix} a_1 \ a_2 \end{pmatrix}\) or as a row vector \(\begin{pmatrix} a_1 \ a_2 \end{pmatrix}\). Hereinafter, by a vector we mean a column vector, unless otherwise stated.

\sphinxAtStartPar
The notion of a vector in the plane can be generalized to 3\sphinxhyphen{}dimensional space, and, in general, to \(n\)\sphinxhyphen{}dimensional space (which can no longer be visualized):
\begin{equation*}
\begin{split}
    \mathbf{a} = a_1 \mathbf{e}_1 + a_2 \mathbf{e}_2 + ... + a_n \mathbf{e}_n = \begin{pmatrix} a_1 \ a_2 \\ ... \ a_n \end{pmatrix}
\end{split}
\end{equation*}

\section{Vector operations}
\label{\detokenize{book/linalg/en/vectors:vector-operations}}
\sphinxAtStartPar
As stated earlier, there are two basic operations on vectors in the formal definition:
\begin{itemize}
\item {} 
\sphinxAtStartPar
addition:

\end{itemize}
\begin{equation*}
\begin{split}
    \mathbf{a} + \mathbf{b} = (a_1 + b_1) \mathbf{e}_1 + (a_2 + b_2) \mathbf{e}_2 + ... + (a_n + b_n) \mathbf{e}_n = \ = \begin{pmatrix} a_1 \ a_2 \\ ... \ a_n \end{pmatrix} + \begin{pmatrix} b_1 \\ b_2 \\ ... \ b_n \end{pmatrix} = \begin{pmatrix} a_1 + b_1 \ a_2 + b_2 \\ ... \ a_n + b_n \end{pmatrix}
\end{split}
\end{equation*}\begin{itemize}
\item {} 
\sphinxAtStartPar
multiplication of a vector by a number (scalar):

\end{itemize}
\begin{equation*}
\begin{split}
    \lambda \mathbf{a} = \lambda a_1 \mathbf{e}_1 + \lambda a_2 \mathbf{e}_2 + ... + \lambda a_n \mathbf{e}_n = \lambda \begin{pmatrix} a_1 \\ a_2 \\ ... \\ a_n \end{pmatrix} = \begin{pmatrix} \lambda a_1 \\ \lambda a_2 \\ ... \\ \lambda a_n \end{pmatrix}
\end{split}
\end{equation*}
\sphinxAtStartPar
The operation of multiplying a vector by a number can be interpreted geometrically as a contraction/extension of a vector.

\sphinxAtStartPar
Using these two operations, we can define \sphinxstylestrong{linear combinations of vectors}: \(\alpha_1 \mathbf{a}_1 + \alpha_2 \mathbf{a}_2 + ... + \alpha_n \mathbf{a}_n ,\) where \(\mathbf{a}_1, \mathbf{a}_2, ..., \mathbf{a}_n\) are vectors and \(\alpha_1, \alpha_2, ..., \alpha_n\) are numbers.


\section{The norm (length) of a vector}
\label{\detokenize{book/linalg/en/vectors:the-norm-length-of-a-vector}}
\sphinxAtStartPar
In linear algebra, the term \sphinxstylestrong{norm} is used to generalize the notion of vector length. It can be said that the notions of length and norm are equivalent.

\sphinxAtStartPar
Formally the norm is defined as a functional in the vector space satisfying \sphinxhref{https://en.wikipedia.org/wiki/Norm\_(mathematics)}{3 axioms}. Norm is mapping elements of this space (vectors) to the set of non\sphinxhyphen{}negative real numbers.

\sphinxAtStartPar
There are many functionals satisfying this definition of norm, but we will consider the most commonly used one – \sphinxstylestrong{Euclidean norm}.

\sphinxAtStartPar
For simplicity, let us consider a vector in the plane. Geometrically, it is a directional segment. The directionality of a vector has no effect on its length, so we can work with it as a segment in the plane and calculate its length using school formulas.
Note that the vector coordinates correspond to the numbers multiplying coordinate axis orthogonal vectors, so the vector length formula is: \(\lVert \mathbf{a} \rVert = \sqrt{a_1^2 + a_2^2}\). Accordingly, in general, the formula is  \(\lVert \mathbf{a} \rVert = \sqrt{a_1^2 + a_2^2 + ... + a_n^2}\).


\section{Scalar product}
\label{\detokenize{book/linalg/en/vectors:scalar-product}}
\sphinxAtStartPar
One of the most common operations on two vectors is the so\sphinxhyphen{}called \sphinxstylestrong{scalar product}, the result of which is a number (scalar) – hence the name of the operation.

\sphinxAtStartPar
\sphinxstylestrong{Note}: In addition to scalar product there is also \sphinxhref{https://en.wikipedia.org/wiki/Cross\_product}{vector product or cross product} over a pair of vectors, the result of which is a vector. There is also \sphinxhref{https://en.wikipedia.org/wiki/Triple\_product}{triple product} over a triplet of vectors, the result of which is a number. These operations will not be covered in this course.

\sphinxAtStartPar
Scalar product is used in determining the length of vectors and the angle between them. This operation has two definitions:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Algebraic: \( \mathbf{a} \cdot \mathbf{b} = a_1 b_1 + a_2 b_2 + ... + a_n b_n\)

\item {} 
\sphinxAtStartPar
geometric: \(\mathbf{a} \cdot \mathbf{b} = \lVert \mathbf{a} \rVert \lVert \mathbf{b} \rVert \cos{\\theta},\) where \(\theta\) is the angle between the vectors \(\mathbf{a}\) and \(\mathbf{b}\).

\end{itemize}

\sphinxAtStartPar
Using both of these definitions, we can derive a formula for calculating the cosine of the angle between the vectors:
\begin{equation*}
\begin{split}
    \cos{\theta} = \frac{\mathbf{a} \cdot \mathbf{b}}{\lVert \mathbf{a} \rVert \lVert \mathbf{b} \rVert} = \frac{a_1 b_1 + a_2 b_2 + ... + a_n b_n}{\sqrt{a_1^2 + a_2^2 + ... + a_n^2} \sqrt{b_1^2 + b_2^2 + ... + b_n^2}}
\end{split}
\end{equation*}
\sphinxAtStartPar
Using this formula we can arrive at one of the main properties of scalar product, which is that \sphinxstylestrong{two vectors are perpendicular if and only if their scalar product is 0}: \(\mathbf{a} \perp \mathbf{b} \leftrightarrow \cos{\theta} = 0 \leftrightarrow \mathbf{a} \cdot \mathbf{b} = 0\)

\sphinxAtStartPar
The scalar product can be used to calculate the vector norm as follows: \(\lVert \mathbf{a} \rVert = \sqrt{\mathbf{a} \cdot \mathbf{a}}\)


\section{Linear independence}
\label{\detokenize{book/linalg/en/vectors:linear-independence}}
\sphinxAtStartPar
One of the fundamental concepts of linear algebra is \sphinxstylestrong{linear dependence/independence}.

\sphinxAtStartPar
To define this concept, consider a set of several vectors. A set of vectors is \sphinxstylestrong{linearly dependent} if there exists nontrivial linear combination of vectors of this set (at least one element of this combination is not 0) equal to a zero vector (a vector consisting only of 0):
\begin{equation*}
\begin{split}
    \lambda_1 \mathbf{a}_1 + \lambda_2 \mathbf{a}_2 + ... + \lambda_m \mathbf{a}_m = \begin{pmatrix} 0 \\ 0 \\ ... \\ 0 \end{pmatrix}, \ \exists j, \, \lambda_j \not = {0}
\end{split}
\end{equation*}
\sphinxAtStartPar
If a set of vectors is not linearly dependent, that is, there is no nontrivial linear combination of vectors of a given set equal to the zero vector, then such a set of vectors is called \sphinxstylestrong{linearly independent}.

\sphinxAtStartPar
\sphinxstylestrong{Example}:
\begin{itemize}
\item {} 
\sphinxAtStartPar
A linearly independent set of vectors (only the zero coefficients of a linear combination lead to a zero vector):

\end{itemize}
\begin{equation*}
\begin{split}
    \begin{pmatrix} 1 \\ 0 \\ 0 \end{pmatrix} \begin{pmatrix} 0 \\ 1 \\ 0 \end{pmatrix} \begin{pmatrix} 0 \\\ 0 \\ 1 \end{pmatrix} \rightarrow 0 \cdot \begin{pmatrix} 1 \\ 0 \\ 0  \end{pmatrix} + 0 \cdot \begin{pmatrix} 0 \\ 1 \\ 0 \end{pmatrix} + 0 \cdot \begin{pmatrix} 0 \\ 0 \\ 1 \end{pmatrix} = \begin{pmatrix} 0 \\ 0 \\ 0 \end{pmatrix}
\end{split}
\end{equation*}\begin{itemize}
\item {} 
\sphinxAtStartPar
linearly dependent set of vectors (there are non\sphinxhyphen{}zero coefficients of the linear combination that lead to the zero vector):

\end{itemize}
\begin{equation*}
\begin{split}
    \begin{pmatrix} 1 \\ 0 \\ 0 \end{pmatrix} \begin{pmatrix} 0 \\ 1 \\ 0 \end{pmatrix} \begin{pmatrix} 2 \\ 3 \\ 0 \end{pmatrix} \rightarrow 2 \cdot \begin{pmatrix} 1 \\ 0 \\ 0 \end{pmatrix} + 3 \cdot \begin{pmatrix} 0 \\ 1 \\ 0 \end{pmatrix} - 1 \cdot\begin{pmatrix} 2 \\ 3 \\ 0 \end{pmatrix} = \begin{pmatrix} 0 \\ 0 \\ 0 \end{pmatrix}
\end{split}
\end{equation*}
\sphinxAtStartPar
The following property can be deduced from the definition of linear dependence:
A set of vectors is linearly dependent if and only if one of the elements of that set can be expressed through the remaining elements.

\sphinxAtStartPar
\sphinxstylestrong{Note}: If vectors represent some characteristics of objects, then linear dependence can be interpreted as data redundancy.

\sphinxAtStartPar
The notion of linear independence introduces the concept of \sphinxstylestrong{dimensionality} of a vector space – the maximum number of linearly independent vectors in it.


\section{Basis}
\label{\detokenize{book/linalg/en/vectors:basis}}
\sphinxAtStartPar
In the formal definition of a vector there are no quantitative interpretations of it, just two operations on vectors and 8 axioms.

\sphinxAtStartPar
So where do quantitative measurements come from? To make this clear, we need to introduce the concept of \sphinxstylestrong{basis}.

\sphinxAtStartPar
A basis is a finite set of vectors in a vector space such that any vector in that space can be uniquely represented as a linear combination of vectors of that set.

\sphinxAtStartPar
Recall one of the examples above, where we represented a rectangular coordinate system in the plane and unit vectors \(\mathbf{e}_1\), \(\mathbf{e}_2\). \(\mathbf{e}_1 = \begin{pmatrix} 1 \\ 0 \end{pmatrix}\), \(\mathbf{e}_2 = \begin{pmatrix} 0 \\ 1 \end{pmatrix}\).
In this example, we decompose the arbitrary vector \(\mathbf{a}\) as follows:
\begin{equation*}
\begin{split}
    \mathbf{a} = a_1 \mathbf{e}_1 + a_2 \mathbf{e}_2 = a_1 \begin{pmatrix} 1 \\ 0 \end{pmatrix} + a_2 \begin{pmatrix} 0 \\ 1 \end{pmatrix} = \begin{pmatrix} a_1 \\ 0 \end{pmatrix} + \begin{pmatrix} 0 \\ a_2 \end{pmatrix} = \begin{pmatrix} a_1 \\ a_2 \end{pmatrix}
\end{split}
\end{equation*}
\sphinxAtStartPar
It turns out that the orthogonal vectors \(\mathbf{e}_1\), \(\mathbf{e}_2\) \sphinxstylestrong{are the basis of the two\sphinxhyphen{}dimensional vector space}, and by linear combination of these vectors we can uniquely represent any vector in this space.

\sphinxAtStartPar
The question arises, is this basis unique in two\sphinxhyphen{}dimensional space, or not?

\sphinxAtStartPar
The answer to this question is no. In fact, one can take any two vectors (\sphinxstylestrong{almost any}) and they will also form a basis, meaning that any vector can be decomposed by their linear combination.

\sphinxAtStartPar
\sphinxstylestrong{Example}.

\sphinxAtStartPar
Suppose we have a vector \(\begin{pmatrix} 2 \\ 3 \end{pmatrix}\) in a basis of unit orthogonal vectors, and we want to decompose it in another basis \(\begin{pmatrix} -2 \\ 0 \end{pmatrix} \begin{pmatrix} 0 \\ -3 \end{pmatrix}\):
\begin{equation*}
\begin{split}
    \alpha_1 \begin{pmatrix} -2 \\ 0 \end{pmatrix} + \alpha_2 \begin{pmatrix} 0 \\ -3 \end{pmatrix} = \begin{pmatrix} 2 \\3 \end{pmatrix}
\end{split}
\end{equation*}
\sphinxAtStartPar
From where we can find that \(\alpha_1 = -1\), \(\alpha_2 = -1\):
\begin{equation*}
\begin{split}
    -1 \begin{pmatrix} -2 \\ 0 \end{pmatrix} + -1 \begin{pmatrix} 0 \\ -3 \end{pmatrix} = \begin{pmatrix} 2 \\ 0 \end{pmatrix} + \begin{pmatrix} 0 \\ 3 \end{pmatrix} = \begin{pmatrix} 2 \\ 3 \end{pmatrix}
\end{split}
\end{equation*}
\sphinxAtStartPar
So, vector \(\begin{pmatrix} 2 \\ 3 \end{pmatrix}\) in the basis of unit orthogonal vectors is represented as \(\begin{pmatrix} -1 \\ -1 \end{pmatrix}\) in the basis \(\begin{pmatrix} -2 \\ 0 \end{pmatrix} \begin{pmatrix} 0 \\ -3 \end{pmatrix}\).

\sphinxAtStartPar
But, as mentioned before, \sphinxstylestrong{not any set of vectors}  makes a basis.

\sphinxAtStartPar
For example, the set of vectors \(\begin{pmatrix} -2 \\ 0 \end{pmatrix}\), \(\begin{pmatrix} -3 \\ 0 \end{pmatrix}\) cannot decompose the vector \(\begin{pmatrix} 2 \\ 3 \end{pmatrix}\), so this set of vectors is not a basis.

\sphinxAtStartPar
What is the fundamental difference between these sets, and can the basis of a two\sphinxhyphen{}dimensional space consist of more or fewer vectors than 2?

\sphinxAtStartPar
Linear algebra has an answer to this:

\sphinxAtStartPar
\sphinxstylestrong{Any \(n\) linearly independent vectors of \(n\)\sphinxhyphen{}dimensional vector space form the basis of that space.}

\sphinxAtStartPar
Exactly due to the linear dependence, the vectors \(\begin{pmatrix} -2 \\ 0 \end{pmatrix}\), \(\begin{pmatrix} -3 \\ 0 \end{pmatrix}\) can’t be the basis of a two\sphinxhyphen{}dimensional space.


\section{What did we learn?}
\label{\detokenize{book/linalg/en/vectors:what-did-we-learn}}\begin{itemize}
\item {} 
\sphinxAtStartPar
The definition of a vector;

\item {} 
\sphinxAtStartPar
The operations on vectors;

\item {} 
\sphinxAtStartPar
The vector norm (length);

\item {} 
\sphinxAtStartPar
The scalar product;

\item {} 
\sphinxAtStartPar
The linear independence;

\item {} 
\sphinxAtStartPar
The basis.

\end{itemize}

\begin{sphinxthebibliography}{Havlivce}
\bibitem[ion]{book/bibliography:id42}
\sphinxAtStartPar
Single trapped atom captures science photography competition's top prize. Accessed: 2021\sphinxhyphen{}10\sphinxhyphen{}05. URL: \sphinxurl{https://webarchive.nationalarchives.gov.uk/ukgwa/20200930161403/https://epsrc.ukri.org/newsevents/news/single-trapped-atom-captures-science-photography-competitions-top-prize/}.
\bibitem[Mon]{book/bibliography:id10}
\sphinxAtStartPar
Varenna summer school on ion traps: quantum simulation, lecture i. Accessed: 2021\sphinxhyphen{}10\sphinxhyphen{}05. URL: \sphinxurl{https://iontrap.umd.edu/wp-content/uploads/2014/01/Lecture1\_QSIM.pptx}.
\bibitem[AMunozNK21]{book/bibliography:id17}
\sphinxAtStartPar
Shahnawaz Ahmed, Carlos Sánchez Muñoz, Franco Nori, and Anton Frisk Kockum. Quantum state tomography with conditional generative adversarial networks. \sphinxstyleemphasis{Physical Review Letters}, 127(14):140502, 2021. \sphinxhref{https://doi.org/https://doi.org/10.1103/PhysRevLett.127.140502}{doi:https://doi.org/10.1103/PhysRevLett.127.140502}.
\bibitem[And19]{book/bibliography:id28}
\sphinxAtStartPar
Neculai Andrei. A diagonal quasi\sphinxhyphen{}newton updating method for unconstrained optimization. \sphinxstyleemphasis{Numerical Algorithms}, 81(2):575–590, 2019. \sphinxhref{https://doi.org/https://doi.org/10.1007/s11075-018-0562-7}{doi:https://doi.org/10.1007/s11075\sphinxhyphen{}018\sphinxhyphen{}0562\sphinxhyphen{}7}.
\bibitem[Arn51]{book/bibliography:id18}
\sphinxAtStartPar
Walter Edwin Arnoldi. The principle of minimized iterations in the solution of the matrix eigenvalue problem. \sphinxstyleemphasis{Quarterly of applied mathematics}, 9(1):17–29, 1951. URL: \sphinxurl{https://www.ams.org/journals/qam/1951-09-01/S0033-569X-1951-42792-9/S0033-569X-1951-42792-9.pdf}.
\bibitem[ABBradler+21]{book/bibliography:id2}
\sphinxAtStartPar
J. M. Arrazola, V. Bergholm, K. Brádler, T. R. Bromley, M. J. Collins, I. Dhand, A. Fumagalli, T. Gerrits, A. Goussev, L. G. Helt, J. Hundal, T. Isacsson, R. B. Israel, J. Izaac, S. Jahangiri, R. Janik, N. Killoran, S. P. Kumar, J. Lavoie, A. E. Lita, D. H. Mahler, M. Menotti, B. Morrison, S. W. Nam, L. Neuhaus, H. Y. Qi, N. Quesada, A. Repingon, K. K. Sabapathy, M. Schuld, D. Su, J. Swinarton, A. Száva, K. Tan, P. Tan, V. D. Vaidya, Z. Vernon, Z. Zabaneh, and Y. Zhang. Quantum circuits with many photons on a programmable nanophotonic chip. \sphinxstyleemphasis{Nature}, 591(7848):54–60, mar 2021. \sphinxhref{https://arxiv.org/abs/2103.02109}{arXiv:2103.02109}, \sphinxhref{https://doi.org/10.1038/s41586-021-03202-1}{doi:10.1038/s41586\sphinxhyphen{}021\sphinxhyphen{}03202\sphinxhyphen{}1}.
\bibitem[AAB+19]{book/bibliography:id68}
\sphinxAtStartPar
Frank Arute, Kunal Arya, Ryan Babbush, Dave Bacon, Joseph C Bardin, Rami Barends, Rupak Biswas, Sergio Boixo, Fernando GSL Brandao, David A Buell, and others. Quantum supremacy using a programmable superconducting processor. \sphinxstyleemphasis{Nature}, 574(7779):505–510, 2019. \sphinxhref{https://doi.org/https://doi.org/10.1038/s41586-019-1666-5}{doi:https://doi.org/10.1038/s41586\sphinxhyphen{}019\sphinxhyphen{}1666\sphinxhyphen{}5}.
\bibitem[BGrotschelJungerR88]{book/bibliography:id19}
\sphinxAtStartPar
Francisco Barahona, Martin Grötschel, Michael Jünger, and Gerhard Reinelt. An application of combinatorial optimization to statistical physics and circuit layout design. \sphinxstyleemphasis{Operations Research}, 36(3):493–513, 1988.
\bibitem[BAG21]{book/bibliography:id20}
\sphinxAtStartPar
Afrad Basheer, A. Afham, and Sandeep K. Goyal. Quantum \$k\$\sphinxhyphen{}nearest neighbors algorithm. 2021. \sphinxhref{https://arxiv.org/abs/2003.09187}{arXiv:2003.09187}.
\bibitem[BV04]{book/bibliography:id3}
\sphinxAtStartPar
Stephen Boyd and Lieven Vandenberghe. \sphinxstyleemphasis{Convex Optimization}. Cambridge University Press, March 2004. ISBN 0521833787. URL: \sphinxurl{http://www.amazon.com/exec/obidos/redirect?tag=citeulike-20\textbackslash{}\&path=ASIN/0521833787}.
\bibitem[BK02]{book/bibliography:id21}
\sphinxAtStartPar
Sergey Bravyi and Alexei Kitaev. Fermionic quantum computation. \sphinxstyleemphasis{Annals of Physics}, 298(1):210–226, 2002.
\bibitem[BVM+21]{book/bibliography:id22}
\sphinxAtStartPar
Michael Broughton, Guillaume Verdon, Trevor McCourt, Antonio J. Martinez, Jae Hyeon Yoo, Sergei V. Isakov, Philip Massey, Ramin Halavati, Murphy Yuezhen Niu, Alexander Zlokapa, Evan Peters, Owen Lockwood, Andrea Skolik, Sofiene Jerbi, Vedran Dunjko, Martin Leib, Michael Streif, David Von Dollen, Hongxiang Chen, Shuxiang Cao, Roeland Wiersema, Hsin\sphinxhyphen{}Yuan Huang, Jarrod R. McClean, Ryan Babbush, Sergio Boixo, Dave Bacon, Alan K. Ho, Hartmut Neven, and Masoud Mohseni. Tensorflow quantum: a software framework for quantum machine learning. 2021. URL: \sphinxurl{https://arxiv.org/abs/2003.02989}, \sphinxhref{https://arxiv.org/abs/2003.02989}{arXiv:2003.02989}.
\bibitem[CCH+19]{book/bibliography:id24}
\sphinxAtStartPar
Giuseppe Carleo, Kenny Choo, Damian Hofmann, James ET Smith, Tom Westerhout, Fabien Alet, Emily J Davis, Stavros Efthymiou, Ivan Glasser, Sheng\sphinxhyphen{}Hsuan Lin, and others. Netket: a machine learning toolkit for many\sphinxhyphen{}body quantum systems. \sphinxstyleemphasis{SoftwareX}, 10:100311, 2019.
\bibitem[CT17]{book/bibliography:id23}
\sphinxAtStartPar
Giuseppe Carleo and Matthias Troyer. Solving the quantum many\sphinxhyphen{}body problem with artificial neural networks. \sphinxstyleemphasis{Science}, 355(6325):602–606, 2017. URL: \sphinxurl{https://arxiv.org/abs/1606.02318}.
\bibitem[CBSG17]{book/bibliography:id57}
\sphinxAtStartPar
Andrew W. Cross, Lev S. Bishop, John A. Smolin, and Jay M. Gambetta. Open quantum assembly language. 2017. URL: \sphinxurl{https://arxiv.org/abs/1707.03429}, \sphinxhref{https://arxiv.org/abs/1707.03429}{arXiv:1707.03429}.
\bibitem[DAPN21]{book/bibliography:id60}
\sphinxAtStartPar
Prasanna Date, Davis Arthur, and Lauren Pusey\sphinxhyphen{}Nazzaro. Qubo formulations for training machine learning models. \sphinxstyleemphasis{Scientific Reports}, 11:10029, May 2021. URL: \sphinxurl{https://doi.org/10.1038/s41598-021-89461-4}, \sphinxhref{https://doi.org/10.1038/s41598-021-89461-4}{doi:10.1038/s41598\sphinxhyphen{}021\sphinxhyphen{}89461\sphinxhyphen{}4}.
\bibitem[DPP19]{book/bibliography:id29}
\sphinxAtStartPar
Prasanna Date, Robert Patton, and Thomas Potok. Efficiently embedding qubo problems on adiabatic quantum computers. \sphinxstyleemphasis{Quantum Information Processing}, 18:117, Mar 2019. URL: \sphinxurl{https://doi.org/10.1007/s11128-019-2236-3}, \sphinxhref{https://doi.org/10.1007/s11128-019-2236-3}{doi:10.1007/s11128\sphinxhyphen{}019\sphinxhyphen{}2236\sphinxhyphen{}3}.
\bibitem[DFO20]{book/bibliography:id26}
\sphinxAtStartPar
Marc Peter Deisenroth, A Aldo Faisal, and Cheng Soon Ong. \sphinxstyleemphasis{Mathematics for machine learning}. Cambridge University Press, 2020. \sphinxurl{https://mml-book.github.io/book/mml-book.pdf}.
\bibitem[DHM+18]{book/bibliography:id27}
\sphinxAtStartPar
Danial Dervovic, Mark Herbster, Peter Mountney, Simone Severini, Naïri Usher, and Leonard Wossnig. Quantum linear systems algorithms: a primer. 2018. \sphinxhref{https://arxiv.org/abs/1802.08227}{arXiv:1802.08227}.
\bibitem[FGG14]{book/bibliography:id31}
\sphinxAtStartPar
Edward Farhi, Jeffrey Goldstone, and Sam Gutmann. A quantum approximate optimization algorithm. 2014. \sphinxhref{https://arxiv.org/abs/1411.4028}{arXiv:1411.4028}.
\bibitem[FGGS00]{book/bibliography:id30}
\sphinxAtStartPar
Edward Farhi, Jeffrey Goldstone, Sam Gutmann, and Michael Sipser. Quantum computation by adiabatic evolution. 2000. \sphinxhref{https://arxiv.org/abs/0001106}{arXiv:0001106}.
\bibitem[GKD19]{book/bibliography:id32}
\sphinxAtStartPar
Fred Glover, Gary Kochenberger, and Yu Du. A tutorial on formulating and using qubo models. 2019. \sphinxhref{https://arxiv.org/abs/1811.11538}{arXiv:1811.11538}.
\bibitem[GBC16]{book/bibliography:id4}
\sphinxAtStartPar
Ian Goodfellow, Yoshua Bengio, and Aaron Courville. \sphinxstyleemphasis{Deep Learning}. MIT Press, 2016. \sphinxurl{http://www.deeplearningbook.org}.
\bibitem[GK21]{book/bibliography:id5}
\sphinxAtStartPar
Peter Groszkowski and Jens Koch. Scqubits: a python package for superconducting qubits. \sphinxstyleemphasis{arXiv e\sphinxhyphen{}prints}, jul 2021. \sphinxhref{https://arxiv.org/abs/2107.08552}{arXiv:2107.08552}.
\bibitem[HHL09]{book/bibliography:id6}
\sphinxAtStartPar
Aram W. Harrow, Avinatan Hassidim, and Seth Lloyd. Quantum algorithm for linear systems of equations. \sphinxstyleemphasis{Physical Review Letters}, Oct 2009. URL: \sphinxurl{https://arxiv.org/abs/0811.3171v3}, \sphinxhref{https://doi.org/10.1103/physrevlett.103.150502}{doi:10.1103/physrevlett.103.150502}.
\bibitem[Has70]{book/bibliography:id34}
\sphinxAtStartPar
W. K. Hastings. Monte Carlo sampling methods using Markov chains and their applications. \sphinxstyleemphasis{Biometrika}, 57(1):97–109, 04 1970. URL: \sphinxurl{https://doi.org/10.1093/biomet/57.1.97}, \sphinxhref{https://arxiv.org/abs/https://academic.oup.com/biomet/article-pdf/57/1/97/23940249/57-1-97.pdf}{arXiv:https://academic.oup.com/biomet/article\sphinxhyphen{}pdf/57/1/97/23940249/57\sphinxhyphen{}1\sphinxhyphen{}97.pdf}, \sphinxhref{https://doi.org/10.1093/biomet/57.1.97}{doi:10.1093/biomet/57.1.97}.
\bibitem[HavlivcekCorcolesT+19]{book/bibliography:id58}
\sphinxAtStartPar
Vojtěch Havlíček, Antonio D Córcoles, Kristan Temme, Aram W Harrow, Abhinav Kandala, Jerry M Chow, and Jay M Gambetta. Supervised learning with quantum\sphinxhyphen{}enhanced feature spaces. \sphinxstyleemphasis{Nature}, 567(7747):209–212, Mar 2019. URL: \sphinxurl{https://arxiv.org/abs/1804.11326}, \sphinxhref{https://doi.org/10.1038/s41586-019-0980-2}{doi:10.1038/s41586\sphinxhyphen{}019\sphinxhyphen{}0980\sphinxhyphen{}2}.
\bibitem[HSchatzleNoe20]{book/bibliography:id36}
\sphinxAtStartPar
Jan Hermann, Zeno Schätzle, and Frank Noé. Deep\sphinxhyphen{}neural\sphinxhyphen{}network solution of the electronic schrödinger equation. \sphinxstyleemphasis{Nature Chemistry}, 12(10):891–897, 2020. URL: \sphinxurl{https://www.nature.com/articles/s41557-020-0544-y}.
\bibitem[HAGH+20]{book/bibliography:id37}
\sphinxAtStartPar
Mohamed Hibat\sphinxhyphen{}Allah, Martin Ganahl, Lauren E Hayward, Roger G Melko, and Juan Carrasquilla. Recurrent neural network wave functions. \sphinxstyleemphasis{Physical Review Research}, 2(2):023358, 2020. URL: \sphinxurl{https://arxiv.org/abs/2002.02973}.
\bibitem[HZL+17]{book/bibliography:id40}
\sphinxAtStartPar
He\sphinxhyphen{}Liang Huang, You\sphinxhyphen{}Wei Zhao, Tan Li, Feng\sphinxhyphen{}Guang Li, Yu\sphinxhyphen{}Tao Du, Xiang\sphinxhyphen{}Qun Fu, Shuo Zhang, Xiang Wang, and Wan\sphinxhyphen{}Su Bao. Homomorphic encryption experiments on ibm's cloud quantum computing platform. 2017. \sphinxhref{https://arxiv.org/abs/1612.02886}{arXiv:1612.02886}.
\bibitem[HPM+19]{book/bibliography:id41}
\sphinxAtStartPar
William Huggins, Piyush Patil, Bradley Mitchell, K Birgitta Whaley, and E Miles Stoudenmire. Towards quantum machine learning with tensor networks. \sphinxstyleemphasis{Quantum Science and Technology}, 4(2):024001, Jan 2019. URL: \sphinxurl{https://arxiv.org/abs/1803.11537}, \sphinxhref{https://doi.org/10.1088/2058-9565/aaea94}{doi:10.1088/2058\sphinxhyphen{}9565/aaea94}.
\bibitem[Isi25]{book/bibliography:id43}
\sphinxAtStartPar
Ernst Ising. Beitrag zur theorie des ferromagnetismus. \sphinxstyleemphasis{Zeitschrift für Physik}, 31(1):253–258, 1925.
\bibitem[Jas55]{book/bibliography:id44}
\sphinxAtStartPar
Robert Jastrow. Many\sphinxhyphen{}body problem with strong forces. \sphinxstyleemphasis{Physical Review}, 98(5):1479, 1955.
\bibitem[KN98]{book/bibliography:id45}
\sphinxAtStartPar
Tadashi Kadowaki and Hidetoshi Nishimori. Quantum annealing in the transverse ising model. \sphinxstyleemphasis{Phys. Rev. E}, 58:5355–5363, Nov 1998. URL: \sphinxurl{https://link.aps.org/doi/10.1103/PhysRevE.58.5355}, \sphinxhref{https://doi.org/10.1103/PhysRevE.58.5355}{doi:10.1103/PhysRevE.58.5355}.
\bibitem[KMT+17]{book/bibliography:id33}
\sphinxAtStartPar
Abhinav Kandala, Antonio Mezzacapo, Kristan Temme, Maika Takita, Markus Brink, Jerry M Chow, and Jay M Gambetta. Hardware\sphinxhyphen{}efficient variational quantum eigensolver for small molecules and quantum magnets. \sphinxstyleemphasis{Nature}, 549(7671):242–246, 2017. URL: \sphinxurl{https://www.nature.com/articles/nature23879}, \sphinxhref{https://doi.org/10.1038/nature23879}{doi:10.1038/nature23879}.
\bibitem[KYG+07]{book/bibliography:id7}
\sphinxAtStartPar
Jens Koch, Terri M Yu, Jay Gambetta, A A Houck, D I Schuster, J Majer, Alexandre Blais, M H Devoret, S M Girvin, and R J Schoelkopf. Charge\sphinxhyphen{}insensitive qubit design derived from the Cooper pair box. \sphinxstyleemphasis{Physical Review A}, 10 2007. \sphinxhref{https://doi.org/10.1103/physreva.76.042319}{doi:10.1103/physreva.76.042319}.
\bibitem[KKY+19]{book/bibliography:id8}
\sphinxAtStartPar
P Krantz, M Kjaergaard, F Yan, T P Orlando, S Gustavsson, and W D Oliver. A Guide to Superconducting Qubits for New Quantum Information Engineers. \sphinxstyleemphasis{Applied Physics Review}, 2019. \sphinxhref{https://arxiv.org/abs/1904.06560v1}{arXiv:1904.06560v1}.
\bibitem[Lan50]{book/bibliography:id46}
\sphinxAtStartPar
Cornelius Lanczos. An iteration method for the solution of the eigenvalue problem of linear differential and integral operators. \sphinxstyleemphasis{Journal of Research of the National Bureau of Standards}, 1950.
\bibitem[LD10]{book/bibliography:id47}
\sphinxAtStartPar
Ailsa H Land and Alison G Doig. An automatic method for solving discrete programming problems. In \sphinxstyleemphasis{50 Years of Integer Programming 1958\sphinxhyphen{}2008}, pages 105–132. Springer, 2010.
\bibitem[LTG21]{book/bibliography:id49}
\sphinxAtStartPar
Junde Li, Rasit Topaloglu, and Swaroop Ghosh. Quantum generative models for small molecule drug discovery. 2021. \sphinxhref{https://arxiv.org/abs/2101.03438}{arXiv:2101.03438}.
\bibitem[LJGS+90]{book/bibliography:id50}
\sphinxAtStartPar
EY Loh Jr, JE Gubernatis, RT Scalettar, SR White, DJ Scalapino, and RL Sugar. Sign problem in the numerical simulation of many\sphinxhyphen{}electron systems. \sphinxstyleemphasis{Physical Review B}, 41(13):9301, 1990.
\bibitem[Lom04]{book/bibliography:id51}
\sphinxAtStartPar
Chris Lomont. The hidden subgroup problem\sphinxhyphen{}review and open problems. \sphinxstyleemphasis{arXiv preprint quant\sphinxhyphen{}ph/0411037}, 2004.
\bibitem[Luc14]{book/bibliography:id25}
\sphinxAtStartPar
Andrew Lucas. Ising formulations of many np problems. \sphinxstyleemphasis{Frontiers in physics}, 2:5, 2014. URL: \sphinxurl{https://arxiv.org/abs/1302.5843}, \sphinxhref{https://doi.org/https://doi.org/10.3389/fphy.2014.00005}{doi:https://doi.org/10.3389/fphy.2014.00005}.
\bibitem[MBK21]{book/bibliography:id38}
\sphinxAtStartPar
Andrea Mari, Thomas R. Bromley, and Nathan Killoran. Estimating the gradient and higher\sphinxhyphen{}order derivatives on quantum hardware. \sphinxstyleemphasis{Physical Review A}, 103(1):012405, Jan 2021. URL: \sphinxurl{https://arxiv.org/abs/2008.06517}, \sphinxhref{https://doi.org/10.1103/physreva.103.012405}{doi:10.1103/physreva.103.012405}.
\bibitem[MST17]{book/bibliography:id52}
\sphinxAtStartPar
Kyle Mills, Michael Spanner, and Isaac Tamblyn. Deep learning and the schrödinger equation. \sphinxstyleemphasis{Physical Review A}, 96(4):042113, 2017. URL: \sphinxurl{https://arxiv.org/abs/1702.01361}.
\bibitem[MKF19]{book/bibliography:id11}
\sphinxAtStartPar
Kosuke Mitarai, Masahiro Kitagawa, and Keisuke Fujii. Quantum analog\sphinxhyphen{}digital conversion. \sphinxstyleemphasis{Phys. Rev. A}, 99:012301, Jan 2019. URL: \sphinxurl{https://link.aps.org/doi/10.1103/PhysRevA.99.012301}, \sphinxhref{https://doi.org/10.1103/PhysRevA.99.012301}{doi:10.1103/PhysRevA.99.012301}.
\bibitem[MNKF18]{book/bibliography:id55}
\sphinxAtStartPar
Kosuke Mitarai, Makoto Negoro, Masahiro Kitagawa, and Keisuke Fujii. Quantum circuit learning. \sphinxstyleemphasis{Physical Review A}, 98(3):032309, Sep 2018. URL: \sphinxurl{https://arxiv.org/abs/1803.00745}, \sphinxhref{https://doi.org/10.1103/PhysRevA.98.032309}{doi:10.1103/PhysRevA.98.032309}.
\bibitem[MRT18]{book/bibliography:id9}
\sphinxAtStartPar
Mehryar Mohri, Afshin Rostamizadeh, and Ameet Talwalkar. \sphinxstyleemphasis{Foundations of Machine Learning}. Adaptive Computation and Machine Learning. MIT Press, Cambridge, MA, 2 edition, 2018. ISBN 978\sphinxhyphen{}0\sphinxhyphen{}262\sphinxhyphen{}03940\sphinxhyphen{}6.
\bibitem[NSS+08]{book/bibliography:id70}
\sphinxAtStartPar
Chetan Nayak, Steven H. Simon, Ady Stern, Michael Freedman, and Sankar Das Sarma. Non\sphinxhyphen{}abelian anyons and topological quantum computation. \sphinxstyleemphasis{Reviews of Modern Physics}, 80(3):1083–1159, Sep 2008. URL: \sphinxurl{http://dx.doi.org/10.1103/RevModPhys.80.1083}, \sphinxhref{https://doi.org/10.1103/revmodphys.80.1083}{doi:10.1103/revmodphys.80.1083}.
\bibitem[New06]{book/bibliography:id54}
\sphinxAtStartPar
M. E. J. Newman. Modularity and community structure in networks. \sphinxstyleemphasis{Proceedings of the National Academy of Sciences}, 103(23):8577–8582, May 2006. URL: \sphinxurl{https://arxiv.org/abs/physics/0602124}, \sphinxhref{https://doi.org/10.1073/pnas.0601602103}{doi:10.1073/pnas.0601602103}.
\bibitem[RGM+17]{book/bibliography:id12}
\sphinxAtStartPar
Marco Roth, Marc Ganzhorn, Nikolaj Moll, Stefan Filipp, Gian Salis, and Sebastian Schmidt. Analysis of a parametrically driven exchange\sphinxhyphen{}type gate and a two\sphinxhyphen{}photon excitation gate between superconducting qubits. \sphinxstyleemphasis{Physical Review A}, 2017. \sphinxhref{https://doi.org/10.1103/PhysRevA.96.062323}{doi:10.1103/PhysRevA.96.062323}.
\bibitem[SZK+18]{book/bibliography:id13}
\sphinxAtStartPar
N. Samkharadze, G. Zheng, N. Kalhor, D. Brousse, A. Sammak, U. C. Mendes, A. Blais, G. Scappucci, and L. M. K. Vandersypen. Strong spin\sphinxhyphen{}photon coupling in silicon. \sphinxstyleemphasis{Science}, 359(6380):1123–1127, 2018. URL: \sphinxurl{https://www.science.org/doi/abs/10.1126/science.aar4054}, \sphinxhref{https://doi.org/10.1126/science.aar4054}{doi:10.1126/science.aar4054}.
\bibitem[SRL12]{book/bibliography:id61}
\sphinxAtStartPar
Jacob T. Seeley, Martin J. Richard, and Peter J. Love. The bravyi\sphinxhyphen{}kitaev transformation for quantum computation of electronic structure. \sphinxstyleemphasis{The Journal of chemical physics}, 137(22):224109, 2012. URL: \sphinxurl{https://arxiv.org/abs/1208.5986}.
\bibitem[SK75]{book/bibliography:id62}
\sphinxAtStartPar
David Sherrington and Scott Kirkpatrick. Solvable model of a spin\sphinxhyphen{}glass. \sphinxstyleemphasis{Phys. Rev. Lett.}, 35:1792–1796, Dec 1975. URL: \sphinxurl{https://link.aps.org/doi/10.1103/PhysRevLett.35.1792}, \sphinxhref{https://doi.org/10.1103/PhysRevLett.35.1792}{doi:10.1103/PhysRevLett.35.1792}.
\bibitem[SB19]{book/bibliography:id63}
\sphinxAtStartPar
Semyon Sinchenko and Dmitry Bazhanov. The deep learning and statistical physics applications to the problems of combinatorial optimization. \sphinxstyleemphasis{arXiv preprint arXiv:1911.10680}, 2019. URL: \sphinxurl{https://arxiv.org/abs/1911.10680}.
\bibitem[SCZ17]{book/bibliography:id56}
\sphinxAtStartPar
Robert S. Smith, Michael J. Curtis, and William J. Zeng. A practical quantum instruction set architecture. 2017. \sphinxhref{https://arxiv.org/abs/1608.03355}{arXiv:1608.03355}.
\bibitem[SCBR14]{book/bibliography:id64}
\sphinxAtStartPar
Stanislav Sobolevsky, Riccardo Campari, Alexander Belyi, and Carlo Ratti. General optimization technique for high\sphinxhyphen{}quality community detection in complex networks. \sphinxstyleemphasis{Phys. Rev. E}, 90:012811, Jul 2014. URL: \sphinxurl{https://link.aps.org/doi/10.1103/PhysRevE.90.012811}, \sphinxhref{https://doi.org/10.1103/PhysRevE.90.012811}{doi:10.1103/PhysRevE.90.012811}.
\bibitem[SBC+21]{book/bibliography:id65}
\sphinxAtStartPar
Samuel A. Stein, Betis Baheri, Daniel Chen, Ying Mao, Qiang Guan, Ang Li, Bo Fang, and Shuai Xu. Qugan: a generative adversarial network through quantum states. 2021. \sphinxhref{https://arxiv.org/abs/2010.09036}{arXiv:2010.09036}.
\bibitem[SF14]{book/bibliography:id66}
\sphinxAtStartPar
Leonard Susskind and Art Friedman. \sphinxstyleemphasis{Quantum mechanics: the theoretical minimum}. Basic Books, 2014.
\bibitem[SYG+20]{book/bibliography:id59}
\sphinxAtStartPar
Yudai Suzuki, Hiroshi Yano, Qi Gao, Shumpei Uno, Tomoki Tanaka, Manato Akiyama, and Naoki Yamamoto. Analysis and synthesis of feature map for kernel\sphinxhyphen{}based quantum classifier. \sphinxstyleemphasis{Quantum Machine Intelligence}, 2(1):1–9, Jul 2020. URL: \sphinxurl{https://arxiv.org/abs/1906.10467}, \sphinxhref{https://doi.org/10.1007/s42484-020-00020-y}{doi:10.1007/s42484\sphinxhyphen{}020\sphinxhyphen{}00020\sphinxhyphen{}y}.
\bibitem[TKTD20]{book/bibliography:id69}
\sphinxAtStartPar
Alexander Teplukhin, Brian K Kendrick, Sergei Tretiak, and Pavel A Dub. Electronic structure with direct diagonalization on a d\sphinxhyphen{}wave quantum annealer. \sphinxstyleemphasis{Scientific reports}, 10(1):1–11, 2020.
\bibitem[VDS98]{book/bibliography:id72}
\sphinxAtStartPar
Jan Von Delft and Herbert Schoeller. Bosonization for beginners—refermionization for experts. \sphinxstyleemphasis{Annalen der Physik}, 7(4):225–305, 1998.
\bibitem[VD17]{book/bibliography:id14}
\sphinxAtStartPar
Uri Vool and Michel Devoret. Introduction to quantum electromagnetic circuits. \sphinxstyleemphasis{International Journal of Circuit Theory and Applications}, 45(7):897–934, 2017. URL: \sphinxurl{https://onlinelibrary.wiley.com/doi/abs/10.1002/cta.2359}, \sphinxhref{https://doi.org/10.1002/cta.2359}{doi:10.1002/cta.2359}.
\bibitem[WSB+05]{book/bibliography:id15}
\sphinxAtStartPar
A. Wallraff, D. I. Schuster, A. Blais, L. Frunzio, J. Majer, M. H. Devoret, S. M. Girvin, and R. J. Schoelkopf. Approaching unit visibility for control of a superconducting qubit with dispersive readout. \sphinxstyleemphasis{Physical Review Letters}, 95(6):060501, 8 2005. URL: \sphinxurl{https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.95.060501}, \sphinxhref{https://arxiv.org/abs/0502645}{arXiv:0502645}, \sphinxhref{https://doi.org/10.1103/PhysRevLett.95.060501}{doi:10.1103/PhysRevLett.95.060501}.
\bibitem[WBD+19]{book/bibliography:id16}
\sphinxAtStartPar
K. Wright, K. M. Beck, S. Debnath, J. M. Amini, Y. Nam, N. Grzesiak, J. S. Chen, N. C. Pisenti, M. Chmielewski, C. Collins, K. M. Hudek, J. Mizrahi, J. D. Wong\sphinxhyphen{}Campos, S. Allen, J. Apisdorf, P. Solomon, M. Williams, A. M. Ducore, A. Blinov, S. M. Kreikemeier, V. Chaplin, M. Keesan, C. Monroe, and J. Kim. Benchmarking an 11\sphinxhyphen{}qubit quantum computer. \sphinxstyleemphasis{Nature Communications}, 10(1):1–6, dec 2019. \sphinxhref{https://arxiv.org/abs/1903.08181}{arXiv:1903.08181}, \sphinxhref{https://doi.org/10.1038/s41467-019-13534-2}{doi:10.1038/s41467\sphinxhyphen{}019\sphinxhyphen{}13534\sphinxhyphen{}2}.
\bibitem[Zac77]{book/bibliography:id75}
\sphinxAtStartPar
Wayne W Zachary. An information flow model for conflict and fission in small groups. \sphinxstyleemphasis{Journal of anthropological research}, 33(4):452–473, 1977.
\bibitem[01]{book/bibliography:id71}
\sphinxAtStartPar
Кокин А. А. Валиев К. А. \sphinxstyleemphasis{Квантовые компьютеры: надежды и реальность}. НИЦ "Регулярная и хаотическая динамика", 2001.
\bibitem[89]{book/bibliography:id48}
\sphinxAtStartPar
Лифшиц Е. М. Ландау Л. Д. \sphinxstyleemphasis{Квантовая механика: Нерелятивистская теория.} Наука, 1989. URL: \sphinxurl{https://www.math.purdue.edu/~eremenko/dvi/LL.pdf}.
\bibitem[15a]{book/bibliography:id39}
\sphinxAtStartPar
Иванов М.Г. \sphinxstyleemphasis{Как понимать квантовую механику.} Регулярная и хаотическая динамика, 2015. URL: \sphinxurl{https://mipt.ru/upload/medialibrary/533/quant-2.pdf}.
\bibitem[07]{book/bibliography:id53}
\sphinxAtStartPar
Килин С. Я. Могилевцев Д. С. \sphinxstyleemphasis{Методы квантовой оптики структурированных резервуаров}. Белорусская наука, 2007. URL: \sphinxurl{https://www.litres.ru/d-s-mogilevcev/metody-kvantovoy-optiki-strukturirovannyh-rezervuarov-7073607/}.
\bibitem[15b]{book/bibliography:id67}
\sphinxAtStartPar
Леонард Сасскинд and Арт Фридман. \sphinxstyleemphasis{Квантовая механика. Теоретический минимум}. СПб.: Питер, 2015.
\end{sphinxthebibliography}







\renewcommand{\indexname}{Index}
\printindex
\end{document}